/**
 * Copyright (c) 1995 - 2019 Cycorp, Inc.  All rights reserved.
 */
package com.cyc.cycjava.cycl;


import static com.cyc.cycjava.cycl.access_macros.define_obsolete_register;
import static com.cyc.cycjava.cycl.cyc_testing.generic_testing.define_test_case_table_int;
import static com.cyc.cycjava.cycl.subl_macro_promotions.$catch_error_message_target$;
import static com.cyc.cycjava.cycl.subl_macros.do_sequence_index_doneP;
import static com.cyc.cycjava.cycl.subl_macros.do_sequence_index_update;
import static com.cyc.cycjava.cycl.subl_macros.do_sequence_index_valueP;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_a;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_comma;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_newline;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_question;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_space;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.charE;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.append;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.cons;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.listS;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.make_list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.nconc;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.nth;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.rplaca;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.rplacd;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.set_nth;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.bind;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.currentBinding;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.rebind;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.eq;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.eql;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.equal;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.equalp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.identity;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Functions.apply;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Functions.funcall;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.clrhash;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntryKey;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntrySetIterator;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntryValue;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.gethash;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.iteratorHasNext;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.iteratorNextEntry;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.make_hash_table;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.releaseEntrySetIterator;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.sethash;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Locks.make_lock;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Locks.release_lock;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Locks.seize_lock;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.abs;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.add;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.divide;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.evenp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.integerDivide;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.max;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.minus;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.mod;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.multiply;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.numE;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.numG;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.numGE;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.numL;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.numLE;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.plusp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.round;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.subtract;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.zerop;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Packages.intern;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.PrintLow.format;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.cconcatenate;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.count;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.count_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.delete;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.delete_duplicates;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.delete_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.elt;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.find;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.find_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.length;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.nreverse;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.nsubstitute_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.position;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.position_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.remove;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.remove_duplicates;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.remove_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.reverse;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.search;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.subseq;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.substitute_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.fboundp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.get;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.make_symbol;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.symbol_function;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.symbol_name;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Threads.$is_thread_performing_cleanupP$;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.atom;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.function_spec_p;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.hash_table_p;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.integerp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.keywordp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.listp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.sequencep;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.stringp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.sublisp_null;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.symbolp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.vectorp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.arg2;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.getValuesAsVector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.multiple_value_list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.nth_value_step_1;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.nth_value_step_2;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.resetMultipleValues;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.restoreValuesFromVector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.values;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Vectors.aref;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Vectors.make_vector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Vectors.set_aref;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Vectors.vector;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeBoolean;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeDouble;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeInteger;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeKeyword;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeString;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeSymbol;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeUninternedSymbol;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.cdestructuring_bind_error;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.destructuring_bind_must_consp;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.destructuring_bind_must_listp;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.property_list_member;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.acons;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.adjoin;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.assoc;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.assoc_if;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.butlast;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.caar;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.cadr;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.cdar;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.cddr;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.copy_alist;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.copy_list;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.copy_tree;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.getf;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.intersection;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.last;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.ldiff;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.member;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.member_if;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.nbutlast;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.nsublis;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.nsubst;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.nsubst_if;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.nthcdr;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.nunion;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.pairlis;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.putf;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.rassoc;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.rassoc_if;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.remf;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.second;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.set_difference;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.subsetp;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.subst;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.subst_if;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.third;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.union;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.print_high.prin1;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.print_high.princ;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.print_high.princ_to_string;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.$read_default_float_format$;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.bq_cons;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.read_delimited_list;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.terpri;
import static com.cyc.tool.subl.util.SubLFiles.declareFunction;
import static com.cyc.tool.subl.util.SubLFiles.declareMacro;
import static com.cyc.tool.subl.util.SubLFiles.deflexical;
import static com.cyc.tool.subl.util.SubLFiles.defparameter;

import java.util.Iterator;
import java.util.Map;

import com.cyc.tool.subl.jrtl.nativeCode.subLisp.BinaryFunction;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Errors;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Mapping;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sort;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.StreamsLow;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Strings;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.SubLThread;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.UnaryFunction;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLList;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObject;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLProcess;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLString;
import com.cyc.tool.subl.jrtl.nativeCode.type.number.SubLFloat;
import com.cyc.tool.subl.jrtl.nativeCode.type.number.SubLInteger;
import com.cyc.tool.subl.jrtl.nativeCode.type.symbol.SubLSymbol;
import com.cyc.tool.subl.jrtl.translatedCode.sublisp.random;
import com.cyc.tool.subl.util.SubLFile;
import com.cyc.tool.subl.util.SubLFiles;
import com.cyc.tool.subl.util.SubLFiles.LispMethod;
import com.cyc.tool.subl.util.SubLTrampolineFile;
import com.cyc.tool.subl.util.SubLTranslatedFile;


/**
 * Copyright (c) 1995 - 2019 Cycorp, Inc.  All rights reserved.
 * module:      LIST-UTILITIES
 * source file: /cyc/top/cycl/list-utilities.lisp
 * created:     2019/07/03 17:37:11
 */
public final class list_utilities extends SubLTranslatedFile implements V12 {
    public static final SubLObject subloop_reserved_initialize_nadd_to_end_test_case_instance(SubLObject new_instance) {
        classes.subloop_initialize_slot(new_instance, OBJECT, ISOLATED_P, NIL);
        classes.subloop_initialize_slot(new_instance, OBJECT, INSTANCE_NUMBER, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, RESULT, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, TEST_METHOD, NIL);
        classes.subloop_initialize_slot(new_instance, NADD_TO_END_TEST_CASE, P_QUEUE, NIL);
        return NIL;
    }

    public static final SubLObject subloop_reserved_initialize_nadd_to_end_test_case_class(SubLObject new_instance) {
        classes.subloop_initialize_slot(new_instance, OBJECT, INSTANCE_COUNT, ZERO_INTEGER);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, MODULE, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, CATEGORIES, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, SUITES, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, TEST_METHODS, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, ENABLED, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, LOCK, NIL);
        return NIL;
    }

    public static final SubLObject subloop_reserved_initialize_list_macros_test_case_instance(SubLObject new_instance) {
        classes.subloop_initialize_slot(new_instance, OBJECT, ISOLATED_P, NIL);
        classes.subloop_initialize_slot(new_instance, OBJECT, INSTANCE_NUMBER, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, RESULT, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, TEST_METHOD, NIL);
        classes.subloop_initialize_slot(new_instance, LIST_MACROS_TEST_CASE, P_QUEUE, NIL);
        return NIL;
    }

    public static final SubLObject subloop_reserved_initialize_list_macros_test_case_class(SubLObject new_instance) {
        classes.subloop_initialize_slot(new_instance, OBJECT, INSTANCE_COUNT, ZERO_INTEGER);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, MODULE, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, CATEGORIES, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, SUITES, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, TEST_METHODS, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, ENABLED, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, LOCK, NIL);
        return NIL;
    }

    public static final SubLObject subloop_reserved_initialize_last1_test_case_instance(SubLObject new_instance) {
        classes.subloop_initialize_slot(new_instance, OBJECT, ISOLATED_P, NIL);
        classes.subloop_initialize_slot(new_instance, OBJECT, INSTANCE_NUMBER, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, RESULT, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, TEST_METHOD, NIL);
        classes.subloop_initialize_slot(new_instance, LAST1_TEST_CASE, P_QUEUE, NIL);
        return NIL;
    }

    public static final SubLObject subloop_reserved_initialize_last1_test_case_class(SubLObject new_instance) {
        classes.subloop_initialize_slot(new_instance, OBJECT, INSTANCE_COUNT, ZERO_INTEGER);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, MODULE, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, CATEGORIES, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, SUITES, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, TEST_METHODS, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, ENABLED, NIL);
        classes.subloop_initialize_slot(new_instance, TEST_CASE, LOCK, NIL);
        return NIL;
    }

    public static final SubLObject set_nadd_to_end_test_case_p_queue(SubLObject nadd_to_end_test_case, SubLObject value) {
        return classes.subloop_set_access_protected_instance_slot(nadd_to_end_test_case, value, THREE_INTEGER, P_QUEUE);
    }

    public static final SubLObject set_list_macros_test_case_p_queue(SubLObject list_macros_test_case, SubLObject value) {
        return classes.subloop_set_access_protected_instance_slot(list_macros_test_case, value, THREE_INTEGER, P_QUEUE);
    }

    public static final SubLObject set_last1_test_case_p_queue(SubLObject last1_test_case, SubLObject value) {
        return classes.subloop_set_access_protected_instance_slot(last1_test_case, value, THREE_INTEGER, P_QUEUE);
    }

    public static final SubLObject nadd_to_end_test_case_p(SubLObject nadd_to_end_test_case) {
        return classes.subloop_instanceof_class(nadd_to_end_test_case, NADD_TO_END_TEST_CASE);
    }

    public static final SubLObject list_macros_test_case_p(SubLObject list_macros_test_case) {
        return classes.subloop_instanceof_class(list_macros_test_case, LIST_MACROS_TEST_CASE);
    }

    public static final SubLObject last1_test_case_p(SubLObject last1_test_case) {
        return classes.subloop_instanceof_class(last1_test_case, LAST1_TEST_CASE);
    }

    public static final SubLObject get_nadd_to_end_test_case_p_queue(SubLObject nadd_to_end_test_case) {
        return classes.subloop_get_access_protected_instance_slot(nadd_to_end_test_case, THREE_INTEGER, P_QUEUE);
    }

    public static final SubLObject get_list_macros_test_case_p_queue(SubLObject list_macros_test_case) {
        return classes.subloop_get_access_protected_instance_slot(list_macros_test_case, THREE_INTEGER, P_QUEUE);
    }

    public static final SubLObject get_last1_test_case_p_queue(SubLObject last1_test_case) {
        return classes.subloop_get_access_protected_instance_slot(last1_test_case, THREE_INTEGER, P_QUEUE);
    }

    // Internal Constant Initializer Methods
    @LispMethod(comment = "Internal Constant Initializer Methods")
    private static final SubLObject _constant_200_initializer() {
        return list(new SubLObject[]{ list(list(list(ONE_INTEGER), list(ONE_INTEGER)), list(ONE_INTEGER)), list(list(NIL, list(ONE_INTEGER)), NIL), list(list(list(ONE_INTEGER), NIL), NIL), list(list(list(ONE_INTEGER), list(TWO_INTEGER)), NIL), list(list(list(ONE_INTEGER, THREE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER)), NIL), list(list(list(TWO_INTEGER, FOUR_INTEGER), list(ONE_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER), list(THREE_INTEGER, FOUR_INTEGER)), NIL), list(list(list(THREE_INTEGER, FOUR_INTEGER), list(ONE_INTEGER, TWO_INTEGER)), NIL), list(list(list(ZERO_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ZERO_INTEGER)), NIL), list(list(list(ONE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ONE_INTEGER)), list(ONE_INTEGER)), list(list(list(TWO_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(TWO_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(TWO_INTEGER)), list(TWO_INTEGER)), list(list(list(THREE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(THREE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER)), list(THREE_INTEGER)), list(list(list(FOUR_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER)), NIL), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER)), NIL), list(list(list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER), list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(ONE_INTEGER)), list(list(list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER)), list(FOUR_INTEGER)), list(list(list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER), list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER)), list(FOUR_INTEGER)), list(list(list(FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(NINE_INTEGER)), list(list(list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER), list(FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER)), list(NINE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER)), NIL), list(list(list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER), list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER)), list(FOUR_INTEGER)), list(list(list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER), list(TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER)), list(FOUR_INTEGER)), list(list(list(ZERO_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ZERO_INTEGER, NINE_INTEGER)), NIL), list(list(list(ONE_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ONE_INTEGER, NINE_INTEGER)), list(ONE_INTEGER)), list(list(list(TWO_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(TWO_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(TWO_INTEGER, NINE_INTEGER)), list(TWO_INTEGER)), list(list(list(THREE_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(THREE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER, NINE_INTEGER)), list(THREE_INTEGER)), list(list(list(FOUR_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER, NINE_INTEGER)), NIL), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER)), list(THREE_INTEGER, SEVEN_INTEGER)), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(THREE_INTEGER, SEVEN_INTEGER, NINE_INTEGER)), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, makeInteger(99)), list(TWO_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(THREE_INTEGER, SEVEN_INTEGER)) });
    }

    static private final SubLString $str_alt64$ = makeString("");

    public static final SubLFile me = new list_utilities();

 public static final String myName = "com.cyc.cycjava.cycl.list_utilities";


    // defparameter
    @LispMethod(comment = "the cutoff beyond which it\'s more efficient to use a hashtable\r\nthan an N^2 non-consing algorithm, used for the fast-* functions.\ndefparameter\nthe cutoff beyond which it\'s more efficient to use a hashtable\nthan an N^2 non-consing algorithm, used for the fast-* functions.")
    public static final SubLSymbol $magic_hashing_cutoff$ = makeSymbol("*MAGIC-HASHING-CUTOFF*");

    // defparameter
    /**
     * This variable is only to be used below by the negated sequence and test
     * functions
     */
    @LispMethod(comment = "This variable is only to be used below by the negated sequence and test\r\nfunctions\ndefparameter\nThis variable is only to be used below by the negated sequence and test\nfunctions")
    public static final SubLSymbol $negated_test_func$ = makeSymbol("*NEGATED-TEST-FUNC*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $position_if_binary_lambda_func$ = makeSymbol("*POSITION-IF-BINARY-LAMBDA-FUNC*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $position_if_binary_lambda_arg2$ = makeSymbol("*POSITION-IF-BINARY-LAMBDA-ARG2*");

    // defparameter
    @LispMethod(comment = "defparameter")
    public static final SubLSymbol $listified_vector_marker$ = makeSymbol("*LISTIFIED-VECTOR-MARKER*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_eq_table$ = makeSymbol("*REMOVE-DUPLICATES-EQ-TABLE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_eql_table$ = makeSymbol("*REMOVE-DUPLICATES-EQL-TABLE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_equal_table$ = makeSymbol("*REMOVE-DUPLICATES-EQUAL-TABLE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_equalp_table$ = makeSymbol("*REMOVE-DUPLICATES-EQUALP-TABLE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_eq_table_lock$ = makeSymbol("*REMOVE-DUPLICATES-EQ-TABLE-LOCK*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_eql_table_lock$ = makeSymbol("*REMOVE-DUPLICATES-EQL-TABLE-LOCK*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_equal_table_lock$ = makeSymbol("*REMOVE-DUPLICATES-EQUAL-TABLE-LOCK*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $remove_duplicates_equalp_table_lock$ = makeSymbol("*REMOVE-DUPLICATES-EQUALP-TABLE-LOCK*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $plistlist_sort_indicator$ = makeSymbol("*PLISTLIST-SORT-INDICATOR*");

    // defparameter
    @LispMethod(comment = "defparameter")
    public static final SubLSymbol $subseq_subst_recursive_answers$ = makeSymbol("*SUBSEQ-SUBST-RECURSIVE-ANSWERS*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $sort_via_position_guide$ = makeSymbol("*SORT-VIA-POSITION-GUIDE*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $sort_via_position_test$ = makeSymbol("*SORT-VIA-POSITION-TEST*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $sort_via_test_function$ = makeSymbol("*SORT-VIA-TEST-FUNCTION*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $preferred_term_set$ = makeSymbol("*PREFERRED-TERM-SET*");

    @LispMethod(comment = "Internal Constants")
    // Internal Constants
    private static final SubLInteger $int$80 = makeInteger(80);

    static private final SubLString $str1$nth_cycling__width_must_be_greate = makeString("nth-cycling: width must be greater than zero");

    static private final SubLString $str2$nth_cycling__width_must_be_less_t = makeString("nth-cycling: width must be less than or equal to list length");

    static private final SubLString $str3$nth_cycling__width_overruns_offse = makeString("nth-cycling: width overruns offset");

    static private final SubLList $list4 = list(makeSymbol("VAR"), makeSymbol("PLACE"));

    static private final SubLList $list9 = list(list(makeSymbol("VAR"), makeSymbol("PLACE")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list11 = list(makeSymbol("ITEM"), makeSymbol("PLACE"), makeSymbol("MAX-LENGTH"));

    private static final SubLSymbol FIRST_N = makeSymbol("FIRST-N");

    static private final SubLSymbol $sym15$_ = makeSymbol("-");

    static private final SubLList $list16 = list(ONE_INTEGER);

    static private final SubLList $list17 = list(list(makeSymbol("&REST"), makeSymbol("VAR-LIST-FORMS")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list18 = list(makeSymbol("VAR"), makeSymbol("LISTFORM"));

    static private final SubLList $list24 = list(list(makeSymbol("NUMBER-VAR"), makeSymbol("&REST"), makeSymbol("VAR-LIST-FORMS")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list25 = list(ZERO_INTEGER);

    private static final SubLSymbol CDOLIST_MULTIPLE = makeSymbol("CDOLIST-MULTIPLE");

    static private final SubLList $list28 = list(list(makeSymbol("ENDVAR"), makeSymbol("&REST"), makeSymbol("VAR-LIST-FORMS")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLString $str29$Malformed_csome_multiple_____S_wa = makeString("Malformed csome-multiple -- ~S was not a variable");

    static private final SubLList $list32 = list(list(makeSymbol("ELEM-VAR"), makeSymbol("NUMBER-VAR"), makeSymbol("LISTFORM")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLSymbol $sym33$LIST_VAR = makeUninternedSymbol("LIST-VAR");

    static private final SubLSymbol $sym34$_ = makeSymbol("+");

    static private final SubLList $list35 = list(list(makeSymbol("VAR"), makeSymbol("LISTFORM")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLSymbol $sym38$LIST_VAR = makeUninternedSymbol("LIST-VAR");

    static private final SubLSymbol $sym39$1_ = makeSymbol("1-");

    static private final SubLList $list41 = list(list(makeSymbol("ELEM-VAR"), makeSymbol("NUMBER-VAR"), makeSymbol("LISTFORM"), makeSymbol("ENDVAR")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLSymbol $sym42$LIST_VAR = makeUninternedSymbol("LIST-VAR");

    private static final SubLSymbol CDOLIST_CYCLING_COMPLEX = makeSymbol("CDOLIST-CYCLING-COMPLEX");

    static private final SubLList $list44 = list(list(makeSymbol("VAR-LIST-FORMS"), makeSymbol("&OPTIONAL"), list(makeSymbol("SECONDARY-LISTS"), NIL)), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLString $$$COUNTER = makeString("COUNTER");

    static private final SubLString $str46$_orig = makeString("-orig");

    static private final SubLString $str47$_cdr = makeString("-cdr");

    private static final SubLSymbol NTH_CYCLING = makeSymbol("NTH-CYCLING");

    static private final SubLList $list49 = list(list(makeSymbol("LEAF-VAR"), makeSymbol("TREE"), makeSymbol("&KEY"), list(makeSymbol("LIST-TYPE"), list(QUOTE, makeSymbol("LISTP"))), makeSymbol("DONE")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list50 = list(makeKeyword("LIST-TYPE"), $DONE);

    private static final SubLSymbol $ALLOW_OTHER_KEYS = makeKeyword("ALLOW-OTHER-KEYS");

    static private final SubLSymbol $sym55$SUBTREE_LIST_VAR = makeUninternedSymbol("SUBTREE-LIST-VAR");

    static private final SubLSymbol $sym56$CURRENT_SUBTREE_VAR = makeUninternedSymbol("CURRENT-SUBTREE-VAR");

    static private final SubLSymbol $sym57$NODE_VAR = makeUninternedSymbol("NODE-VAR");

    static private final SubLSymbol $sym62$_OPTIONAL = makeSymbol("&OPTIONAL");

    static private final SubLString $str64$ = makeString("");

    private static final SubLSymbol $DOT_FOR_DOTTED_LIST = makeKeyword("DOT-FOR-DOTTED-LIST");

    private static final SubLSymbol NEGATED_TEST_FUNC = makeSymbol("NEGATED-TEST-FUNC");

    private static final SubLSymbol POSITION_IF_BINARY_LAMBDA = makeSymbol("POSITION-IF-BINARY-LAMBDA");

    static private final SubLList $list72 = list(NIL);

    private static final SubLSymbol TREE_POSITION_DFS = makeSymbol("TREE-POSITION-DFS");

    private static final SubLSymbol TREE_POSITION_BFS = makeSymbol("TREE-POSITION-BFS");

    private static final SubLSymbol LESSER_LENGTH_P = makeSymbol("LESSER-LENGTH-P");

    static private final SubLList $list77 = cons(makeSymbol("KEY"), makeSymbol("VALUE1"));

    static private final SubLString $str78$The_lists_of_keys_and_data_are_of = makeString("The lists of keys and data are of unequal length.");

    static private final SubLSymbol $sym79$DOUBLETON_ = makeSymbol("DOUBLETON?");

    static private final SubLList $list80 = list(makeSymbol("THING-ONE"), makeSymbol("THING-TWO"));

    static private final SubLString $str81$FIRST_OF_will_multiply_evaluate__ = makeString("FIRST-OF will multiply evaluate ~s");

    static private final SubLString $str87$_s_was_not_a_singleton = makeString("~s was not a singleton");

    private static final SubLSymbol $IGNORE_ERRORS_TARGET = makeKeyword("IGNORE-ERRORS-TARGET");

    private static final SubLSymbol IGNORE_ERRORS_HANDLER = makeSymbol("IGNORE-ERRORS-HANDLER", "SUBLISP");

    private static final SubLFloat $float$0_01 = makeDouble(0.01);

    static private final SubLString $str92$Position_is_not_valid_for_the_siz = makeString("Position is not valid for the size of list.");

    private static final SubLSymbol NUM_LIST_CACHED = makeSymbol("NUM-LIST-CACHED");

    public static final SubLSymbol $num_list_cached_caching_state$ = makeSymbol("*NUM-LIST-CACHED-CACHING-STATE*");

    private static final SubLSymbol KBEQ = makeSymbol("KBEQ");

    static private final SubLSymbol $sym97$_ = makeSymbol("<");

    static private final SubLSymbol $sym98$__ = makeSymbol("<=");

    static private final SubLString $str99$Number_of_repetitions_must_be_gre = makeString("Number of repetitions must be greater than 1. Got ~S");

    static private final SubLSymbol $sym103$TREE_SET_EQUAL_ = makeSymbol("TREE-SET-EQUAL?");

    private static final SubLSymbol FUNCTION_SYMBOL_P = makeSymbol("FUNCTION-SYMBOL-P");

    private static final SubLString $str106$_S_is_not_a_listified_vector_mark = makeString("~S is not a listified vector marked with ~S");

    private static final SubLSymbol FLIP_CONS = makeSymbol("FLIP-CONS");

    private static final SubLSymbol $sym109$STRING_ = makeSymbol("STRING=");

    private static final SubLSymbol $sym110$STRING_ = makeSymbol("STRING<");

    private static final SubLSymbol SAFE_SPLICE_INTO_SORTED_LIST = makeSymbol("SAFE-SPLICE-INTO-SORTED-LIST");

    private static final SubLList $list119 = list(list(list(ONE_INTEGER, NIL, makeSymbol("<")), list(ONE_INTEGER)), list(list(ONE_INTEGER, list(TWO_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER)), list(list(TWO_INTEGER, list(ONE_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER)), list(list(ONE_INTEGER, list(TWO_INTEGER, THREE_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(TWO_INTEGER, list(ONE_INTEGER, THREE_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(THREE_INTEGER, list(ONE_INTEGER, TWO_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(makeString("xxx"), list(makeString("x"), makeString("xxxx")), makeSymbol("<"), makeSymbol("LENGTH")), list(makeString("x"), makeString("xxx"), makeString("xxxx"))));

    private static final SubLSymbol $sym120$_REST = makeSymbol("&REST");

    static private final SubLList $list121 = list(makeSymbol("&OPTIONAL"), makeSymbol("&REST"));

    private static final SubLList $list122 = cons(T, T);

    private static final SubLSymbol $sym123$CAR_IS_EL_VAR_ = makeSymbol("CAR-IS-EL-VAR?");

    private static final SubLString $str124$_s____s = makeString("~s = ~s");

    private static final SubLList $list125 = cons(makeSymbol("ELEMENT"), makeSymbol("REST"));

    private static final SubLInteger $int$500 = makeInteger(500);

    private static final SubLString $str128$remove_duplicates_eq_table_lock = makeString("remove-duplicates eq table lock");

    private static final SubLString $str129$remove_duplicates_eql_table_lock = makeString("remove-duplicates eql table lock");

    private static final SubLString $str130$remove_duplicates_equal_table_loc = makeString("remove-duplicates equal table lock");

    private static final SubLString $str131$remove_duplicates_equalp_table_lo = makeString("remove-duplicates equalp table lock");

    private static final SubLSymbol $sym135$TERM__ = makeSymbol("TERM-<");

    private static final SubLSymbol $sym136$SAFE__ = makeSymbol("SAFE-<");

    private static final SubLList $list138 = list(makeSymbol("ALIST-VAR"), makeSymbol("KEY"), makeSymbol("VALUE"), makeSymbol("&OPTIONAL"), list(makeSymbol("KEY-TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))), list(makeSymbol("VALUE-TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))));

    static private final SubLList $list139 = list(makeSymbol("FUNCTION"), EQL);

    private static final SubLSymbol ALIST_PUSHNEW = makeSymbol("ALIST-PUSHNEW");

    static private final SubLList $list141 = list(makeSymbol("ALIST-VAR"), makeSymbol("KEY"), makeSymbol("VALUE"), makeSymbol("&OPTIONAL"), list(makeSymbol("KEY-TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))));

    private static final SubLSymbol ALIST_PUSH = makeSymbol("ALIST-PUSH");

    static private final SubLList $list143 = list(makeSymbol("ALIST-VAR"), makeSymbol("KEY"), makeSymbol("VALUE"), makeSymbol("&OPTIONAL"), list(makeSymbol("TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))));

    private static final SubLSymbol ALIST_ENTER = makeSymbol("ALIST-ENTER");

    private static final SubLList $list145 = cons(makeSymbol("KEY"), makeSymbol("VALUE"));

    static private final SubLList $list146 = cons(makeSymbol("CAR"), makeSymbol("CDR"));

    static private final SubLList $list147 = list(makeSymbol("FIRST"), makeSymbol("SECOND"));

    private static final SubLSymbol CONS_TO_TUPLE = makeSymbol("CONS-TO-TUPLE");

    private static final SubLList $list149 = list(makeSymbol("PLIST"), makeSymbol("INDICATOR"), makeSymbol("VALUE"));

    static private final SubLList $list151 = list(makeSymbol("PLIST"), makeSymbol("KEY"), makeSymbol("&KEY"), list(makeSymbol("INCREMENT"), ONE_INTEGER));

    private static final SubLList $list152 = list(makeKeyword("INCREMENT"));

    private static final SubLSymbol PLIST_ENTER = makeSymbol("PLIST-ENTER");

    private static final SubLSymbol PLIST_LOOKUP = makeSymbol("PLIST-LOOKUP");

    private static final SubLList $list156 = list(makeSymbol("PLIST"), makeSymbol("KEY"), makeSymbol("VALUE"));

    private static final SubLList $list157 = list(makeSymbol("PLIST"), makeSymbol("INDICATOR-TO-REMOVE"));

    private static final SubLSymbol PLIST_EXCEPT = makeSymbol("PLIST-EXCEPT");

    private static final SubLSymbol PLISTLIST_SORT_KEY = makeSymbol("PLISTLIST-SORT-KEY");

    private static final SubLString $str162$_A_and__A = makeString("~A and ~A");

    private static final SubLString $str164$__ = makeString(", ");

    private static final SubLString $str165$__and_ = makeString(", and ");

    private static final SubLString $str166$_a_____a__ = makeString("~a -> ~a~%");

    private static final SubLString $str169$_a___4_2f__ = makeString("~a  ~4,2f~%");

    private static final SubLString $str170$_a___a__ = makeString("~a  ~a~%");

    private static final SubLString $str171$_a___s__ = makeString("~a  ~s~%");

    private static final SubLString $str173$___ = makeString(" | ");

    private static final SubLList $list174 = list(makeSymbol("SUBST-INDEX"), makeSymbol("SUBST-LENGTH"), makeSymbol("SUBST-ITEM"));

    private static final SubLFloat $float$0_5 = makeDouble(0.5);

    private static final SubLSymbol SORT_VIA_POSITION_EARLIER = makeSymbol("SORT-VIA-POSITION-EARLIER");

    private static final SubLSymbol SORT_VIA_TEST_EARLIER = makeSymbol("SORT-VIA-TEST-EARLIER");

    private static final SubLSymbol $sym179$_ = makeSymbol(">");

    private static final SubLSymbol $sym180$SAFE__ = makeSymbol("SAFE->");

    private static final SubLSymbol $sym181$SAFE_TREE__ = makeSymbol("SAFE-TREE-<");

    private static final SubLSymbol $sym182$SET__ = makeSymbol("SET-<");

    private static final SubLSymbol NOT_CONSP = makeSymbol("NOT-CONSP");

    private static final SubLSymbol $sym184$LIST_STRUCTURE__ = makeSymbol("LIST-STRUCTURE-<");

    private static final SubLSymbol $sym186$_ = makeSymbol("=");

    private static final SubLList $list191 = listS(makeSymbol("ONE"), makeSymbol("TWO"), makeSymbol("THREE"), makeSymbol("REST"));

    private static final SubLSymbol GET_ARGLIST = makeSymbol("GET-ARGLIST");

    private static final SubLList $list193 = list(makeSymbol("FUNCTION-SYMBOL-ARGLIST"));

    private static final SubLSymbol $sym195$_ = makeSymbol("*");

    private static final SubLList $list196 = list(list(makeSymbol("RESULT"), makeSymbol("VAR"), makeSymbol("LIST")), makeSymbol("EXP"), makeSymbol("&BODY"), makeSymbol("BODY"));

    private static final SubLString $str199$Expected__S__got__S = makeString("Expected ~S, got ~S");

    private static final SubLString $str200$_S_was_not_a_form_with_operator__ = makeString("~S was not a form with operator ~S");

    static private final SubLList $list206 = list(new SubLObject[]{ makeSymbol("FIRST"), makeSymbol("SECOND"), makeSymbol("THIRD"), makeSymbol("FOURTH"), makeSymbol("FIFTH"), makeSymbol("SIXTH"), makeSymbol("SEVENTH"), makeSymbol("EIGHTH"), makeSymbol("NINTH"), makeSymbol("TENTH") });

    private static final SubLString $str207$choose__S__default___ = makeString("choose ~S (default)~%");

    private static final SubLSymbol $sym208$FAST_SUPERSET_ = makeSymbol("FAST-SUPERSET?");

    private static final SubLString $str209$can_t_choose__S_since_incompatibl = makeString("can't choose ~S since incompatible with previous skip reasons ~S~%");

    private static final SubLString $str210$past_incompatible___S__ = makeString("past-incompatible: ~S~%");

    private static final SubLString $str211$future_incompatible_choosable___S = makeString("future-incompatible-choosable: ~S~%");

    private static final SubLString $str212$choose__S__not_past_incompatible_ = makeString("choose ~S (not past incompatible)~%");

    private static final SubLString $str213$skip__S__past_incompatible_or_fut = makeString("skip ~S (past incompatible or future incompatible choosable)~%");

    private static final SubLSymbol $sym214$SETS_EQUAL_ = makeSymbol("SETS-EQUAL?");

    private static final SubLSymbol TEST_COMPUTE_ALL_COMPATIBLE_SUBLISTS = makeSymbol("TEST-COMPUTE-ALL-COMPATIBLE-SUBLISTS");

    public static final SubLObject $list217 = _constant_217_initializer();

    static private final SubLList $list218 = list(CHAR_newline);

    private static final SubLString $str219$Invalid_graph_txt_specification_r = makeString("Invalid graph.txt specification row ~S needs ~A elems");

    private static final SubLString $$$1 = makeString("1");

    private static final SubLString $str221$Expected___S__ = makeString("Expected: ~S~%");

    private static final SubLString $str222$Got___ = makeString("Got:~%");

    private static final SubLString $str223$___S__ = makeString("  ~S~%");

    private static final SubLSymbol TEST_FIND_MAXIMUM_INDEPENDENT_SET = makeSymbol("TEST-FIND-MAXIMUM-INDEPENDENT-SET");

    static private final SubLList $list225 = list(new SubLObject[]{ list(list(makeString("0 1 1 1 \n1 0 1 1 \n1 1 0 1 \n1 1 1 0"), ONE_INTEGER, list(list(TWO_INTEGER))), T), list(list(makeString("0 0 0 1 1 1  \n0 0 0 1 1 1  \n0 0 0 1 1 1  \n1 1 1 0 0 0  \n1 1 1 0 0 0  \n1 1 1 0 0 0"), THREE_INTEGER, list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER))), T), list(list(makeString("0 1 1 0 1 1 \n1 0 1 1 0 1 \n1 1 0 1 1 0 \n0 1 1 0 1 1 \n1 0 1 1 0 1 \n1 1 0 1 1 0"), TWO_INTEGER, list(list(ONE_INTEGER, FOUR_INTEGER))), T), list(list(makeString("0 1 1 0 1 1 0  \n1 0 1 1 0 1 0  \n1 1 0 1 1 0 0  \n0 1 1 0 0 0 1  \n1 0 1 0 0 0 1  \n1 1 0 0 0 0 1  \n0 0 0 1 1 1 0"), THREE_INTEGER, list(list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER))), T), list(list(makeString("0 1 0 0 0 0 1 1  \n1 0 1 0 0 0 0 1 \n0 1 0 1 0 0 0 1  \n0 0 1 0 1 0 0 1  \n0 0 0 1 0 1 0 1  \n0 0 0 0 1 0 1 1  \n1 0 0 0 0 1 0 1  \n1 1 1 1 1 1 1 0"), THREE_INTEGER, list(list(ONE_INTEGER, FOUR_INTEGER, SIX_INTEGER))), T), list(list(makeString("0 1 0 1 0 1 0 0 \n1 0 1 0 0 0 1 0 \n0 1 0 1 0 0 0 1 \n1 0 1 0 1 0 0 0 \n0 0 0 1 0 1 0 1 \n1 0 0 0 1 0 1 0 \n0 1 0 0 0 1 0 1 \n0 0 1 0 1 0 1 0"), FOUR_INTEGER, list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER))), T), list(list(makeString("0 1 0 0 1 0 1 0 0 0  \n1 0 1 0 0 0 0 1 0 0  \n0 1 0 1 0 0 0 0 1 0  \n0 0 1 0 1 0 0 0 0 1  \n1 0 0 1 0 1 0 0 0 0  \n0 0 0 0 1 0 0 1 1 0  \n1 0 0 0 0 0 0 0 1 1  \n0 1 0 0 0 1 0 0 0 1  \n0 0 1 0 0 1 1 0 0 0  \n0 0 0 1 0 0 1 1 0 0"), FOUR_INTEGER, list(list(ONE_INTEGER, THREE_INTEGER, SIX_INTEGER, TEN_INTEGER))), T), list(list(makeString("0 0 1 1 1 1 0 1 1 1 1  \n0 0 1 1 1 1 0 1 1 1 1  \n1 1 0 1 0 0 1 0 0 0 0  \n1 1 1 0 0 0 1 0 0 0 0  \n1 1 0 0 0 1 1 0 0 0 0  \n1 1 0 0 1 0 1 0 0 0 0  \n0 0 1 1 1 1 0 1 1 1 1  \n1 1 0 0 0 0 1 0 1 0 0  \n1 1 0 0 0 0 1 1 0 0 0  \n1 1 0 0 0 0 1 0 0 0 1  \n1 1 0 0 0 0 1 0 0 1 0"), FOUR_INTEGER, list(list(THREE_INTEGER, SIX_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER), list(ONE_INTEGER, TWO_INTEGER, SEVEN_INTEGER))), T), list(list(makeString("0 1 1 1 1 1 0 0 0 0 0  \n1 0 0 0 0 0 1 0 1 0 0  \n1 0 0 0 0 0 0 1 0 1 0  \n1 0 0 0 0 0 0 0 1 0 1  \n1 0 0 0 0 0 1 0 0 1 0  \n1 0 0 0 0 0 0 1 0 0 1  \n0 1 0 0 1 0 0 1 0 0 1  \n0 0 1 0 0 1 1 0 1 0 0  \n0 1 0 1 0 0 0 1 0 1 0  \n0 0 1 0 1 0 0 0 1 0 1 \n0 0 0 1 0 1 1 0 0 1 0"), FIVE_INTEGER, list(list(TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER))), T), list(list(makeString("0 1 0 1 1 0 1 0 0 0 0  \n1 0 1 0 0 0 0 1 0 0 0  \n0 1 0 1 0 0 0 0 1 0 0  \n1 0 1 0 0 0 0 0 0 1 0  \n1 0 0 0 0 1 0 0 0 1 0  \n0 0 0 0 1 0 1 0 0 0 1  \n1 0 0 0 0 1 0 1 0 0 0  \n0 1 0 0 0 0 1 0 1 0 1  \n0 0 1 0 0 0 0 1 0 1 0  \n0 0 0 1 1 0 0 0 1 0 1  \n0 0 0 0 0 1 0 1 0 1 0"), SIX_INTEGER, list(list(TWO_INTEGER, FOUR_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER, ELEVEN_INTEGER), list(ONE_INTEGER, THREE_INTEGER, SIX_INTEGER, EIGHT_INTEGER, TEN_INTEGER))), T), list(list(makeString("0 1 1 0 0 1 1 1 0 0 0 0 \n 1 0 1 1 1 1 0 0 0 0 0 0 \n 1 1 0 1 0 0 0 1 1 0 0 0 \n 0 1 1 0 1 0 0 0 1 1 0 0 \n 0 1 0 1 0 1 0 0 0 1 1 0 \n 1 1 0 0 1 0 1 0 0 0 1 0 \n 1 0 0 0 0 1 0 1 0 0 1 1 \n 1 0 1 0 0 0 1 0 1 0 0 1 \n 0 0 1 1 0 0 0 1 0 1 0 1 \n 0 0 0 1 1 0 0 0 1 0 1 1 \n 0 0 0 0 1 1 1 0 0 1 0 1 \n 0 0 0 0 0 0 1 1 1 1 1 0"), THREE_INTEGER, list(list(FOUR_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER))), T), list(list(makeString("0 0 0 1 0 0 0 1 0 0 0 1 0 0  \n0 0 1 0 0 0 1 0 0 0 1 0 0 0  \n0 1 0 1 0 0 0 0 0 0 0 0 0 1 \n1 0 1 0 1 0 0 0 0 0 0 0 0 0  \n0 0 0 1 0 1 0 0 0 1 0 0 0 0  \n0 0 0 0 1 0 1 0 0 0 0 0 1 0  \n0 1 0 0 0 1 0 1 0 0 0 0 0 0  \n1 0 0 0 0 0 1 0 1 0 0 0 0 0 \n0 0 0 0 0 0 0 1 0 1 0 0 0 1  \n0 0 0 0 1 0 0 0 1 0 1 0 0 0  \n0 1 0 0 0 0 0 0 0 1 0 1 0 0  \n1 0 0 0 0 0 0 0 0 0 1 0 1 0  \n0 0 0 0 0 1 0 0 0 0 0 1 0 1  \n0 0 1 0 0 0 0 0 1 0 0 0 1 0"), SEVEN_INTEGER, list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER, ELEVEN_INTEGER, THIRTEEN_INTEGER))), T), list(list(makeString("0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0  \n0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0  \n0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0  \n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0  \n0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0  \n1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0  \n0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0  \n0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 0  \n0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0  \n0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0  \n0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0  \n0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0  \n1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0  \n0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0  \n0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1  \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 "), NINE_INTEGER, list(list(new SubLObject[]{ ONE_INTEGER, THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER, NINE_INTEGER, TEN_INTEGER, TWELVE_INTEGER, FOURTEEN_INTEGER, SIXTEEN_INTEGER }))), T), list(list(makeString("0 1 1 0 1 0 0 0 1 1 0 0 0 1 0 1 1  \n1 0 1 1 0 1 0 0 0 1 1 0 0 0 1 0 1  \n1 1 0 1 1 0 1 0 0 0 1 1 0 0 0 1 0  \n0 1 1 0 1 1 0 1 0 0 0 1 1 0 0 0 1  \n1 0 1 1 0 1 1 0 1 0 0 0 1 1 0 0 0  \n0 1 0 1 1 0 1 1 0 1 0 0 0 1 1 0 0  \n0 0 1 0 1 1 0 1 1 0 1 0 0 0 1 1 0  \n0 0 0 1 0 1 1 0 1 1 0 1 0 0 0 1 1  \n1 0 0 0 1 0 1 1 0 1 1 0 1 0 0 0 1  \n1 1 0 0 0 1 0 1 1 0 1 1 0 1 0 0 0  \n0 1 1 0 0 0 1 0 1 1 0 1 1 0 1 0 0  \n0 0 1 1 0 0 0 1 0 1 1 0 1 1 0 1 0  \n0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 0 1  \n1 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 0  \n0 1 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1  \n1 0 1 0 0 0 1 1 0 0 0 1 0 1 1 0 1  \n1 1 0 1 0 0 0 1 1 0 0 0 1 0 1 1 0"), THREE_INTEGER, list(list(ELEVEN_INTEGER, FOURTEEN_INTEGER, SEVENTEEN_INTEGER))), T), list(list(makeString("0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1  \n0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0  \n0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 1 0 0  \n0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 0  \n0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 1  \n0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 1  \n0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 0  \n0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 1 0 0  \n0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0  \n0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1  \n1 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0  \n0 1 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0  \n1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0  \n0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0  \n0 0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0  \n0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0  \n0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0  \n1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0  \n1 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0"), TEN_INTEGER, list(list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, NINE_INTEGER, TEN_INTEGER }))), T), list(list(makeString("0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 \n1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \n0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 \n0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \n1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 \n0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 \n0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 \n0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0 \n0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 \n1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 \n0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 \n0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 \n0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 \n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 \n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0"), EIGHT_INTEGER, list(list(ONE_INTEGER, THREE_INTEGER, SIX_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER, THIRTEEN_INTEGER, SIXTEEN_INTEGER, EIGHTEEN_INTEGER))), T) });

    private static final SubLSymbol COMPARATOR_COMPARE = makeSymbol("COMPARATOR-COMPARE");

    private static final SubLSymbol $sym227$_EXIT = makeSymbol("%EXIT");

    private static final SubLSymbol A_PREFERRED_OVER_B = makeSymbol("A-PREFERRED-OVER-B");

    private static final SubLString $str229$__The_implementer_must_ensure_tha = makeString("~&The implementer must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y, but for\n x=~S\n y=~S\ncompare(x, y)==~S ;; (comparator-compare \'~A ~S ~S)\ncompare(y, x)==~S ;; (comparator-compare \'~A ~S ~S)");

    private static final SubLString $str230$__The_implementer_must_ensure_tha = makeString("~&The implementer must ensure that the relation is transitive: ((compare(x, y)>0) && (compare(y, z)>0)) implies compare(x, z)>0, but for\n x=~S\n y=~S\n z=~S\ncompare(x, y)==~S ;; (comparator-compare \'~A ~S ~S)\ncompare(y, z)==~S ;; (comparator-compare \'~A ~S ~S)\ncompare(x, z)==~S ;; (comparator-compare \'~A ~S ~S)~%");

    private static final SubLString $str231$__The_implementer_must_ensure_tha = makeString("~&The implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z, but for:\n x=~S\n y=~S\n z=~S\ncompare(x, y)==~S ;; (comparator-compare \'~A ~S ~S)\ncompare(x, z)==~S ;; (comparator-compare \'~A ~S ~S)\n which is not equal to \ncompare(y, z)==~S ;; (comparator-compare \'~A ~S ~S)~%");

    private static final SubLSymbol NINTERSECT_SORTED = makeSymbol("NINTERSECT-SORTED");

    private static final SubLObject $list233 = _constant_233_initializer();

    private static final SubLSymbol REMOVE_SUBSUMED_ITEMS = makeSymbol("REMOVE-SUBSUMED-ITEMS");

    private static final SubLList $list235 = list(list(list(list(makeString("foo"), makeString("food"), makeString("bar")), makeSymbol("SUBSTRING?")), list(makeString("foo"), makeString("bar"))), list(list(list(makeString("foo"), makeString("food"), makeString("bart"), makeString("bar")), makeSymbol("SUBSTRING?")), list(makeString("foo"), makeString("bar"))), list(list(list(makeString("bar")), makeSymbol("SUBSTRING?")), list(makeString("bar"))), list(list(NIL, makeSymbol("SUBSTRING?")), NIL), list(list(list(ONE_INTEGER, ONE_INTEGER), makeSymbol("<=")), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, ONE_INTEGER), makeSymbol("<=")), list(ONE_INTEGER, ONE_INTEGER)));

    private static final SubLSymbol REMOVE_NTH = makeSymbol("REMOVE-NTH");

    private static final SubLList $list237 = list(list(list(ZERO_INTEGER, list(TWO_INTEGER, ONE_INTEGER)), list(ONE_INTEGER)), list(list(ZERO_INTEGER, list(ONE_INTEGER)), NIL));

    private static final SubLSymbol FIND_FIRST_AND_NREPLACE_TEST = makeSymbol("FIND-FIRST-AND-NREPLACE-TEST");

    private static final SubLList $list239 = list(list(list(ONE_INTEGER, TWO_INTEGER, list(ONE_INTEGER, ONE_INTEGER, ONE_INTEGER)), list(TWO_INTEGER, ONE_INTEGER, ONE_INTEGER)));

    private static final SubLSymbol REMOVE_NESTED_NTH = makeSymbol("REMOVE-NESTED-NTH");

    private static final SubLList $list241 = list(list(list(list(ONE_INTEGER), list(ONE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ZERO_INTEGER)), list(list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ONE_INTEGER, ZERO_INTEGER)), list(ONE_INTEGER, list(ONE_INTEGER), THREE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ONE_INTEGER, ONE_INTEGER)), list(ONE_INTEGER, list(TWO_INTEGER), THREE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, THREE_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ONE_INTEGER, ONE_INTEGER)), list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER)));

    private static final SubLSymbol POSITION_FROM_END = makeSymbol("POSITION-FROM-END");

    private static final SubLList $list243 = list(new SubLObject[]{ list(list(CHAR_a, makeString("abc")), ZERO_INTEGER), list(list(CHAR_a, makeString("bcd")), NIL), list(list(CHAR_a, makeString("aba")), TWO_INTEGER), list(list(makeSymbol("A"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("A"))), TWO_INTEGER), list(list(makeSymbol("A"), vector(new SubLObject[]{ makeSymbol("A"), makeSymbol("B"), makeSymbol("A") })), TWO_INTEGER), list(list(CHAR_a, makeString("abA"), EQL), ZERO_INTEGER), list(list(CHAR_a, makeString("abA"), EQUALP), TWO_INTEGER), list(list(CHAR_a, makeString("abA"), EQUALP, IDENTITY, ONE_INTEGER), ONE_INTEGER), list(list(CHAR_a, makeString("abA"), EQUALP, IDENTITY, ZERO_INTEGER, ONE_INTEGER), ZERO_INTEGER) });

    private static final SubLSymbol FIND_AND_REPLACE = makeSymbol("FIND-AND-REPLACE");

    private static final SubLList $list245 = list(list(list(ONE_INTEGER, TWO_INTEGER, list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(TWO_INTEGER, TWO_INTEGER, THREE_INTEGER)));

    private static final SubLSymbol FIRST_N_IF = makeSymbol("FIRST-N-IF");

    private static final SubLList $list247 = list(list(list(THREE_INTEGER, makeSymbol("NUMBERP"), list(makeSymbol("A"), ONE_INTEGER, TWO_INTEGER, makeSymbol("B"), THREE_INTEGER, FOUR_INTEGER, makeSymbol("C"))), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(NINE_INTEGER, makeSymbol("SYMBOLP"), list(makeSymbol("A"), ONE_INTEGER, TWO_INTEGER, makeSymbol("B"), THREE_INTEGER, FOUR_INTEGER, makeSymbol("C"))), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), list(list(TWO_INTEGER, makeSymbol("SYMBOLP"), list(list(ONE_INTEGER, TWO_INTEGER), list(makeSymbol("A"), THREE_INTEGER), list(makeSymbol("B"), makeSymbol("C")), list(makeSymbol("D"), FOUR_INTEGER), list(FIVE_INTEGER, makeSymbol("E"))), makeSymbol("FIRST")), list(list(makeSymbol("A"), THREE_INTEGER), list(makeSymbol("B"), makeSymbol("C")))));

    private static final SubLSymbol TREE_POSITION_IF_BFS = makeSymbol("TREE-POSITION-IF-BFS");

    private static final SubLList $list249 = list(makeSymbol("TREE-POSITION-TEST-CASE-TABLES"));

    private static final SubLList $list250 = list(list(list(makeSymbol("PRIME-NUMBER?"), list(list(ZERO_INTEGER, ZERO_INTEGER, list(ZERO_INTEGER, SEVEN_INTEGER)), list(THREE_INTEGER))), list(ONE_INTEGER, ZERO_INTEGER)));

    private static final SubLSymbol TREE_POSITION_IF_DFS = makeSymbol("TREE-POSITION-IF-DFS");

    private static final SubLList $list252 = list(list(list(makeSymbol("PRIME-NUMBER?"), list(list(ZERO_INTEGER, ZERO_INTEGER, list(ZERO_INTEGER, SEVEN_INTEGER)), list(THREE_INTEGER))), list(ZERO_INTEGER, TWO_INTEGER, ONE_INTEGER)));

    private static final SubLSymbol ARG_POSITIONS_DFS = makeSymbol("ARG-POSITIONS-DFS");

    private static final SubLList $list254 = list(list(list(TWO_INTEGER, list(TWO_INTEGER), EQUAL), list(list(ZERO_INTEGER))), list(list(list(TWO_INTEGER), list(TWO_INTEGER), EQUAL), list(NIL)));

    private static final SubLSymbol ARG_POSITIONS_BFS = makeSymbol("ARG-POSITIONS-BFS");

    private static final SubLSymbol RANK_TUPLES = makeSymbol("RANK-TUPLES");

    private static final SubLList $list257 = list(list(list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, ONE_INTEGER))), list(list(ZERO_INTEGER, ONE_INTEGER, ZERO_INTEGER, TWO_INTEGER, ONE_INTEGER, THREE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, TWO_INTEGER, FOUR_INTEGER, TWO_INTEGER, FIVE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, ONE_INTEGER, THREE_INTEGER, ZERO_INTEGER, ONE_INTEGER))));

    private static final SubLSymbol $sym258$NMEMBER_ = makeSymbol("NMEMBER?");

    private static final SubLList $list259 = list(list(list(makeSymbol("C"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), T), list(list(makeSymbol("B"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), T), list(list(makeSymbol("A"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), T), list(list(makeSymbol("Z"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), NIL));

    private static final SubLSymbol ALIST_NLOOKUP_WITHOUT_VALUES = makeSymbol("ALIST-NLOOKUP-WITHOUT-VALUES");

    private static final SubLList $list261 = list(list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), THREE_INTEGER), makeSymbol("C")), list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), TWO_INTEGER), makeSymbol("B")), list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), ONE_INTEGER), makeSymbol("A")), list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), ZERO_INTEGER), NIL));

    private static final SubLSymbol $sym262$EXACTLY_ONE_DISTINCT_MEMBER_ = makeSymbol("EXACTLY-ONE-DISTINCT-MEMBER?");

    static private final SubLList $list263 = list(list(list(NIL), NIL), list(list(list(ONE_INTEGER)), T), list(list(list(ONE_INTEGER, ONE_INTEGER)), T), list(list(list(ONE_INTEGER, ONE_INTEGER, ONE_INTEGER)), T), list(list(list(ONE_INTEGER, ONE_INTEGER, ONE_INTEGER, TWO_INTEGER)), NIL));

    private static final SubLSymbol SORT_PREFERRED_LIST_TO_FRONT = makeSymbol("SORT-PREFERRED-LIST-TO-FRONT");

    private static final SubLList $list265 = list(list(list(list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C")), list(makeSymbol("C"))), list(makeSymbol("C"), makeSymbol("A"), makeSymbol("B"))), list(list(list(cons(makeSymbol("A"), makeSymbol("B")), cons(makeSymbol("C"), makeSymbol("D")), cons(makeSymbol("E"), makeSymbol("F"))), list(makeSymbol("E")), makeSymbol("FIRST")), list(cons(makeSymbol("E"), makeSymbol("F")), cons(makeSymbol("A"), makeSymbol("B")), cons(makeSymbol("C"), makeSymbol("D")))));

    private static final SubLString $str266$List_Utilities_Module_Supercatego = makeString("List Utilities Module Supercategory");

    private static final SubLString $$$Utility_Subcategory = makeString("Utility Subcategory");

    private static final SubLString $str268$nadd_to_end_Testing_Suite = makeString("nadd-to-end Testing Suite");

    private static final SubLString $$$last1_Testing_Suite = makeString("last1 Testing Suite");

    /**
     * Convert OBJECT to T or NIL
     */
    @LispMethod(comment = "Convert OBJECT to T or NIL")
    public static final SubLObject sublisp_boolean_alt(SubLObject v_object) {
        return makeBoolean(NIL != v_object);
    }

    /**
     * Convert OBJECT to T or NIL
     */
    @LispMethod(comment = "Convert OBJECT to T or NIL")
    public static SubLObject sublisp_boolean(final SubLObject v_object) {
        return makeBoolean(NIL != v_object);
    }

    /**
     * Convert OBJECT to NIL or T
     */
    @LispMethod(comment = "Convert OBJECT to NIL or T")
    public static final SubLObject not_boolean_alt(SubLObject v_object) {
        return sublisp_null(v_object);
    }

    /**
     * Convert OBJECT to NIL or T
     */
    @LispMethod(comment = "Convert OBJECT to NIL or T")
    public static SubLObject not_boolean(final SubLObject v_object) {
        return sublisp_null(v_object);
    }

    public static final SubLObject not_eq_alt(SubLObject obj1, SubLObject obj2) {
        return makeBoolean(obj1 != obj2);
    }

    public static SubLObject not_eq(final SubLObject obj1, final SubLObject obj2) {
        return makeBoolean(!obj1.eql(obj2));
    }

    public static final SubLObject not_eql_alt(SubLObject obj1, SubLObject obj2) {
        return makeBoolean(!obj1.eql(obj2));
    }

    public static SubLObject not_eql(final SubLObject obj1, final SubLObject obj2) {
        return makeBoolean(!obj1.eql(obj2));
    }

    public static final SubLObject not_equal_alt(SubLObject obj1, SubLObject obj2) {
        return makeBoolean(!obj1.equal(obj2));
    }

    public static SubLObject not_equal(final SubLObject obj1, final SubLObject obj2) {
        return makeBoolean(!obj1.equal(obj2));
    }

    public static final SubLObject not_equalp_alt(SubLObject obj1, SubLObject obj2) {
        return makeBoolean(!obj1.equalp(obj2));
    }

    public static SubLObject not_equalp(final SubLObject obj1, final SubLObject obj2) {
        return makeBoolean(!obj1.equalp(obj2));
    }

    public static final SubLObject not_assoc_alt(SubLObject item, SubLObject alist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean(NIL == assoc(item, alist, test, key));
    }

    public static SubLObject not_assoc(final SubLObject item, final SubLObject alist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean(NIL == assoc(item, alist, test, key));
    }

    public static final SubLObject not_consp_alt(SubLObject v_object) {
        return makeBoolean(!v_object.isCons());
    }

    public static SubLObject not_consp(final SubLObject v_object) {
        return makeBoolean(!v_object.isCons());
    }

    public static final SubLObject eq_and_not_eq_alt(SubLObject obj1, SubLObject obj2) {
        return NIL;
    }

    public static SubLObject eq_and_not_eq(final SubLObject obj1, final SubLObject obj2) {
        return NIL;
    }

    /**
     * Like @xref false except it takes two arguments, which false also does.
     */
    @LispMethod(comment = "Like @xref false except it takes two arguments, which false also does.")
    public static final SubLObject bull_alt(SubLObject obj1, SubLObject obj2) {
        return NIL;
    }

    /**
     * Like @xref false except it takes two arguments, which false also does.
     */
    @LispMethod(comment = "Like @xref false except it takes two arguments, which false also does.")
    public static SubLObject bull(final SubLObject obj1, final SubLObject obj2) {
        return NIL;
    }

    public static SubLObject no_op() {
        return NIL;
    }

    public static final SubLObject caadr_alt(SubLObject list) {
        return cadr(list).first();
    }

    public static SubLObject caadr(final SubLObject list) {
        return cadr(list).first();
    }

    public static final SubLObject caddr_alt(SubLObject cons) {
        return cddr(cons).first();
    }

    public static SubLObject caddr(final SubLObject cons) {
        return cddr(cons).first();
    }

    public static final SubLObject cdddr_alt(SubLObject cons) {
        return cddr(cons).rest();
    }

    public static SubLObject cdddr(final SubLObject cons) {
        return cddr(cons).rest();
    }

    public static final SubLObject cadddr_alt(SubLObject cons) {
        return com.cyc.cycjava.cycl.list_utilities.cdddr(cons).first();
    }

    public static SubLObject cadddr(final SubLObject cons) {
        return cdddr(cons).first();
    }

    public static final SubLObject cadadr_alt(SubLObject cons) {
        return cadr(cadr(cons));
    }

    public static SubLObject cadadr(final SubLObject cons) {
        return cadr(cadr(cons));
    }

    public static final SubLObject cadar_alt(SubLObject cons) {
        return cdar(cons).first();
    }

    public static SubLObject cadar(final SubLObject cons) {
        return cdar(cons).first();
    }

    public static final SubLObject cdadr_alt(SubLObject list) {
        return cadr(list).rest();
    }

    public static SubLObject cdadr(final SubLObject list) {
        return cadr(list).rest();
    }

    /**
     * conses x onto the end of list l
     *
     * @unknown ckoehnen
     */
    @LispMethod(comment = "conses x onto the end of list l\r\n\r\n@unknown ckoehnen")
    public static final SubLObject snoc_alt(SubLObject x, SubLObject l) {
        return append(l, list(x));
    }

    /**
     * conses x onto the end of list l
     *
     * @unknown ckoehnen
     */
    @LispMethod(comment = "conses x onto the end of list l\r\n\r\n@unknown ckoehnen")
    public static SubLObject snoc(final SubLObject x, final SubLObject l) {
        return append(l, list(x));
    }

    public static final SubLObject list_rotate_left_alt(SubLObject list) {
        if (list.isCons()) {
            return append(list.rest(), list(list.first()));
        }
        return NIL;
    }

    public static SubLObject list_rotate_left(final SubLObject list) {
        if (list.isCons()) {
            return append(list.rest(), list(list.first()));
        }
        return NIL;
    }

    public static final SubLObject list_rotate_right_alt(SubLObject list) {
        if (list.isCons()) {
            return append(last(list, UNPROVIDED), butlast(list, UNPROVIDED));
        }
        return NIL;
    }

    public static SubLObject list_rotate_right(final SubLObject list) {
        if (list.isCons()) {
            return append(last(list, UNPROVIDED), butlast(list, UNPROVIDED));
        }
        return NIL;
    }

    public static final SubLObject proper_subsetp_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean((NIL != subsetp(list1, list2, test, key)) && (NIL == subsetp(list2, list1, test, key)));
    }

    public static SubLObject proper_subsetp(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean((NIL != subsetp(list1, list2, test, key)) && (NIL == subsetp(list2, list1, test, key)));
    }

    /**
     * This assumes that list1 and list2 are sorted by equivalent ordering relations.
     * The result is undefined when they are not.
     */
    @LispMethod(comment = "This assumes that list1 and list2 are sorted by equivalent ordering relations.\r\nThe result is undefined when they are not.\nThis assumes that list1 and list2 are sorted by equivalent ordering relations.\nThe result is undefined when they are not.")
    public static final SubLObject proper_subsetp_pre_sorted_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean((NIL != subsetp(list1, list2, test, key)) && (!list1.equal(list2)));
    }

    /**
     * This assumes that list1 and list2 are sorted by equivalent ordering relations.
     * The result is undefined when they are not.
     */
    @LispMethod(comment = "This assumes that list1 and list2 are sorted by equivalent ordering relations.\r\nThe result is undefined when they are not.\nThis assumes that list1 and list2 are sorted by equivalent ordering relations.\nThe result is undefined when they are not.")
    public static SubLObject proper_subsetp_pre_sorted(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean((NIL != subsetp(list1, list2, test, key)) && (!list1.equal(list2)));
    }

    /**
     * Exactly like nth for 0 <= N < (length LIST).  For N not in this range, nth-cycling essentially returns (nth (mod N (length LIST) LIST).  For the advanced usage, WIDTH and OFFSET may be specified to have nth-cycling use an arbitrary sublist of a list.
     *
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Exactly like nth for 0 <= N < (length LIST).  For N not in this range, nth-cycling essentially returns (nth (mod N (length LIST) LIST).  For the advanced usage, WIDTH and OFFSET may be specified to have nth-cycling use an arbitrary sublist of a list.\r\n\r\n@unknown jantos\r\n@unknown done")
    public static final SubLObject nth_cycling_alt(SubLObject n, SubLObject list, SubLObject width, SubLObject offset) {
        if (width == UNPROVIDED) {
            width = NIL;
        }
        if (offset == UNPROVIDED) {
            offset = ZERO_INTEGER;
        }
        {
            SubLObject list_length = length(list);
            if (ZERO_INTEGER.numE(list_length)) {
                return NIL;
            }
            if (NIL == width) {
                width = list_length;
            }
            if (width.numL(ZERO_INTEGER)) {
                Errors.error($str_alt1$nth_cycling__width_must_be_greate);
            } else {
                if (width.numG(list_length)) {
                    Errors.error($str_alt2$nth_cycling__width_must_be_less_t);
                } else {
                    if (offset.numL(ZERO_INTEGER) && width.numG(abs(offset))) {
                        Errors.error($str_alt3$nth_cycling__width_overruns_offse);
                    } else {
                        if (offset.numG(ZERO_INTEGER) && width.numG(subtract(list_length, offset))) {
                            Errors.error($str_alt3$nth_cycling__width_overruns_offse);
                        }
                    }
                }
            }
            if (!ZERO_INTEGER.numE(offset)) {
                if (ZERO_INTEGER.numL(offset)) {
                    list = nthcdr(offset, list);
                } else {
                    list = nthcdr(add(list_length, offset), list);
                }
            }
            return nth(mod(n, width), list);
        }
    }

    /**
     * Exactly like nth for 0 <= N < (length LIST).  For N not in this range, nth-cycling essentially returns (nth (mod N (length LIST) LIST).  For the advanced usage, WIDTH and OFFSET may be specified to have nth-cycling use an arbitrary sublist of a list.
     *
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Exactly like nth for 0 <= N < (length LIST).  For N not in this range, nth-cycling essentially returns (nth (mod N (length LIST) LIST).  For the advanced usage, WIDTH and OFFSET may be specified to have nth-cycling use an arbitrary sublist of a list.\r\n\r\n@unknown jantos\r\n@unknown done")
    public static SubLObject nth_cycling(final SubLObject n, SubLObject list, SubLObject width, SubLObject offset) {
        if (width == UNPROVIDED) {
            width = NIL;
        }
        if (offset == UNPROVIDED) {
            offset = ZERO_INTEGER;
        }
        final SubLObject list_length = length(list);
        if (ZERO_INTEGER.numE(list_length)) {
            return NIL;
        }
        if (NIL == width) {
            width = list_length;
        }
        if (width.numL(ZERO_INTEGER)) {
            Errors.error($str1$nth_cycling__width_must_be_greate);
        } else
            if (width.numG(list_length)) {
                Errors.error($str2$nth_cycling__width_must_be_less_t);
            } else
                if (offset.numL(ZERO_INTEGER) && width.numG(abs(offset))) {
                    Errors.error($str3$nth_cycling__width_overruns_offse);
                } else
                    if (offset.numG(ZERO_INTEGER) && width.numG(subtract(list_length, offset))) {
                        Errors.error($str3$nth_cycling__width_overruns_offse);
                    }



        if (!ZERO_INTEGER.numE(offset)) {
            if (ZERO_INTEGER.numL(offset)) {
                list = nthcdr(offset, list);
            } else {
                list = nthcdr(add(list_length, offset), list);
            }
        }
        return nth(mod(n, width), list);
    }

    /**
     * Pop the first item off of the list at PLACE and set the variable VAR to its value.
     */
    @LispMethod(comment = "Pop the first item off of the list at PLACE and set the variable VAR to its value.")
    public static final SubLObject pop_setq_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject var = NIL;
            SubLObject place = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt4);
            var = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt4);
            place = current.first();
            current = current.rest();
            if (NIL == current) {
                return list(PROGN, list(CSETQ, var, list(FIRST, place)), list(CPOP, place));
            } else {
                cdestructuring_bind_error(datum, $list_alt4);
            }
        }
        return NIL;
    }

    /**
     * Pop the first item off of the list at PLACE and set the variable VAR to its value.
     */
    @LispMethod(comment = "Pop the first item off of the list at PLACE and set the variable VAR to its value.")
    public static SubLObject pop_setq(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject var = NIL;
        SubLObject place = NIL;
        destructuring_bind_must_consp(current, datum, $list4);
        var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list4);
        place = current.first();
        current = current.rest();
        if (NIL == current) {
            return list(PROGN, list(CSETQ, var, list(FIRST, place)), list(CPOP, place));
        }
        cdestructuring_bind_error(datum, $list4);
        return NIL;
    }

    /**
     * Pop the first item off of the list at PLACE and bind the variable VAR to its value while executing BODY.
     */
    @LispMethod(comment = "Pop the first item off of the list at PLACE and bind the variable VAR to its value while executing BODY.")
    public static final SubLObject pop_bind_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt9);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject var = NIL;
                    SubLObject place = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt9);
                    var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt9);
                    place = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        current = temp;
                        {
                            SubLObject body = current;
                            return listS(CLET, list(list(var, list(FIRST, place))), list(CPOP, place), append(body, NIL));
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list_alt9);
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Pop the first item off of the list at PLACE and bind the variable VAR to its value while executing BODY.
     */
    @LispMethod(comment = "Pop the first item off of the list at PLACE and bind the variable VAR to its value while executing BODY.")
    public static SubLObject pop_bind(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list9);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject var = NIL;
        SubLObject place = NIL;
        destructuring_bind_must_consp(current, datum, $list9);
        var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list9);
        place = current.first();
        current = current.rest();
        if (NIL == current) {
            final SubLObject body;
            current = body = temp;
            return listS(CLET, list(list(var, list(FIRST, place))), list(CPOP, place), append(body, NIL));
        }
        cdestructuring_bind_error(datum, $list9);
        return NIL;
    }

    /**
     * Push ITEM onto the list at PLACE, and prevent the length of the list from exceeding MAX-LENGTH if necessary by knocking an element off the end of it (or multiple elements, if the list already exceeds MAX-LENGTH).
     */
    @LispMethod(comment = "Push ITEM onto the list at PLACE, and prevent the length of the list from exceeding MAX-LENGTH if necessary by knocking an element off the end of it (or multiple elements, if the list already exceeds MAX-LENGTH).")
    public static final SubLObject push_max_length_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject item = NIL;
            SubLObject place = NIL;
            SubLObject max_length = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt11);
            item = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt11);
            place = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt11);
            max_length = current.first();
            current = current.rest();
            if (NIL == current) {
                return list(CSETF, place, list(CONS, item, list(FIRST_N, listS($sym15$_, max_length, $list_alt16), place)));
            } else {
                cdestructuring_bind_error(datum, $list_alt11);
            }
        }
        return NIL;
    }

    /**
     * Push ITEM onto the list at PLACE, and prevent the length of the list from exceeding MAX-LENGTH if necessary by knocking an element off the end of it (or multiple elements, if the list already exceeds MAX-LENGTH).
     */
    @LispMethod(comment = "Push ITEM onto the list at PLACE, and prevent the length of the list from exceeding MAX-LENGTH if necessary by knocking an element off the end of it (or multiple elements, if the list already exceeds MAX-LENGTH).")
    public static SubLObject push_max_length(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject item = NIL;
        SubLObject place = NIL;
        SubLObject max_length = NIL;
        destructuring_bind_must_consp(current, datum, $list11);
        item = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list11);
        place = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list11);
        max_length = current.first();
        current = current.rest();
        if (NIL == current) {
            return list(CSETF, place, list(CONS, item, list(FIRST_N, listS($sym15$_, max_length, $list16), place)));
        }
        cdestructuring_bind_error(datum, $list11);
        return NIL;
    }

    /**
     * Iterates multiple varaibles over multiple lists, i.e., the procedural analogue of
     * MAPCAR.  VAR-LIST-FORMS should be a list of the form ((var0 listform0)
     * (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,
     * binds var0 to (nth i listform0), var1 to (nth i listform1), etc.  Loop
     * does not terminate until all of var0..varn are NIL.
     *
     * @unknown sutton
     */
    @LispMethod(comment = "Iterates multiple varaibles over multiple lists, i.e., the procedural analogue of\r\nMAPCAR.  VAR-LIST-FORMS should be a list of the form ((var0 listform0)\r\n(var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,\r\nbinds var0 to (nth i listform0), var1 to (nth i listform1), etc.  Loop\r\ndoes not terminate until all of var0..varn are NIL.\r\n\r\n@unknown sutton\nIterates multiple varaibles over multiple lists, i.e., the procedural analogue of\nMAPCAR.  VAR-LIST-FORMS should be a list of the form ((var0 listform0)\n(var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,\nbinds var0 to (nth i listform0), var1 to (nth i listform1), etc.  Loop\ndoes not terminate until all of var0..varn are NIL.")
    public static final SubLObject cdolist_multiple_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt17);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject var_list_forms = current;
                    current = temp;
                    {
                        SubLObject body = current;
                        SubLObject init_forms = NIL;
                        SubLObject end_test_forms = NIL;
                        SubLObject cdolist_list_var = var_list_forms;
                        SubLObject form = NIL;
                        for (form = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , form = cdolist_list_var.first()) {
                            {
                                SubLObject datum_1 = form;
                                SubLObject current_2 = datum_1;
                                SubLObject var = NIL;
                                SubLObject listform = NIL;
                                destructuring_bind_must_consp(current_2, datum_1, $list_alt18);
                                var = current_2.first();
                                current_2 = current_2.rest();
                                destructuring_bind_must_consp(current_2, datum_1, $list_alt18);
                                listform = current_2.first();
                                current_2 = current_2.rest();
                                if (NIL == current_2) {
                                    {
                                        SubLObject list_sym = make_symbol(symbol_name(var));
                                        init_forms = cons(list(list_sym, listform, list(CDR, list_sym)), init_forms);
                                        init_forms = cons(list(var, list(CAR, list_sym), list(CAR, list_sym)), init_forms);
                                        end_test_forms = cons(list(NULL, list_sym), end_test_forms);
                                    }
                                } else {
                                    cdestructuring_bind_error(datum_1, $list_alt18);
                                }
                            }
                        }
                        return listS(CDO, nreverse(init_forms), list(bq_cons(CAND, end_test_forms)), append(body, NIL));
                    }
                }
            }
        }
    }

    /**
     * Iterates multiple varaibles over multiple lists, i.e., the procedural analogue of
     * MAPCAR.  VAR-LIST-FORMS should be a list of the form ((var0 listform0)
     * (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,
     * binds var0 to (nth i listform0), var1 to (nth i listform1), etc.  Loop
     * does not terminate until all of var0..varn are NIL.
     *
     * @unknown sutton
     */
    @LispMethod(comment = "Iterates multiple varaibles over multiple lists, i.e., the procedural analogue of\r\nMAPCAR.  VAR-LIST-FORMS should be a list of the form ((var0 listform0)\r\n(var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,\r\nbinds var0 to (nth i listform0), var1 to (nth i listform1), etc.  Loop\r\ndoes not terminate until all of var0..varn are NIL.\r\n\r\n@unknown sutton\nIterates multiple varaibles over multiple lists, i.e., the procedural analogue of\nMAPCAR.  VAR-LIST-FORMS should be a list of the form ((var0 listform0)\n(var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,\nbinds var0 to (nth i listform0), var1 to (nth i listform1), etc.  Loop\ndoes not terminate until all of var0..varn are NIL.")
    public static SubLObject cdolist_multiple(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list17);
        final SubLObject temp = current.rest();
        final SubLObject var_list_forms;
        current = var_list_forms = current.first();
        final SubLObject body;
        current = body = temp;
        SubLObject init_forms = NIL;
        SubLObject end_test_forms = NIL;
        SubLObject cdolist_list_var = var_list_forms;
        SubLObject form = NIL;
        form = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current_$2;
            final SubLObject datum_$1 = current_$2 = form;
            SubLObject var = NIL;
            SubLObject listform = NIL;
            destructuring_bind_must_consp(current_$2, datum_$1, $list18);
            var = current_$2.first();
            current_$2 = current_$2.rest();
            destructuring_bind_must_consp(current_$2, datum_$1, $list18);
            listform = current_$2.first();
            current_$2 = current_$2.rest();
            if (NIL == current_$2) {
                final SubLObject list_sym = make_symbol(symbol_name(var));
                init_forms = cons(list(list_sym, listform, list(CDR, list_sym)), init_forms);
                init_forms = cons(list(var, list(CAR, list_sym), list(CAR, list_sym)), init_forms);
                end_test_forms = cons(list(NULL, list_sym), end_test_forms);
            } else {
                cdestructuring_bind_error(datum_$1, $list18);
            }
            cdolist_list_var = cdolist_list_var.rest();
            form = cdolist_list_var.first();
        } 
        return listS(CDO, nreverse(init_forms), list(bq_cons(CAND, end_test_forms)), append(body, NIL));
    }

    /**
     * Just like CDOLIST-MULTIPLE except that NUMBER-VAR (which starts at
     * 0) is incremented at (the end of) each iteration.
     *
     * @unknown kknight
     */
    @LispMethod(comment = "Just like CDOLIST-MULTIPLE except that NUMBER-VAR (which starts at\r\n0) is incremented at (the end of) each iteration.\r\n\r\n@unknown kknight\nJust like CDOLIST-MULTIPLE except that NUMBER-VAR (which starts at\n0) is incremented at (the end of) each iteration.")
    public static final SubLObject cdolist_multiple_numbered_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt24);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject number_var = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt24);
                    number_var = current.first();
                    current = current.rest();
                    {
                        SubLObject var_list_forms = current;
                        current = temp;
                        {
                            SubLObject body = current;
                            return list(CLET, list(bq_cons(number_var, $list_alt25)), listS(CDOLIST_MULTIPLE, var_list_forms, append(body, list(list(CINC, number_var)))));
                        }
                    }
                }
            }
        }
    }

    /**
     * Just like CDOLIST-MULTIPLE except that NUMBER-VAR (which starts at
     * 0) is incremented at (the end of) each iteration.
     *
     * @unknown kknight
     */
    @LispMethod(comment = "Just like CDOLIST-MULTIPLE except that NUMBER-VAR (which starts at\r\n0) is incremented at (the end of) each iteration.\r\n\r\n@unknown kknight\nJust like CDOLIST-MULTIPLE except that NUMBER-VAR (which starts at\n0) is incremented at (the end of) each iteration.")
    public static SubLObject cdolist_multiple_numbered(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list24);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject number_var = NIL;
        destructuring_bind_must_consp(current, datum, $list24);
        number_var = current.first();
        final SubLObject var_list_forms;
        current = var_list_forms = current.rest();
        final SubLObject body;
        current = body = temp;
        return list(CLET, list(bq_cons(number_var, $list25)), listS(CDOLIST_MULTIPLE, var_list_forms, append(body, list(list(CINC, number_var)))));
    }

    /**
     * Iterates multiple variables over multiple lists until END-VAR is T. Just like
     *
     * @unknown CDOLIST-MULTIPLE, VAR-LIST-FORMS should be a list of the form ((var0 listform0)
    (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,
    binds var0 to (nth i listform0), var1 to (nth i listform1), etc.  The loop
    does not terminate until all of var0..varn are NIL, or END-VAR is T.
     * @unknown This macro is totally modelled after @xref CDOLIST-MULTIPLE.
     * @unknown zelal
     */
    @LispMethod(comment = "Iterates multiple variables over multiple lists until END-VAR is T. Just like\r\n\r\n@unknown CDOLIST-MULTIPLE, VAR-LIST-FORMS should be a list of the form ((var0 listform0)\r\n(var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,\r\nbinds var0 to (nth i listform0), var1 to (nth i listform1), etc.  The loop\r\ndoes not terminate until all of var0..varn are NIL, or END-VAR is T.\r\n@unknown This macro is totally modelled after @xref CDOLIST-MULTIPLE.\r\n@unknown zelal")
    public static final SubLObject csome_multiple_alt(SubLObject macroform, SubLObject environment) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject datum = macroform.rest();
                SubLObject current = datum;
                destructuring_bind_must_consp(current, datum, $list_alt28);
                {
                    SubLObject temp = current.rest();
                    current = current.first();
                    {
                        SubLObject endvar = NIL;
                        destructuring_bind_must_consp(current, datum, $list_alt28);
                        endvar = current.first();
                        current = current.rest();
                        {
                            SubLObject var_list_forms = current;
                            current = temp;
                            {
                                SubLObject body = current;
                                if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
                                    if (!endvar.isSymbol()) {
                                        Errors.error($str_alt29$Malformed_csome_multiple_____S_wa, endvar);
                                    }
                                }
                                {
                                    SubLObject init_forms = NIL;
                                    SubLObject end_test_forms = NIL;
                                    SubLObject cdolist_list_var = var_list_forms;
                                    SubLObject form = NIL;
                                    for (form = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , form = cdolist_list_var.first()) {
                                        {
                                            SubLObject datum_3 = form;
                                            SubLObject current_4 = datum_3;
                                            SubLObject var = NIL;
                                            SubLObject listform = NIL;
                                            destructuring_bind_must_consp(current_4, datum_3, $list_alt18);
                                            var = current_4.first();
                                            current_4 = current_4.rest();
                                            destructuring_bind_must_consp(current_4, datum_3, $list_alt18);
                                            listform = current_4.first();
                                            current_4 = current_4.rest();
                                            if (NIL == current_4) {
                                                {
                                                    SubLObject list_sym = make_symbol(symbol_name(var));
                                                    init_forms = cons(list(list_sym, listform, list(CDR, list_sym)), init_forms);
                                                    init_forms = cons(list(var, list(CAR, list_sym), list(CAR, list_sym)), init_forms);
                                                    end_test_forms = cons(list(NULL, list_sym), end_test_forms);
                                                }
                                            } else {
                                                cdestructuring_bind_error(datum_3, $list_alt18);
                                            }
                                        }
                                    }
                                    return list(PUNLESS, endvar, listS(CDO, nreverse(init_forms), list(list(COR, endvar, bq_cons(CAND, end_test_forms))), append(body, NIL)));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Iterates multiple variables over multiple lists until END-VAR is T. Just like
     *
     * @unknown CDOLIST-MULTIPLE, VAR-LIST-FORMS should be a list of the form ((var0 listform0)
    (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,
    binds var0 to (nth i listform0), var1 to (nth i listform1), etc.  The loop
    does not terminate until all of var0..varn are NIL, or END-VAR is T.
     * @unknown This macro is totally modelled after @xref CDOLIST-MULTIPLE.
     * @unknown zelal
     */
    @LispMethod(comment = "Iterates multiple variables over multiple lists until END-VAR is T. Just like\r\n\r\n@unknown CDOLIST-MULTIPLE, VAR-LIST-FORMS should be a list of the form ((var0 listform0)\r\n(var1 listform1) ... (varn listformn)).  For the ith iteration of the loop,\r\nbinds var0 to (nth i listform0), var1 to (nth i listform1), etc.  The loop\r\ndoes not terminate until all of var0..varn are NIL, or END-VAR is T.\r\n@unknown This macro is totally modelled after @xref CDOLIST-MULTIPLE.\r\n@unknown zelal")
    public static SubLObject csome_multiple(final SubLObject macroform, final SubLObject environment) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list28);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject endvar = NIL;
        destructuring_bind_must_consp(current, datum, $list28);
        endvar = current.first();
        final SubLObject var_list_forms;
        current = var_list_forms = current.rest();
        final SubLObject body;
        current = body = temp;
        if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (!endvar.isSymbol())) {
            Errors.error($str29$Malformed_csome_multiple_____S_wa, endvar);
        }
        SubLObject init_forms = NIL;
        SubLObject end_test_forms = NIL;
        SubLObject cdolist_list_var = var_list_forms;
        SubLObject form = NIL;
        form = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current_$4;
            final SubLObject datum_$3 = current_$4 = form;
            SubLObject var = NIL;
            SubLObject listform = NIL;
            destructuring_bind_must_consp(current_$4, datum_$3, $list18);
            var = current_$4.first();
            current_$4 = current_$4.rest();
            destructuring_bind_must_consp(current_$4, datum_$3, $list18);
            listform = current_$4.first();
            current_$4 = current_$4.rest();
            if (NIL == current_$4) {
                final SubLObject list_sym = make_symbol(symbol_name(var));
                init_forms = cons(list(list_sym, listform, list(CDR, list_sym)), init_forms);
                init_forms = cons(list(var, list(CAR, list_sym), list(CAR, list_sym)), init_forms);
                end_test_forms = cons(list(NULL, list_sym), end_test_forms);
            } else {
                cdestructuring_bind_error(datum_$3, $list18);
            }
            cdolist_list_var = cdolist_list_var.rest();
            form = cdolist_list_var.first();
        } 
        return list(PUNLESS, endvar, listS(CDO, nreverse(init_forms), list(list(COR, endvar, bq_cons(CAND, end_test_forms))), append(body, NIL)));
    }

    /**
     * Iterates ELEM-VAR over each element in LISTFORM, incrementing NUMBER-VAR
     * by 1 for each iteration (starts at 0).  Evaluates BODY on each
     * iteration.
     */
    @LispMethod(comment = "Iterates ELEM-VAR over each element in LISTFORM, incrementing NUMBER-VAR\r\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\r\niteration.\nIterates ELEM-VAR over each element in LISTFORM, incrementing NUMBER-VAR\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\niteration.")
    public static final SubLObject cdolist_numbered_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt32);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject elem_var = NIL;
                    SubLObject number_var = NIL;
                    SubLObject listform = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt32);
                    elem_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt32);
                    number_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt32);
                    listform = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        current = temp;
                        {
                            SubLObject body = current;
                            SubLObject list_var = $sym33$LIST_VAR;
                            return listS(CDO, list(list(list_var, listform, list(CDR, list_var)), list(elem_var, list(CAR, list_var), list(CAR, list_var)), list(number_var, ZERO_INTEGER, list($sym34$_, ONE_INTEGER, number_var))), list(list(NULL, list_var)), append(body, NIL));
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list_alt32);
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Iterates ELEM-VAR over each element in LISTFORM, incrementing NUMBER-VAR
     * by 1 for each iteration (starts at 0).  Evaluates BODY on each
     * iteration.
     */
    @LispMethod(comment = "Iterates ELEM-VAR over each element in LISTFORM, incrementing NUMBER-VAR\r\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\r\niteration.\nIterates ELEM-VAR over each element in LISTFORM, incrementing NUMBER-VAR\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\niteration.")
    public static SubLObject cdolist_numbered(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list32);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject elem_var = NIL;
        SubLObject number_var = NIL;
        SubLObject listform = NIL;
        destructuring_bind_must_consp(current, datum, $list32);
        elem_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list32);
        number_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list32);
        listform = current.first();
        current = current.rest();
        if (NIL == current) {
            final SubLObject body;
            current = body = temp;
            final SubLObject list_var = $sym33$LIST_VAR;
            return listS(CDO, list(list(list_var, listform, list(CDR, list_var)), list(elem_var, list(CAR, list_var), list(CAR, list_var)), list(number_var, ZERO_INTEGER, list($sym34$_, ONE_INTEGER, number_var))), list(list(NULL, list_var)), append(body, NIL));
        }
        cdestructuring_bind_error(datum, $list32);
        return NIL;
    }

    /**
     * Iterates VAR over each element in LISTFORM backward.  Evaluates BODY on each
     * iteration.
     */
    @LispMethod(comment = "Iterates VAR over each element in LISTFORM backward.  Evaluates BODY on each\r\niteration.\nIterates VAR over each element in LISTFORM backward.  Evaluates BODY on each\niteration.")
    public static final SubLObject cdolist_backward_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt35);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject var = NIL;
                    SubLObject listform = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt35);
                    var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt35);
                    listform = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        current = temp;
                        {
                            SubLObject body = current;
                            return listS(CDOLIST, list(var, list(REVERSE, listform)), append(body, NIL));
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list_alt35);
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Iterates VAR over each element in LISTFORM backward.  Evaluates BODY on each
     * iteration.
     */
    @LispMethod(comment = "Iterates VAR over each element in LISTFORM backward.  Evaluates BODY on each\r\niteration.\nIterates VAR over each element in LISTFORM backward.  Evaluates BODY on each\niteration.")
    public static SubLObject cdolist_backward(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list35);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject var = NIL;
        SubLObject listform = NIL;
        destructuring_bind_must_consp(current, datum, $list35);
        var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list35);
        listform = current.first();
        current = current.rest();
        if (NIL == current) {
            final SubLObject body;
            current = body = temp;
            return listS(CDOLIST, list(var, list(REVERSE, listform)), append(body, NIL));
        }
        cdestructuring_bind_error(datum, $list35);
        return NIL;
    }

    /**
     * Iterates ELEM-VAR over each element in LISTFORM backward, decrementing NUMBER-VAR
     * by 1 for each iteration (ends at 0).  Evaluates BODY on each
     * iteration.
     */
    @LispMethod(comment = "Iterates ELEM-VAR over each element in LISTFORM backward, decrementing NUMBER-VAR\r\nby 1 for each iteration (ends at 0).  Evaluates BODY on each\r\niteration.\nIterates ELEM-VAR over each element in LISTFORM backward, decrementing NUMBER-VAR\nby 1 for each iteration (ends at 0).  Evaluates BODY on each\niteration.")
    public static final SubLObject cdolist_backward_numbered_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt32);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject elem_var = NIL;
                    SubLObject number_var = NIL;
                    SubLObject listform = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt32);
                    elem_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt32);
                    number_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt32);
                    listform = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        current = temp;
                        {
                            SubLObject body = current;
                            SubLObject list_var = $sym38$LIST_VAR;
                            return listS(CDO, list(list(list_var, list(REVERSE, listform), list(CDR, list_var)), list(elem_var, list(CAR, list_var), list(CAR, list_var)), list(number_var, list($sym39$1_, list(LENGTH, listform)), list($sym39$1_, number_var))), list(list(NULL, list_var)), append(body, NIL));
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list_alt32);
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Iterates ELEM-VAR over each element in LISTFORM backward, decrementing NUMBER-VAR
     * by 1 for each iteration (ends at 0).  Evaluates BODY on each
     * iteration.
     */
    @LispMethod(comment = "Iterates ELEM-VAR over each element in LISTFORM backward, decrementing NUMBER-VAR\r\nby 1 for each iteration (ends at 0).  Evaluates BODY on each\r\niteration.\nIterates ELEM-VAR over each element in LISTFORM backward, decrementing NUMBER-VAR\nby 1 for each iteration (ends at 0).  Evaluates BODY on each\niteration.")
    public static SubLObject cdolist_backward_numbered(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list32);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject elem_var = NIL;
        SubLObject number_var = NIL;
        SubLObject listform = NIL;
        destructuring_bind_must_consp(current, datum, $list32);
        elem_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list32);
        number_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list32);
        listform = current.first();
        current = current.rest();
        if (NIL == current) {
            final SubLObject body;
            current = body = temp;
            final SubLObject list_var = $sym38$LIST_VAR;
            return listS(CDO, list(list(list_var, list(REVERSE, listform), list(CDR, list_var)), list(elem_var, list(CAR, list_var), list(CAR, list_var)), list(number_var, list($sym39$1_, list(LENGTH, listform)), list($sym39$1_, number_var))), list(list(NULL, list_var)), append(body, NIL));
        }
        cdestructuring_bind_error(datum, $list32);
        return NIL;
    }

    /**
     * Iterates ELEM-VAR over each element in LIST, incrementing NUMBER-VAR
     * by 1 for each iteration (starts at 0).  Evaluates BODY on each
     * iteration.  Stops if ENDVAR becomes true.
     */
    @LispMethod(comment = "Iterates ELEM-VAR over each element in LIST, incrementing NUMBER-VAR\r\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\r\niteration.  Stops if ENDVAR becomes true.\nIterates ELEM-VAR over each element in LIST, incrementing NUMBER-VAR\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\niteration.  Stops if ENDVAR becomes true.")
    public static final SubLObject csome_numbered_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt41);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject elem_var = NIL;
                    SubLObject number_var = NIL;
                    SubLObject listform = NIL;
                    SubLObject endvar = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt41);
                    elem_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt41);
                    number_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt41);
                    listform = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt41);
                    endvar = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        current = temp;
                        {
                            SubLObject body = current;
                            SubLObject list_var = $sym42$LIST_VAR;
                            return listS(CDO, list(list(list_var, listform, list(CDR, list_var)), list(elem_var, list(CAR, list_var), list(CAR, list_var)), list(number_var, ZERO_INTEGER, list($sym34$_, ONE_INTEGER, number_var))), list(list(COR, endvar, list(NULL, list_var))), append(body, NIL));
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list_alt41);
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Iterates ELEM-VAR over each element in LIST, incrementing NUMBER-VAR
     * by 1 for each iteration (starts at 0).  Evaluates BODY on each
     * iteration.  Stops if ENDVAR becomes true.
     */
    @LispMethod(comment = "Iterates ELEM-VAR over each element in LIST, incrementing NUMBER-VAR\r\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\r\niteration.  Stops if ENDVAR becomes true.\nIterates ELEM-VAR over each element in LIST, incrementing NUMBER-VAR\nby 1 for each iteration (starts at 0).  Evaluates BODY on each\niteration.  Stops if ENDVAR becomes true.")
    public static SubLObject csome_numbered(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list41);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject elem_var = NIL;
        SubLObject number_var = NIL;
        SubLObject listform = NIL;
        SubLObject endvar = NIL;
        destructuring_bind_must_consp(current, datum, $list41);
        elem_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list41);
        number_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list41);
        listform = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list41);
        endvar = current.first();
        current = current.rest();
        if (NIL == current) {
            final SubLObject body;
            current = body = temp;
            final SubLObject list_var = $sym42$LIST_VAR;
            return listS(CDO, list(list(list_var, listform, list(CDR, list_var)), list(elem_var, list(CAR, list_var), list(CAR, list_var)), list(number_var, ZERO_INTEGER, list($sym34$_, ONE_INTEGER, number_var))), list(list(COR, endvar, list(NULL, list_var))), append(body, NIL));
        }
        cdestructuring_bind_error(datum, $list41);
        return NIL;
    }

    /**
     * Iterates multiple variables over multiple lists like @xref cdolist-multiple, but with the additional functionality of reusing the smaller lists so that instead of biding a variable to nil after the list is used up as cdolist-multiple does, we iterate through the smaller lists again.  VAR-LIST-FORMS should be a list of the form ((var0 listform0) (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop, binds var0 to (nth-cycling i listform0), var1 to (nth-cycling i listform1), etc.  Loop does not terminate until the longest list is iterated through.
     *
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Iterates multiple variables over multiple lists like @xref cdolist-multiple, but with the additional functionality of reusing the smaller lists so that instead of biding a variable to nil after the list is used up as cdolist-multiple does, we iterate through the smaller lists again.  VAR-LIST-FORMS should be a list of the form ((var0 listform0) (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop, binds var0 to (nth-cycling i listform0), var1 to (nth-cycling i listform1), etc.  Loop does not terminate until the longest list is iterated through.\r\n\r\n@unknown jantos\r\n@unknown done")
    public static final SubLObject cdolist_cycling_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt17);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject var_list_forms = current;
                    current = temp;
                    {
                        SubLObject body = current;
                        return listS(CDOLIST_CYCLING_COMPLEX, list(var_list_forms), append(body, NIL));
                    }
                }
            }
        }
    }

    /**
     * Iterates multiple variables over multiple lists like @xref cdolist-multiple, but with the additional functionality of reusing the smaller lists so that instead of biding a variable to nil after the list is used up as cdolist-multiple does, we iterate through the smaller lists again.  VAR-LIST-FORMS should be a list of the form ((var0 listform0) (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop, binds var0 to (nth-cycling i listform0), var1 to (nth-cycling i listform1), etc.  Loop does not terminate until the longest list is iterated through.
     *
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Iterates multiple variables over multiple lists like @xref cdolist-multiple, but with the additional functionality of reusing the smaller lists so that instead of biding a variable to nil after the list is used up as cdolist-multiple does, we iterate through the smaller lists again.  VAR-LIST-FORMS should be a list of the form ((var0 listform0) (var1 listform1) ... (varn listformn)).  For the ith iteration of the loop, binds var0 to (nth-cycling i listform0), var1 to (nth-cycling i listform1), etc.  Loop does not terminate until the longest list is iterated through.\r\n\r\n@unknown jantos\r\n@unknown done")
    public static SubLObject cdolist_cycling(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list17);
        final SubLObject temp = current.rest();
        final SubLObject var_list_forms;
        current = var_list_forms = current.first();
        final SubLObject body;
        current = body = temp;
        return listS(CDOLIST_CYCLING_COMPLEX, list(var_list_forms), append(body, NIL));
    }

    /**
     * Essentially the same as @xref cdolist-cycling but allows specification of which lists are "secondary", meaning lists we don't use to determine when to stop iterating.  e.g. if we do (cdolist-cycling ((number '(1 2 3)) (parity '('odd 'even))) [...]), we'll get a meaningful mapping.  But if the list '(1 2 3 4) was just '(1), the mapping breaks down.  The solution is to do a (cdolist-cycling-complex (((number '(1)) (parity '('odd 'even))) (1)) [...]), which means that the list at position 1 isn't used to determine when to stop iterating and so only one iterations is done.
     *
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Essentially the same as @xref cdolist-cycling but allows specification of which lists are \"secondary\", meaning lists we don\'t use to determine when to stop iterating.  e.g. if we do (cdolist-cycling ((number \'(1 2 3)) (parity \'(\'odd \'even))) [...]), we\'ll get a meaningful mapping.  But if the list \'(1 2 3 4) was just \'(1), the mapping breaks down.  The solution is to do a (cdolist-cycling-complex (((number \'(1)) (parity \'(\'odd \'even))) (1)) [...]), which means that the list at position 1 isn\'t used to determine when to stop iterating and so only one iterations is done.\r\n\r\n@unknown jantos\r\n@unknown done")
    public static final SubLObject cdolist_cycling_complex_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt44);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject var_list_forms = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt44);
                    var_list_forms = current.first();
                    current = current.rest();
                    {
                        SubLObject secondary_lists = (current.isCons()) ? ((SubLObject) (current.first())) : NIL;
                        destructuring_bind_must_listp(current, datum, $list_alt44);
                        current = current.rest();
                        if (NIL == current) {
                            current = temp;
                            {
                                SubLObject body = current;
                                SubLObject init_forms = NIL;
                                SubLObject end_test_forms = NIL;
                                SubLObject count_sym = make_symbol($$$COUNTER);
                                init_forms = cons(list(count_sym, ZERO_INTEGER, list($sym34$_, ONE_INTEGER, count_sym)), init_forms);
                                {
                                    SubLObject list_var = NIL;
                                    SubLObject form = NIL;
                                    SubLObject form_num = NIL;
                                    for (list_var = var_list_forms, form = list_var.first(), form_num = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , form = list_var.first() , form_num = add(ONE_INTEGER, form_num)) {
                                        {
                                            SubLObject datum_5 = form;
                                            SubLObject current_6 = datum_5;
                                            SubLObject var = NIL;
                                            SubLObject listform = NIL;
                                            destructuring_bind_must_consp(current_6, datum_5, $list_alt18);
                                            var = current_6.first();
                                            current_6 = current_6.rest();
                                            destructuring_bind_must_consp(current_6, datum_5, $list_alt18);
                                            listform = current_6.first();
                                            current_6 = current_6.rest();
                                            if (NIL == current_6) {
                                                {
                                                    SubLObject list_sym_orig = make_symbol(cconcatenate(symbol_name(var), $str_alt46$_orig));
                                                    SubLObject list_sym_cdr = make_symbol(cconcatenate(symbol_name(var), $str_alt47$_cdr));
                                                    init_forms = cons(list(list_sym_orig, listform, list_sym_orig), init_forms);
                                                    init_forms = cons(list(list_sym_cdr, list_sym_orig, list(CDR, list_sym_cdr)), init_forms);
                                                    init_forms = cons(list(var, list(CAR, list_sym_orig), list(NTH_CYCLING, count_sym, list_sym_orig)), init_forms);
                                                    if (NIL == subl_promotions.memberP(form_num, secondary_lists, UNPROVIDED, UNPROVIDED)) {
                                                        end_test_forms = cons(list(NULL, list_sym_cdr), end_test_forms);
                                                    }
                                                }
                                            } else {
                                                cdestructuring_bind_error(datum_5, $list_alt18);
                                            }
                                        }
                                    }
                                }
                                return list(CLET, list(bq_cons(count_sym, $list_alt25)), listS(CDO, nreverse(init_forms), list(bq_cons(CAND, end_test_forms)), append(body, NIL)));
                            }
                        } else {
                            cdestructuring_bind_error(datum, $list_alt44);
                        }
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Essentially the same as @xref cdolist-cycling but allows specification of which lists are "secondary", meaning lists we don't use to determine when to stop iterating.  e.g. if we do (cdolist-cycling ((number '(1 2 3)) (parity '('odd 'even))) [...]), we'll get a meaningful mapping.  But if the list '(1 2 3 4) was just '(1), the mapping breaks down.  The solution is to do a (cdolist-cycling-complex (((number '(1)) (parity '('odd 'even))) (1)) [...]), which means that the list at position 1 isn't used to determine when to stop iterating and so only one iterations is done.
     *
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Essentially the same as @xref cdolist-cycling but allows specification of which lists are \"secondary\", meaning lists we don\'t use to determine when to stop iterating.  e.g. if we do (cdolist-cycling ((number \'(1 2 3)) (parity \'(\'odd \'even))) [...]), we\'ll get a meaningful mapping.  But if the list \'(1 2 3 4) was just \'(1), the mapping breaks down.  The solution is to do a (cdolist-cycling-complex (((number \'(1)) (parity \'(\'odd \'even))) (1)) [...]), which means that the list at position 1 isn\'t used to determine when to stop iterating and so only one iterations is done.\r\n\r\n@unknown jantos\r\n@unknown done")
    public static SubLObject cdolist_cycling_complex(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list44);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject var_list_forms = NIL;
        destructuring_bind_must_consp(current, datum, $list44);
        var_list_forms = current.first();
        current = current.rest();
        final SubLObject secondary_lists = (current.isCons()) ? current.first() : NIL;
        destructuring_bind_must_listp(current, datum, $list44);
        current = current.rest();
        if (NIL == current) {
            final SubLObject body;
            current = body = temp;
            SubLObject init_forms = NIL;
            SubLObject end_test_forms = NIL;
            final SubLObject count_sym = make_symbol($$$COUNTER);
            init_forms = cons(list(count_sym, ZERO_INTEGER, list($sym34$_, ONE_INTEGER, count_sym)), init_forms);
            SubLObject list_var = NIL;
            SubLObject form = NIL;
            SubLObject form_num = NIL;
            list_var = var_list_forms;
            form = list_var.first();
            for (form_num = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , form = list_var.first() , form_num = add(ONE_INTEGER, form_num)) {
                SubLObject current_$6;
                final SubLObject datum_$5 = current_$6 = form;
                SubLObject var = NIL;
                SubLObject listform = NIL;
                destructuring_bind_must_consp(current_$6, datum_$5, $list18);
                var = current_$6.first();
                current_$6 = current_$6.rest();
                destructuring_bind_must_consp(current_$6, datum_$5, $list18);
                listform = current_$6.first();
                current_$6 = current_$6.rest();
                if (NIL == current_$6) {
                    final SubLObject list_sym_orig = make_symbol(cconcatenate(symbol_name(var), $str46$_orig));
                    final SubLObject list_sym_cdr = make_symbol(cconcatenate(symbol_name(var), $str47$_cdr));
                    init_forms = cons(list(list_sym_orig, listform, list_sym_orig), init_forms);
                    init_forms = cons(list(list_sym_cdr, list_sym_orig, list(CDR, list_sym_cdr)), init_forms);
                    init_forms = cons(list(var, list(CAR, list_sym_orig), list(NTH_CYCLING, count_sym, list_sym_orig)), init_forms);
                    if (NIL == subl_promotions.memberP(form_num, secondary_lists, UNPROVIDED, UNPROVIDED)) {
                        end_test_forms = cons(list(NULL, list_sym_cdr), end_test_forms);
                    }
                } else {
                    cdestructuring_bind_error(datum_$5, $list18);
                }
            }
            return list(CLET, list(bq_cons(count_sym, $list25)), listS(CDO, nreverse(init_forms), list(bq_cons(CAND, end_test_forms)), append(body, NIL)));
        }
        cdestructuring_bind_error(datum, $list44);
        return NIL;
    }

    /**
     * Descend recursively into the possibly-nested list TREE, executing BODY with LEAF-VAR bound to each leaf node.
     * The order of iterations is arbitrary.
     * Anything that fails the LIST-TYPE test will be treated as a leaf node.  For example if LIST-TYPE is 'listp,
     * then NIL will be treated as a subtree with no leaves, and a dotted list will cause an error.  If LIST-TYPE is
     * 'proper-list-p, then both NIL and dotted lists will be treated as leaves.
     *
     * @unknown bgottesm
     */
    @LispMethod(comment = "Descend recursively into the possibly-nested list TREE, executing BODY with LEAF-VAR bound to each leaf node.\r\nThe order of iterations is arbitrary.\r\nAnything that fails the LIST-TYPE test will be treated as a leaf node.  For example if LIST-TYPE is \'listp,\r\nthen NIL will be treated as a subtree with no leaves, and a dotted list will cause an error.  If LIST-TYPE is\r\n\'proper-list-p, then both NIL and dotted lists will be treated as leaves.\r\n\r\n@unknown bgottesm\nDescend recursively into the possibly-nested list TREE, executing BODY with LEAF-VAR bound to each leaf node.\nThe order of iterations is arbitrary.\nAnything that fails the LIST-TYPE test will be treated as a leaf node.  For example if LIST-TYPE is \'listp,\nthen NIL will be treated as a subtree with no leaves, and a dotted list will cause an error.  If LIST-TYPE is\n\'proper-list-p, then both NIL and dotted lists will be treated as leaves.")
    public static final SubLObject do_tree_leaves_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt49);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject leaf_var = NIL;
                    SubLObject tree = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt49);
                    leaf_var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt49);
                    tree = current.first();
                    current = current.rest();
                    {
                        SubLObject allow_other_keys_p = NIL;
                        SubLObject rest = current;
                        SubLObject bad = NIL;
                        SubLObject current_7 = NIL;
                        for (; NIL != rest;) {
                            destructuring_bind_must_consp(rest, datum, $list_alt49);
                            current_7 = rest.first();
                            rest = rest.rest();
                            destructuring_bind_must_consp(rest, datum, $list_alt49);
                            if (NIL == member(current_7, $list_alt50, UNPROVIDED, UNPROVIDED)) {
                                bad = T;
                            }
                            if (current_7 == $ALLOW_OTHER_KEYS) {
                                allow_other_keys_p = rest.first();
                            }
                            rest = rest.rest();
                        }
                        if ((NIL != bad) && (NIL == allow_other_keys_p)) {
                            cdestructuring_bind_error(datum, $list_alt49);
                        }
                        {
                            SubLObject list_type_tail = property_list_member($LIST_TYPE, current);
                            SubLObject list_type = (NIL != list_type_tail) ? ((SubLObject) (cadr(list_type_tail))) : LISTP;
                            SubLObject done_tail = property_list_member($DONE, current);
                            SubLObject done = (NIL != done_tail) ? ((SubLObject) (cadr(done_tail))) : NIL;
                            current = temp;
                            {
                                SubLObject body = current;
                                SubLObject subtree_list_var = $sym55$SUBTREE_LIST_VAR;
                                SubLObject current_subtree_var = $sym56$CURRENT_SUBTREE_VAR;
                                SubLObject node_var = $sym57$NODE_VAR;
                                return list(CLET, list(list(subtree_list_var, list(LIST, tree))), list(CDO, list(list(current_subtree_var, list(FIRST, subtree_list_var), list(FIRST, subtree_list_var))), list(list(COR, done, list(NULL, subtree_list_var))), list(CPOP, subtree_list_var), list(DO_LIST, list(node_var, current_subtree_var, $DONE, done), list(PIF, list(list_type, node_var), list(CPUSH, node_var, subtree_list_var), listS(CLET, list(list(leaf_var, node_var)), append(body, NIL))))));
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Descend recursively into the possibly-nested list TREE, executing BODY with LEAF-VAR bound to each leaf node.
     * The order of iterations is arbitrary.
     * Anything that fails the LIST-TYPE test will be treated as a leaf node.  For example if LIST-TYPE is 'listp,
     * then NIL will be treated as a subtree with no leaves, and a dotted list will cause an error.  If LIST-TYPE is
     * 'proper-list-p, then both NIL and dotted lists will be treated as leaves.
     *
     * @unknown bgottesm
     */
    @LispMethod(comment = "Descend recursively into the possibly-nested list TREE, executing BODY with LEAF-VAR bound to each leaf node.\r\nThe order of iterations is arbitrary.\r\nAnything that fails the LIST-TYPE test will be treated as a leaf node.  For example if LIST-TYPE is \'listp,\r\nthen NIL will be treated as a subtree with no leaves, and a dotted list will cause an error.  If LIST-TYPE is\r\n\'proper-list-p, then both NIL and dotted lists will be treated as leaves.\r\n\r\n@unknown bgottesm\nDescend recursively into the possibly-nested list TREE, executing BODY with LEAF-VAR bound to each leaf node.\nThe order of iterations is arbitrary.\nAnything that fails the LIST-TYPE test will be treated as a leaf node.  For example if LIST-TYPE is \'listp,\nthen NIL will be treated as a subtree with no leaves, and a dotted list will cause an error.  If LIST-TYPE is\n\'proper-list-p, then both NIL and dotted lists will be treated as leaves.")
    public static SubLObject do_tree_leaves(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list49);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject leaf_var = NIL;
        SubLObject tree = NIL;
        destructuring_bind_must_consp(current, datum, $list49);
        leaf_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list49);
        tree = current.first();
        current = current.rest();
        SubLObject allow_other_keys_p = NIL;
        SubLObject rest = current;
        SubLObject bad = NIL;
        SubLObject current_$7 = NIL;
        while (NIL != rest) {
            destructuring_bind_must_consp(rest, datum, $list49);
            current_$7 = rest.first();
            rest = rest.rest();
            destructuring_bind_must_consp(rest, datum, $list49);
            if (NIL == member(current_$7, $list50, UNPROVIDED, UNPROVIDED)) {
                bad = T;
            }
            if (current_$7 == $ALLOW_OTHER_KEYS) {
                allow_other_keys_p = rest.first();
            }
            rest = rest.rest();
        } 
        if ((NIL != bad) && (NIL == allow_other_keys_p)) {
            cdestructuring_bind_error(datum, $list49);
        }
        final SubLObject list_type_tail = property_list_member($LIST_TYPE, current);
        final SubLObject list_type = (NIL != list_type_tail) ? cadr(list_type_tail) : LISTP;
        final SubLObject done_tail = property_list_member($DONE, current);
        final SubLObject done = (NIL != done_tail) ? cadr(done_tail) : NIL;
        final SubLObject body;
        current = body = temp;
        final SubLObject subtree_list_var = $sym55$SUBTREE_LIST_VAR;
        final SubLObject current_subtree_var = $sym56$CURRENT_SUBTREE_VAR;
        final SubLObject node_var = $sym57$NODE_VAR;
        return list(CLET, list(list(subtree_list_var, list(LIST, tree))), list(CDO, list(list(current_subtree_var, list(FIRST, subtree_list_var), list(FIRST, subtree_list_var))), list(list(COR, done, list(NULL, subtree_list_var))), list(CPOP, subtree_list_var), list(DO_LIST, list(node_var, current_subtree_var, $DONE, done), list(PIF, list(list_type, node_var), list(CPUSH, node_var, subtree_list_var), listS(CLET, list(list(leaf_var, node_var)), append(body, NIL))))));
    }

    /**
     *
     *
     * @return listp; the list of arguments from ARG-LIST.
     */
    @LispMethod(comment = "@return listp; the list of arguments from ARG-LIST.")
    public static final SubLObject args_from_arg_list_alt(SubLObject arg_list) {
        {
            SubLObject args = NIL;
            SubLObject optionalP = NIL;
            SubLObject cdolist_list_var = arg_list;
            SubLObject arg_spec = NIL;
            for (arg_spec = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , arg_spec = cdolist_list_var.first()) {
                if (arg_spec == $sym62$_OPTIONAL) {
                    optionalP = T;
                } else {
                    if (NIL == optionalP) {
                        args = cons(arg_spec, args);
                    } else {
                        if (arg_spec.isCons() && arg_spec.first().isSymbol()) {
                            args = cons(arg_spec.first(), args);
                        } else {
                            args = cons(arg_spec, args);
                        }
                    }
                }
            }
            return nreverse(args);
        }
    }

    /**
     *
     *
     * @return listp; the list of arguments from ARG-LIST.
     */
    @LispMethod(comment = "@return listp; the list of arguments from ARG-LIST.")
    public static SubLObject args_from_arg_list(final SubLObject arg_list) {
        SubLObject args = NIL;
        SubLObject optionalP = NIL;
        SubLObject cdolist_list_var = arg_list;
        SubLObject arg_spec = NIL;
        arg_spec = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (arg_spec == $sym62$_OPTIONAL) {
                optionalP = T;
            } else
                if (NIL == optionalP) {
                    args = cons(arg_spec, args);
                } else
                    if (arg_spec.isCons() && arg_spec.first().isSymbol()) {
                        args = cons(arg_spec.first(), args);
                    } else {
                        args = cons(arg_spec, args);
                    }


            cdolist_list_var = cdolist_list_var.rest();
            arg_spec = cdolist_list_var.first();
        } 
        return nreverse(args);
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is strictly less than N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is strictly less than N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static final SubLObject lengthL_alt(SubLObject seq, SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        if (!seq.isList()) {
            return numL(length(seq), n);
        }
        {
            SubLObject tail = NIL;
            SubLObject i = NIL;
            for (tail = seq, i = ZERO_INTEGER; !i.numGE(n); tail = tail.rest() , i = add(i, ONE_INTEGER)) {
                if (NIL == tail) {
                    return T;
                }
                if (!tail.isCons()) {
                    return NIL != count_dotted_listP ? ((SubLObject) (numL(add(i, ONE_INTEGER), n))) : T;
                }
            }
            return NIL;
        }
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is strictly less than N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is strictly less than N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static SubLObject lengthL(final SubLObject seq, final SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        if (!seq.isList()) {
            return numL(length(seq), n);
        }
        SubLObject tail = NIL;
        SubLObject i = NIL;
        tail = seq;
        for (i = ZERO_INTEGER; !i.numGE(n); i = add(i, ONE_INTEGER)) {
            if (NIL == tail) {
                return T;
            }
            if (!tail.isCons()) {
                return NIL != count_dotted_listP ? numL(add(i, ONE_INTEGER), n) : T;
            }
            tail = tail.rest();
        }
        return NIL;
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is less than or equal to N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is less than or equal to N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static final SubLObject lengthLE_alt(SubLObject seq, SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return com.cyc.cycjava.cycl.list_utilities.lengthL(seq, add(n, ONE_INTEGER), count_dotted_listP);
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is less than or equal to N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is less than or equal to N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static SubLObject lengthLE(final SubLObject seq, final SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return lengthL(seq, add(n, ONE_INTEGER), count_dotted_listP);
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is exactly N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is exactly N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static final SubLObject lengthE_alt(SubLObject seq, SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        if (!seq.isList()) {
            return numE(length(seq), n);
        }
        if (!((NIL != count_dotted_listP) || (NIL != com.cyc.cycjava.cycl.list_utilities.dotted_list_p(seq)))) {
            {
                SubLObject pcase_var = n;
                if (pcase_var.eql(ZERO_INTEGER)) {
                    return sublisp_null(seq);
                } else {
                    if (pcase_var.eql(ONE_INTEGER)) {
                        return com.cyc.cycjava.cycl.list_utilities.singletonP(seq);
                    } else {
                        if (pcase_var.eql(TWO_INTEGER)) {
                            return com.cyc.cycjava.cycl.list_utilities.doubletonP(seq);
                        } else {
                            if (pcase_var.eql(THREE_INTEGER)) {
                                return com.cyc.cycjava.cycl.list_utilities.tripleP(seq);
                            }
                        }
                    }
                }
            }
        }
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.lengthLE(seq, n, count_dotted_listP)) && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthGE(seq, n, count_dotted_listP)));
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is exactly N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is exactly N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static SubLObject lengthE(final SubLObject seq, final SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        if (!seq.isList()) {
            return numE(length(seq), n);
        }
        if ((NIL == count_dotted_listP) && (NIL == dotted_list_p(seq))) {
            if (n.eql(ZERO_INTEGER)) {
                return sublisp_null(seq);
            }
            if (n.eql(ONE_INTEGER)) {
                return singletonP(seq);
            }
            if (n.eql(TWO_INTEGER)) {
                return doubletonP(seq);
            }
            if (n.eql(THREE_INTEGER)) {
                return tripleP(seq);
            }
        }
        return makeBoolean((NIL != lengthLE(seq, n, count_dotted_listP)) && (NIL != lengthGE(seq, n, count_dotted_listP)));
    }

    public static final SubLObject lengthsE_alt(SubLObject list_of_seqs, SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        {
            SubLObject failureP = NIL;
            if (NIL == failureP) {
                {
                    SubLObject csome_list_var = list_of_seqs;
                    SubLObject seq = NIL;
                    for (seq = csome_list_var.first(); !((NIL != failureP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , seq = csome_list_var.first()) {
                        if (NIL == com.cyc.cycjava.cycl.list_utilities.lengthE(seq, n, count_dotted_listP)) {
                            failureP = T;
                        }
                    }
                }
            }
            return makeBoolean(NIL == failureP);
        }
    }

    public static SubLObject lengthsE(final SubLObject list_of_seqs, final SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        SubLObject failureP = NIL;
        if (NIL == failureP) {
            SubLObject csome_list_var = list_of_seqs;
            SubLObject seq = NIL;
            seq = csome_list_var.first();
            while ((NIL == failureP) && (NIL != csome_list_var)) {
                if (NIL == lengthE(seq, n, count_dotted_listP)) {
                    failureP = T;
                }
                csome_list_var = csome_list_var.rest();
                seq = csome_list_var.first();
            } 
        }
        return makeBoolean(NIL == failureP);
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is strictly greater than N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is strictly greater than N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static final SubLObject lengthG_alt(SubLObject seq, SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.lengthLE(seq, n, count_dotted_listP));
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is strictly greater than N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is strictly greater than N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static SubLObject lengthG(final SubLObject seq, final SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return makeBoolean(NIL == lengthLE(seq, n, count_dotted_listP));
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is greater than or equal to N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is greater than or equal to N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static final SubLObject lengthGE_alt(SubLObject seq, SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.lengthL(seq, n, count_dotted_listP));
    }

    /**
     *
     *
     * @return boolean; whether the length of SEQ is greater than or equal to N.
     * @param count-dotted-list?
     * 		whether (1 2 . 3) counts as length 2 or 3.
     * 		If it is t, it counts as length 3, otherwise it counts as length 2.
     */
    @LispMethod(comment = "@return boolean; whether the length of SEQ is greater than or equal to N.\r\n@param count-dotted-list?\r\n\t\twhether (1 2 . 3) counts as length 2 or 3.\r\n\t\tIf it is t, it counts as length 3, otherwise it counts as length 2.")
    public static SubLObject lengthGE(final SubLObject seq, final SubLObject n, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return makeBoolean(NIL == lengthL(seq, n, count_dotted_listP));
    }

    /**
     *
     *
     * @param SEQUENCE
    sequencep
     * 		
     * @return boolean; non-nil if the length of SEQUENCE is zero, nil otherwise
     */
    @LispMethod(comment = "@param SEQUENCE\nsequencep\r\n\t\t\r\n@return boolean; non-nil if the length of SEQUENCE is zero, nil otherwise")
    public static final SubLObject zero_length_p_alt(SubLObject sequence) {
        SubLTrampolineFile.checkType(sequence, SEQUENCEP);
        if (sequence.isString()) {
            return eql($str_alt64$, sequence);
        } else {
            return com.cyc.cycjava.cycl.list_utilities.lengthE(sequence, ZERO_INTEGER, UNPROVIDED);
        }
    }

    /**
     *
     *
     * @param SEQUENCE
    sequencep
     * 		
     * @return boolean; non-nil if the length of SEQUENCE is zero, nil otherwise
     */
    @LispMethod(comment = "@param SEQUENCE\nsequencep\r\n\t\t\r\n@return boolean; non-nil if the length of SEQUENCE is zero, nil otherwise")
    public static SubLObject zero_length_p(final SubLObject sequence) {
        assert NIL != sequencep(sequence) : "! sequencep(sequence) " + ("Types.sequencep(sequence) " + "CommonSymbols.NIL != Types.sequencep(sequence) ") + sequence;
        if (sequence.isString()) {
            return eql($str64$, sequence);
        }
        if (sequence.isList()) {
            return sublisp_null(sequence);
        }
        return lengthE(sequence, ZERO_INTEGER, UNPROVIDED);
    }

    /**
     *
     *
     * @return boolean; whether the two sequences have the same length.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the two sequences have the same length.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static final SubLObject same_length_p_alt(SubLObject seq1, SubLObject seq2) {
        if (NIL == seq1) {
            return makeBoolean((NIL == seq2) || ((!seq2.isCons()) && length(seq2).isZero()));
        } else {
            if (seq1.isCons()) {
                if (NIL == seq2) {
                    return NIL;
                } else {
                    if (seq2.isCons()) {
                        {
                            SubLObject sublist1 = NIL;
                            SubLObject sublist2 = NIL;
                            for (sublist1 = seq1, sublist2 = seq2; !((NIL == sublist1) || (NIL == sublist2)); sublist1 = sublist1.rest() , sublist2 = sublist2.rest()) {
                            }
                            return eq(sublist1, sublist2);
                        }
                    } else {
                        return numE(length(seq1), length(seq2));
                    }
                }
            } else {
                if (NIL == seq2) {
                    return zerop(length(seq1));
                } else {
                    return com.cyc.cycjava.cycl.list_utilities.lengthE(seq2, length(seq1), UNPROVIDED);
                }
            }
        }
    }

    /**
     *
     *
     * @return boolean; whether the two sequences have the same length.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the two sequences have the same length.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static SubLObject same_length_p(final SubLObject seq1, final SubLObject seq2) {
        if (NIL == seq1) {
            return makeBoolean((NIL == seq2) || ((!seq2.isCons()) && length(seq2).isZero()));
        }
        if (seq1.isCons()) {
            if (NIL == seq2) {
                return NIL;
            }
            if (seq2.isCons()) {
                SubLObject sublist1;
                SubLObject sublist2;
                for (sublist1 = NIL, sublist2 = NIL, sublist1 = seq1, sublist2 = seq2; (NIL != sublist1) && (NIL != sublist2); sublist1 = sublist1.rest() , sublist2 = sublist2.rest()) {
                }
                return eq(sublist1, sublist2);
            }
            return numE(length(seq1), length(seq2));
        } else {
            if (NIL == seq2) {
                return zerop(length(seq1));
            }
            return lengthE(seq2, length(seq1), UNPROVIDED);
        }
    }

    /**
     *
     *
     * @return boolean; whether all sequences in LIST-OF-SEQS have the same length
     * @param LIST-OF-SEQS;
     * 		a list of sequences
     * @unknown kknight
     */
    @LispMethod(comment = "@return boolean; whether all sequences in LIST-OF-SEQS have the same length\r\n@param LIST-OF-SEQS;\r\n\t\ta list of sequences\r\n@unknown kknight")
    public static final SubLObject same_lengths_p_alt(SubLObject list_of_seqs) {
        {
            SubLObject differentP = NIL;
            if (NIL == differentP) {
                {
                    SubLObject csome_list_var = list_of_seqs.rest();
                    SubLObject seq = NIL;
                    for (seq = csome_list_var.first(); !((NIL != differentP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , seq = csome_list_var.first()) {
                        differentP = makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.same_length_p(seq, list_of_seqs.first()));
                    }
                }
            }
            return makeBoolean(NIL == differentP);
        }
    }

    /**
     *
     *
     * @return boolean; whether all sequences in LIST-OF-SEQS have the same length
     * @param LIST-OF-SEQS;
     * 		a list of sequences
     * @unknown kknight
     */
    @LispMethod(comment = "@return boolean; whether all sequences in LIST-OF-SEQS have the same length\r\n@param LIST-OF-SEQS;\r\n\t\ta list of sequences\r\n@unknown kknight")
    public static SubLObject same_lengths_p(final SubLObject list_of_seqs) {
        SubLObject differentP = NIL;
        if (NIL == differentP) {
            SubLObject csome_list_var;
            SubLObject seq;
            for (csome_list_var = list_of_seqs.rest(), seq = NIL, seq = csome_list_var.first(); (NIL == differentP) && (NIL != csome_list_var); differentP = makeBoolean(NIL == same_length_p(seq, list_of_seqs.first())) , csome_list_var = csome_list_var.rest() , seq = csome_list_var.first()) {
            }
        }
        return makeBoolean(NIL == differentP);
    }

    public static final SubLObject longer_p_alt(SubLObject seq1, SubLObject seq2) {
        return com.cyc.cycjava.cycl.list_utilities.greater_length_p(seq1, seq2);
    }

    public static SubLObject longer_p(final SubLObject seq1, final SubLObject seq2) {
        return greater_length_p(seq1, seq2);
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of greater length than the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of greater length than the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static final SubLObject greater_length_p_alt(SubLObject seq1, SubLObject seq2) {
        if (NIL == seq1) {
            return NIL;
        } else {
            if (seq1.isCons()) {
                if (NIL == seq2) {
                    return T;
                } else {
                    if (seq2.isCons()) {
                        {
                            SubLObject sublist1 = NIL;
                            SubLObject sublist2 = NIL;
                            for (sublist1 = seq1, sublist2 = seq2; !((NIL == sublist1) || (NIL == sublist2)); sublist1 = sublist1.rest() , sublist2 = sublist2.rest()) {
                            }
                            return makeBoolean((NIL != sublist1) && (NIL == sublist2));
                        }
                    } else {
                        return numG(length(seq1), length(seq2));
                    }
                }
            } else {
                if (NIL == seq2) {
                    return makeBoolean(!length(seq1).isZero());
                } else {
                    return com.cyc.cycjava.cycl.list_utilities.lengthL(seq2, length(seq1), UNPROVIDED);
                }
            }
        }
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of greater length than the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of greater length than the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static SubLObject greater_length_p(final SubLObject seq1, final SubLObject seq2) {
        if (NIL == seq1) {
            return NIL;
        }
        if (seq1.isCons()) {
            if (NIL == seq2) {
                return T;
            }
            if (seq2.isCons()) {
                SubLObject sublist1;
                SubLObject sublist2;
                for (sublist1 = NIL, sublist2 = NIL, sublist1 = seq1, sublist2 = seq2; (NIL != sublist1) && (NIL != sublist2); sublist1 = sublist1.rest() , sublist2 = sublist2.rest()) {
                }
                return makeBoolean((NIL != sublist1) && (NIL == sublist2));
            }
            return numG(length(seq1), length(seq2));
        } else {
            if (NIL == seq2) {
                return makeBoolean(!length(seq1).isZero());
            }
            return lengthL(seq2, length(seq1), UNPROVIDED);
        }
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of greater or equal length than the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of greater or equal length than the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static final SubLObject greater_or_same_length_p_alt(SubLObject seq1, SubLObject seq2) {
        if (NIL == seq1) {
            return makeBoolean((NIL == seq2) || ((!seq2.isCons()) && length(seq2).isZero()));
        } else {
            if (seq1.isCons()) {
                if (NIL == seq2) {
                    return T;
                } else {
                    if (seq2.isCons()) {
                        {
                            SubLObject sublist1 = NIL;
                            SubLObject sublist2 = NIL;
                            for (sublist1 = seq1, sublist2 = seq2; !((NIL == sublist1) || (NIL == sublist2)); sublist1 = sublist1.rest() , sublist2 = sublist2.rest()) {
                            }
                            return makeBoolean((sublist1 == sublist2) || (NIL == sublist2));
                        }
                    } else {
                        return numGE(length(seq1), length(seq2));
                    }
                }
            } else {
                if (NIL == seq2) {
                    return T;
                } else {
                    return com.cyc.cycjava.cycl.list_utilities.lengthLE(seq2, length(seq1), UNPROVIDED);
                }
            }
        }
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of greater or equal length than the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of greater or equal length than the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static SubLObject greater_or_same_length_p(final SubLObject seq1, final SubLObject seq2) {
        if (NIL == seq1) {
            return makeBoolean((NIL == seq2) || ((!seq2.isCons()) && length(seq2).isZero()));
        }
        if (seq1.isCons()) {
            if (NIL == seq2) {
                return T;
            }
            if (seq2.isCons()) {
                SubLObject sublist1;
                SubLObject sublist2;
                for (sublist1 = NIL, sublist2 = NIL, sublist1 = seq1, sublist2 = seq2; (NIL != sublist1) && (NIL != sublist2); sublist1 = sublist1.rest() , sublist2 = sublist2.rest()) {
                }
                return makeBoolean(sublist1.eql(sublist2) || (NIL == sublist2));
            }
            return numGE(length(seq1), length(seq2));
        } else {
            if (NIL == seq2) {
                return T;
            }
            return lengthLE(seq2, length(seq1), UNPROVIDED);
        }
    }

    public static final SubLObject shorter_p_alt(SubLObject seq1, SubLObject seq2) {
        return com.cyc.cycjava.cycl.list_utilities.lesser_length_p(seq1, seq2);
    }

    public static SubLObject shorter_p(final SubLObject seq1, final SubLObject seq2) {
        return lesser_length_p(seq1, seq2);
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of lesser length than the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of lesser length than the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static final SubLObject lesser_length_p_alt(SubLObject seq1, SubLObject seq2) {
        return com.cyc.cycjava.cycl.list_utilities.greater_length_p(seq2, seq1);
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of lesser length than the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of lesser length than the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static SubLObject lesser_length_p(final SubLObject seq1, final SubLObject seq2) {
        return greater_length_p(seq2, seq1);
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of lesser or same length then the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of lesser or same length then the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static final SubLObject lesser_or_same_length_p_alt(SubLObject seq1, SubLObject seq2) {
        return com.cyc.cycjava.cycl.list_utilities.greater_or_same_length_p(seq2, seq1);
    }

    /**
     *
     *
     * @return boolean; whether the first sequence is of lesser or same length then the second sequence.
     * @param seq1;
     * 		a sequence.
     * @unknown seq2; a sequence.
     * @unknown sdevoy
     */
    @LispMethod(comment = "@return boolean; whether the first sequence is of lesser or same length then the second sequence.\r\n@param seq1;\r\n\t\ta sequence.\r\n@unknown seq2; a sequence.\r\n@unknown sdevoy")
    public static SubLObject lesser_or_same_length_p(final SubLObject seq1, final SubLObject seq2) {
        return greater_or_same_length_p(seq2, seq1);
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ an empty list?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ an empty list?")
    public static final SubLObject empty_list_p_alt(SubLObject obj) {
        return makeBoolean(obj.isList() && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthE(obj, ZERO_INTEGER, UNPROVIDED)));
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ an empty list?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ an empty list?")
    public static SubLObject empty_list_p(final SubLObject obj) {
        return makeBoolean(obj.isList() && (NIL != lengthE(obj, ZERO_INTEGER, UNPROVIDED)));
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a non-empty list?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a non-empty list?")
    public static final SubLObject non_empty_list_p_alt(SubLObject obj) {
        return makeBoolean(obj.isList() && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthG(obj, ZERO_INTEGER, UNPROVIDED)));
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a non-empty list?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a non-empty list?")
    public static SubLObject non_empty_list_p(final SubLObject obj) {
        return makeBoolean(obj.isList() && (NIL != lengthG(obj, ZERO_INTEGER, UNPROVIDED)));
    }

    public static final SubLObject proper_list_p_alt(SubLObject v_object) {
        return makeBoolean(v_object.isCons() && (NIL == last(v_object, UNPROVIDED).rest()));
    }

    public static SubLObject proper_list_p(final SubLObject v_object) {
        return makeBoolean(v_object.isCons() && (NIL == last(v_object, UNPROVIDED).rest()));
    }

    public static final SubLObject dotted_list_p_alt(SubLObject v_object) {
        return makeBoolean(v_object.isCons() && (NIL != last(v_object, UNPROVIDED).rest()));
    }

    public static SubLObject dotted_list_p(final SubLObject v_object) {
        return makeBoolean(v_object.isCons() && (NIL != last(v_object, UNPROVIDED).rest()));
    }

    public static final SubLObject non_dotted_list_p_alt(SubLObject v_object) {
        return makeBoolean((NIL == v_object) || (NIL != com.cyc.cycjava.cycl.list_utilities.proper_list_p(v_object)));
    }

    public static SubLObject non_dotted_list_p(final SubLObject v_object) {
        return makeBoolean((NIL == v_object) || (NIL != proper_list_p(v_object)));
    }

    public static final SubLObject dotted_length_alt(SubLObject cons) {
        {
            SubLObject cdr = cons.rest();
            if (!cdr.isCons()) {
                return ONE_INTEGER;
            } else {
                return add(ONE_INTEGER, com.cyc.cycjava.cycl.list_utilities.dotted_length(cdr));
            }
        }
    }

    public static SubLObject dotted_length(final SubLObject cons) {
        final SubLObject cdr = cons.rest();
        if (!cdr.isCons()) {
            return ONE_INTEGER;
        }
        return add(ONE_INTEGER, dotted_length(cdr));
    }

    public static final SubLObject dotted_last_alt(SubLObject cons) {
        return last(cons, UNPROVIDED).rest();
    }

    public static SubLObject dotted_last(final SubLObject cons) {
        return last(cons, UNPROVIDED).rest();
    }

    public static final SubLObject dotted_butlast_alt(SubLObject cons) {
        if (cons.isCons()) {
            {
                SubLObject car = cons.first();
                SubLObject cdr = cons.rest();
                if (cdr.isCons()) {
                    return cons(car, com.cyc.cycjava.cycl.list_utilities.dotted_butlast(cdr));
                } else {
                    if (NIL != cdr) {
                        return list(car);
                    } else {
                        return NIL;
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject dotted_butlast(final SubLObject cons) {
        if (!cons.isCons()) {
            return NIL;
        }
        final SubLObject car = cons.first();
        final SubLObject cdr = cons.rest();
        if (cdr.isCons()) {
            return cons(car, dotted_butlast(cdr));
        }
        if (NIL != cdr) {
            return list(car);
        }
        return NIL;
    }

    public static final SubLObject undot_alt(SubLObject cons) {
        if (cons.isCons()) {
            {
                SubLObject car = cons.first();
                SubLObject cdr = cons.rest();
                if (cdr.isCons()) {
                    return cons(car, com.cyc.cycjava.cycl.list_utilities.undot(cdr));
                } else {
                    if (NIL != cdr) {
                        return cons(car, cons(cdr, NIL));
                    } else {
                        return cons;
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject undot(final SubLObject cons) {
        if (!cons.isCons()) {
            return NIL;
        }
        final SubLObject car = cons.first();
        final SubLObject cdr = cons.rest();
        if (cdr.isCons()) {
            return cons(car, undot(cdr));
        }
        if (NIL != cdr) {
            return cons(car, cons(cdr, NIL));
        }
        return cons;
    }

    public static final SubLObject add_to_dotted_end_alt(SubLObject v_object, SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.nadd_to_dotted_end(v_object, copy_list(list));
    }

    public static SubLObject add_to_dotted_end(final SubLObject v_object, final SubLObject list) {
        return nadd_to_dotted_end(v_object, copy_list(list));
    }

    public static final SubLObject nadd_to_dotted_end_alt(SubLObject v_object, SubLObject list) {
        if (list.isList()) {
            {
                SubLObject cons = last(list, UNPROVIDED);
                SubLObject cdr = cons.rest();
                if (NIL != cdr) {
                    rplacd(cons, cons(cdr, v_object));
                } else {
                    rplacd(cons, v_object);
                }
            }
            return list;
        }
        return NIL;
    }

    public static SubLObject nadd_to_dotted_end(final SubLObject v_object, final SubLObject list) {
        if (list.isList()) {
            final SubLObject cons = last(list, UNPROVIDED);
            final SubLObject cdr = cons.rest();
            if (NIL != cdr) {
                rplacd(cons, cons(cdr, v_object));
            } else {
                rplacd(cons, v_object);
            }
            return list;
        }
        return NIL;
    }

    /**
     * A destructive version of @xref dot-last.
     *
     * @unknown pace
     */
    @LispMethod(comment = "A destructive version of @xref dot-last.\r\n\r\n@unknown pace")
    public static final SubLObject ndot_last_alt(SubLObject list) {
        {
            SubLObject last_elem = last(list, UNPROVIDED).first();
            return com.cyc.cycjava.cycl.list_utilities.nadd_to_dotted_end(last_elem, nbutlast(list, UNPROVIDED));
        }
    }

    /**
     * A destructive version of @xref dot-last.
     *
     * @unknown pace
     */
    @LispMethod(comment = "A destructive version of @xref dot-last.\r\n\r\n@unknown pace")
    public static SubLObject ndot_last(final SubLObject list) {
        final SubLObject last_elem = last(list, UNPROVIDED).first();
        return nadd_to_dotted_end(last_elem, nbutlast(list, UNPROVIDED));
    }

    /**
     * e.g. (1 2 3) -> (1 2 . 3)
     *
     * @unknown pace
     */
    @LispMethod(comment = "e.g. (1 2 3) -> (1 2 . 3)\r\n\r\n@unknown pace")
    public static final SubLObject dot_last_alt(SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.ndot_last(copy_list(list));
    }

    /**
     * e.g. (1 2 3) -> (1 2 . 3)
     *
     * @unknown pace
     */
    @LispMethod(comment = "e.g. (1 2 3) -> (1 2 . 3)\r\n\r\n@unknown pace")
    public static SubLObject dot_last(final SubLObject list) {
        return ndot_last(copy_list(list));
    }

    /**
     * Make a dotted list from LIST by essentially replacing the symbol DOT with '.'.  For example, (a b :dot-for-dotted-list c) -> (a b . c).
     *
     * @return 0 list ;; the resulting list
     * @return 1 boolean ;; nil if the conversion failed, o/w t
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Make a dotted list from LIST by essentially replacing the symbol DOT with \'.\'.  For example, (a b :dot-for-dotted-list c) -> (a b . c).\r\n\r\n@return 0 list ;; the resulting list\r\n@return 1 boolean ;; nil if the conversion failed, o/w t\r\n@unknown jantos\r\n@unknown done")
    public static final SubLObject possible_dotted_list_to_dotted_list_alt(SubLObject list, SubLObject dot) {
        if (dot == UNPROVIDED) {
            dot = $DOT_FOR_DOTTED_LIST;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (!list.isList()) {
                return values(list, T);
            }
            {
                SubLObject list_d = NIL;
                SubLObject doneP = NIL;
                if (NIL == doneP) {
                    {
                        SubLObject csome_list_var = list;
                        SubLObject sublist = NIL;
                        for (sublist = csome_list_var.first(); !((NIL != doneP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , sublist = csome_list_var.first()) {
                            thread.resetMultipleValues();
                            {
                                SubLObject sublist_d = com.cyc.cycjava.cycl.list_utilities.possible_dotted_list_to_dotted_list(sublist, UNPROVIDED);
                                SubLObject okP = thread.secondMultipleValue();
                                thread.resetMultipleValues();
                                list_d = cons(sublist_d, list_d);
                                if (NIL == okP) {
                                    doneP = T;
                                }
                            }
                        }
                    }
                }
                if (NIL != doneP) {
                    return values(NIL, NIL);
                }
                list = nreverse(list_d);
            }
            {
                SubLObject dot_at = position(dot, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                if (NIL != dot_at) {
                    {
                        SubLObject length_of_list = length(list);
                        if (THREE_INTEGER.numG(length_of_list)) {
                            return values(NIL, NIL);
                        } else {
                            if (!dot_at.numE(subtract(length_of_list, TWO_INTEGER))) {
                                return values(NIL, NIL);
                            } else {
                                if (last(list, UNPROVIDED).first() == dot) {
                                    return values(NIL, NIL);
                                } else {
                                    rplacd(nthcdr(subtract(length_of_list, THREE_INTEGER), list), nthcdr(subtract(length_of_list, ONE_INTEGER), list).first());
                                }
                            }
                        }
                    }
                }
                return values(list, T);
            }
        }
    }

    /**
     * Make a dotted list from LIST by essentially replacing the symbol DOT with '.'.  For example, (a b :dot-for-dotted-list c) -> (a b . c).
     *
     * @return 0 list ;; the resulting list
     * @return 1 boolean ;; nil if the conversion failed, o/w t
     * @unknown jantos
     * @unknown done
     */
    @LispMethod(comment = "Make a dotted list from LIST by essentially replacing the symbol DOT with \'.\'.  For example, (a b :dot-for-dotted-list c) -> (a b . c).\r\n\r\n@return 0 list ;; the resulting list\r\n@return 1 boolean ;; nil if the conversion failed, o/w t\r\n@unknown jantos\r\n@unknown done")
    public static SubLObject possible_dotted_list_to_dotted_list(SubLObject list, SubLObject dot) {
        if (dot == UNPROVIDED) {
            dot = $DOT_FOR_DOTTED_LIST;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (!list.isList()) {
            return subl_promotions.values2(list, T);
        }
        SubLObject list_d = NIL;
        SubLObject doneP = NIL;
        if (NIL == doneP) {
            SubLObject csome_list_var = list;
            SubLObject sublist = NIL;
            sublist = csome_list_var.first();
            while ((NIL == doneP) && (NIL != csome_list_var)) {
                thread.resetMultipleValues();
                final SubLObject sublist_d = possible_dotted_list_to_dotted_list(sublist, UNPROVIDED);
                final SubLObject okP = thread.secondMultipleValue();
                thread.resetMultipleValues();
                list_d = cons(sublist_d, list_d);
                if (NIL == okP) {
                    doneP = T;
                }
                csome_list_var = csome_list_var.rest();
                sublist = csome_list_var.first();
            } 
        }
        if (NIL != doneP) {
            return subl_promotions.values2(NIL, NIL);
        }
        list = nreverse(list_d);
        final SubLObject dot_at = position(dot, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        if (NIL != dot_at) {
            final SubLObject length_of_list = length(list);
            if (THREE_INTEGER.numG(length_of_list)) {
                return subl_promotions.values2(NIL, NIL);
            }
            if (!dot_at.numE(subtract(length_of_list, TWO_INTEGER))) {
                return subl_promotions.values2(NIL, NIL);
            }
            if (last(list, UNPROVIDED).first().eql(dot)) {
                return subl_promotions.values2(NIL, NIL);
            }
            rplacd(nthcdr(subtract(length_of_list, THREE_INTEGER), list), nthcdr(subtract(length_of_list, ONE_INTEGER), list).first());
        }
        return subl_promotions.values2(list, T);
    }

    /**
     *
     *
     * @return BOOLEAN; Is LIST a proper list at least through position N?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEAN; Is LIST a proper list at least through position N?\r\n@unknown baxter")
    public static final SubLObject list_non_dotted_through_n_p_alt(SubLObject list, SubLObject n) {
        {
            SubLObject remaining = NIL;
            SubLObject i = NIL;
            for (remaining = list, i = ZERO_INTEGER; !i.numG(n); remaining = remaining.rest() , i = number_utilities.f_1X(i)) {
                if (!remaining.isList()) {
                    return NIL;
                } else {
                    if (NIL == remaining) {
                        return NIL;
                    }
                }
            }
            return T;
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is LIST a proper list at least through position N?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEAN; Is LIST a proper list at least through position N?\r\n@unknown baxter")
    public static SubLObject list_non_dotted_through_n_p(final SubLObject list, final SubLObject n) {
        SubLObject remaining = NIL;
        SubLObject i = NIL;
        remaining = list;
        for (i = ZERO_INTEGER; !i.numG(n); i = number_utilities.f_1X(i)) {
            if (!remaining.isList()) {
                return NIL;
            }
            if (NIL == remaining) {
                return NIL;
            }
            remaining = remaining.rest();
        }
        return T;
    }

    public static final SubLObject negated_test_func_alt(SubLObject obj) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            return makeBoolean(NIL == funcall($negated_test_func$.getDynamicValue(thread), obj));
        }
    }

    public static SubLObject negated_test_func(final SubLObject obj) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject dynamicValue = $negated_test_func$.getDynamicValue(thread);
	return makeBoolean(NIL == funcall(dynamicValue, obj));
    }

    /**
     * Negated version of REMOVE-IF
     */
    @LispMethod(comment = "Negated version of REMOVE-IF")
    public static final SubLObject remove_if_not_alt(SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = remove_if(NEGATED_TEST_FUNC, sequence, key, start, end, count);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Negated version of REMOVE-IF
     */
    @LispMethod(comment = "Negated version of REMOVE-IF")
    public static SubLObject remove_if_not(final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = remove_if(NEGATED_TEST_FUNC, sequence, key, start, end, count);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of DELETE-IF
     */
    @LispMethod(comment = "Negated version of DELETE-IF")
    public static final SubLObject delete_if_not_alt(SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = delete_if(NEGATED_TEST_FUNC, sequence, key, start, end, count);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Negated version of DELETE-IF
     */
    @LispMethod(comment = "Negated version of DELETE-IF")
    public static SubLObject delete_if_not(final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = delete_if(NEGATED_TEST_FUNC, sequence, key, start, end, count);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of SUBSTITUTE-IF
     */
    @LispMethod(comment = "Negated version of SUBSTITUTE-IF")
    public static final SubLObject substitute_if_not_alt(SubLObject v_new, SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = substitute_if(v_new, NEGATED_TEST_FUNC, sequence, key, start, end, count);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Negated version of SUBSTITUTE-IF
     */
    @LispMethod(comment = "Negated version of SUBSTITUTE-IF")
    public static SubLObject substitute_if_not(final SubLObject v_new, final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = substitute_if(v_new, NEGATED_TEST_FUNC, sequence, key, start, end, count);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of NSUBSTITUTE-IF
     */
    @LispMethod(comment = "Negated version of NSUBSTITUTE-IF")
    public static final SubLObject nsubstitute_if_not_alt(SubLObject v_new, SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = nsubstitute_if(v_new, NEGATED_TEST_FUNC, sequence, key, start, end, count);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Negated version of NSUBSTITUTE-IF
     */
    @LispMethod(comment = "Negated version of NSUBSTITUTE-IF")
    public static SubLObject nsubstitute_if_not(final SubLObject v_new, final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = nsubstitute_if(v_new, NEGATED_TEST_FUNC, sequence, key, start, end, count);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of FIND-IF
     */
    @LispMethod(comment = "Negated version of FIND-IF")
    public static final SubLObject find_if_not_alt(SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = find_if(NEGATED_TEST_FUNC, sequence, key, start, end);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Negated version of FIND-IF
     */
    @LispMethod(comment = "Negated version of FIND-IF")
    public static SubLObject find_if_not(final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = find_if(NEGATED_TEST_FUNC, sequence, key, start, end);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of POSITION-IF
     */
    @LispMethod(comment = "Negated version of POSITION-IF")
    public static final SubLObject position_if_not_alt(SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = position_if(NEGATED_TEST_FUNC, sequence, key, start, end);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Negated version of POSITION-IF
     */
    @LispMethod(comment = "Negated version of POSITION-IF")
    public static SubLObject position_if_not(final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = position_if(NEGATED_TEST_FUNC, sequence, key, start, end);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject position_if_binary_lambda_alt(SubLObject v_object) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            return funcall($position_if_binary_lambda_func$.getDynamicValue(thread), v_object, $position_if_binary_lambda_arg2$.getDynamicValue(thread));
        }
    }

    public static SubLObject position_if_binary_lambda(final SubLObject v_object) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        return funcall($position_if_binary_lambda_func$.getDynamicValue(thread), v_object, $position_if_binary_lambda_arg2$.getDynamicValue(thread));
    }

    /**
     * Like @xref position-if with a test of (lambda (x) (TEST x ARG2)).
     */
    @LispMethod(comment = "Like @xref position-if with a test of (lambda (x) (TEST x ARG2)).")
    public static final SubLObject position_if_binary_alt(SubLObject test, SubLObject sequence, SubLObject arg2, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                {
                    SubLObject _prev_bind_0 = $position_if_binary_lambda_func$.currentBinding(thread);
                    SubLObject _prev_bind_1 = $position_if_binary_lambda_arg2$.currentBinding(thread);
                    try {
                        $position_if_binary_lambda_func$.bind(test, thread);
                        $position_if_binary_lambda_arg2$.bind(arg2, thread);
                        result = position_if(POSITION_IF_BINARY_LAMBDA, sequence, key, start, end);
                    } finally {
                        $position_if_binary_lambda_arg2$.rebind(_prev_bind_1, thread);
                        $position_if_binary_lambda_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     * Like @xref position-if with a test of (lambda (x) (TEST x ARG2)).
     */
    @LispMethod(comment = "Like @xref position-if with a test of (lambda (x) (TEST x ARG2)).")
    public static SubLObject position_if_binary(final SubLObject test, final SubLObject sequence, final SubLObject arg2, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        final SubLObject _prev_bind_0 = $position_if_binary_lambda_func$.currentBinding(thread);
        final SubLObject _prev_bind_2 = $position_if_binary_lambda_arg2$.currentBinding(thread);
        try {
            $position_if_binary_lambda_func$.bind(test, thread);
            $position_if_binary_lambda_arg2$.bind(arg2, thread);
            result = position_if(POSITION_IF_BINARY_LAMBDA, sequence, key, start, end);
        } finally {
            $position_if_binary_lambda_arg2$.rebind(_prev_bind_2, thread);
            $position_if_binary_lambda_func$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    /**
     *
     *
     * @return NIL or NON-NEGATIVE-INTEGER-P; The position (where 0 is the left-most position) of the right-most element in the subsequence of SEQUENCE bounded by START and END that matches ITEM by TEST.
     */
    @LispMethod(comment = "@return NIL or NON-NEGATIVE-INTEGER-P; The position (where 0 is the left-most position) of the right-most element in the subsequence of SEQUENCE bounded by START and END that matches ITEM by TEST.")
    public static final SubLObject position_from_end_alt(SubLObject item, SubLObject sequence, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        {
            SubLObject real_end = (NIL != end) ? ((SubLObject) (end)) : number_utilities.f_1_(length(sequence));
            SubLObject max = subtract(real_end, start);
            SubLObject end_var = MINUS_ONE_INTEGER;
            SubLObject position = NIL;
            for (position = max; !position.numLE(end_var); position = add(position, MINUS_ONE_INTEGER)) {
                if (NIL != funcall(test, item, funcall(key, elt(sequence, add(start, position))))) {
                    return position;
                }
            }
        }
        return NIL;
    }

    /**
     *
     *
     * @return NIL or NON-NEGATIVE-INTEGER-P; The position (where 0 is the left-most position) of the right-most element in the subsequence of SEQUENCE bounded by START and END that matches ITEM by TEST.
     */
    @LispMethod(comment = "@return NIL or NON-NEGATIVE-INTEGER-P; The position (where 0 is the left-most position) of the right-most element in the subsequence of SEQUENCE bounded by START and END that matches ITEM by TEST.")
    public static SubLObject position_from_end(final SubLObject item, final SubLObject sequence, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        final SubLObject real_end = (NIL != end) ? end : number_utilities.f_1_(length(sequence));
        final SubLObject max = subtract(real_end, start);
        SubLObject end_var;
        SubLObject position;
        for (end_var = MINUS_ONE_INTEGER, position = NIL, position = max; !position.numLE(end_var); position = add(position, MINUS_ONE_INTEGER)) {
            if (NIL != funcall(test, item, funcall(key, elt(sequence, add(start, position))))) {
                return position;
            }
        }
        return NIL;
    }

    /**
     *
     *
     * @return LISTP of all positions of ITEM in TREE.
     * @param OPAQUE-TEST:
     * 		Don't look inside any subexpressions that satisfy this.
     * @unknown Returns NIL if TREE is a dotted list.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of all positions of ITEM in TREE.\r\n@param OPAQUE-TEST:\r\n\t\tDon\'t look inside any subexpressions that satisfy this.\r\n@unknown Returns NIL if TREE is a dotted list.\r\n@unknown baxter")
    public static final SubLObject tree_positions_alt(SubLObject item, SubLObject tree, SubLObject test, SubLObject opaque_test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (opaque_test == UNPROVIDED) {
            opaque_test = NIL;
        }
        if (tree.isAtom()) {
            return NIL;
        } else {
            if (NIL != com.cyc.cycjava.cycl.list_utilities.dotted_list_p(tree)) {
                return NIL;
            } else {
                {
                    SubLObject positions = NIL;
                    SubLObject pos = ZERO_INTEGER;
                    SubLObject cdolist_list_var = tree;
                    SubLObject subtree = NIL;
                    for (subtree = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , subtree = cdolist_list_var.first()) {
                        if (NIL != funcall(test, item, subtree)) {
                            positions = cons(pos, positions);
                        } else {
                            if ((NIL != fboundp(opaque_test)) && (NIL != funcall(opaque_test, subtree))) {
                            } else {
                                if (subtree.isList()) {
                                    {
                                        SubLObject cdolist_list_var_8 = com.cyc.cycjava.cycl.list_utilities.tree_positions(item, subtree, test, UNPROVIDED);
                                        SubLObject position = NIL;
                                        for (position = cdolist_list_var_8.first(); NIL != cdolist_list_var_8; cdolist_list_var_8 = cdolist_list_var_8.rest() , position = cdolist_list_var_8.first()) {
                                            if (position.isList()) {
                                                positions = cons(cons(pos, position), positions);
                                            } else {
                                                positions = cons(list(pos, position), positions);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        pos = add(pos, ONE_INTEGER);
                    }
                    return positions;
                }
            }
        }
    }

    /**
     *
     *
     * @return LISTP of all positions of ITEM in TREE.
     * @param OPAQUE-TEST:
     * 		Don't look inside any subexpressions that satisfy this.
     * @unknown Returns NIL if TREE is a dotted list.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of all positions of ITEM in TREE.\r\n@param OPAQUE-TEST:\r\n\t\tDon\'t look inside any subexpressions that satisfy this.\r\n@unknown Returns NIL if TREE is a dotted list.\r\n@unknown baxter")
    public static SubLObject tree_positions(final SubLObject item, final SubLObject tree, SubLObject test, SubLObject opaque_test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (opaque_test == UNPROVIDED) {
            opaque_test = NIL;
        }
        if (tree.isAtom()) {
            return NIL;
        }
        if (NIL != dotted_list_p(tree)) {
            return NIL;
        }
        SubLObject positions = NIL;
        SubLObject pos = ZERO_INTEGER;
        SubLObject cdolist_list_var = tree;
        SubLObject subtree = NIL;
        subtree = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, item, subtree)) {
                positions = cons(pos, positions);
            } else
                if ((NIL == fboundp(opaque_test)) || (NIL == funcall(opaque_test, subtree))) {
                    if (subtree.isList()) {
                        SubLObject cdolist_list_var_$8 = tree_positions(item, subtree, test, UNPROVIDED);
                        SubLObject position = NIL;
                        position = cdolist_list_var_$8.first();
                        while (NIL != cdolist_list_var_$8) {
                            if (position.isList()) {
                                positions = cons(cons(pos, position), positions);
                            } else {
                                positions = cons(list(pos, position), positions);
                            }
                            cdolist_list_var_$8 = cdolist_list_var_$8.rest();
                            position = cdolist_list_var_$8.first();
                        } 
                    }
                }

            pos = add(pos, ONE_INTEGER);
            cdolist_list_var = cdolist_list_var.rest();
            subtree = cdolist_list_var.first();
        } 
        return positions;
    }

    public static SubLObject tree_positions_w_parents(final SubLObject item, final SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (tree.isAtom()) {
            return NIL;
        }
        if (NIL != dotted_list_p(tree)) {
            return NIL;
        }
        SubLObject positions = NIL;
        SubLObject pos = ZERO_INTEGER;
        SubLObject root_nodes = NIL;
        SubLObject node = NIL;
        SubLObject cdolist_list_var = tree;
        SubLObject subtree = NIL;
        subtree = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, item, subtree)) {
                positions = cons(list(pos), positions);
                root_nodes = cons(list(node), root_nodes);
            } else
                if (subtree.isList()) {
                    final SubLObject positions_nodes = tree_positions_w_parents(item, subtree, test);
                    SubLObject cdolist_list_var_$9 = positions_nodes.first();
                    SubLObject position = NIL;
                    position = cdolist_list_var_$9.first();
                    while (NIL != cdolist_list_var_$9) {
                        if (position.isList()) {
                            positions = cons(cons(pos, position), positions);
                        } else {
                            positions = cons(list(pos, position), positions);
                        }
                        cdolist_list_var_$9 = cdolist_list_var_$9.rest();
                        position = cdolist_list_var_$9.first();
                    } 
                    SubLObject cdolist_list_var_$10 = second(positions_nodes);
                    SubLObject nodes = NIL;
                    nodes = cdolist_list_var_$10.first();
                    while (NIL != cdolist_list_var_$10) {
                        if (nodes.isList()) {
                            root_nodes = cons(cons(node, nodes), root_nodes);
                        } else {
                            root_nodes = cons(list(node, nodes), root_nodes);
                        }
                        cdolist_list_var_$10 = cdolist_list_var_$10.rest();
                        nodes = cdolist_list_var_$10.first();
                    } 
                }

            pos = add(pos, ONE_INTEGER);
            if (tree.isList()) {
                node = tree.first();
            } else {
                node = tree;
            }
            cdolist_list_var = cdolist_list_var.rest();
            subtree = cdolist_list_var.first();
        } 
        return list(positions, root_nodes);
    }

    public static SubLObject difference_from_head(SubLObject list1, SubLObject list2) {
        SubLObject common_path = NIL;
        while ((NIL != list1) && (NIL != list2)) {
            final SubLObject item1 = list1.first();
            final SubLObject item2 = list2.first();
            if (!item1.equalp(item2)) {
                return list(nreverse(common_path), list1, list2);
            }
            common_path = cons(item1, common_path);
            list1 = list1.rest();
            list2 = list2.rest();
        } 
        return list(nreverse(common_path), list2, list1);
    }

    /**
     * Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.
     * It does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the top level.
     * e.g. (tree-position-bfs 3 '(1 2 (3 2 1) 4 3)) -> (4)
     *
     * @see tree-position-dfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\r\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the top level.\r\ne.g. (tree-position-bfs 3 \'(1 2 (3 2 1) 4 3)) -> (4)\r\n\r\n@see tree-position-dfs\r\n@unknown pace\nReturns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the top level.\ne.g. (tree-position-bfs 3 \'(1 2 (3 2 1) 4 3)) -> (4)")
    public static final SubLObject tree_position_bfs_alt(SubLObject item, SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (tree.isCons()) {
            {
                SubLObject pos = com.cyc.cycjava.cycl.list_utilities.list_position(item, tree, test, UNPROVIDED);
                if (NIL != pos) {
                    return list(pos);
                }
            }
            {
                SubLObject pos = ZERO_INTEGER;
                SubLObject tree_pos = NIL;
                SubLObject rest = NIL;
                for (rest = tree; !rest.isAtom(); rest = rest.rest()) {
                    {
                        SubLObject subtree = rest.first();
                        tree_pos = com.cyc.cycjava.cycl.list_utilities.tree_position_bfs(item, subtree, test);
                        if (NIL != tree_pos) {
                            return cons(pos, tree_pos);
                        } else {
                            pos = add(pos, ONE_INTEGER);
                        }
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.
     * It does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the top level.
     * e.g. (tree-position-bfs 3 '(1 2 (3 2 1) 4 3)) -> (4)
     *
     * @see tree-position-dfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\r\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the top level.\r\ne.g. (tree-position-bfs 3 \'(1 2 (3 2 1) 4 3)) -> (4)\r\n\r\n@see tree-position-dfs\r\n@unknown pace\nReturns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the top level.\ne.g. (tree-position-bfs 3 \'(1 2 (3 2 1) 4 3)) -> (4)")
    public static SubLObject tree_position_bfs(final SubLObject item, final SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (tree.isCons()) {
            SubLObject pos = list_position(item, tree, test, UNPROVIDED);
            if (NIL != pos) {
                return list(pos);
            }
            pos = ZERO_INTEGER;
            SubLObject tree_pos = NIL;
            SubLObject rest;
            SubLObject subtree;
            for (rest = NIL, rest = tree; !rest.isAtom(); rest = rest.rest()) {
                subtree = rest.first();
                tree_pos = tree_position_bfs(item, subtree, test);
                if (NIL != tree_pos) {
                    return cons(pos, tree_pos);
                }
                pos = add(pos, ONE_INTEGER);
            }
        }
        return NIL;
    }

    /**
     * Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.
     * It does a depth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the beginning.
     * e.g. (tree-position-dfs 3 '(1 2 (3 2 1) 4 3)) -> (2 0)
     *
     * @see tree-position-bfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\r\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the beginning.\r\ne.g. (tree-position-dfs 3 \'(1 2 (3 2 1) 4 3)) -> (2 0)\r\n\r\n@see tree-position-bfs\r\n@unknown pace\nReturns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the beginning.\ne.g. (tree-position-dfs 3 \'(1 2 (3 2 1) 4 3)) -> (2 0)")
    public static final SubLObject tree_position_dfs_alt(SubLObject item, SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (tree.isCons()) {
            {
                SubLObject pos = ZERO_INTEGER;
                SubLObject tree_pos = NIL;
                SubLObject rest = NIL;
                for (rest = tree; !rest.isAtom(); rest = rest.rest()) {
                    {
                        SubLObject subtree = rest.first();
                        if (NIL != funcall(test, item, subtree)) {
                            return list(pos);
                        }
                        tree_pos = com.cyc.cycjava.cycl.list_utilities.tree_position_dfs(item, subtree, test);
                        if (NIL != tree_pos) {
                            return cons(pos, tree_pos);
                        } else {
                            pos = add(pos, ONE_INTEGER);
                        }
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.
     * It does a depth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the beginning.
     * e.g. (tree-position-dfs 3 '(1 2 (3 2 1) 4 3)) -> (2 0)
     *
     * @see tree-position-bfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\r\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the beginning.\r\ne.g. (tree-position-dfs 3 \'(1 2 (3 2 1) 4 3)) -> (2 0)\r\n\r\n@see tree-position-bfs\r\n@unknown pace\nReturns the position of ITEM in TREE as a list.  Taking successive nths of this list on TREE will lead you back to ITEM.\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, it will find the one nearest the beginning.\ne.g. (tree-position-dfs 3 \'(1 2 (3 2 1) 4 3)) -> (2 0)")
    public static SubLObject tree_position_dfs(final SubLObject item, final SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (tree.isCons()) {
            SubLObject pos = ZERO_INTEGER;
            SubLObject tree_pos = NIL;
            SubLObject rest;
            SubLObject subtree;
            for (rest = NIL, rest = tree; !rest.isAtom(); rest = rest.rest()) {
                subtree = rest.first();
                if (NIL != funcall(test, item, subtree)) {
                    return list(pos);
                }
                tree_pos = tree_position_dfs(item, subtree, test);
                if (NIL != tree_pos) {
                    return cons(pos, tree_pos);
                }
                pos = add(pos, ONE_INTEGER);
            }
        }
        return NIL;
    }

    /**
     * Like @xref POSITION except LIST must be a list.
     * When processing dotted lists, the final cdr is ignored.
     *
     * @unknown goolsbey
     */
    @LispMethod(comment = "Like @xref POSITION except LIST must be a list.\r\nWhen processing dotted lists, the final cdr is ignored.\r\n\r\n@unknown goolsbey\nLike @xref POSITION except LIST must be a list.\nWhen processing dotted lists, the final cdr is ignored.")
    public static final SubLObject list_position_alt(SubLObject item, SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(list, LISTP);
        if (NIL != com.cyc.cycjava.cycl.list_utilities.non_dotted_list_p(list)) {
            return position(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } else {
            {
                SubLObject i = ZERO_INTEGER;
                SubLObject rest = NIL;
                for (rest = list; !rest.isAtom(); rest = rest.rest()) {
                    {
                        SubLObject subtree = rest.first();
                        if (NIL != funcall(test, item, funcall(key, subtree))) {
                            return i;
                        }
                        i = add(i, ONE_INTEGER);
                    }
                }
                return NIL;
            }
        }
    }

    /**
     * Like @xref POSITION except LIST must be a list.
     * When processing dotted lists, the final cdr is ignored.
     *
     * @unknown goolsbey
     */
    @LispMethod(comment = "Like @xref POSITION except LIST must be a list.\r\nWhen processing dotted lists, the final cdr is ignored.\r\n\r\n@unknown goolsbey\nLike @xref POSITION except LIST must be a list.\nWhen processing dotted lists, the final cdr is ignored.")
    public static SubLObject list_position(final SubLObject item, final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (NIL != non_dotted_list_p(list)) {
            return position(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        SubLObject i = ZERO_INTEGER;
        SubLObject rest;
        SubLObject subtree;
        for (rest = NIL, rest = list; !rest.isAtom(); rest = rest.rest()) {
            subtree = rest.first();
            if (NIL != funcall(test, item, funcall(key, subtree))) {
                return i;
            }
            i = add(i, ONE_INTEGER);
        }
        return NIL;
    }

    /**
     * Returns true if tree-position is a flat list of integers.
     * Ussually, items of this type are lists of nths for uniquely
     * identifying an element in a tree.
     *
     * @unknown tbrussea
     */
    @LispMethod(comment = "Returns true if tree-position is a flat list of integers.\r\nUssually, items of this type are lists of nths for uniquely\r\nidentifying an element in a tree.\r\n\r\n@unknown tbrussea\nReturns true if tree-position is a flat list of integers.\nUssually, items of this type are lists of nths for uniquely\nidentifying an element in a tree.")
    public static final SubLObject tree_position_p_alt(SubLObject tree_position) {
        if (!tree_position.isList()) {
            return NIL;
        }
        {
            SubLObject cdolist_list_var = tree_position;
            SubLObject cur_atom = NIL;
            for (cur_atom = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cur_atom = cdolist_list_var.first()) {
                if (!cur_atom.isInteger()) {
                    return NIL;
                }
            }
        }
        return T;
    }

    /**
     * Returns true if tree-position is a flat list of integers.
     * Ussually, items of this type are lists of nths for uniquely
     * identifying an element in a tree.
     *
     * @unknown tbrussea
     */
    @LispMethod(comment = "Returns true if tree-position is a flat list of integers.\r\nUssually, items of this type are lists of nths for uniquely\r\nidentifying an element in a tree.\r\n\r\n@unknown tbrussea\nReturns true if tree-position is a flat list of integers.\nUssually, items of this type are lists of nths for uniquely\nidentifying an element in a tree.")
    public static SubLObject tree_position_p(final SubLObject tree_position) {
        if (!tree_position.isList()) {
            return NIL;
        }
        SubLObject cdolist_list_var = tree_position;
        SubLObject cur_atom = NIL;
        cur_atom = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (!cur_atom.isInteger()) {
                return NIL;
            }
            cdolist_list_var = cdolist_list_var.rest();
            cur_atom = cdolist_list_var.first();
        } 
        return T;
    }

    /**
     *
     *
     * @param POSITIONS;
     * 		listp (of possibly nested positions)
     * @param TREE;
    listp
     * 		
     * @return listp
    Returns a flat list of elements in TREE whose positions are specified by POSITIONS.
     * @unknown (tree-nested-nths '(3 (2 0)) '(A B (C B A) E C))  =>  (E C)
     * @unknown (tree-nested-nths '(4 (2 (3 0))) '(A B (C B A (F)) E C)) =>  (C F)
     * @unknown (tree-nested-nths '(4 (2 0) (2 (2 0))) '(A B (C B (C) A) D C)) => (C C C)
     * @unknown zelal
     */
    @LispMethod(comment = "@param POSITIONS;\r\n\t\tlistp (of possibly nested positions)\r\n@param TREE;\nlistp\r\n\t\t\r\n@return listp\r\nReturns a flat list of elements in TREE whose positions are specified by POSITIONS.\r\n@unknown (tree-nested-nths \'(3 (2 0)) \'(A B (C B A) E C))  =>  (E C)\r\n@unknown (tree-nested-nths \'(4 (2 (3 0))) \'(A B (C B A (F)) E C)) =>  (C F)\r\n@unknown (tree-nested-nths \'(4 (2 0) (2 (2 0))) \'(A B (C B (C) A) D C)) => (C C C)\r\n@unknown zelal")
    public static final SubLObject tree_nested_nths_alt(SubLObject positions, SubLObject tree) {
        if (tree.isAtom()) {
            return NIL;
        } else {
            if (NIL != com.cyc.cycjava.cycl.list_utilities.dotted_list_p(tree)) {
                return NIL;
            } else {
                {
                    SubLObject items = NIL;
                    SubLObject cdolist_list_var = positions;
                    SubLObject sub_position = NIL;
                    for (sub_position = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , sub_position = cdolist_list_var.first()) {
                        if (sub_position.isInteger()) {
                            items = cons(nth(sub_position, tree), items);
                        } else {
                            if (sub_position.isList()) {
                                items = nconc(items, com.cyc.cycjava.cycl.list_utilities.tree_nested_nths(sub_position.rest(), nth(sub_position.first(), tree)));
                            }
                        }
                    }
                    return items;
                }
            }
        }
    }

    /**
     *
     *
     * @param POSITIONS;
     * 		listp (of possibly nested positions)
     * @param TREE;
    listp
     * 		
     * @return listp
    Returns a flat list of elements in TREE whose positions are specified by POSITIONS.
     * @unknown (tree-nested-nths '(3 (2 0)) '(A B (C B A) E C))  =>  (E C)
     * @unknown (tree-nested-nths '(4 (2 (3 0))) '(A B (C B A (F)) E C)) =>  (C F)
     * @unknown (tree-nested-nths '(4 (2 0) (2 (2 0))) '(A B (C B (C) A) D C)) => (C C C)
     * @unknown zelal
     */
    @LispMethod(comment = "@param POSITIONS;\r\n\t\tlistp (of possibly nested positions)\r\n@param TREE;\nlistp\r\n\t\t\r\n@return listp\r\nReturns a flat list of elements in TREE whose positions are specified by POSITIONS.\r\n@unknown (tree-nested-nths \'(3 (2 0)) \'(A B (C B A) E C))  =>  (E C)\r\n@unknown (tree-nested-nths \'(4 (2 (3 0))) \'(A B (C B A (F)) E C)) =>  (C F)\r\n@unknown (tree-nested-nths \'(4 (2 0) (2 (2 0))) \'(A B (C B (C) A) D C)) => (C C C)\r\n@unknown zelal")
    public static SubLObject tree_nested_nths(final SubLObject positions, final SubLObject tree) {
        if (tree.isAtom()) {
            return NIL;
        }
        if (NIL != dotted_list_p(tree)) {
            return NIL;
        }
        SubLObject items = NIL;
        SubLObject cdolist_list_var = positions;
        SubLObject sub_position = NIL;
        sub_position = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (sub_position.isInteger()) {
                items = cons(nth(sub_position, tree), items);
            } else
                if (sub_position.isList()) {
                    items = nconc(items, tree_nested_nths(sub_position.rest(), nth(sub_position.first(), tree)));
                }

            cdolist_list_var = cdolist_list_var.rest();
            sub_position = cdolist_list_var.first();
        } 
        return items;
    }

    /**
     *
     *
     * @param POSITIONS;
     * 		listp (of flat-list positions like those returned by @xref TREE-POSITIONS)
     * @param TREE;
    listp
     * 		
     * @return listp
    Returns a flat list of elements in TREE whose positions are specified by POSITIONS.
     * @see TREE-POSITIONS
     * @unknown (tree-nths '(3 (2 0)) '(A B (C B A) E C))  =>  (E C)
     * @unknown (tree-nths '(4 (2 3 0)) '(A B (C B A (F)) E C)) =>  (C F)
     * @unknown (tree-nths '(4 (2 0) (2 2 0)) '(A B (C B (C) A) D C)) => (C C C)
     * @unknown zelal
     */
    @LispMethod(comment = "@param POSITIONS;\r\n\t\tlistp (of flat-list positions like those returned by @xref TREE-POSITIONS)\r\n@param TREE;\nlistp\r\n\t\t\r\n@return listp\r\nReturns a flat list of elements in TREE whose positions are specified by POSITIONS.\r\n@see TREE-POSITIONS\r\n@unknown (tree-nths \'(3 (2 0)) \'(A B (C B A) E C))  =>  (E C)\r\n@unknown (tree-nths \'(4 (2 3 0)) \'(A B (C B A (F)) E C)) =>  (C F)\r\n@unknown (tree-nths \'(4 (2 0) (2 2 0)) \'(A B (C B (C) A) D C)) => (C C C)\r\n@unknown zelal")
    public static final SubLObject tree_nths_alt(SubLObject positions, SubLObject tree) {
        {
            SubLObject items = NIL;
            SubLObject cdolist_list_var = positions;
            SubLObject position = NIL;
            for (position = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , position = cdolist_list_var.first()) {
                items = cons(com.cyc.cycjava.cycl.list_utilities.get_nested_nth(tree, position.isList() ? ((SubLObject) (position)) : list(position), UNPROVIDED), items);
            }
            return nreverse(items);
        }
    }

    /**
     *
     *
     * @param POSITIONS;
     * 		listp (of flat-list positions like those returned by @xref TREE-POSITIONS)
     * @param TREE;
    listp
     * 		
     * @return listp
    Returns a flat list of elements in TREE whose positions are specified by POSITIONS.
     * @see TREE-POSITIONS
     * @unknown (tree-nths '(3 (2 0)) '(A B (C B A) E C))  =>  (E C)
     * @unknown (tree-nths '(4 (2 3 0)) '(A B (C B A (F)) E C)) =>  (C F)
     * @unknown (tree-nths '(4 (2 0) (2 2 0)) '(A B (C B (C) A) D C)) => (C C C)
     * @unknown zelal
     */
    @LispMethod(comment = "@param POSITIONS;\r\n\t\tlistp (of flat-list positions like those returned by @xref TREE-POSITIONS)\r\n@param TREE;\nlistp\r\n\t\t\r\n@return listp\r\nReturns a flat list of elements in TREE whose positions are specified by POSITIONS.\r\n@see TREE-POSITIONS\r\n@unknown (tree-nths \'(3 (2 0)) \'(A B (C B A) E C))  =>  (E C)\r\n@unknown (tree-nths \'(4 (2 3 0)) \'(A B (C B A (F)) E C)) =>  (C F)\r\n@unknown (tree-nths \'(4 (2 0) (2 2 0)) \'(A B (C B (C) A) D C)) => (C C C)\r\n@unknown zelal")
    public static SubLObject tree_nths(final SubLObject positions, final SubLObject tree) {
        SubLObject items = NIL;
        SubLObject cdolist_list_var = positions;
        SubLObject position = NIL;
        position = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            items = cons(get_nested_nth(tree, position.isList() ? position : list(position), UNPROVIDED), items);
            cdolist_list_var = cdolist_list_var.rest();
            position = cdolist_list_var.first();
        } 
        return nreverse(items);
    }

    public static final SubLObject has_nested_nth_p_alt(SubLObject v_object, SubLObject where) {
        return nth_value_step_2(nth_value_step_1(ONE_INTEGER), com.cyc.cycjava.cycl.list_utilities.get_nested_nth(v_object, where, UNPROVIDED));
    }

    public static SubLObject has_nested_nth_p(final SubLObject v_object, final SubLObject where) {
        return nth_value_step_2(nth_value_step_1(ONE_INTEGER), get_nested_nth(v_object, where, UNPROVIDED));
    }

    /**
     * WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be returned.
     * e.g. (get-nested-nth '(1 2 (3 4) 5)) '(2 1)) would return 4)
     *
     * @return 0; The item at WHERE in OBJECT, or DEFAULT if nothing is there.
     * @return 1 booleanp; Did we find something?
     * @unknown jantos
     */
    @LispMethod(comment = "WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be returned.\r\ne.g. (get-nested-nth \'(1 2 (3 4) 5)) \'(2 1)) would return 4)\r\n\r\n@return 0; The item at WHERE in OBJECT, or DEFAULT if nothing is there.\r\n@return 1 booleanp; Did we find something?\r\n@unknown jantos\nWHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be returned.\ne.g. (get-nested-nth \'(1 2 (3 4) 5)) \'(2 1)) would return 4)")
    public static final SubLObject get_nested_nth_alt(SubLObject v_object, SubLObject where, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject firstwhere = where.first();
            SubLObject subwhere = where.rest();
            if (NIL == firstwhere) {
                return values(v_object, T);
            } else {
                if ((firstwhere.isInteger() && v_object.isList()) && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthG(v_object, firstwhere, UNPROVIDED))) {
                    {
                        SubLObject target = nth(firstwhere, v_object);
                        return com.cyc.cycjava.cycl.list_utilities.get_nested_nth(target, subwhere, UNPROVIDED);
                    }
                } else {
                    return values(v_default, NIL);
                }
            }
        }
    }

    /**
     * WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be returned.
     * e.g. (get-nested-nth '(1 2 (3 4) 5)) '(2 1)) would return 4)
     *
     * @return 0; The item at WHERE in OBJECT, or DEFAULT if nothing is there.
     * @return 1 booleanp; Did we find something?
     * @unknown jantos
     */
    @LispMethod(comment = "WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be returned.\r\ne.g. (get-nested-nth \'(1 2 (3 4) 5)) \'(2 1)) would return 4)\r\n\r\n@return 0; The item at WHERE in OBJECT, or DEFAULT if nothing is there.\r\n@return 1 booleanp; Did we find something?\r\n@unknown jantos\nWHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be returned.\ne.g. (get-nested-nth \'(1 2 (3 4) 5)) \'(2 1)) would return 4)")
    public static SubLObject get_nested_nth(final SubLObject v_object, final SubLObject where, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        final SubLObject firstwhere = where.first();
        final SubLObject subwhere = where.rest();
        if (NIL == firstwhere) {
            return subl_promotions.values2(v_object, T);
        }
        if ((firstwhere.isInteger() && v_object.isList()) && (NIL != lengthG(v_object, firstwhere, UNPROVIDED))) {
            final SubLObject target = nth(firstwhere, v_object);
            return get_nested_nth(target, subwhere, UNPROVIDED);
        }
        return subl_promotions.values2(v_default, NIL);
    }

    /**
     * A non-destructive version of @xref nreplace-nested-nth
     */
    @LispMethod(comment = "A non-destructive version of @xref nreplace-nested-nth")
    public static final SubLObject replace_nested_nth_alt(SubLObject list, SubLObject where, SubLObject new_car) {
        return com.cyc.cycjava.cycl.list_utilities.nreplace_nested_nth(copy_tree(list), where, new_car);
    }

    /**
     * A non-destructive version of @xref nreplace-nested-nth
     */
    @LispMethod(comment = "A non-destructive version of @xref nreplace-nested-nth")
    public static SubLObject replace_nested_nth(final SubLObject list, final SubLObject where, final SubLObject new_car) {
        return nreplace_nested_nth(copy_tree(list), where, new_car);
    }

    /**
     * WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be replaced by NEW-CAR.
     * e.g. (nreplace-nested-nth '(1 2 (3 4) 5) '(2 1) nil) would modify the list to (1 2 (3 NIL) 5)
     * This is destructive.
     *
     * @unknown pace
     */
    @LispMethod(comment = "WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be replaced by NEW-CAR.\r\ne.g. (nreplace-nested-nth \'(1 2 (3 4) 5) \'(2 1) nil) would modify the list to (1 2 (3 NIL) 5)\r\nThis is destructive.\r\n\r\n@unknown pace\nWHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be replaced by NEW-CAR.\ne.g. (nreplace-nested-nth \'(1 2 (3 4) 5) \'(2 1) nil) would modify the list to (1 2 (3 NIL) 5)\nThis is destructive.")
    public static final SubLObject nreplace_nested_nth_alt(SubLObject v_object, SubLObject where, SubLObject new_car) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL != where) {
                thread.resetMultipleValues();
                {
                    SubLObject new_obj = com.cyc.cycjava.cycl.list_utilities.nreplace_nested_nth(nth(where.first(), v_object), where.rest(), new_car);
                    SubLObject terminalP = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    if (NIL != terminalP) {
                        {
                            SubLObject target = nthcdr(where.first(), v_object);
                            if (target.isCons()) {
                                rplaca(target, new_car);
                            }
                        }
                    }
                    return values(v_object, NIL);
                }
            }
            return values(v_object, sublisp_null(where));
        }
    }

    /**
     * WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be replaced by NEW-CAR.
     * e.g. (nreplace-nested-nth '(1 2 (3 4) 5) '(2 1) nil) would modify the list to (1 2 (3 NIL) 5)
     * This is destructive.
     *
     * @unknown pace
     */
    @LispMethod(comment = "WHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be replaced by NEW-CAR.\r\ne.g. (nreplace-nested-nth \'(1 2 (3 4) 5) \'(2 1) nil) would modify the list to (1 2 (3 NIL) 5)\r\nThis is destructive.\r\n\r\n@unknown pace\nWHERE is a list of integers, which when taken on OBJECT as nths in sequence, lead to the item to be replaced by NEW-CAR.\ne.g. (nreplace-nested-nth \'(1 2 (3 4) 5) \'(2 1) nil) would modify the list to (1 2 (3 NIL) 5)\nThis is destructive.")
    public static SubLObject nreplace_nested_nth(final SubLObject v_object, final SubLObject where, final SubLObject new_car) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (NIL != where) {
            thread.resetMultipleValues();
            final SubLObject new_obj = nreplace_nested_nth(nth(where.first(), v_object), where.rest(), new_car);
            final SubLObject terminalP = thread.secondMultipleValue();
            thread.resetMultipleValues();
            if (NIL != terminalP) {
                final SubLObject target = nthcdr(where.first(), v_object);
                if (target.isCons()) {
                    rplaca(target, new_car);
                }
            }
            return subl_promotions.values2(v_object, NIL);
        }
        return subl_promotions.values2(v_object, sublisp_null(where));
    }

    /**
     *
     *
     * @return a copy of LIST minus the element at WHERE, if one exists.
     * @unknown - non-destructive.
     */
    @LispMethod(comment = "@return a copy of LIST minus the element at WHERE, if one exists.\r\n@unknown - non-destructive.")
    public static final SubLObject remove_nested_nth_alt(SubLObject list, SubLObject where) {
        SubLTrampolineFile.checkType(list, PROPER_LIST_P);
        SubLTrampolineFile.checkType(where, PROPER_LIST_P);
        {
            SubLObject list_var = where;
            SubLTrampolineFile.checkType(list_var, NON_DOTTED_LIST_P);
            {
                SubLObject cdolist_list_var = list_var;
                SubLObject elem = NIL;
                for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                    SubLTrampolineFile.checkType(elem, NON_NEGATIVE_INTEGER_P);
                }
            }
        }
        return com.cyc.cycjava.cycl.list_utilities.delete_nested_nth_internal(copy_tree(list), where);
    }

    /**
     *
     *
     * @return a copy of LIST minus the element at WHERE, if one exists.
     * @unknown - non-destructive.
     */
    @LispMethod(comment = "@return a copy of LIST minus the element at WHERE, if one exists.\r\n@unknown - non-destructive.")
    public static SubLObject remove_nested_nth(final SubLObject list, final SubLObject where) {
        assert NIL != proper_list_p(list) : "! list_utilities.proper_list_p(list) " + ("list_utilities.proper_list_p(list) " + "CommonSymbols.NIL != list_utilities.proper_list_p(list) ") + list;
        assert NIL != proper_list_p(where) : "! list_utilities.proper_list_p(where) " + ("list_utilities.proper_list_p(where) " + "CommonSymbols.NIL != list_utilities.proper_list_p(where) ") + where;
        assert NIL != non_dotted_list_p(where) : "! list_utilities.non_dotted_list_p(where) " + ("list_utilities.non_dotted_list_p(where) " + "CommonSymbols.NIL != list_utilities.non_dotted_list_p(where) ") + where;
        SubLObject cdolist_list_var = where;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            assert NIL != subl_promotions.non_negative_integer_p(elem) : "! subl_promotions.non_negative_integer_p(elem) " + ("subl_promotions.non_negative_integer_p(elem) " + "CommonSymbols.NIL != subl_promotions.non_negative_integer_p(elem) ") + elem;
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return delete_nested_nth_internal(copy_tree(list), where);
    }

    /**
     *
     *
     * @return a version of LIST minus the element at WHERE, if one exists.
     * @unknown - destructive.
     */
    @LispMethod(comment = "@return a version of LIST minus the element at WHERE, if one exists.\r\n@unknown - destructive.")
    public static final SubLObject delete_nested_nth_alt(SubLObject list, SubLObject where) {
        SubLTrampolineFile.checkType(list, PROPER_LIST_P);
        SubLTrampolineFile.checkType(where, PROPER_LIST_P);
        {
            SubLObject list_var = where;
            SubLTrampolineFile.checkType(list_var, NON_DOTTED_LIST_P);
            {
                SubLObject cdolist_list_var = list_var;
                SubLObject elem = NIL;
                for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                    SubLTrampolineFile.checkType(elem, NON_NEGATIVE_INTEGER_P);
                }
            }
        }
        return com.cyc.cycjava.cycl.list_utilities.delete_nested_nth_internal(list, where);
    }

    /**
     *
     *
     * @return a version of LIST minus the element at WHERE, if one exists.
     * @unknown - destructive.
     */
    @LispMethod(comment = "@return a version of LIST minus the element at WHERE, if one exists.\r\n@unknown - destructive.")
    public static SubLObject delete_nested_nth(final SubLObject list, final SubLObject where) {
        assert NIL != proper_list_p(list) : "! list_utilities.proper_list_p(list) " + ("list_utilities.proper_list_p(list) " + "CommonSymbols.NIL != list_utilities.proper_list_p(list) ") + list;
        assert NIL != proper_list_p(where) : "! list_utilities.proper_list_p(where) " + ("list_utilities.proper_list_p(where) " + "CommonSymbols.NIL != list_utilities.proper_list_p(where) ") + where;
        assert NIL != non_dotted_list_p(where) : "! list_utilities.non_dotted_list_p(where) " + ("list_utilities.non_dotted_list_p(where) " + "CommonSymbols.NIL != list_utilities.non_dotted_list_p(where) ") + where;
        SubLObject cdolist_list_var = where;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            assert NIL != subl_promotions.non_negative_integer_p(elem) : "! subl_promotions.non_negative_integer_p(elem) " + ("subl_promotions.non_negative_integer_p(elem) " + "CommonSymbols.NIL != subl_promotions.non_negative_integer_p(elem) ") + elem;
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return delete_nested_nth_internal(list, where);
    }

    public static final SubLObject delete_nested_nth_internal_alt(SubLObject list, SubLObject where) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.lengthG(where, ONE_INTEGER, UNPROVIDED)) {
            {
                SubLObject sublist = nth(where.first(), list);
                SubLObject new_sublist = com.cyc.cycjava.cycl.list_utilities.delete_nested_nth_internal(sublist, where.rest());
                return com.cyc.cycjava.cycl.list_utilities.nreplace_nth(where.first(), new_sublist, list);
            }
        } else {
            return com.cyc.cycjava.cycl.list_utilities.delete_nth(where.first(), list);
        }
    }

    public static SubLObject delete_nested_nth_internal(final SubLObject list, final SubLObject where) {
        if (NIL != lengthG(where, ONE_INTEGER, UNPROVIDED)) {
            final SubLObject sublist = nth(where.first(), list);
            final SubLObject new_sublist = delete_nested_nth_internal(sublist, where.rest());
            return nreplace_nth(where.first(), new_sublist, list);
        }
        return delete_nth(where.first(), list);
    }

    /**
     *
     *
     * @unknown pace
     */
    @LispMethod(comment = "@unknown pace")
    public static final SubLObject tree_positions_int_alt(SubLObject item, SubLObject tree, SubLObject pos_function, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (item == $DELETED) {
            return NIL;
        }
        if (NIL != funcall(test, item, tree)) {
            return $list_alt72;
        }
        {
            SubLObject temp_tree = copy_tree(tree);
            SubLObject result = $DUMMY;
            SubLObject positions = NIL;
            for (; NIL != result;) {
                result = funcall(pos_function, item, temp_tree, test);
                if (NIL != result) {
                    positions = cons(result, positions);
                    com.cyc.cycjava.cycl.list_utilities.nreplace_nested_nth(temp_tree, result, $DELETED);
                }
            }
            return nreverse(positions);
        }
    }

    /**
     *
     *
     * @unknown pace
     */
    @LispMethod(comment = "@unknown pace")
    public static SubLObject tree_positions_int(final SubLObject item, final SubLObject tree, final SubLObject pos_function, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (item == $DELETED) {
            return NIL;
        }
        if (NIL != funcall(test, item, tree)) {
            return $list72;
        }
        final SubLObject temp_tree = copy_tree(tree);
        SubLObject result = $DUMMY;
        SubLObject positions = NIL;
        while (NIL != result) {
            result = funcall(pos_function, item, temp_tree, test);
            if (NIL != result) {
                positions = cons(result, positions);
                nreplace_nested_nth(temp_tree, result, $DELETED);
            }
        } 
        return nreverse(positions);
    }

    /**
     * Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.
     * It does a depth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the top will be nearest the beginning.
     * e.g. (tree-positions-dfs 3 '(1 2 (3 2 1) 4 3)) -> ((2 0) (4))
     *
     * @see tree-positions-bfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\r\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the top will be nearest the beginning.\r\ne.g. (tree-positions-dfs 3 \'(1 2 (3 2 1) 4 3)) -> ((2 0) (4))\r\n\r\n@see tree-positions-bfs\r\n@unknown pace\nReturns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the top will be nearest the beginning.\ne.g. (tree-positions-dfs 3 \'(1 2 (3 2 1) 4 3)) -> ((2 0) (4))")
    public static final SubLObject tree_positions_dfs_alt(SubLObject item, SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_positions_int(item, tree, TREE_POSITION_DFS, test);
    }

    /**
     * Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.
     * It does a depth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the top will be nearest the beginning.
     * e.g. (tree-positions-dfs 3 '(1 2 (3 2 1) 4 3)) -> ((2 0) (4))
     *
     * @see tree-positions-bfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\r\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the top will be nearest the beginning.\r\ne.g. (tree-positions-dfs 3 \'(1 2 (3 2 1) 4 3)) -> ((2 0) (4))\r\n\r\n@see tree-positions-bfs\r\n@unknown pace\nReturns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\nIt does a depth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the top will be nearest the beginning.\ne.g. (tree-positions-dfs 3 \'(1 2 (3 2 1) 4 3)) -> ((2 0) (4))")
    public static SubLObject tree_positions_dfs(final SubLObject item, final SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return tree_positions_int(item, tree, TREE_POSITION_DFS, test);
    }

    /**
     * Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.
     * It does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the beginning will be nearest the beginning.
     * e.g. (tree-positions-bfs 3 '(1 2 (3 2 1) 4 3)) -> ((4) (2 0))
     *
     * @see tree-positions-dfs
     * @unknown pace
     */
    @LispMethod(comment = "Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\r\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the beginning will be nearest the beginning.\r\ne.g. (tree-positions-bfs 3 \'(1 2 (3 2 1) 4 3)) -> ((4) (2 0))\r\n\r\n@see tree-positions-dfs\r\n@unknown pace\nReturns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the beginning will be nearest the beginning.\ne.g. (tree-positions-bfs 3 \'(1 2 (3 2 1) 4 3)) -> ((4) (2 0))")
    public static final SubLObject tree_positions_bfs_alt(SubLObject item, SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_positions_int(item, tree, TREE_POSITION_BFS, test);
    }

    @LispMethod(comment = "Returns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\r\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the beginning will be nearest the beginning.\r\ne.g. (tree-positions-bfs 3 \'(1 2 (3 2 1) 4 3)) -> ((4) (2 0))\r\n\r\n@see tree-positions-dfs\r\n@unknown pace\nReturns a list of the positions of ITEM in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to ITEM.\nIt does a breadth-first search, so if there is more than one occurrence of ITEM in TREE, the ones nearest the beginning will be nearest the beginning.\ne.g. (tree-positions-bfs 3 \'(1 2 (3 2 1) 4 3)) -> ((4) (2 0))")
    public static SubLObject tree_positions_bfs(final SubLObject item, final SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return tree_positions_int(item, tree, TREE_POSITION_BFS, test);
    }

    public static final SubLObject containing_subtrees_alt(SubLObject item, SubLObject tree) {
        {
            SubLObject paths = com.cyc.cycjava.cycl.list_utilities.tree_positions(item, tree, UNPROVIDED, UNPROVIDED);
            SubLObject containing_trees = NIL;
            SubLObject cdolist_list_var = paths;
            SubLObject path = NIL;
            for (path = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , path = cdolist_list_var.first()) {
                containing_trees = cons(path.isInteger() ? ((SubLObject) (tree)) : com.cyc.cycjava.cycl.list_utilities.get_nested_nth(tree, butlast(path, UNPROVIDED), UNPROVIDED), containing_trees);
            }
            return containing_trees;
        }
    }

    public static SubLObject containing_subtrees(final SubLObject item, final SubLObject tree) {
        final SubLObject paths = tree_positions(item, tree, UNPROVIDED, UNPROVIDED);
        SubLObject containing_trees = NIL;
        SubLObject cdolist_list_var = paths;
        SubLObject path = NIL;
        path = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            containing_trees = cons(path.isInteger() ? tree : get_nested_nth(tree, butlast(path, UNPROVIDED), UNPROVIDED), containing_trees);
            cdolist_list_var = cdolist_list_var.rest();
            path = cdolist_list_var.first();
        } 
        return containing_trees;
    }

    /**
     * Returns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.
     * It does a depth-first search, so if there is more than one occurrence of items passing TEST in TREE, the ones nearest the beginning will be nearest the beginning.
     * e.g. (tree-positions-if-dfs 'prime-number? '(1 2 (3 2 1) 4 3)) -> ((1) (2 0) (2 1) (4))
     *
     * @see tree-positions-if-bfs
     * @unknown baxter
     */
    @LispMethod(comment = "Returns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\r\nIt does a depth-first search, so if there is more than one occurrence of items passing TEST in TREE, the ones nearest the beginning will be nearest the beginning.\r\ne.g. (tree-positions-if-dfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (2 0) (2 1) (4))\r\n\r\n@see tree-positions-if-bfs\r\n@unknown baxter\nReturns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\nIt does a depth-first search, so if there is more than one occurrence of items passing TEST in TREE, the ones nearest the beginning will be nearest the beginning.\ne.g. (tree-positions-if-dfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (2 0) (2 1) (4))")
    public static final SubLObject tree_positions_if_dfs_alt(SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_positions_if_dfs_int(test, tree, key);
    }

    @LispMethod(comment = "Returns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\r\nIt does a depth-first search, so if there is more than one occurrence of items passing TEST in TREE, the ones nearest the beginning will be nearest the beginning.\r\ne.g. (tree-positions-if-dfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (2 0) (2 1) (4))\r\n\r\n@see tree-positions-if-bfs\r\n@unknown baxter\nReturns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\nIt does a depth-first search, so if there is more than one occurrence of items passing TEST in TREE, the ones nearest the beginning will be nearest the beginning.\ne.g. (tree-positions-if-dfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (2 0) (2 1) (4))")
    public static SubLObject tree_positions_if_dfs(final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_positions_if_dfs_int(test, tree, key);
    }

    /**
     * Returns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.
     * If there is more than one occurrence of items passing TEST in TREE, the ones nearest the top will be nearest the beginning.
     * e.g. (tree-positions-if-bfs 'prime-number? '(1 2 (3 2 1) 4 3)) -> ((1) (4) (2 0) (2 1))
     *
     * @see tree-positions-if-dfs
     * @unknown baxter
     */
    @LispMethod(comment = "Returns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\r\nIf there is more than one occurrence of items passing TEST in TREE, the ones nearest the top will be nearest the beginning.\r\ne.g. (tree-positions-if-bfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (4) (2 0) (2 1))\r\n\r\n@see tree-positions-if-dfs\r\n@unknown baxter\nReturns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\nIf there is more than one occurrence of items passing TEST in TREE, the ones nearest the top will be nearest the beginning.\ne.g. (tree-positions-if-bfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (4) (2 0) (2 1))")
    public static final SubLObject tree_positions_if_bfs_alt(SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.stable_sort(com.cyc.cycjava.cycl.list_utilities.tree_positions_if_dfs_int(test, tree, key), symbol_function(LESSER_LENGTH_P), UNPROVIDED);
    }

    @LispMethod(comment = "Returns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\r\nIf there is more than one occurrence of items passing TEST in TREE, the ones nearest the top will be nearest the beginning.\r\ne.g. (tree-positions-if-bfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (4) (2 0) (2 1))\r\n\r\n@see tree-positions-if-dfs\r\n@unknown baxter\nReturns a list of the positions of items passing TEST in TREE as a list of lists.  Taking successive nths of any element of this list on TREE will lead you back to TEST.\nIf there is more than one occurrence of items passing TEST in TREE, the ones nearest the top will be nearest the beginning.\ne.g. (tree-positions-if-bfs \'prime-number? \'(1 2 (3 2 1) 4 3)) -> ((1) (4) (2 0) (2 1))")
    public static SubLObject tree_positions_if_bfs(final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.stable_sort(tree_positions_if_dfs_int(test, tree, key), symbol_function(LESSER_LENGTH_P), UNPROVIDED);
    }

    /**
     *
     *
     * @unknown baxter
     */
    @LispMethod(comment = "@unknown baxter")
    public static final SubLObject tree_positions_if_dfs_int_alt(SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject ans = NIL;
            SubLObject current_index = ZERO_INTEGER;
            SubLObject rest = NIL;
            for (rest = tree; !rest.isAtom(); rest = rest.rest()) {
                {
                    SubLObject subtree = rest.first();
                    if (NIL != funcall(test, funcall(key, subtree))) {
                        ans = cons(list(current_index), ans);
                    }
                    {
                        SubLObject cdolist_list_var = com.cyc.cycjava.cycl.list_utilities.tree_positions_if_dfs_int(test, subtree, key);
                        SubLObject tree_pos = NIL;
                        for (tree_pos = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , tree_pos = cdolist_list_var.first()) {
                            ans = cons(cons(current_index, tree_pos), ans);
                        }
                    }
                }
                current_index = add(current_index, ONE_INTEGER);
            }
            return ans;
        }
    }

    /**
     *
     *
     * @unknown baxter
     */
    @LispMethod(comment = "@unknown baxter")
    public static SubLObject tree_positions_if_dfs_int(final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject ans = NIL;
        SubLObject current_index = ZERO_INTEGER;
        SubLObject rest;
        SubLObject subtree;
        SubLObject cdolist_list_var;
        SubLObject tree_pos;
        for (rest = NIL, rest = tree; !rest.isAtom(); rest = rest.rest()) {
            subtree = rest.first();
            if (NIL != funcall(test, funcall(key, subtree))) {
                ans = cons(list(current_index), ans);
            }
            cdolist_list_var = tree_positions_if_dfs_int(test, subtree, key);
            tree_pos = NIL;
            tree_pos = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                ans = cons(cons(current_index, tree_pos), ans);
                cdolist_list_var = cdolist_list_var.rest();
                tree_pos = cdolist_list_var.first();
            } 
            current_index = add(current_index, ONE_INTEGER);
        }
        return ans;
    }

    /**
     * Returns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.
     * If there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the top level.
     * e.g. (tree-position-if-bfs 'prime-number? '(10 (7 10) 4 7)) -> (3)
     *
     * @see tree-position-if-dfs
     * @unknown baxter
     */
    @LispMethod(comment = "Returns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\r\nIf there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the top level.\r\ne.g. (tree-position-if-bfs \'prime-number? \'(10 (7 10) 4 7)) -> (3)\r\n\r\n@see tree-position-if-dfs\r\n@unknown baxter\nReturns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\nIf there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the top level.\ne.g. (tree-position-if-bfs \'prime-number? \'(10 (7 10) 4 7)) -> (3)")
    public static final SubLObject tree_position_if_bfs_alt(SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_positions_if_bfs(test, tree, key).first();
    }

    @LispMethod(comment = "Returns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\r\nIf there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the top level.\r\ne.g. (tree-position-if-bfs \'prime-number? \'(10 (7 10) 4 7)) -> (3)\r\n\r\n@see tree-position-if-dfs\r\n@unknown baxter\nReturns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\nIf there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the top level.\ne.g. (tree-position-if-bfs \'prime-number? \'(10 (7 10) 4 7)) -> (3)")
    public static SubLObject tree_position_if_bfs(final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_positions_if_bfs(test, tree, key).first();
    }

    /**
     * Returns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.
     * It does a depth-first search, so if there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the beginning.
     * e.g. (tree-position-if-dfs 'prime-number? '(10 (7 10) 4 7)) -> (1 0)
     *
     * @see tree-position-if-bfs
     * @unknown baxter
     */
    @LispMethod(comment = "Returns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\r\nIt does a depth-first search, so if there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the beginning.\r\ne.g. (tree-position-if-dfs \'prime-number? \'(10 (7 10) 4 7)) -> (1 0)\r\n\r\n@see tree-position-if-bfs\r\n@unknown baxter\nReturns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\nIt does a depth-first search, so if there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the beginning.\ne.g. (tree-position-if-dfs \'prime-number? \'(10 (7 10) 4 7)) -> (1 0)")
    public static final SubLObject tree_position_if_dfs_alt(SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (tree.isCons()) {
            {
                SubLObject pos = ZERO_INTEGER;
                SubLObject tree_pos = NIL;
                SubLObject rest = NIL;
                for (rest = tree; !rest.isAtom(); rest = rest.rest()) {
                    {
                        SubLObject subtree = rest.first();
                        if (NIL != funcall(test, funcall(key, subtree))) {
                            return list(pos);
                        }
                        tree_pos = com.cyc.cycjava.cycl.list_utilities.tree_position_if_dfs(test, subtree, key);
                        if (NIL != tree_pos) {
                            return cons(pos, tree_pos);
                        } else {
                            pos = add(pos, ONE_INTEGER);
                        }
                    }
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Returns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\r\nIt does a depth-first search, so if there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the beginning.\r\ne.g. (tree-position-if-dfs \'prime-number? \'(10 (7 10) 4 7)) -> (1 0)\r\n\r\n@see tree-position-if-bfs\r\n@unknown baxter\nReturns the position of an item passing TEST in TREE as a list.  Taking successive nths of this list on TREE will lead you back to TEST.\nIt does a depth-first search, so if there is more than one occurrence of an item passing TEST in TREE, it will find the one nearest the beginning.\ne.g. (tree-position-if-dfs \'prime-number? \'(10 (7 10) 4 7)) -> (1 0)")
    public static SubLObject tree_position_if_dfs(final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (tree.isCons()) {
            SubLObject pos = ZERO_INTEGER;
            SubLObject tree_pos = NIL;
            SubLObject rest;
            SubLObject subtree;
            for (rest = NIL, rest = tree; !rest.isAtom(); rest = rest.rest()) {
                subtree = rest.first();
                if (NIL != funcall(test, funcall(key, subtree))) {
                    return list(pos);
                }
                tree_pos = tree_position_if_dfs(test, subtree, key);
                if (NIL != tree_pos) {
                    return cons(pos, tree_pos);
                }
                pos = add(pos, ONE_INTEGER);
            }
        }
        return NIL;
    }

    /**
     * Negated version of COUNT-IF
     */
    @LispMethod(comment = "Negated version of COUNT-IF")
    public static final SubLObject count_if_not_alt(SubLObject test, SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = count_if(NEGATED_TEST_FUNC, sequence, key, start, end);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Negated version of COUNT-IF")
    public static SubLObject count_if_not(final SubLObject test, final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = count_if(NEGATED_TEST_FUNC, sequence, key, start, end);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of SUBST-IF
     */
    @LispMethod(comment = "Negated version of SUBST-IF")
    public static final SubLObject subst_if_not_alt(SubLObject v_new, SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = subst_if(v_new, NEGATED_TEST_FUNC, tree, key);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Negated version of SUBST-IF")
    public static SubLObject subst_if_not(final SubLObject v_new, final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = subst_if(v_new, NEGATED_TEST_FUNC, tree, key);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of NSUBST-IF
     */
    @LispMethod(comment = "Negated version of NSUBST-IF")
    public static final SubLObject nsubst_if_not_alt(SubLObject v_new, SubLObject test, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = nsubst_if(v_new, NEGATED_TEST_FUNC, tree, key);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Negated version of NSUBST-IF")
    public static SubLObject nsubst_if_not(final SubLObject v_new, final SubLObject test, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = nsubst_if(v_new, NEGATED_TEST_FUNC, tree, key);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of MEMBER-IF
     */
    @LispMethod(comment = "Negated version of MEMBER-IF")
    public static final SubLObject member_if_not_alt(SubLObject test, SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(test, thread);
                        ans = member_if(NEGATED_TEST_FUNC, list, key);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Negated version of MEMBER-IF")
    public static SubLObject member_if_not(final SubLObject test, final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(test, thread);
            ans = member_if(NEGATED_TEST_FUNC, list, key);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of ASSOC-IF
     */
    @LispMethod(comment = "Negated version of ASSOC-IF")
    public static final SubLObject assoc_if_not_alt(SubLObject predicate, SubLObject alist) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(predicate, thread);
                        ans = assoc_if(NEGATED_TEST_FUNC, alist);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Negated version of ASSOC-IF")
    public static SubLObject assoc_if_not(final SubLObject predicate, final SubLObject alist) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(predicate, thread);
            ans = assoc_if(NEGATED_TEST_FUNC, alist);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Negated version of RASSOC-IF
     */
    @LispMethod(comment = "Negated version of RASSOC-IF")
    public static final SubLObject rassoc_if_not_alt(SubLObject predicate, SubLObject alist) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
                    try {
                        $negated_test_func$.bind(predicate, thread);
                        ans = rassoc_if(NEGATED_TEST_FUNC, alist);
                    } finally {
                        $negated_test_func$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Negated version of RASSOC-IF")
    public static SubLObject rassoc_if_not(final SubLObject predicate, final SubLObject alist) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $negated_test_func$.currentBinding(thread);
        try {
            $negated_test_func$.bind(predicate, thread);
            ans = rassoc_if(NEGATED_TEST_FUNC, alist);
        } finally {
            $negated_test_func$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @return listp; all pairs in ALIST for which ITEM is the key.
     */
    @LispMethod(comment = "@return listp; all pairs in ALIST for which ITEM is the key.")
    public static final SubLObject assoc_all_alt(SubLObject item, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = alist;
            SubLObject pair = NIL;
            for (pair = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pair = cdolist_list_var.first()) {
                if (NIL != funcall(test, item, pair.first())) {
                    result = cons(pair, result);
                }
            }
            return nreverse(result);
        }
    }

    /**
     *
     *
     * @return listp; all pairs in ALIST for which ITEM is the key.
     */
    @LispMethod(comment = "@return listp; all pairs in ALIST for which ITEM is the key.")
    public static SubLObject assoc_all(final SubLObject item, final SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = alist;
        SubLObject pair = NIL;
        pair = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, item, pair.first())) {
                result = cons(pair, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            pair = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    /**
     *
     *
     * @return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes '(KEY (DATA)) onto ALIST if KEY is not already one of the keys.
    Example list: '((:foo (1 2 3)) (:bar (4 5 6)))
    Example call: (assoc-push :foo 0 '((:foo (1 2 3)) (:bar (4 5 6)))) ->
    '((:foo (0 1 2 3)) (:bar (4 5 6)))
     */
    @LispMethod(comment = "@return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes \'(KEY (DATA)) onto ALIST if KEY is not already one of the keys.\r\nExample list: \'((:foo (1 2 3)) (:bar (4 5 6)))\r\nExample call: (assoc-push :foo 0 \'((:foo (1 2 3)) (:bar (4 5 6)))) ->\r\n\'((:foo (0 1 2 3)) (:bar (4 5 6)))")
    public static final SubLObject assoc_push_alt(SubLObject key, SubLObject data, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject spot = assoc(key, alist, test, UNPROVIDED);
            if (NIL == spot) {
                alist = cons(list(key, list(data)), alist);
            } else {
                rplacd(spot, list(cons(data, spot.rest().first())));
            }
        }
        return alist;
    }

    /**
     *
     *
     * @return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes '(KEY (DATA)) onto ALIST if KEY is not already one of the keys.
    Example list: '((:foo (1 2 3)) (:bar (4 5 6)))
    Example call: (assoc-push :foo 0 '((:foo (1 2 3)) (:bar (4 5 6)))) ->
    '((:foo (0 1 2 3)) (:bar (4 5 6)))
     */
    @LispMethod(comment = "@return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes \'(KEY (DATA)) onto ALIST if KEY is not already one of the keys.\r\nExample list: \'((:foo (1 2 3)) (:bar (4 5 6)))\r\nExample call: (assoc-push :foo 0 \'((:foo (1 2 3)) (:bar (4 5 6)))) ->\r\n\'((:foo (0 1 2 3)) (:bar (4 5 6)))")
    public static SubLObject assoc_push(final SubLObject key, final SubLObject data, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject spot = assoc(key, alist, test, UNPROVIDED);
        if (NIL == spot) {
            alist = cons(list(key, list(data)), alist);
        } else {
            rplacd(spot, list(cons(data, spot.rest().first())));
        }
        return alist;
    }

    /**
     *
     *
     * @return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes '(KEY (DATA)) onto ALIST if KEY is not already one of the keys.
    Example list: '((:foo (1 2 3)) (:bar (4 5 6)))
    Example call: (assoc-push :foo 0 '((:foo (1 2 3)) (:bar (4 5 6)))) ->
    '((:foo (0 1 2 3)) (:bar (4 5 6)))
     */
    @LispMethod(comment = "@return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes \'(KEY (DATA)) onto ALIST if KEY is not already one of the keys.\r\nExample list: \'((:foo (1 2 3)) (:bar (4 5 6)))\r\nExample call: (assoc-push :foo 0 \'((:foo (1 2 3)) (:bar (4 5 6)))) ->\r\n\'((:foo (0 1 2 3)) (:bar (4 5 6)))")
    public static final SubLObject assoc_pushnew_alt(SubLObject key, SubLObject data, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject spot = assoc(key, alist, test, UNPROVIDED);
            if (NIL == spot) {
                alist = cons(list(key, list(data)), alist);
            } else {
                if (NIL == subl_promotions.memberP(data, spot.rest().first(), UNPROVIDED, UNPROVIDED)) {
                    rplacd(spot, list(cons(data, spot.rest().first())));
                }
            }
        }
        return alist;
    }

    /**
     *
     *
     * @return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes '(KEY (DATA)) onto ALIST if KEY is not already one of the keys.
    Example list: '((:foo (1 2 3)) (:bar (4 5 6)))
    Example call: (assoc-push :foo 0 '((:foo (1 2 3)) (:bar (4 5 6)))) ->
    '((:foo (0 1 2 3)) (:bar (4 5 6)))
     */
    @LispMethod(comment = "@return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes \'(KEY (DATA)) onto ALIST if KEY is not already one of the keys.\r\nExample list: \'((:foo (1 2 3)) (:bar (4 5 6)))\r\nExample call: (assoc-push :foo 0 \'((:foo (1 2 3)) (:bar (4 5 6)))) ->\r\n\'((:foo (0 1 2 3)) (:bar (4 5 6)))")
    public static SubLObject assoc_pushnew(final SubLObject key, final SubLObject data, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject spot = assoc(key, alist, test, UNPROVIDED);
        if (NIL == spot) {
            alist = cons(list(key, list(data)), alist);
        } else
            if (NIL == subl_promotions.memberP(data, spot.rest().first(), UNPROVIDED, UNPROVIDED)) {
                rplacd(spot, list(cons(data, spot.rest().first())));
            }

        return alist;
    }

    /**
     *
     *
     * @return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes '(KEY (DATA)) onto ALIST if KEY is not already one of the keys.
    Example list: '((:foo 1 2 3) (:bar 4 5 6))
    Example call: (assoc-push :foo 0 '((:foo 1 2 3) (:bar 4 5 6))) ->
    '((:foo 0 1 2 3) (:bar 4 5 6))
     */
    @LispMethod(comment = "@return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes \'(KEY (DATA)) onto ALIST if KEY is not already one of the keys.\r\nExample list: \'((:foo 1 2 3) (:bar 4 5 6))\r\nExample call: (assoc-push :foo 0 \'((:foo 1 2 3) (:bar 4 5 6))) ->\r\n\'((:foo 0 1 2 3) (:bar 4 5 6))")
    public static final SubLObject dotted_assoc_push_alt(SubLObject key, SubLObject data, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject spot = assoc(key, alist, test, UNPROVIDED);
            if (NIL == spot) {
                alist = cons(list(key, data), alist);
            } else {
                rplacd(spot, cons(data, spot.rest()));
            }
        }
        return alist;
    }

    /**
     *
     *
     * @return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes '(KEY (DATA)) onto ALIST if KEY is not already one of the keys.
    Example list: '((:foo 1 2 3) (:bar 4 5 6))
    Example call: (assoc-push :foo 0 '((:foo 1 2 3) (:bar 4 5 6))) ->
    '((:foo 0 1 2 3) (:bar 4 5 6))
     */
    @LispMethod(comment = "@return listp; destructively modifies ALIST, by pushing DATA onto the values associated with KEY. pushes \'(KEY (DATA)) onto ALIST if KEY is not already one of the keys.\r\nExample list: \'((:foo 1 2 3) (:bar 4 5 6))\r\nExample call: (assoc-push :foo 0 \'((:foo 1 2 3) (:bar 4 5 6))) ->\r\n\'((:foo 0 1 2 3) (:bar 4 5 6))")
    public static SubLObject dotted_assoc_push(final SubLObject key, final SubLObject data, SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject spot = assoc(key, alist, test, UNPROVIDED);
        if (NIL == spot) {
            alist = cons(list(key, data), alist);
        } else {
            rplacd(spot, cons(data, spot.rest()));
        }
        return alist;
    }

    /**
     *
     *
     * @return booleanp; compares alist1 and alist2 for equality with respect
    to all mappings of the function ASSOC on each list.
     * @unknown sdevoy;
    Example call: (assoc-equal '((foo a) (bar b)) '((bar b) (foo a))) -> T.
    Example call: (assoc-equal '((foo a) (bar b)) '((foo a))) -> NIL.
     */
    @LispMethod(comment = "@return booleanp; compares alist1 and alist2 for equality with respect\r\nto all mappings of the function ASSOC on each list.\r\n@unknown sdevoy;\r\nExample call: (assoc-equal \'((foo a) (bar b)) \'((bar b) (foo a))) -> T.\r\nExample call: (assoc-equal \'((foo a) (bar b)) \'((foo a))) -> NIL.")
    public static final SubLObject assoc_equal_alt(SubLObject alist1, SubLObject alist2) {
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.assoc_subsumedP(alist1, alist2, symbol_function(EQL))) && (NIL != com.cyc.cycjava.cycl.list_utilities.assoc_subsumedP(alist2, alist1, symbol_function(EQL))));
    }

    /**
     *
     *
     * @return booleanp; compares alist1 and alist2 for equality with respect
    to all mappings of the function ASSOC on each list.
     * @unknown sdevoy;
    Example call: (assoc-equal '((foo a) (bar b)) '((bar b) (foo a))) -> T.
    Example call: (assoc-equal '((foo a) (bar b)) '((foo a))) -> NIL.
     */
    @LispMethod(comment = "@return booleanp; compares alist1 and alist2 for equality with respect\r\nto all mappings of the function ASSOC on each list.\r\n@unknown sdevoy;\r\nExample call: (assoc-equal \'((foo a) (bar b)) \'((bar b) (foo a))) -> T.\r\nExample call: (assoc-equal \'((foo a) (bar b)) \'((foo a))) -> NIL.")
    public static SubLObject assoc_equal(final SubLObject alist1, final SubLObject alist2) {
        return makeBoolean((NIL != assoc_subsumedP(alist1, alist2, symbol_function(EQL))) && (NIL != assoc_subsumedP(alist2, alist1, symbol_function(EQL))));
    }

    /**
     *
     *
     * @return BOOLEAN; Is every mapping in ALIST1 also in ALIST2?
     */
    @LispMethod(comment = "@return BOOLEAN; Is every mapping in ALIST1 also in ALIST2?")
    public static final SubLObject assoc_subsumedP_alt(SubLObject alist1, SubLObject alist2, SubLObject test) {
        {
            SubLObject used_keys = NIL;
            SubLObject cdolist_list_var = alist1;
            SubLObject cons = NIL;
            for (cons = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cons = cdolist_list_var.first()) {
                {
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value1 = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt77);
                    key = current.first();
                    current = current.rest();
                    value1 = current;
                    if (NIL == subl_promotions.memberP(key, used_keys, test, UNPROVIDED)) {
                        used_keys = cons(key, used_keys);
                        {
                            SubLObject association = assoc(key, alist2, test, UNPROVIDED);
                            if ((NIL == association) || (association.isCons() && (!value1.equal(association.rest())))) {
                                return NIL;
                            }
                        }
                    }
                }
            }
        }
        return T;
    }

    /**
     *
     *
     * @return BOOLEAN; Is every mapping in ALIST1 also in ALIST2?
     */
    @LispMethod(comment = "@return BOOLEAN; Is every mapping in ALIST1 also in ALIST2?")
    public static SubLObject assoc_subsumedP(final SubLObject alist1, final SubLObject alist2, final SubLObject test) {
        SubLObject used_keys = NIL;
        SubLObject cdolist_list_var = alist1;
        SubLObject cons = NIL;
        cons = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current;
            final SubLObject datum = current = cons;
            SubLObject key = NIL;
            SubLObject value1 = NIL;
            destructuring_bind_must_consp(current, datum, $list77);
            key = current.first();
            current = value1 = current.rest();
            if (NIL == subl_promotions.memberP(key, used_keys, test, UNPROVIDED)) {
                used_keys = cons(key, used_keys);
                final SubLObject association = assoc(key, alist2, test, UNPROVIDED);
                if ((NIL == association) || (association.isCons() && (!value1.equal(association.rest())))) {
                    return NIL;
                }
            }
            cdolist_list_var = cdolist_list_var.rest();
            cons = cdolist_list_var.first();
        } 
        return T;
    }

    /**
     * Extends ALIST to contain identity mappings for each element of
     * LIST which does not already exist as a key in ALIST.  More precisely:
     *
     * @return alist-p; a possibly extended and destructible copy of ALIST
    which contains additional (ELEM . ELEM) pairs for each ELEM in LIST
    which does not already appear as a key in ALIST.
     */
    @LispMethod(comment = "Extends ALIST to contain identity mappings for each element of\r\nLIST which does not already exist as a key in ALIST.  More precisely:\r\n\r\n@return alist-p; a possibly extended and destructible copy of ALIST\r\nwhich contains additional (ELEM . ELEM) pairs for each ELEM in LIST\r\nwhich does not already appear as a key in ALIST.\nExtends ALIST to contain identity mappings for each element of\nLIST which does not already exist as a key in ALIST.  More precisely:")
    public static final SubLObject alist_extend_alt(SubLObject alist, SubLObject list) {
        {
            SubLObject full_alist = copy_alist(alist);
            SubLObject keys = com.cyc.cycjava.cycl.list_utilities.alist_keys(alist);
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (NIL == subl_promotions.memberP(elem, keys, UNPROVIDED, UNPROVIDED)) {
                    full_alist = com.cyc.cycjava.cycl.list_utilities.alist_enter(full_alist, elem, elem, UNPROVIDED);
                }
            }
            return full_alist;
        }
    }

    @LispMethod(comment = "Extends ALIST to contain identity mappings for each element of\r\nLIST which does not already exist as a key in ALIST.  More precisely:\r\n\r\n@return alist-p; a possibly extended and destructible copy of ALIST\r\nwhich contains additional (ELEM . ELEM) pairs for each ELEM in LIST\r\nwhich does not already appear as a key in ALIST.\nExtends ALIST to contain identity mappings for each element of\nLIST which does not already exist as a key in ALIST.  More precisely:")
    public static SubLObject alist_extend(final SubLObject alist, final SubLObject list) {
        SubLObject full_alist = copy_alist(alist);
        final SubLObject keys = alist_keys(alist);
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == subl_promotions.memberP(elem, keys, UNPROVIDED, UNPROVIDED)) {
                full_alist = alist_enter(full_alist, elem, elem, UNPROVIDED);
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return full_alist;
    }

    /**
     *
     *
     * @return alist-p; where the nth element consists of the nth element in
    LIST and the result of applying FUNC to that element
     */
    @LispMethod(comment = "@return alist-p; where the nth element consists of the nth element in\r\nLIST and the result of applying FUNC to that element")
    public static final SubLObject make_alist_alt(SubLObject list, SubLObject func) {
        if (func == UNPROVIDED) {
            func = symbol_function(IDENTITY);
        }
        {
            SubLObject alist = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject item = NIL;
            for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                alist = cons(list(item, func == symbol_function(IDENTITY) ? ((SubLObject) (item)) : funcall(func, item)), alist);
            }
            return nreverse(alist);
        }
    }

    /**
     *
     *
     * @return alist-p; where the nth element consists of the nth element in
    LIST and the result of applying FUNC to that element
     */
    @LispMethod(comment = "@return alist-p; where the nth element consists of the nth element in\r\nLIST and the result of applying FUNC to that element")
    public static SubLObject make_alist(final SubLObject list, SubLObject func) {
        if (func == UNPROVIDED) {
            func = symbol_function(IDENTITY);
        }
        SubLObject alist = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject item = NIL;
        item = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            alist = cons(list(item, func.eql(symbol_function(IDENTITY)) ? item : funcall(func, item)), alist);
            cdolist_list_var = cdolist_list_var.rest();
            item = cdolist_list_var.first();
        } 
        return nreverse(alist);
    }

    public static final SubLObject make_alist_from_keys_and_values_alt(SubLObject keys, SubLObject values) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.same_length_p(keys, values)) {
            Errors.error($str_alt78$The_lists_of_keys_and_data_are_of);
        }
        {
            SubLObject alist = NIL;
            SubLObject key = NIL;
            SubLObject key_9 = NIL;
            SubLObject value = NIL;
            SubLObject value_10 = NIL;
            for (key = keys, key_9 = key.first(), value = values, value_10 = value.first(); !((NIL == value) && (NIL == key)); key = key.rest() , key_9 = key.first() , value = value.rest() , value_10 = value.first()) {
                alist = cons(cons(key_9, value_10), alist);
            }
            return nreverse(alist);
        }
    }

    public static SubLObject make_alist_from_keys_and_values(final SubLObject keys, final SubLObject values) {
        if (NIL == same_length_p(keys, values)) {
            Errors.error($str78$The_lists_of_keys_and_data_are_of);
        }
        SubLObject alist = NIL;
        SubLObject key = NIL;
        SubLObject key_$11 = NIL;
        SubLObject value = NIL;
        SubLObject value_$12 = NIL;
        key = keys;
        key_$11 = key.first();
        value = values;
        value_$12 = value.first();
        while ((NIL != value) || (NIL != key)) {
            alist = cons(cons(key_$11, value_$12), alist);
            key = key.rest();
            key_$11 = key.first();
            value = value.rest();
            value_$12 = value.first();
        } 
        return nreverse(alist);
    }

    /**
     * Returns a list of pairs, where nth pair is made up of the nth elements in LIST-1 and LIST-2,
     * in that order. LIST-1 and LIST-2 must be of the same length.
     *
     * @unknown This is similar to @xref pairlis, but returns a list of proper-list-p's rather than of dotted-list-p's.
     */
    @LispMethod(comment = "Returns a list of pairs, where nth pair is made up of the nth elements in LIST-1 and LIST-2,\r\nin that order. LIST-1 and LIST-2 must be of the same length.\r\n\r\n@unknown This is similar to @xref pairlis, but returns a list of proper-list-p\'s rather than of dotted-list-p\'s.\nReturns a list of pairs, where nth pair is made up of the nth elements in LIST-1 and LIST-2,\nin that order. LIST-1 and LIST-2 must be of the same length.")
    public static final SubLObject make_pair_list_alt(SubLObject list_1, SubLObject list_2) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.same_length_p(list_1, list_2)) {
            Errors.error($str_alt78$The_lists_of_keys_and_data_are_of);
        }
        {
            SubLObject result = NIL;
            SubLObject item_1 = NIL;
            SubLObject item_1_11 = NIL;
            SubLObject item_2 = NIL;
            SubLObject item_2_12 = NIL;
            for (item_1 = list_1, item_1_11 = item_1.first(), item_2 = list_2, item_2_12 = item_2.first(); !((NIL == item_2) && (NIL == item_1)); item_1 = item_1.rest() , item_1_11 = item_1.first() , item_2 = item_2.rest() , item_2_12 = item_2.first()) {
                result = cons(list(item_1_11, item_2_12), result);
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Returns a list of pairs, where nth pair is made up of the nth elements in LIST-1 and LIST-2,\r\nin that order. LIST-1 and LIST-2 must be of the same length.\r\n\r\n@unknown This is similar to @xref pairlis, but returns a list of proper-list-p\'s rather than of dotted-list-p\'s.\nReturns a list of pairs, where nth pair is made up of the nth elements in LIST-1 and LIST-2,\nin that order. LIST-1 and LIST-2 must be of the same length.")
    public static SubLObject make_pair_list(final SubLObject list_1, final SubLObject list_2) {
        if (NIL == same_length_p(list_1, list_2)) {
            Errors.error($str78$The_lists_of_keys_and_data_are_of);
        }
        SubLObject result = NIL;
        SubLObject item_1 = NIL;
        SubLObject item_1_$13 = NIL;
        SubLObject item_2 = NIL;
        SubLObject item_2_$14 = NIL;
        item_1 = list_1;
        item_1_$13 = item_1.first();
        item_2 = list_2;
        item_2_$14 = item_2.first();
        while ((NIL != item_2) || (NIL != item_1)) {
            result = cons(list(item_1_$13, item_2_$14), result);
            item_1 = item_1.rest();
            item_1_$13 = item_1.first();
            item_2 = item_2.rest();
            item_2_$14 = item_2.first();
        } 
        return nreverse(result);
    }

    /**
     * The inverse of @xref MAKE-PAIR-LIST
     */
    @LispMethod(comment = "The inverse of @xref MAKE-PAIR-LIST")
    public static final SubLObject make_paired_lists_alt(SubLObject pair_list) {
        {
            SubLObject list_var = pair_list;
            SubLTrampolineFile.checkType(list_var, NON_DOTTED_LIST_P);
            {
                SubLObject cdolist_list_var = list_var;
                SubLObject elem = NIL;
                for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                    SubLTrampolineFile.checkType(elem, $sym79$DOUBLETON_);
                }
            }
        }
        {
            SubLObject result1 = NIL;
            SubLObject result2 = NIL;
            SubLObject cdolist_list_var = pair_list;
            SubLObject pair = NIL;
            for (pair = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pair = cdolist_list_var.first()) {
                result1 = cons(pair.first(), result1);
                result2 = cons(second(pair), result2);
            }
            return list(nreverse(result1), nreverse(result2));
        }
    }

    @LispMethod(comment = "The inverse of @xref MAKE-PAIR-LIST")
    public static SubLObject make_paired_lists(final SubLObject pair_list) {
        assert NIL != non_dotted_list_p(pair_list) : "! list_utilities.non_dotted_list_p(pair_list) " + ("list_utilities.non_dotted_list_p(pair_list) " + "CommonSymbols.NIL != list_utilities.non_dotted_list_p(pair_list) ") + pair_list;
        SubLObject cdolist_list_var = pair_list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            assert NIL != doubletonP(elem) : "! list_utilities.doubletonP(elem) " + ("list_utilities.doubletonP(elem) " + "CommonSymbols.NIL != list_utilities.doubletonP(elem) ") + elem;
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        SubLObject result1 = NIL;
        SubLObject result2 = NIL;
        SubLObject cdolist_list_var2 = pair_list;
        SubLObject pair = NIL;
        pair = cdolist_list_var2.first();
        while (NIL != cdolist_list_var2) {
            result1 = cons(pair.first(), result1);
            result2 = cons(second(pair), result2);
            cdolist_list_var2 = cdolist_list_var2.rest();
            pair = cdolist_list_var2.first();
        } 
        return list(nreverse(result1), nreverse(result2));
    }

    /**
     * If list1 is a list then first-safe-for-atoms returns the first
     * element of the list, else it returns nil.  Thus if being used as a key
     * function then (eql nil (funcall key some-atom)) will return t for any atom.
     */
    @LispMethod(comment = "If list1 is a list then first-safe-for-atoms returns the first\r\nelement of the list, else it returns nil.  Thus if being used as a key\r\nfunction then (eql nil (funcall key some-atom)) will return t for any atom.\nIf list1 is a list then first-safe-for-atoms returns the first\nelement of the list, else it returns nil.  Thus if being used as a key\nfunction then (eql nil (funcall key some-atom)) will return t for any atom.")
    public static final SubLObject first_safe_for_atoms_alt(SubLObject list1) {
        if (list1.isAtom()) {
            return NIL;
        } else {
            return list1.first();
        }
    }

    @LispMethod(comment = "If list1 is a list then first-safe-for-atoms returns the first\r\nelement of the list, else it returns nil.  Thus if being used as a key\r\nfunction then (eql nil (funcall key some-atom)) will return t for any atom.\nIf list1 is a list then first-safe-for-atoms returns the first\nelement of the list, else it returns nil.  Thus if being used as a key\nfunction then (eql nil (funcall key some-atom)) will return t for any atom.")
    public static SubLObject first_safe_for_atoms(final SubLObject list1) {
        if (list1.isAtom()) {
            return NIL;
        }
        return list1.first();
    }

    /**
     * may eval THING-ONE twice, but will not eval THING-TWO
     * unless THING-ONE is null.
     */
    @LispMethod(comment = "may eval THING-ONE twice, but will not eval THING-TWO\r\nunless THING-ONE is null.\nmay eval THING-ONE twice, but will not eval THING-TWO\nunless THING-ONE is null.")
    public static final SubLObject first_of_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject thing_one = NIL;
            SubLObject thing_two = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt80);
            thing_one = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt80);
            thing_two = current.first();
            current = current.rest();
            if (NIL == current) {
                if (NIL == com.cyc.cycjava.cycl.list_utilities.non_side_effecting_form_p(thing_one)) {
                    Errors.warn($str_alt81$FIRST_OF_will_multiply_evaluate__, thing_one);
                }
                return list(FIF, thing_one, thing_one, thing_two);
            } else {
                cdestructuring_bind_error(datum, $list_alt80);
            }
        }
        return NIL;
    }

    @LispMethod(comment = "may eval THING-ONE twice, but will not eval THING-TWO\r\nunless THING-ONE is null.\nmay eval THING-ONE twice, but will not eval THING-TWO\nunless THING-ONE is null.")
    public static SubLObject first_of(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject thing_one = NIL;
        SubLObject thing_two = NIL;
        destructuring_bind_must_consp(current, datum, $list80);
        thing_one = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list80);
        thing_two = current.first();
        current = current.rest();
        if (NIL == current) {
            if (NIL == non_side_effecting_form_p(thing_one)) {
                Errors.warn($str81$FIRST_OF_will_multiply_evaluate__, thing_one);
            }
            return list(FIF, thing_one, thing_one, thing_two);
        }
        cdestructuring_bind_error(datum, $list80);
        return NIL;
    }

    /**
     * Cons a new pair only if the CAR or CDR of CONS are not EQ to CAR and CDR.
     *
     * @see ncons for a destructive version of this.
     */
    @LispMethod(comment = "Cons a new pair only if the CAR or CDR of CONS are not EQ to CAR and CDR.\r\n\r\n@see ncons for a destructive version of this.")
    public static final SubLObject recons_alt(SubLObject car, SubLObject cdr, SubLObject cons) {
        if ((cons.first() == car) && (cons.rest() == cdr)) {
            return cons;
        } else {
            return cons(car, cdr);
        }
    }

    @LispMethod(comment = "Cons a new pair only if the CAR or CDR of CONS are not EQ to CAR and CDR.\r\n\r\n@see ncons for a destructive version of this.")
    public static SubLObject recons(final SubLObject car, final SubLObject cdr, final SubLObject cons) {
        if (cons.first().eql(car) && cons.rest().eql(cdr)) {
            return cons;
        }
        return cons(car, cdr);
    }

    /**
     * Return CONS after replacing its CAR and CDR.
     *
     * @see recons for a non-destructive version of this.
     */
    @LispMethod(comment = "Return CONS after replacing its CAR and CDR.\r\n\r\n@see recons for a non-destructive version of this.")
    public static final SubLObject ncons_alt(SubLObject car, SubLObject cdr, SubLObject cons) {
        if (!car.eql(cons.first())) {
            rplaca(cons, car);
        }
        if (!cdr.eql(cons.rest())) {
            rplacd(cons, cdr);
        }
        return cons;
    }

    @LispMethod(comment = "Return CONS after replacing its CAR and CDR.\r\n\r\n@see recons for a non-destructive version of this.")
    public static SubLObject ncons(final SubLObject car, final SubLObject cdr, final SubLObject cons) {
        if (!car.eql(cons.first())) {
            rplaca(cons, car);
        }
        if (!cdr.eql(cons.rest())) {
            rplacd(cons, cdr);
        }
        return cons;
    }

    public static final SubLObject delete_first_alt(SubLObject obj, SubLObject sequence, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return delete(obj, sequence, test, symbol_function(IDENTITY), ZERO_INTEGER, NIL, ONE_INTEGER);
    }

    public static SubLObject delete_first(final SubLObject obj, final SubLObject sequence, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return delete(obj, sequence, test, symbol_function(IDENTITY), ZERO_INTEGER, NIL, ONE_INTEGER);
    }

    public static final SubLObject remove_first_alt(SubLObject obj, SubLObject sequence, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return remove(obj, sequence, test, symbol_function(IDENTITY), ZERO_INTEGER, NIL, ONE_INTEGER);
    }

    public static SubLObject remove_first(final SubLObject obj, final SubLObject sequence, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return remove(obj, sequence, test, symbol_function(IDENTITY), ZERO_INTEGER, NIL, ONE_INTEGER);
    }

    public static SubLObject remove_duplicates_equal(final SubLObject sequence, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return remove_duplicates(sequence, symbol_function(EQUAL), key, start, end);
    }

    /**
     * A destructive version of @xref mapcar.
     * WARNING: This will produce really funky behaviour if elements of LIST share list structure.
     */
    @LispMethod(comment = "A destructive version of @xref mapcar.\r\nWARNING: This will produce really funky behaviour if elements of LIST share list structure.\nA destructive version of @xref mapcar.\nWARNING: This will produce really funky behaviour if elements of LIST share list structure.")
    public static final SubLObject nmapcar_alt(SubLObject function, SubLObject list) {
        {
            SubLObject partial_list = NIL;
            for (partial_list = list; NIL != partial_list; partial_list = partial_list.rest()) {
                rplaca(partial_list, funcall(function, partial_list.first()));
            }
        }
        return list;
    }

    @LispMethod(comment = "A destructive version of @xref mapcar.\r\nWARNING: This will produce really funky behaviour if elements of LIST share list structure.\nA destructive version of @xref mapcar.\nWARNING: This will produce really funky behaviour if elements of LIST share list structure.")
    public static SubLObject nmapcar(final SubLObject function, final SubLObject list) {
        SubLObject partial_list;
        for (partial_list = NIL, partial_list = list; NIL != partial_list; partial_list = partial_list.rest()) {
            rplaca(partial_list, funcall(function, partial_list.first()));
        }
        return list;
    }

    public static SubLObject mapcar_multiple(final SubLObject functions, final SubLObject list) {
        if (NIL == functions) {
            return list;
        }
        return Mapping.mapcar(functions.first(), mapcar_multiple(functions.rest(), list));
    }

    public static final SubLObject mapappend_alt(SubLObject function, SubLObject list) {
        {
            SubLObject ans = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject old = NIL;
            for (old = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , old = cdolist_list_var.first()) {
                {
                    SubLObject cdolist_list_var_13 = funcall(function, old);
                    SubLObject v_new = NIL;
                    for (v_new = cdolist_list_var_13.first(); NIL != cdolist_list_var_13; cdolist_list_var_13 = cdolist_list_var_13.rest() , v_new = cdolist_list_var_13.first()) {
                        ans = cons(v_new, ans);
                    }
                }
            }
            return nreverse(ans);
        }
    }

    public static SubLObject mapappend(final SubLObject function, final SubLObject list) {
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject old = NIL;
        old = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$15 = funcall(function, old);
            SubLObject v_new = NIL;
            v_new = cdolist_list_var_$15.first();
            while (NIL != cdolist_list_var_$15) {
                ans = cons(v_new, ans);
                cdolist_list_var_$15 = cdolist_list_var_$15.rest();
                v_new = cdolist_list_var_$15.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            old = cdolist_list_var.first();
        } 
        return nreverse(ans);
    }

    /**
     *
     *
     * @param FUNCTION
     * 		a unary function that returns a list.
     * @param LIST
     * 		a list, each of whose elements is a valid argument to FUNCTION.
     * 		FUNCTION is applied to each element of LIST to get a new element X (which is also a list).
     * 		Then we return the unique elements of X, concatenating over all elements of LIST.
     * 		e.g. (define mapabs (list) (ret (mapcar 'abs list)))
     * 		(mapunion 'mapabs '((1 2 3) (0 -1 -2))) -> (1 2 3 0)
     */
    @LispMethod(comment = "@param FUNCTION\r\n\t\ta unary function that returns a list.\r\n@param LIST\r\n\t\ta list, each of whose elements is a valid argument to FUNCTION.\r\n\t\tFUNCTION is applied to each element of LIST to get a new element X (which is also a list).\r\n\t\tThen we return the unique elements of X, concatenating over all elements of LIST.\r\n\t\te.g. (define mapabs (list) (ret (mapcar \'abs list)))\r\n\t\t(mapunion \'mapabs \'((1 2 3) (0 -1 -2))) -> (1 2 3 0)")
    public static final SubLObject mapunion_alt(SubLObject function, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject ans = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject old = NIL;
            for (old = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , old = cdolist_list_var.first()) {
                {
                    SubLObject cdolist_list_var_14 = funcall(function, old);
                    SubLObject v_new = NIL;
                    for (v_new = cdolist_list_var_14.first(); NIL != cdolist_list_var_14; cdolist_list_var_14 = cdolist_list_var_14.rest() , v_new = cdolist_list_var_14.first()) {
                        {
                            SubLObject item_var = v_new;
                            if (NIL == member(item_var, ans, test, symbol_function(IDENTITY))) {
                                ans = cons(item_var, ans);
                            }
                        }
                    }
                }
            }
            return nreverse(ans);
        }
    }

    /**
     *
     *
     * @param FUNCTION
     * 		a unary function that returns a list.
     * @param LIST
     * 		a list, each of whose elements is a valid argument to FUNCTION.
     * 		FUNCTION is applied to each element of LIST to get a new element X (which is also a list).
     * 		Then we return the unique elements of X, concatenating over all elements of LIST.
     * 		e.g. (define mapabs (list) (ret (mapcar 'abs list)))
     * 		(mapunion 'mapabs '((1 2 3) (0 -1 -2))) -> (1 2 3 0)
     */
    @LispMethod(comment = "@param FUNCTION\r\n\t\ta unary function that returns a list.\r\n@param LIST\r\n\t\ta list, each of whose elements is a valid argument to FUNCTION.\r\n\t\tFUNCTION is applied to each element of LIST to get a new element X (which is also a list).\r\n\t\tThen we return the unique elements of X, concatenating over all elements of LIST.\r\n\t\te.g. (define mapabs (list) (ret (mapcar \'abs list)))\r\n\t\t(mapunion \'mapabs \'((1 2 3) (0 -1 -2))) -> (1 2 3 0)")
    public static SubLObject mapunion(final SubLObject function, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject old = NIL;
        old = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$16 = funcall(function, old);
            SubLObject v_new = NIL;
            v_new = cdolist_list_var_$16.first();
            while (NIL != cdolist_list_var_$16) {
                final SubLObject item_var = v_new;
                if (NIL == member(item_var, ans, test, symbol_function(IDENTITY))) {
                    ans = cons(item_var, ans);
                }
                cdolist_list_var_$16 = cdolist_list_var_$16.rest();
                v_new = cdolist_list_var_$16.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            old = cdolist_list_var.first();
        } 
        return nreverse(ans);
    }

    public static final SubLObject mapnunion_alt(SubLObject function, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject ans = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject old = NIL;
            for (old = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , old = cdolist_list_var.first()) {
                ans = nunion(funcall(function, old), ans, test, UNPROVIDED);
            }
            return ans;
        }
    }

    public static SubLObject mapnunion(final SubLObject function, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject old = NIL;
        old = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            ans = nunion(funcall(function, old), ans, test, UNPROVIDED);
            cdolist_list_var = cdolist_list_var.rest();
            old = cdolist_list_var.first();
        } 
        return ans;
    }

    public static final SubLObject mapcar_product_alt(SubLObject function, SubLObject list1, SubLObject list2) {
        {
            SubLObject ans = NIL;
            if ((NIL != list1) && (NIL != list2)) {
                {
                    SubLObject cdolist_list_var = list1;
                    SubLObject item1 = NIL;
                    for (item1 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item1 = cdolist_list_var.first()) {
                        {
                            SubLObject cdolist_list_var_15 = list2;
                            SubLObject item2 = NIL;
                            for (item2 = cdolist_list_var_15.first(); NIL != cdolist_list_var_15; cdolist_list_var_15 = cdolist_list_var_15.rest() , item2 = cdolist_list_var_15.first()) {
                                ans = cons(funcall(function, item1, item2), ans);
                            }
                        }
                    }
                }
            }
            return nreverse(ans);
        }
    }

    public static SubLObject mapcar_product(final SubLObject function, final SubLObject list1, final SubLObject list2) {
        SubLObject ans = NIL;
        if ((NIL != list1) && (NIL != list2)) {
            SubLObject cdolist_list_var = list1;
            SubLObject item1 = NIL;
            item1 = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cdolist_list_var_$17 = list2;
                SubLObject item2 = NIL;
                item2 = cdolist_list_var_$17.first();
                while (NIL != cdolist_list_var_$17) {
                    ans = cons(funcall(function, item1, item2), ans);
                    cdolist_list_var_$17 = cdolist_list_var_$17.rest();
                    item2 = cdolist_list_var_$17.first();
                } 
                cdolist_list_var = cdolist_list_var.rest();
                item1 = cdolist_list_var.first();
            } 
        }
        return nreverse(ans);
    }

    /**
     * Similar to (delete-duplicates (mapcar FUNCTION LIST) TEST) except :
     * (a) It is O(N) in length of LIST.
     * (b) It preserves the original order of LIST.
     */
    @LispMethod(comment = "Similar to (delete-duplicates (mapcar FUNCTION LIST) TEST) except :\r\n(a) It is O(N) in length of LIST.\r\n(b) It preserves the original order of LIST.\nSimilar to (delete-duplicates (mapcar FUNCTION LIST) TEST) except :\n(a) It is O(N) in length of LIST.\n(b) It preserves the original order of LIST.")
    public static final SubLObject mapcar_unique_alt(SubLObject function, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(function, FUNCTION_SPEC_P);
        SubLTrampolineFile.checkType(list, LISTP);
        if (NIL == list) {
            return NIL;
        } else {
            if (NIL != com.cyc.cycjava.cycl.list_utilities.singletonP(list)) {
                return make_list(ONE_INTEGER, funcall(function, list.first()));
            } else {
                {
                    SubLObject seen_set = set.new_set(test, UNPROVIDED);
                    SubLObject answers = NIL;
                    SubLObject cdolist_list_var = list;
                    SubLObject element = NIL;
                    for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                        {
                            SubLObject v_answer = funcall(function, element);
                            if (NIL == set.set_memberP(v_answer, seen_set)) {
                                set.set_add(v_answer, seen_set);
                                answers = cons(v_answer, answers);
                            }
                        }
                    }
                    set.clear_set(seen_set);
                    return nreverse(answers);
                }
            }
        }
    }

    @LispMethod(comment = "Similar to (delete-duplicates (mapcar FUNCTION LIST) TEST) except :\r\n(a) It is O(N) in length of LIST.\r\n(b) It preserves the original order of LIST.\nSimilar to (delete-duplicates (mapcar FUNCTION LIST) TEST) except :\n(a) It is O(N) in length of LIST.\n(b) It preserves the original order of LIST.")
    public static SubLObject mapcar_unique(final SubLObject function, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != function_spec_p(function) : "! function_spec_p(function) " + ("Types.function_spec_p(function) " + "CommonSymbols.NIL != Types.function_spec_p(function) ") + function;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (NIL == list) {
            return NIL;
        }
        if (NIL != singletonP(list)) {
            return make_list(ONE_INTEGER, funcall(function, list.first()));
        }
        final SubLObject seen_set = set.new_set(test, UNPROVIDED);
        SubLObject answers = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject v_answer = funcall(function, element);
            if (NIL == set.set_memberP(v_answer, seen_set)) {
                set.set_add(v_answer, seen_set);
                answers = cons(v_answer, answers);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        set.clear_set(seen_set);
        return nreverse(answers);
    }

    /**
     * Returns a list consisting of the last item in LIST.
     */
    @LispMethod(comment = "Returns a list consisting of the last item in LIST.")
    public static final SubLObject last1_alt(SubLObject list) {
        {
            SubLObject rest = NIL;
            SubLObject next = NIL;
            for (rest = list, next = rest.rest(); !next.isAtom(); rest = next , next = rest.rest()) {
            }
            return rest;
        }
    }

    @LispMethod(comment = "Returns a list consisting of the last item in LIST.")
    public static SubLObject last1(final SubLObject list) {
        SubLObject rest;
        SubLObject next;
        for (rest = NIL, next = NIL, rest = list, next = rest.rest(); !next.isAtom(); next = rest.rest()) {
            rest = next;
        }
        return rest;
    }

    /**
     * Returns the LIST with ITEM as the new last element.
     */
    @LispMethod(comment = "Returns the LIST with ITEM as the new last element.")
    public static final SubLObject add_to_end_alt(SubLObject item, SubLObject list) {
        return append(list, list(item));
    }

    @LispMethod(comment = "Returns the LIST with ITEM as the new last element.")
    public static SubLObject add_to_end(final SubLObject item, final SubLObject list) {
        return append(list, list(item));
    }

    /**
     * Returns the LIST with ITEM as the new last element.
     * LIST may be destructively modified.
     */
    @LispMethod(comment = "Returns the LIST with ITEM as the new last element.\r\nLIST may be destructively modified.\nReturns the LIST with ITEM as the new last element.\nLIST may be destructively modified.")
    public static final SubLObject nadd_to_end_alt(SubLObject item, SubLObject list) {
        {
            SubLObject new_last_cons = cons(item, NIL);
            if (NIL != list) {
                {
                    SubLObject old_last_cons = com.cyc.cycjava.cycl.list_utilities.last1(list);
                    rplacd(old_last_cons, new_last_cons);
                }
            } else {
                list = new_last_cons;
            }
        }
        return list;
    }

    @LispMethod(comment = "Returns the LIST with ITEM as the new last element.\r\nLIST may be destructively modified.\nReturns the LIST with ITEM as the new last element.\nLIST may be destructively modified.")
    public static SubLObject nadd_to_end(final SubLObject item, SubLObject list) {
        final SubLObject new_last_cons = cons(item, NIL);
        if (NIL != list) {
            final SubLObject old_last_cons = last1(list);
            rplacd(old_last_cons, new_last_cons);
        } else {
            list = new_last_cons;
        }
        return list;
    }

    public static final SubLObject adjoin_to_end_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != subl_promotions.memberP(item, list, test, UNPROVIDED)) {
            return list;
        } else {
            return com.cyc.cycjava.cycl.list_utilities.add_to_end(item, list);
        }
    }

    public static SubLObject adjoin_to_end(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != subl_promotions.memberP(item, list, test, UNPROVIDED)) {
            return list;
        }
        return add_to_end(item, list);
    }

    public static final SubLObject nadjoin_to_end_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != subl_promotions.memberP(item, list, test, UNPROVIDED)) {
            return list;
        } else {
            return com.cyc.cycjava.cycl.list_utilities.nadd_to_end(item, list);
        }
    }

    public static SubLObject nadjoin_to_end(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != subl_promotions.memberP(item, list, test, UNPROVIDED)) {
            return list;
        }
        return nadd_to_end(item, list);
    }

    public static final SubLObject add_to_end_if_alt(SubLObject item, SubLObject list) {
        if (NIL != item) {
            return com.cyc.cycjava.cycl.list_utilities.add_to_end(item, list);
        } else {
            return list;
        }
    }

    public static SubLObject add_to_end_if(final SubLObject item, final SubLObject list) {
        if (NIL != item) {
            return add_to_end(item, list);
        }
        return list;
    }

    public static final SubLObject nadd_to_end_if_alt(SubLObject item, SubLObject list) {
        if (NIL != item) {
            return com.cyc.cycjava.cycl.list_utilities.nadd_to_end(item, list);
        } else {
            return list;
        }
    }

    public static SubLObject nadd_to_end_if(final SubLObject item, final SubLObject list) {
        if (NIL != item) {
            return nadd_to_end(item, list);
        }
        return list;
    }

    public static final SubLObject nth_from_end_alt(SubLObject n, SubLObject list) {
        {
            SubLObject len = length(list);
            SubLObject i = number_utilities.f_1_(subtract(len, n));
            return NIL != subl_promotions.non_negative_integer_p(i) ? ((SubLObject) (nth(i, list))) : NIL;
        }
    }

    public static SubLObject nth_from_end(final SubLObject n, final SubLObject list) {
        final SubLObject len = length(list);
        final SubLObject i = number_utilities.f_1_(subtract(len, n));
        return NIL != subl_promotions.non_negative_integer_p(i) ? nth(i, list) : NIL;
    }

    public static final SubLObject remove_from_end_alt(SubLObject item, SubLObject seq, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return nreverse(delete(item, reverse(seq), test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
    }

    public static SubLObject remove_from_end(final SubLObject item, final SubLObject seq, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return nreverse(delete(item, reverse(seq), test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
    }

    public static final SubLObject remove_objects_from_list_alt(SubLObject objs_to_remove, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject cdolist_list_var = objs_to_remove;
            SubLObject obj = NIL;
            for (obj = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , obj = cdolist_list_var.first()) {
                list = remove(obj, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            }
        }
        return list;
    }

    public static SubLObject remove_objects_from_list(final SubLObject objs_to_remove, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject cdolist_list_var = objs_to_remove;
        SubLObject obj = NIL;
        obj = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            list = remove(obj, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            cdolist_list_var = cdolist_list_var.rest();
            obj = cdolist_list_var.first();
        } 
        return list;
    }

    /**
     *
     *
     * @return 0 list; all the elements of LIST which pass FUNC
     * @return 1 list; all the elements of LIST which do not pass FUNC
    Otherwise, order is preserved.
     */
    @LispMethod(comment = "@return 0 list; all the elements of LIST which pass FUNC\r\n@return 1 list; all the elements of LIST which do not pass FUNC\r\nOtherwise, order is preserved.")
    public static final SubLObject partition_list_alt(SubLObject list, SubLObject func) {
        {
            SubLObject head = NIL;
            SubLObject tail = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (NIL != funcall(func, elem)) {
                    head = cons(elem, head);
                } else {
                    tail = cons(elem, tail);
                }
            }
            return values(nreverse(head), nreverse(tail));
        }
    }

    /**
     *
     *
     * @return 0 list; all the elements of LIST which pass FUNC
     * @return 1 list; all the elements of LIST which do not pass FUNC
    Otherwise, order is preserved.
     */
    @LispMethod(comment = "@return 0 list; all the elements of LIST which pass FUNC\r\n@return 1 list; all the elements of LIST which do not pass FUNC\r\nOtherwise, order is preserved.")
    public static SubLObject partition_list(final SubLObject list, final SubLObject func) {
        SubLObject head = NIL;
        SubLObject tail = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(func, elem)) {
                head = cons(elem, head);
            } else {
                tail = cons(elem, tail);
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return subl_promotions.values2(nreverse(head), nreverse(tail));
    }

    /**
     * A destructive version of @xref partition-list.
     * Optimized for the case where most elements will not pass FUNC.
     */
    @LispMethod(comment = "A destructive version of @xref partition-list.\r\nOptimized for the case where most elements will not pass FUNC.\nA destructive version of @xref partition-list.\nOptimized for the case where most elements will not pass FUNC.")
    public static final SubLObject npartition_list_alt(SubLObject list, SubLObject func) {
        {
            SubLObject head = com.cyc.cycjava.cycl.list_utilities.remove_if_not(func, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            SubLObject tail = delete_if(func, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            return values(head, tail);
        }
    }

    @LispMethod(comment = "A destructive version of @xref partition-list.\r\nOptimized for the case where most elements will not pass FUNC.\nA destructive version of @xref partition-list.\nOptimized for the case where most elements will not pass FUNC.")
    public static SubLObject npartition_list(final SubLObject list, final SubLObject func) {
        final SubLObject head = remove_if_not(func, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        if (NIL == head) {
            return subl_promotions.values2(NIL, list);
        }
        final SubLObject tail = delete_if(func, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        return subl_promotions.values2(head, tail);
    }

    /**
     * Partition LIST into items that are equal to TEST-ITEM and items that aren't.
     *
     * @param TEST
     * 		function-spec-p: the equality test to use
     * @param KEY
     * 		function-spec-p: a function to apply to each element of the list, and test the result against TEST-ITEM
     * @return 0 listp: the elements of LIST that equal TEST-ITEM
     * @return 1 listp: the elements of LIST that don't equal TEST-ITEM
     */
    @LispMethod(comment = "Partition LIST into items that are equal to TEST-ITEM and items that aren\'t.\r\n\r\n@param TEST\r\n\t\tfunction-spec-p: the equality test to use\r\n@param KEY\r\n\t\tfunction-spec-p: a function to apply to each element of the list, and test the result against TEST-ITEM\r\n@return 0 listp: the elements of LIST that equal TEST-ITEM\r\n@return 1 listp: the elements of LIST that don\'t equal TEST-ITEM")
    public static final SubLObject partition_list_by_equality_alt(SubLObject list, SubLObject test_item, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject equal_list = NIL;
            SubLObject unequal_list = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (NIL != funcall(test, test_item, funcall(key, elem))) {
                    equal_list = cons(elem, equal_list);
                } else {
                    unequal_list = cons(elem, unequal_list);
                }
            }
            return values(nreverse(equal_list), nreverse(unequal_list));
        }
    }

    @LispMethod(comment = "Partition LIST into items that are equal to TEST-ITEM and items that aren\'t.\r\n\r\n@param TEST\r\n\t\tfunction-spec-p: the equality test to use\r\n@param KEY\r\n\t\tfunction-spec-p: a function to apply to each element of the list, and test the result against TEST-ITEM\r\n@return 0 listp: the elements of LIST that equal TEST-ITEM\r\n@return 1 listp: the elements of LIST that don\'t equal TEST-ITEM")
    public static SubLObject partition_list_by_equality(final SubLObject list, final SubLObject test_item, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject equal_list = NIL;
        SubLObject unequal_list = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, test_item, funcall(key, elem))) {
                equal_list = cons(elem, equal_list);
            } else {
                unequal_list = cons(elem, unequal_list);
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return subl_promotions.values2(nreverse(equal_list), nreverse(unequal_list));
    }

    /**
     * Partitions LIST into N lists.  If LIST is not evenly divisible by N, the earlier
     * returned lists will have more elements.  Maintains order.
     */
    @LispMethod(comment = "Partitions LIST into N lists.  If LIST is not evenly divisible by N, the earlier\r\nreturned lists will have more elements.  Maintains order.\nPartitions LIST into N lists.  If LIST is not evenly divisible by N, the earlier\nreturned lists will have more elements.  Maintains order.")
    public static final SubLObject partition_list_n_ways_alt(SubLObject list, SubLObject n) {
        SubLTrampolineFile.checkType(n, POSITIVE_INTEGER_P);
        {
            SubLObject result = make_list(n, UNPROVIDED);
            SubLObject i = ZERO_INTEGER;
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                set_nth(i, result, cons(elem, nth(i, result)));
                i = add(i, ONE_INTEGER);
                if (i.numGE(n)) {
                    i = ZERO_INTEGER;
                }
            }
            return Mapping.mapcar(NREVERSE, result);
        }
    }

    @LispMethod(comment = "Partitions LIST into N lists.  If LIST is not evenly divisible by N, the earlier\r\nreturned lists will have more elements.  Maintains order.\nPartitions LIST into N lists.  If LIST is not evenly divisible by N, the earlier\nreturned lists will have more elements.  Maintains order.")
    public static SubLObject partition_list_n_ways(final SubLObject list, final SubLObject n) {
        assert NIL != subl_promotions.positive_integer_p(n) : "! subl_promotions.positive_integer_p(n) " + ("subl_promotions.positive_integer_p(n) " + "CommonSymbols.NIL != subl_promotions.positive_integer_p(n) ") + n;
        final SubLObject result = make_list(n, UNPROVIDED);
        SubLObject i = ZERO_INTEGER;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            set_nth(i, result, cons(elem, nth(i, result)));
            i = add(i, ONE_INTEGER);
            if (i.numGE(n)) {
                i = ZERO_INTEGER;
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return Mapping.mapcar(NREVERSE, result);
    }

    /**
     * Partitions LIST into N lists, in a randomized order.  However, it is still the
     * case that the earlier returned lists will have more elements if LIST is not
     * evenly divisible by N.
     */
    @LispMethod(comment = "Partitions LIST into N lists, in a randomized order.  However, it is still the\r\ncase that the earlier returned lists will have more elements if LIST is not\r\nevenly divisible by N.\nPartitions LIST into N lists, in a randomized order.  However, it is still the\ncase that the earlier returned lists will have more elements if LIST is not\nevenly divisible by N.")
    public static final SubLObject randomly_partition_list_n_ways_alt(SubLObject list, SubLObject n) {
        return com.cyc.cycjava.cycl.list_utilities.partition_list_n_ways(com.cyc.cycjava.cycl.list_utilities.randomize_list(list), n);
    }

    @LispMethod(comment = "Partitions LIST into N lists, in a randomized order.  However, it is still the\r\ncase that the earlier returned lists will have more elements if LIST is not\r\nevenly divisible by N.\nPartitions LIST into N lists, in a randomized order.  However, it is still the\ncase that the earlier returned lists will have more elements if LIST is not\nevenly divisible by N.")
    public static SubLObject randomly_partition_list_n_ways(final SubLObject list, final SubLObject n) {
        return partition_list_n_ways(randomize_list(list), n);
    }

    /**
     * Split list into the first N items, and the rest of LIST.
     * If N is greater than the length of LIST, return LIST and NIL.
     *
     * @unknown baxter
     */
    @LispMethod(comment = "Split list into the first N items, and the rest of LIST.\r\nIf N is greater than the length of LIST, return LIST and NIL.\r\n\r\n@unknown baxter\nSplit list into the first N items, and the rest of LIST.\nIf N is greater than the length of LIST, return LIST and NIL.")
    public static final SubLObject split_list_alt(SubLObject list, SubLObject n) {
        {
            SubLObject rest = nthcdr(n, list);
            SubLObject first_n = ldiff(list, rest);
            return values(first_n, rest);
        }
    }

    @LispMethod(comment = "Split list into the first N items, and the rest of LIST.\r\nIf N is greater than the length of LIST, return LIST and NIL.\r\n\r\n@unknown baxter\nSplit list into the first N items, and the rest of LIST.\nIf N is greater than the length of LIST, return LIST and NIL.")
    public static SubLObject split_list(final SubLObject list, final SubLObject n) {
        final SubLObject rest = nthcdr(n, list);
        final SubLObject first_n = ldiff(list, rest);
        return subl_promotions.values2(first_n, rest);
    }

    public static final SubLObject random_element_alt(SubLObject list) {
        SubLTrampolineFile.checkType(list, LISTP);
        if (NIL == list) {
            return NIL;
        } else {
            return nth(random.random(length(list)), list);
        }
    }

    public static SubLObject random_element(final SubLObject list) {
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (NIL == list) {
            return NIL;
        }
        return nth(random.random(length(list)), list);
    }

    public static final SubLObject random_aref_alt(SubLObject vector) {
        SubLTrampolineFile.checkType(vector, VECTORP);
        return aref(vector, random.random(length(vector)));
    }

    public static SubLObject random_aref(final SubLObject vector) {
        assert NIL != vectorp(vector) : "! vectorp(vector) " + ("Types.vectorp(vector) " + "CommonSymbols.NIL != Types.vectorp(vector) ") + vector;
        return aref(vector, random.random(length(vector)));
    }

    /**
     *
     *
     * @return LISTP of N randomly-chosen elements from LIST.
    By convention, if N is greater than the length of LIST, returns
    a randomized version of LIST.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of N randomly-chosen elements from LIST.\r\nBy convention, if N is greater than the length of LIST, returns\r\na randomized version of LIST.\r\n@unknown baxter")
    public static final SubLObject random_n_alt(SubLObject n, SubLObject list) {
        {
            SubLObject length = length(list);
            if (n.numG(length)) {
                return com.cyc.cycjava.cycl.list_utilities.randomize_list(list);
            } else {
                if (number_utilities.f_2X(n).numG(length)) {
                    {
                        SubLObject ans = com.cyc.cycjava.cycl.list_utilities.random_remove_n(subtract(length, n), list);
                        return com.cyc.cycjava.cycl.list_utilities.randomize_list(ans);
                    }
                } else {
                    {
                        SubLObject ans = NIL;
                        SubLObject remaining_candidates = copy_list(list);
                        while (!((NIL == remaining_candidates) || (NIL != com.cyc.cycjava.cycl.list_utilities.lengthGE(ans, n, UNPROVIDED)))) {
                            {
                                SubLObject n_16 = random.random(length(remaining_candidates));
                                SubLObject item = nth(n_16, remaining_candidates);
                                ans = cons(item, ans);
                                remaining_candidates = com.cyc.cycjava.cycl.list_utilities.delete_nth(n_16, remaining_candidates);
                            }
                        } 
                        return ans;
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return LISTP of N randomly-chosen elements from LIST.
    By convention, if N is greater than the length of LIST, returns
    a randomized version of LIST.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of N randomly-chosen elements from LIST.\r\nBy convention, if N is greater than the length of LIST, returns\r\na randomized version of LIST.\r\n@unknown baxter")
    public static SubLObject random_n(final SubLObject n, final SubLObject list) {
        final SubLObject length = length(list);
        if (n.numG(length)) {
            return randomize_list(list);
        }
        if (number_utilities.f_2X(n).numG(length)) {
            final SubLObject ans = random_remove_n(subtract(length, n), list);
            return randomize_list(ans);
        }
        SubLObject ans = NIL;
        SubLObject n_$18;
        SubLObject item;
        for (SubLObject remaining_candidates = copy_list(list); (NIL != remaining_candidates) && (NIL == lengthGE(ans, n, UNPROVIDED)); ans = cons(item, ans) , remaining_candidates = delete_nth(n_$18, remaining_candidates)) {
            n_$18 = random.random(length(remaining_candidates));
            item = nth(n_$18, remaining_candidates);
        }
        return ans;
    }

    /**
     *
     *
     * @return listp; LIST with N randomly-chosen elements removed
     */
    @LispMethod(comment = "@return listp; LIST with N randomly-chosen elements removed")
    public static final SubLObject random_remove_n_alt(SubLObject n, SubLObject list) {
        {
            SubLObject remaining_candidates = copy_list(list);
            SubLObject i = NIL;
            for (i = ZERO_INTEGER; i.numL(n); i = add(i, ONE_INTEGER)) {
                remaining_candidates = com.cyc.cycjava.cycl.list_utilities.random_delete(remaining_candidates);
            }
            return remaining_candidates;
        }
    }

    /**
     *
     *
     * @return listp; LIST with N randomly-chosen elements removed
     */
    @LispMethod(comment = "@return listp; LIST with N randomly-chosen elements removed")
    public static SubLObject random_remove_n(final SubLObject n, final SubLObject list) {
        SubLObject remaining_candidates = copy_list(list);
        SubLObject i;
        for (i = NIL, i = ZERO_INTEGER; i.numL(n); i = add(i, ONE_INTEGER)) {
            remaining_candidates = random_delete(remaining_candidates);
        }
        return remaining_candidates;
    }

    /**
     *
     *
     * @return listp; LIST with a random element deleted
     */
    @LispMethod(comment = "@return listp; LIST with a random element deleted")
    public static final SubLObject random_delete_alt(SubLObject list) {
        {
            SubLObject n = random.random(length(list));
            SubLObject deleted = nth(n, list);
            return values(com.cyc.cycjava.cycl.list_utilities.delete_nth(n, list), deleted);
        }
    }

    /**
     *
     *
     * @return listp; LIST with a random element deleted
     */
    @LispMethod(comment = "@return listp; LIST with a random element deleted")
    public static SubLObject random_delete(final SubLObject list) {
        final SubLObject n = random.random(length(list));
        final SubLObject deleted = nth(n, list);
        return subl_promotions.values2(delete_nth(n, list), deleted);
    }

    /**
     *
     *
     * @return listp; a new list with the same elements as LIST, in a random order.
     * @see randomize-vector-int for the algorithm.
     */
    @LispMethod(comment = "@return listp; a new list with the same elements as LIST, in a random order.\r\n@see randomize-vector-int for the algorithm.")
    public static final SubLObject randomize_list_alt(SubLObject list) {
        return vector_utilities.vector_elements(com.cyc.cycjava.cycl.list_utilities.randomize_vector(com.cyc.cycjava.cycl.list_utilities.list2vector(list)), UNPROVIDED);
    }

    /**
     *
     *
     * @return listp; a new list with the same elements as LIST, in a random order.
     * @see randomize-vector-int for the algorithm.
     */
    @LispMethod(comment = "@return listp; a new list with the same elements as LIST, in a random order.\r\n@see randomize-vector-int for the algorithm.")
    public static SubLObject randomize_list(final SubLObject list) {
        return vector_utilities.vector_elements(randomize_vector(list2vector(list)), UNPROVIDED);
    }

    /**
     *
     *
     * @return vectorp; a new vector with the same elements as VECTOR, in a random order.
     * @see randomize-vector-int for the algorithm.
     */
    @LispMethod(comment = "@return vectorp; a new vector with the same elements as VECTOR, in a random order.\r\n@see randomize-vector-int for the algorithm.")
    public static final SubLObject randomize_vector_alt(SubLObject vector) {
        {
            SubLObject len = length(vector);
            if (len.numLE(ONE_INTEGER)) {
                return vector;
            } else {
                {
                    SubLObject random_vector = make_vector(len, UNPROVIDED);
                    return com.cyc.cycjava.cycl.list_utilities.randomize_vector_int(vector, random_vector, ZERO_INTEGER);
                }
            }
        }
    }

    /**
     *
     *
     * @return vectorp; a new vector with the same elements as VECTOR, in a random order.
     * @see randomize-vector-int for the algorithm.
     */
    @LispMethod(comment = "@return vectorp; a new vector with the same elements as VECTOR, in a random order.\r\n@see randomize-vector-int for the algorithm.")
    public static SubLObject randomize_vector(final SubLObject vector) {
        final SubLObject len = length(vector);
        if (len.numLE(ONE_INTEGER)) {
            return vector;
        }
        final SubLObject random_vector = make_vector(len, UNPROVIDED);
        return randomize_vector_int(vector, random_vector, ZERO_INTEGER);
    }

    /**
     * Algorithm: randomly choose elements from VECTOR and place them in order in
     * the output vector, RANDOM-VECTOR.  Use a DONE-VECTOR to avoid repetition.
     * Once the first half of RANDOM-VECTOR is filled, we'll start getting lots of
     * repetitions, so fill the second half by recursion.
     *
     * @param VECTOR
     * 		vectorp; the vector to randomize.
     * @param RANDOM-VECTOR
     * 		vectorp; the vector to fill with the output.
     * @param OFFSET
     * 		integerp; where the empty part of RANDOM-VECTOR starts.
     */
    @LispMethod(comment = "Algorithm: randomly choose elements from VECTOR and place them in order in\r\nthe output vector, RANDOM-VECTOR.  Use a DONE-VECTOR to avoid repetition.\r\nOnce the first half of RANDOM-VECTOR is filled, we\'ll start getting lots of\r\nrepetitions, so fill the second half by recursion.\r\n\r\n@param VECTOR\r\n\t\tvectorp; the vector to randomize.\r\n@param RANDOM-VECTOR\r\n\t\tvectorp; the vector to fill with the output.\r\n@param OFFSET\r\n\t\tintegerp; where the empty part of RANDOM-VECTOR starts.\nAlgorithm: randomly choose elements from VECTOR and place them in order in\nthe output vector, RANDOM-VECTOR.  Use a DONE-VECTOR to avoid repetition.\nOnce the first half of RANDOM-VECTOR is filled, we\'ll start getting lots of\nrepetitions, so fill the second half by recursion.")
    public static final SubLObject randomize_vector_int_alt(SubLObject vector, SubLObject random_vector, SubLObject offset) {
        {
            SubLObject length = length(vector);
            SubLObject target_length = integerDivide(length, TWO_INTEGER);
            SubLObject done_vector = make_vector(length, UNPROVIDED);
            SubLObject i = ZERO_INTEGER;
            SubLObject doneP = NIL;
            while (NIL == doneP) {
                {
                    SubLObject rand = random.random(length);
                    if (NIL == aref(done_vector, rand)) {
                        set_aref(random_vector, add(i, offset), aref(vector, rand));
                        set_aref(done_vector, rand, T);
                        i = add(i, ONE_INTEGER);
                        if (length.numL(TEN_INTEGER)) {
                            if (i.numE(length)) {
                                return random_vector;
                            }
                        } else {
                            if (i.numE(target_length)) {
                                doneP = T;
                            }
                        }
                    }
                }
            } 
            {
                SubLObject recursive_length = subtract(length, target_length);
                SubLObject recursive_vector = make_vector(recursive_length, UNPROVIDED);
                SubLObject j = ZERO_INTEGER;
                SubLObject vector_var = vector;
                SubLObject backwardP_var = NIL;
                SubLObject length_17 = length(vector_var);
                SubLObject v_iteration = NIL;
                for (v_iteration = ZERO_INTEGER; v_iteration.numL(length_17); v_iteration = add(v_iteration, ONE_INTEGER)) {
                    {
                        SubLObject i_18 = (NIL != backwardP_var) ? ((SubLObject) (subtract(length_17, v_iteration, ONE_INTEGER))) : v_iteration;
                        SubLObject elem = aref(vector_var, i_18);
                        if (NIL == aref(done_vector, i_18)) {
                            set_aref(recursive_vector, j, elem);
                            j = add(j, ONE_INTEGER);
                        }
                    }
                }
                return com.cyc.cycjava.cycl.list_utilities.randomize_vector_int(recursive_vector, random_vector, add(offset, target_length));
            }
        }
    }

    @LispMethod(comment = "Algorithm: randomly choose elements from VECTOR and place them in order in\r\nthe output vector, RANDOM-VECTOR.  Use a DONE-VECTOR to avoid repetition.\r\nOnce the first half of RANDOM-VECTOR is filled, we\'ll start getting lots of\r\nrepetitions, so fill the second half by recursion.\r\n\r\n@param VECTOR\r\n\t\tvectorp; the vector to randomize.\r\n@param RANDOM-VECTOR\r\n\t\tvectorp; the vector to fill with the output.\r\n@param OFFSET\r\n\t\tintegerp; where the empty part of RANDOM-VECTOR starts.\nAlgorithm: randomly choose elements from VECTOR and place them in order in\nthe output vector, RANDOM-VECTOR.  Use a DONE-VECTOR to avoid repetition.\nOnce the first half of RANDOM-VECTOR is filled, we\'ll start getting lots of\nrepetitions, so fill the second half by recursion.")
    public static SubLObject randomize_vector_int(final SubLObject vector, final SubLObject random_vector, final SubLObject offset) {
        final SubLObject length = length(vector);
        final SubLObject target_length = integerDivide(length, TWO_INTEGER);
        final SubLObject done_vector = make_vector(length, UNPROVIDED);
        SubLObject i = ZERO_INTEGER;
        SubLObject doneP = NIL;
        while (NIL == doneP) {
            final SubLObject rand = random.random(length);
            if (NIL == aref(done_vector, rand)) {
                set_aref(random_vector, add(i, offset), aref(vector, rand));
                set_aref(done_vector, rand, T);
                i = add(i, ONE_INTEGER);
                if (length.numL(TEN_INTEGER)) {
                    if (i.numE(length)) {
                        return random_vector;
                    }
                    continue;
                } else {
                    if (!i.numE(target_length)) {
                        continue;
                    }
                    doneP = T;
                }
            }
        } 
        final SubLObject recursive_length = subtract(length, target_length);
        final SubLObject recursive_vector = make_vector(recursive_length, UNPROVIDED);
        SubLObject j = ZERO_INTEGER;
        final SubLObject backwardP_var = NIL;
        SubLObject length_$19;
        SubLObject v_iteration;
        SubLObject i_$20;
        SubLObject elem;
        for (length_$19 = length(vector), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration.numL(length_$19); v_iteration = add(v_iteration, ONE_INTEGER)) {
            i_$20 = (NIL != backwardP_var) ? subtract(length_$19, v_iteration, ONE_INTEGER) : v_iteration;
            elem = aref(vector, i_$20);
            if (NIL == aref(done_vector, i_$20)) {
                set_aref(recursive_vector, j, elem);
                j = add(j, ONE_INTEGER);
            }
        }
        return randomize_vector_int(recursive_vector, random_vector, add(offset, target_length));
    }

    /**
     *
     *
     * @return booleanp; Sorting utility that randomly returns T or nil for a comparison.
     */
    @LispMethod(comment = "@return booleanp; Sorting utility that randomly returns T or nil for a comparison.")
    public static final SubLObject random_compare_alt(SubLObject obj1, SubLObject obj2) {
        return eq(ZERO_INTEGER, random.random(TWO_INTEGER));
    }

    /**
     *
     *
     * @return booleanp; Sorting utility that randomly returns T or nil for a comparison.
     */
    @LispMethod(comment = "@return booleanp; Sorting utility that randomly returns T or nil for a comparison.")
    public static SubLObject random_compare(final SubLObject obj1, final SubLObject obj2) {
        return eq(ZERO_INTEGER, random.random(TWO_INTEGER));
    }

    /**
     *
     *
     * @return booleanp; Sorting utility that returns whether the third element of LIST1 is less than the third element of LIST2.
     */
    @LispMethod(comment = "@return booleanp; Sorting utility that returns whether the third element of LIST1 is less than the third element of LIST2.")
    public static final SubLObject thirdL_alt(SubLObject list1, SubLObject list2) {
        {
            SubLObject num1 = third(list1);
            SubLObject num2 = third(list2);
            if (num1.isNumber() && num2.isNumber()) {
                return numL(num1, num2);
            }
        }
        return NIL;
    }

    /**
     *
     *
     * @return booleanp; Sorting utility that returns whether the third element of LIST1 is less than the third element of LIST2.
     */
    @LispMethod(comment = "@return booleanp; Sorting utility that returns whether the third element of LIST1 is less than the third element of LIST2.")
    public static SubLObject thirdL(final SubLObject list1, final SubLObject list2) {
        final SubLObject num1 = third(list1);
        final SubLObject num2 = third(list2);
        if (num1.isNumber() && num2.isNumber()) {
            return numL(num1, num2);
        }
        return NIL;
    }

    public static SubLObject gather_all(final SubLObject item, final SubLObject seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject v_answer = NIL;
        for (SubLObject sequence_var = seq, end_index = (sequence_var.isList()) ? NIL : length(sequence_var), element_num = ZERO_INTEGER, sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var); NIL == sequence_doneP; sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var)) {
            final SubLObject elt = subl_macros.do_sequence_index_valueP(element_num, sequence_var);
            if (NIL != funcall(test, item, funcall(key, elt))) {
                v_answer = cons(elt, v_answer);
            }
            sequence_var = subl_macros.do_sequence_index_update(sequence_var);
            element_num = add(element_num, ONE_INTEGER);
        }
        return nreverse(v_answer);
    }

    public static final SubLObject find_all_alt(SubLObject item, SubLObject seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject v_answer = NIL;
            SubLObject sequence_var = seq;
            SubLObject end_index = (sequence_var.isList()) ? ((SubLObject) (NIL)) : length(sequence_var);
            SubLObject element_num = ZERO_INTEGER;
            SubLObject sequence_doneP = do_sequence_index_doneP(element_num, end_index, sequence_var);
            while (NIL == sequence_doneP) {
                {
                    SubLObject elt = do_sequence_index_valueP(element_num, sequence_var);
                    if (NIL != funcall(test, funcall(key, elt), item)) {
                        v_answer = cons(elt, v_answer);
                    }
                    sequence_var = do_sequence_index_update(sequence_var);
                    element_num = add(element_num, ONE_INTEGER);
                    sequence_doneP = do_sequence_index_doneP(element_num, end_index, sequence_var);
                }
            } 
            return nreverse(v_answer);
        }
    }

    public static SubLObject find_all(final SubLObject item, final SubLObject seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject v_answer = NIL;
        for (SubLObject sequence_var = seq, end_index = (sequence_var.isList()) ? NIL : length(sequence_var), element_num = ZERO_INTEGER, sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var); NIL == sequence_doneP; sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var)) {
            final SubLObject elt = subl_macros.do_sequence_index_valueP(element_num, sequence_var);
            if (NIL != funcall(test, funcall(key, elt), item)) {
                v_answer = cons(elt, v_answer);
            }
            sequence_var = subl_macros.do_sequence_index_update(sequence_var);
            element_num = add(element_num, ONE_INTEGER);
        }
        return nreverse(v_answer);
    }

    public static final SubLObject find_all_if_alt(SubLObject test, SubLObject seq, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject v_answer = NIL;
            SubLObject sequence_var = seq;
            SubLObject end_index = (sequence_var.isList()) ? ((SubLObject) (NIL)) : length(sequence_var);
            SubLObject element_num = ZERO_INTEGER;
            SubLObject sequence_doneP = do_sequence_index_doneP(element_num, end_index, sequence_var);
            while (NIL == sequence_doneP) {
                {
                    SubLObject elt = do_sequence_index_valueP(element_num, sequence_var);
                    if (NIL != funcall(test, funcall(key, elt))) {
                        v_answer = cons(elt, v_answer);
                    }
                    sequence_var = do_sequence_index_update(sequence_var);
                    element_num = add(element_num, ONE_INTEGER);
                    sequence_doneP = do_sequence_index_doneP(element_num, end_index, sequence_var);
                }
            } 
            return nreverse(v_answer);
        }
    }

    public static SubLObject find_all_if(final SubLObject test, final SubLObject seq, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject v_answer = NIL;
        for (SubLObject sequence_var = seq, end_index = (sequence_var.isList()) ? NIL : length(sequence_var), element_num = ZERO_INTEGER, sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var); NIL == sequence_doneP; sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var)) {
            final SubLObject elt = subl_macros.do_sequence_index_valueP(element_num, sequence_var);
            if (NIL != funcall(test, funcall(key, elt))) {
                v_answer = cons(elt, v_answer);
            }
            sequence_var = subl_macros.do_sequence_index_update(sequence_var);
            element_num = add(element_num, ONE_INTEGER);
        }
        return nreverse(v_answer);
    }

    public static final SubLObject find_all_if_not_alt(SubLObject test, SubLObject seq, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject v_answer = NIL;
            SubLObject sequence_var = seq;
            SubLObject end_index = (sequence_var.isList()) ? ((SubLObject) (NIL)) : length(sequence_var);
            SubLObject element_num = ZERO_INTEGER;
            SubLObject sequence_doneP = do_sequence_index_doneP(element_num, end_index, sequence_var);
            while (NIL == sequence_doneP) {
                {
                    SubLObject elt = do_sequence_index_valueP(element_num, sequence_var);
                    if (NIL == funcall(test, funcall(key, elt))) {
                        v_answer = cons(elt, v_answer);
                    }
                    sequence_var = do_sequence_index_update(sequence_var);
                    element_num = add(element_num, ONE_INTEGER);
                    sequence_doneP = do_sequence_index_doneP(element_num, end_index, sequence_var);
                }
            } 
            return nreverse(v_answer);
        }
    }

    public static SubLObject find_all_if_not(final SubLObject test, final SubLObject seq, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject v_answer = NIL;
        for (SubLObject sequence_var = seq, end_index = (sequence_var.isList()) ? NIL : length(sequence_var), element_num = ZERO_INTEGER, sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var); NIL == sequence_doneP; sequence_doneP = subl_macros.do_sequence_index_doneP(element_num, end_index, sequence_var)) {
            final SubLObject elt = subl_macros.do_sequence_index_valueP(element_num, sequence_var);
            if (NIL == funcall(test, funcall(key, elt))) {
                v_answer = cons(elt, v_answer);
            }
            sequence_var = subl_macros.do_sequence_index_update(sequence_var);
            element_num = add(element_num, ONE_INTEGER);
        }
        return nreverse(v_answer);
    }

    public static final SubLObject all_positions_alt(SubLObject item, SubLObject seq, SubLObject test, SubLObject key, SubLObject start) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        {
            SubLObject result = NIL;
            while (NIL != start) {
                {
                    SubLObject next_position = position(item, seq, test, key, start, UNPROVIDED);
                    if (NIL != next_position) {
                        result = cons(next_position, result);
                        start = number_utilities.f_1X(next_position);
                    } else {
                        start = NIL;
                    }
                }
            } 
            return nreverse(result);
        }
    }

    public static SubLObject all_positions(final SubLObject item, final SubLObject seq, SubLObject test, SubLObject key, SubLObject start) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        SubLObject result = NIL;
        while (NIL != start) {
            final SubLObject next_position = position(item, seq, test, key, start, UNPROVIDED);
            if (NIL != next_position) {
                result = cons(next_position, result);
                start = number_utilities.f_1X(next_position);
            } else {
                start = NIL;
            }
        } 
        return nreverse(result);
    }

    public static final SubLObject only_one_alt(SubLObject list) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
                if (NIL == com.cyc.cycjava.cycl.list_utilities.singletonP(list)) {
                    Errors.error($str_alt87$_s_was_not_a_singleton, list);
                }
            }
            return list.first();
        }
    }

    public static SubLObject only_one(final SubLObject list) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL == singletonP(list))) {
            Errors.error($str87$_s_was_not_a_singleton, list);
        }
        return list.first();
    }

    public static final SubLObject last_one_alt(SubLObject list) {
        return last(list, UNPROVIDED).first();
    }

    public static SubLObject last_one(final SubLObject list) {
        return last(list, UNPROVIDED).first();
    }

    public static final SubLObject penultimate_one_alt(SubLObject list) {
        if (NIL != list.rest()) {
            return nth(subtract(length(list), TWO_INTEGER), list);
        }
        return NIL;
    }

    public static SubLObject penultimate_one(final SubLObject list) {
        if (NIL != list.rest()) {
            return nth(subtract(length(list), TWO_INTEGER), list);
        }
        return NIL;
    }

    public static final SubLObject cons_if_alt(SubLObject thing, SubLObject list) {
        if (NIL != thing) {
            return cons(thing, list);
        } else {
            return list;
        }
    }

    public static SubLObject cons_if(final SubLObject thing, final SubLObject list) {
        if (NIL != thing) {
            return cons(thing, list);
        }
        return list;
    }

    public static final SubLObject list_if_alt(SubLObject v_object) {
        if (NIL != v_object) {
            return list(v_object);
        }
        return NIL;
    }

    public static SubLObject list_if(final SubLObject v_object) {
        if (NIL != v_object) {
            return list(v_object);
        }
        return NIL;
    }

    public static final SubLObject adjoin_if_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != item) {
            return adjoin(item, list, test, UNPROVIDED);
        } else {
            return list;
        }
    }

    public static SubLObject adjoin_if(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != item) {
            return adjoin(item, list, test, UNPROVIDED);
        }
        return list;
    }

    /**
     * Non-recursive function which returns a list of the non-nil atoms in TREE.
     */
    @LispMethod(comment = "Non-recursive function which returns a list of the non-nil atoms in TREE.")
    public static final SubLObject flatten_alt(SubLObject tree) {
        {
            SubLObject stack = list(tree);
            SubLObject temp = NIL;
            SubLObject accumulator = NIL;
            while (NIL != stack) {
                temp = stack.first();
                stack = stack.rest();
                if (temp.isAtom()) {
                    if (NIL != temp) {
                        accumulator = cons(temp, accumulator);
                    }
                } else {
                    if (NIL != temp.rest()) {
                        stack = cons(temp.rest(), stack);
                    }
                    stack = cons(temp.first(), stack);
                }
            } 
            return nreverse(accumulator);
        }
    }

    @LispMethod(comment = "Non-recursive function which returns a list of the non-nil atoms in TREE.")
    public static SubLObject flatten(final SubLObject tree) {
        SubLObject stack = list(tree);
        SubLObject temp = NIL;
        SubLObject accumulator = NIL;
        while (NIL != stack) {
            temp = stack.first();
            stack = stack.rest();
            if (temp.isAtom()) {
                if (NIL == temp) {
                    continue;
                }
                accumulator = cons(temp, accumulator);
            } else {
                if (NIL != temp.rest()) {
                    stack = cons(temp.rest(), stack);
                }
                stack = cons(temp.first(), stack);
            }
        } 
        return nreverse(accumulator);
    }

    public static final SubLObject insert_between_each_alt(SubLObject list, SubLObject v_object) {
        if (NIL == list) {
            return list;
        } else {
            {
                SubLObject ans = list(list.first());
                SubLObject cdolist_list_var = list.rest();
                SubLObject item = NIL;
                for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                    ans = cons(v_object, ans);
                    ans = cons(item, ans);
                }
                return nreverse(ans);
            }
        }
    }

    public static SubLObject insert_between_each(final SubLObject list, final SubLObject v_object) {
        if (NIL == list) {
            return list;
        }
        SubLObject ans = list(list.first());
        SubLObject cdolist_list_var = list.rest();
        SubLObject item = NIL;
        item = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            ans = cons(v_object, ans);
            ans = cons(item, ans);
            cdolist_list_var = cdolist_list_var.rest();
            item = cdolist_list_var.first();
        } 
        return nreverse(ans);
    }

    /**
     * a version of NTH that does not throw errors if n is out of bounds
     */
    @LispMethod(comment = "a version of NTH that does not throw errors if n is out of bounds")
    public static final SubLObject safe_nth_alt(SubLObject n, SubLObject list) {
        {
            SubLObject result = NIL;
            SubLObject ignore_errors_tag = NIL;
            try {
                {
                    SubLObject _prev_bind_0 = currentBinding(Errors.$error_handler$);
                    try {
                        bind(Errors.$error_handler$, symbol_function(IGNORE_ERRORS_HANDLER));
                        try {
                            result = nth(n, list);
                        } catch (Throwable catch_var) {
                            Errors.handleThrowable(catch_var, NIL);
                        }
                    } finally {
                        rebind(Errors.$error_handler$, _prev_bind_0);
                    }
                }
            } catch (Throwable ccatch_env_var) {
                ignore_errors_tag = Errors.handleThrowable(ccatch_env_var, $IGNORE_ERRORS_TARGET);
            }
            return result;
        }
    }

    @LispMethod(comment = "a version of NTH that does not throw errors if n is out of bounds")
    public static SubLObject safe_nth(final SubLObject n, final SubLObject list) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        SubLObject ignore_errors_tag = NIL;
        try {
            thread.throwStack.push($IGNORE_ERRORS_TARGET);
            final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
            try {
                Errors.$error_handler$.bind(symbol_function(IGNORE_ERRORS_HANDLER), thread);
                try {
                    result = nth(n, list);
                } catch (final Throwable catch_var) {
                    Errors.handleThrowable(catch_var, NIL);
                }
            } finally {
                Errors.$error_handler$.rebind(_prev_bind_0, thread);
            }
        } catch (final Throwable ccatch_env_var) {
            ignore_errors_tag = Errors.handleThrowable(ccatch_env_var, $IGNORE_ERRORS_TARGET);
        } finally {
            thread.throwStack.pop();
        }
        return result;
    }

    /**
     * return the items of LIST whose positions appear in POSITIONS-LIST
     */
    @LispMethod(comment = "return the items of LIST whose positions appear in POSITIONS-LIST")
    public static final SubLObject nths_alt(SubLObject positions_list, SubLObject list) {
        SubLTrampolineFile.checkType(positions_list, LISTP);
        SubLTrampolineFile.checkType(list, LISTP);
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = positions_list;
            SubLObject position = NIL;
            for (position = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , position = cdolist_list_var.first()) {
                result = cons(nth(position, list), result);
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "return the items of LIST whose positions appear in POSITIONS-LIST")
    public static SubLObject nths(final SubLObject positions_list, final SubLObject list) {
        assert NIL != listp(positions_list) : "! listp(positions_list) " + ("Types.listp(positions_list) " + "CommonSymbols.NIL != Types.listp(positions_list) ") + positions_list;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        SubLObject result = NIL;
        SubLObject cdolist_list_var = positions_list;
        SubLObject position = NIL;
        position = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = cons(nth(position, list), result);
            cdolist_list_var = cdolist_list_var.rest();
            position = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    /**
     *
     *
     * @return listp; a new list consisting of every Nth element of LIST.
    More precisely, selects those elements of LIST whose position
    is 0 mod N.
     */
    @LispMethod(comment = "@return listp; a new list consisting of every Nth element of LIST.\r\nMore precisely, selects those elements of LIST whose position\r\nis 0 mod N.")
    public static final SubLObject every_nth_alt(SubLObject n, SubLObject list) {
        {
            SubLObject result = NIL;
            SubLObject i = ZERO_INTEGER;
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (i.numE(n)) {
                    i = ZERO_INTEGER;
                }
                if (i.isZero()) {
                    result = cons(elem, result);
                }
                i = add(i, ONE_INTEGER);
            }
            return nreverse(result);
        }
    }

    /**
     *
     *
     * @return listp; a new list consisting of every Nth element of LIST.
    More precisely, selects those elements of LIST whose position
    is 0 mod N.
     */
    @LispMethod(comment = "@return listp; a new list consisting of every Nth element of LIST.\r\nMore precisely, selects those elements of LIST whose position\r\nis 0 mod N.")
    public static SubLObject every_nth(final SubLObject n, final SubLObject list) {
        SubLObject result = NIL;
        SubLObject i = ZERO_INTEGER;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (i.numE(n)) {
                i = ZERO_INTEGER;
            }
            if (i.isZero()) {
                result = cons(elem, result);
            }
            i = add(i, ONE_INTEGER);
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    /**
     * return the first N elements of LIST
     */
    @LispMethod(comment = "return the first N elements of LIST")
    public static final SubLObject first_n_alt(SubLObject n, SubLObject list) {
        return ldiff(list, nthcdr(n, list));
    }

    @LispMethod(comment = "return the first N elements of LIST")
    public static SubLObject first_n(final SubLObject n, final SubLObject list) {
        return ldiff(list, nthcdr(n, list));
    }

    public static final SubLObject first_n_percent_alt(SubLObject percentage, SubLObject list) {
        {
            SubLObject length = length(list);
            SubLObject n = round(multiply(length, percentage, $float$0_01), UNPROVIDED);
            return com.cyc.cycjava.cycl.list_utilities.first_n(n, list);
        }
    }

    public static SubLObject first_n_percent(final SubLObject percentage, final SubLObject list) {
        final SubLObject length = length(list);
        final SubLObject n = round(multiply(length, percentage, $float$0_01), UNPROVIDED);
        return first_n(n, list);
    }

    /**
     *
     *
     * @return LISTP: the first N elements of LIST that pass TEST, or all elements of LIST that pass TEST if there are fewer than N.
    List order is preserved.
     */
    @LispMethod(comment = "@return LISTP: the first N elements of LIST that pass TEST, or all elements of LIST that pass TEST if there are fewer than N.\r\nList order is preserved.")
    public static final SubLObject first_n_if_alt(SubLObject n, SubLObject test, SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject result = NIL;
            SubLObject index = ZERO_INTEGER;
            SubLObject rest = NIL;
            for (rest = list; !(index.numGE(n) || (NIL == rest)); rest = rest.rest()) {
                {
                    SubLObject item = rest.first();
                    if (NIL != funcall(test, funcall(key, item))) {
                        index = add(index, ONE_INTEGER);
                        result = cons(item, result);
                    }
                }
            }
            return nreverse(result);
        }
    }

    /**
     *
     *
     * @return LISTP: the first N elements of LIST that pass TEST, or all elements of LIST that pass TEST if there are fewer than N.
    List order is preserved.
     */
    @LispMethod(comment = "@return LISTP: the first N elements of LIST that pass TEST, or all elements of LIST that pass TEST if there are fewer than N.\r\nList order is preserved.")
    public static SubLObject first_n_if(final SubLObject n, final SubLObject test, final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = NIL;
        SubLObject index;
        SubLObject rest;
        SubLObject item;
        for (index = ZERO_INTEGER, rest = NIL, rest = list; (!index.numGE(n)) && (NIL != rest); rest = rest.rest()) {
            item = rest.first();
            if (NIL != funcall(test, funcall(key, item))) {
                index = add(index, ONE_INTEGER);
                result = cons(item, result);
            }
        }
        return nreverse(result);
    }

    public static final SubLObject first_2_alt(SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.first_n(TWO_INTEGER, list);
    }

    public static SubLObject first_2(final SubLObject list) {
        return first_n(TWO_INTEGER, list);
    }

    public static final SubLObject first_10_alt(SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.first_n(TEN_INTEGER, list);
    }

    public static SubLObject first_10(final SubLObject list) {
        return first_n(TEN_INTEGER, list);
    }

    /**
     * return the last N elements of LIST
     */
    @LispMethod(comment = "return the last N elements of LIST")
    public static final SubLObject last_n_alt(SubLObject n, SubLObject list) {
        {
            SubLObject starting_point = subtract(length(list), n);
            return nthcdr(starting_point, list);
        }
    }

    @LispMethod(comment = "return the last N elements of LIST")
    public static SubLObject last_n(final SubLObject n, final SubLObject list) {
        if (NIL != lengthL(list, n, UNPROVIDED)) {
            return list;
        }
        final SubLObject starting_point = subtract(length(list), n);
        return nthcdr(starting_point, list);
    }

    /**
     *
     *
     * @return listp; the Nth chunk of size K in LIST.
     */
    @LispMethod(comment = "@return listp; the Nth chunk of size K in LIST.")
    public static final SubLObject nth_chunk_of_k_alt(SubLObject list, SubLObject n, SubLObject k) {
        return com.cyc.cycjava.cycl.list_utilities.first_n(k, nthcdr(multiply(n, k), list));
    }

    /**
     *
     *
     * @return listp; the Nth chunk of size K in LIST.
     */
    @LispMethod(comment = "@return listp; the Nth chunk of size K in LIST.")
    public static SubLObject nth_chunk_of_k(final SubLObject list, final SubLObject n, final SubLObject k) {
        return first_n(k, nthcdr(multiply(n, k), list));
    }

    /**
     * delete the Nth item of LIST
     */
    @LispMethod(comment = "delete the Nth item of LIST")
    public static final SubLObject delete_nth_alt(SubLObject n, SubLObject list) {
        SubLTrampolineFile.checkType(n, INTEGERP);
        SubLTrampolineFile.checkType(list, LISTP);
        if (n.numE(ZERO_INTEGER)) {
            return list.rest();
        } else {
            {
                SubLObject sublist = nthcdr(number_utilities.f_1_(n), list);
                if (sublist.isCons()) {
                    rplacd(sublist, cddr(sublist));
                }
                return list;
            }
        }
    }

    @LispMethod(comment = "delete the Nth item of LIST")
    public static SubLObject delete_nth(final SubLObject n, final SubLObject list) {
        assert NIL != integerp(n) : "! integerp(n) " + ("Types.integerp(n) " + "CommonSymbols.NIL != Types.integerp(n) ") + n;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (n.numE(ZERO_INTEGER)) {
            return list.rest();
        }
        final SubLObject sublist = nthcdr(number_utilities.f_1_(n), list);
        if (sublist.isCons()) {
            rplacd(sublist, cddr(sublist));
        }
        return list;
    }

    /**
     * remove the Nth item of LIST
     */
    @LispMethod(comment = "remove the Nth item of LIST")
    public static final SubLObject remove_nth_alt(SubLObject n, SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.delete_nth(n, copy_list(list));
    }

    @LispMethod(comment = "remove the Nth item of LIST")
    public static SubLObject remove_nth(final SubLObject n, final SubLObject list) {
        return delete_nth(n, copy_list(list));
    }

    /**
     *
     *
     * @return list : copy of list with out the last element
     */
    @LispMethod(comment = "@return list : copy of list with out the last element")
    public static final SubLObject remove_last_alt(SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.remove_nth(subtract(length(list), ONE_INTEGER), list);
    }

    /**
     *
     *
     * @return list : copy of list with out the last element
     */
    @LispMethod(comment = "@return list : copy of list with out the last element")
    public static SubLObject remove_last(final SubLObject list) {
        return remove_nth(subtract(length(list), ONE_INTEGER), list);
    }

    /**
     * remove the items of LIST whose positions appear in POSITIONS-LIST
     */
    @LispMethod(comment = "remove the items of LIST whose positions appear in POSITIONS-LIST")
    public static final SubLObject remove_nths_alt(SubLObject positions_list, SubLObject list) {
        SubLTrampolineFile.checkType(positions_list, LISTP);
        SubLTrampolineFile.checkType(list, LISTP);
        {
            SubLObject result = list;
            SubLObject cdolist_list_var = positions_list;
            SubLObject position = NIL;
            for (position = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , position = cdolist_list_var.first()) {
                result = com.cyc.cycjava.cycl.list_utilities.remove_nth(position, result);
            }
            return result;
        }
    }

    @LispMethod(comment = "remove the items of LIST whose positions appear in POSITIONS-LIST")
    public static SubLObject remove_nths(final SubLObject positions_list, final SubLObject list) {
        assert NIL != listp(positions_list) : "! listp(positions_list) " + ("Types.listp(positions_list) " + "CommonSymbols.NIL != Types.listp(positions_list) ") + positions_list;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        SubLObject result = list;
        SubLObject cdolist_list_var = positions_list;
        SubLObject position = NIL;
        position = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = remove_nth(position, result);
            cdolist_list_var = cdolist_list_var.rest();
            position = cdolist_list_var.first();
        } 
        return result;
    }

    /**
     * replace the last item of LIST with NEW (destructive)
     */
    @LispMethod(comment = "replace the last item of LIST with NEW (destructive)")
    public static final SubLObject nreplace_last_alt(SubLObject list, SubLObject v_new) {
        return com.cyc.cycjava.cycl.list_utilities.nreplace_nth(number_utilities.f_1_(length(list)), v_new, list);
    }

    @LispMethod(comment = "replace the last item of LIST with NEW (destructive)")
    public static SubLObject nreplace_last(final SubLObject list, final SubLObject v_new) {
        return nreplace_nth(number_utilities.f_1_(length(list)), v_new, list);
    }

    /**
     * replace the Nth item of LIST with NEW (destructive)
     * This is a safer version of @xref set-nth
     */
    @LispMethod(comment = "replace the Nth item of LIST with NEW (destructive)\r\nThis is a safer version of @xref set-nth\nreplace the Nth item of LIST with NEW (destructive)\nThis is a safer version of @xref set-nth")
    public static final SubLObject nreplace_nth_alt(SubLObject n, SubLObject v_new, SubLObject list) {
        SubLTrampolineFile.checkType(n, INTEGERP);
        SubLTrampolineFile.checkType(list, LISTP);
        if (n.numL(ZERO_INTEGER)) {
            return list;
        } else {
            if (n.numG(subtract(length(list), ONE_INTEGER))) {
                return list;
            } else {
                {
                    SubLObject sublist = nthcdr(n, list);
                    if (sublist.isCons()) {
                        rplaca(sublist, v_new);
                    }
                    return list;
                }
            }
        }
    }

    @LispMethod(comment = "replace the Nth item of LIST with NEW (destructive)\r\nThis is a safer version of @xref set-nth\nreplace the Nth item of LIST with NEW (destructive)\nThis is a safer version of @xref set-nth")
    public static SubLObject nreplace_nth(final SubLObject n, final SubLObject v_new, final SubLObject list) {
        assert NIL != integerp(n) : "! integerp(n) " + ("Types.integerp(n) " + "CommonSymbols.NIL != Types.integerp(n) ") + n;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (n.numL(ZERO_INTEGER)) {
            return list;
        }
        if (n.numG(subtract(length(list), ONE_INTEGER))) {
            return list;
        }
        final SubLObject sublist = nthcdr(n, list);
        if (sublist.isCons()) {
            rplaca(sublist, v_new);
        }
        return list;
    }

    /**
     * Finds all top-level occurrences of OLD in LIST and NON-destructively replaces them with NEW.
     */
    @LispMethod(comment = "Finds all top-level occurrences of OLD in LIST and NON-destructively replaces them with NEW.")
    public static final SubLObject find_and_replace_alt(SubLObject old, SubLObject v_new, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        return NIL != find(old, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED) ? ((SubLObject) (com.cyc.cycjava.cycl.list_utilities.find_and_nreplace(old, v_new, copy_list(list), test))) : list;
    }

    @LispMethod(comment = "Finds all top-level occurrences of OLD in LIST and NON-destructively replaces them with NEW.")
    public static SubLObject find_and_replace(final SubLObject old, final SubLObject v_new, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        return NIL != find(old, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED) ? find_and_nreplace(old, v_new, copy_list(list), test) : list;
    }

    /**
     * Finds all top-level occurrences of OLD in LIST and destructively replaces them with NEW.
     */
    @LispMethod(comment = "Finds all top-level occurrences of OLD in LIST and destructively replaces them with NEW.")
    public static final SubLObject find_and_nreplace_alt(SubLObject old, SubLObject v_new, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        {
            SubLObject cons = NIL;
            for (cons = list; !cons.isAtom(); cons = cons.rest()) {
                if (NIL != funcall(test, cons.first(), old)) {
                    rplaca(cons, v_new);
                }
            }
        }
        return list;
    }

    @LispMethod(comment = "Finds all top-level occurrences of OLD in LIST and destructively replaces them with NEW.")
    public static SubLObject find_and_nreplace(final SubLObject old, final SubLObject v_new, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        SubLObject cons;
        for (cons = NIL, cons = list; !cons.isAtom(); cons = cons.rest()) {
            if (NIL != funcall(test, cons.first(), old)) {
                rplaca(cons, v_new);
            }
        }
        return list;
    }

    /**
     * Finds the first top-level occurrence of OLD in LIST and destructively replaces it with NEW.
     */
    @LispMethod(comment = "Finds the first top-level occurrence of OLD in LIST and destructively replaces it with NEW.")
    public static final SubLObject find_first_and_nreplace_alt(SubLObject old, SubLObject v_new, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        {
            SubLObject cons = NIL;
            for (cons = list; !cons.isAtom(); cons = cons.rest()) {
                if (NIL != funcall(test, cons.first(), old)) {
                    rplacd(cons, v_new);
                    return list;
                }
            }
        }
        return list;
    }

    @LispMethod(comment = "Finds the first top-level occurrence of OLD in LIST and destructively replaces it with NEW.")
    public static SubLObject find_first_and_nreplace(final SubLObject old, final SubLObject v_new, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        SubLObject cons;
        for (cons = NIL, cons = list; !cons.isAtom(); cons = cons.rest()) {
            if (NIL != funcall(test, cons.first(), old)) {
                rplaca(cons, v_new);
                return list;
            }
        }
        return list;
    }

    /**
     * Replace N items of LIST, beginning with the POSth item, with a single copy of NEW.
     * Destructive.  Boundary conditions are handled gracefully; see examples.
     *
     * @unknown - (ncollapse-n-from-pos 3 2 'THREE '(0 1 2 3 4 5)) -> (0 1 THREE 5)
     * @unknown - (ncollapse-n-from-pos 3 -1 'THREE '(0 1 2 3 4 5)) -> (THREE 2 3 4 5)
     * @unknown - (ncollapse-n-from-pos 3 5 'THREE '(0 1 2 3 4 5)) -> (0 1 2 3 4 THREE)
     */
    @LispMethod(comment = "Replace N items of LIST, beginning with the POSth item, with a single copy of NEW.\r\nDestructive.  Boundary conditions are handled gracefully; see examples.\r\n\r\n@unknown - (ncollapse-n-from-pos 3 2 \'THREE \'(0 1 2 3 4 5)) -> (0 1 THREE 5)\r\n@unknown - (ncollapse-n-from-pos 3 -1 \'THREE \'(0 1 2 3 4 5)) -> (THREE 2 3 4 5)\r\n@unknown - (ncollapse-n-from-pos 3 5 \'THREE \'(0 1 2 3 4 5)) -> (0 1 2 3 4 THREE)\nReplace N items of LIST, beginning with the POSth item, with a single copy of NEW.\nDestructive.  Boundary conditions are handled gracefully; see examples.")
    public static final SubLObject ncollapse_n_from_pos_alt(SubLObject n, SubLObject pos, SubLObject v_new, SubLObject list) {
        SubLTrampolineFile.checkType(pos, INTEGERP);
        SubLTrampolineFile.checkType(n, INTEGERP);
        SubLTrampolineFile.checkType(list, LISTP);
        if (add(pos, n).numL(ZERO_INTEGER)) {
            return list;
        } else {
            if (pos.numG(subtract(length(list), ONE_INTEGER))) {
                return list;
            } else {
                {
                    SubLObject sublist = nthcdr(max(pos, ZERO_INTEGER), list);
                    if (sublist.isCons()) {
                        rplaca(sublist, v_new);
                    }
                    {
                        SubLObject cdotimes_end_var = subtract(n, add(ONE_INTEGER, max(minus(pos), ZERO_INTEGER)));
                        SubLObject count = NIL;
                        for (count = ZERO_INTEGER; count.numL(cdotimes_end_var); count = add(count, ONE_INTEGER)) {
                            com.cyc.cycjava.cycl.list_utilities.delete_nth(add(pos, ONE_INTEGER, max(minus(pos), ZERO_INTEGER)), list);
                        }
                    }
                    return list;
                }
            }
        }
    }

    /**
     * Replace N items of LIST, beginning with the POSth item, with a single copy of NEW.
     * Destructive.  Boundary conditions are handled gracefully; see examples.
     *
     * @unknown - (ncollapse-n-from-pos 3 2 'THREE '(0 1 2 3 4 5)) -> (0 1 THREE 5)
     * @unknown - (ncollapse-n-from-pos 3 -1 'THREE '(0 1 2 3 4 5)) -> (THREE 2 3 4 5)
     * @unknown - (ncollapse-n-from-pos 3 5 'THREE '(0 1 2 3 4 5)) -> (0 1 2 3 4 THREE)
     */
    @LispMethod(comment = "Replace N items of LIST, beginning with the POSth item, with a single copy of NEW.\r\nDestructive.  Boundary conditions are handled gracefully; see examples.\r\n\r\n@unknown - (ncollapse-n-from-pos 3 2 \'THREE \'(0 1 2 3 4 5)) -> (0 1 THREE 5)\r\n@unknown - (ncollapse-n-from-pos 3 -1 \'THREE \'(0 1 2 3 4 5)) -> (THREE 2 3 4 5)\r\n@unknown - (ncollapse-n-from-pos 3 5 \'THREE \'(0 1 2 3 4 5)) -> (0 1 2 3 4 THREE)\nReplace N items of LIST, beginning with the POSth item, with a single copy of NEW.\nDestructive.  Boundary conditions are handled gracefully; see examples.")
    public static SubLObject ncollapse_n_from_pos(final SubLObject n, final SubLObject pos, final SubLObject v_new, final SubLObject list) {
        assert NIL != integerp(pos) : "! integerp(pos) " + ("Types.integerp(pos) " + "CommonSymbols.NIL != Types.integerp(pos) ") + pos;
        assert NIL != integerp(n) : "! integerp(n) " + ("Types.integerp(n) " + "CommonSymbols.NIL != Types.integerp(n) ") + n;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (add(pos, n).numL(ZERO_INTEGER)) {
            return list;
        }
        if (pos.numG(subtract(length(list), ONE_INTEGER))) {
            return list;
        }
        final SubLObject sublist = nthcdr(max(pos, ZERO_INTEGER), list);
        if (sublist.isCons()) {
            rplaca(sublist, v_new);
        }
        SubLObject cdotimes_end_var;
        SubLObject count;
        for (cdotimes_end_var = subtract(n, add(ONE_INTEGER, max(minus(pos), ZERO_INTEGER))), count = NIL, count = ZERO_INTEGER; count.numL(cdotimes_end_var); count = add(count, ONE_INTEGER)) {
            delete_nth(add(pos, ONE_INTEGER, max(minus(pos), ZERO_INTEGER)), list);
        }
        return list;
    }

    /**
     * Position must be between 0 and (length list) inclusive.
     * If position = 0, then the item is added to the front of the list.
     * When 0 < position < length, item is inserted
     * before the element currently at that position.  When position = length, item
     * is inserted at the end of the list.  This is a destructive operation.
     */
    @LispMethod(comment = "Position must be between 0 and (length list) inclusive.\r\nIf position = 0, then the item is added to the front of the list.\r\nWhen 0 < position < length, item is inserted\r\nbefore the element currently at that position.  When position = length, item\r\nis inserted at the end of the list.  This is a destructive operation.\nPosition must be between 0 and (length list) inclusive.\nIf position = 0, then the item is added to the front of the list.\nWhen 0 < position < length, item is inserted\nbefore the element currently at that position.  When position = length, item\nis inserted at the end of the list.  This is a destructive operation.")
    public static final SubLObject ninsert_by_position_alt(SubLObject item, SubLObject list, SubLObject position) {
        SubLTrampolineFile.checkType(position, INTEGERP);
        SubLTrampolineFile.checkType(list, LISTP);
        {
            SubLObject list_length = length(list);
            SubLObject sublist = NIL;
            SubLObject insertion_point_on = NIL;
            if (position.numG(list_length) || position.numL(ZERO_INTEGER)) {
                Errors.error($str_alt92$Position_is_not_valid_for_the_siz);
            } else {
                if (position.numLE(ZERO_INTEGER) || list_length.eql(ZERO_INTEGER)) {
                    return cons(item, list);
                } else {
                    if (position.numGE(list_length)) {
                        return nconc(list, list(item));
                    } else {
                        sublist = nthcdr(subtract(position, ONE_INTEGER), list);
                        insertion_point_on = list(item);
                        rplacd(insertion_point_on, sublist.rest());
                        rplacd(sublist, insertion_point_on);
                        return list;
                    }
                }
            }
        }
        return NIL;
    }

    /**
     * Position must be between 0 and (length list) inclusive.
     * If position = 0, then the item is added to the front of the list.
     * When 0 < position < length, item is inserted
     * before the element currently at that position.  When position = length, item
     * is inserted at the end of the list.  This is a destructive operation.
     */
    @LispMethod(comment = "Position must be between 0 and (length list) inclusive.\r\nIf position = 0, then the item is added to the front of the list.\r\nWhen 0 < position < length, item is inserted\r\nbefore the element currently at that position.  When position = length, item\r\nis inserted at the end of the list.  This is a destructive operation.\nPosition must be between 0 and (length list) inclusive.\nIf position = 0, then the item is added to the front of the list.\nWhen 0 < position < length, item is inserted\nbefore the element currently at that position.  When position = length, item\nis inserted at the end of the list.  This is a destructive operation.")
    public static SubLObject ninsert_by_position(final SubLObject item, final SubLObject list, SubLObject position) {
        assert NIL != integerp(position) : "! integerp(position) " + ("Types.integerp(position) " + "CommonSymbols.NIL != Types.integerp(position) ") + position;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        final SubLObject list_length = length(list);
        SubLObject sublist = NIL;
        SubLObject insertion_point_on = NIL;
        if (position.numG(list_length) || position.numL(ZERO_INTEGER)) {
            Errors.error($str92$Position_is_not_valid_for_the_siz);
            return NIL;
        }
        if (position.numLE(ZERO_INTEGER) || list_length.eql(ZERO_INTEGER)) {
            return cons(item, list);
        }
        if (position.numGE(list_length)) {
            return nconc(list, list(item));
        }
        sublist = nthcdr(subtract(position, ONE_INTEGER), list);
        insertion_point_on = list(item);
        rplacd(insertion_point_on, sublist.rest());
        rplacd(sublist, insertion_point_on);
        return list;
    }

    /**
     * Destructively inserts ITEM into a random position in LIST.
     * This position may by the first or last element.
     */
    @LispMethod(comment = "Destructively inserts ITEM into a random position in LIST.\r\nThis position may by the first or last element.\nDestructively inserts ITEM into a random position in LIST.\nThis position may by the first or last element.")
    public static final SubLObject ninsert_randomly_alt(SubLObject item, SubLObject list) {
        {
            SubLObject pos = random.random(number_utilities.f_1X(length(list)));
            return com.cyc.cycjava.cycl.list_utilities.ninsert_by_position(item, list, pos);
        }
    }

    @LispMethod(comment = "Destructively inserts ITEM into a random position in LIST.\r\nThis position may by the first or last element.\nDestructively inserts ITEM into a random position in LIST.\nThis position may by the first or last element.")
    public static SubLObject ninsert_randomly(final SubLObject item, final SubLObject list) {
        final SubLObject pos = random.random(number_utilities.f_1X(length(list)));
        return ninsert_by_position(item, list, pos);
    }/**
     * Destructively inserts ITEM into a random position in LIST.
     * This position may by the first or last element.
     */


    public static final SubLObject ninsert_somewhere_before_and_after_alt(SubLObject insert_item, SubLObject list, SubLObject pivot_item, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject pos = position(pivot_item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            list = com.cyc.cycjava.cycl.list_utilities.ninsert_somewhere_after(insert_item, list, pos);
            list = com.cyc.cycjava.cycl.list_utilities.ninsert_somewhere_before_or_at(insert_item, list, pos);
            return list;
        }
    }

    public static SubLObject ninsert_somewhere_before_and_after(final SubLObject insert_item, SubLObject list, final SubLObject pivot_item, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject pos = position(pivot_item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        list = ninsert_somewhere_after(insert_item, list, pos);
        list = ninsert_somewhere_before_or_at(insert_item, list, pos);
        return list;
    }

    /**
     * Destructively inserts ITEM in LIST somewhere before or at position POS.
     */
    @LispMethod(comment = "Destructively inserts ITEM in LIST somewhere before or at position POS.")
    public static final SubLObject ninsert_somewhere_before_alt(SubLObject item, SubLObject list, SubLObject pos) {
        {
            SubLObject insert_pos = random.random(pos);
            return com.cyc.cycjava.cycl.list_utilities.ninsert_by_position(item, list, insert_pos);
        }
    }

    @LispMethod(comment = "Destructively inserts ITEM in LIST somewhere before or at position POS.")
    public static SubLObject ninsert_somewhere_before(final SubLObject item, final SubLObject list, final SubLObject pos) {
        final SubLObject insert_pos = random.random(pos);
        return ninsert_by_position(item, list, insert_pos);
    }/**
     * Destructively inserts ITEM in LIST somewhere before or at position POS.
     */


    /**
     * Destructively inserts ITEM in LIST somewhere before or at position POS.
     */
    @LispMethod(comment = "Destructively inserts ITEM in LIST somewhere before or at position POS.")
    public static final SubLObject ninsert_somewhere_before_or_at_alt(SubLObject item, SubLObject list, SubLObject pos) {
        {
            SubLObject insert_pos = random.random(number_utilities.f_1X(pos));
            return com.cyc.cycjava.cycl.list_utilities.ninsert_by_position(item, list, insert_pos);
        }
    }

    @LispMethod(comment = "Destructively inserts ITEM in LIST somewhere before or at position POS.")
    public static SubLObject ninsert_somewhere_before_or_at(final SubLObject item, final SubLObject list, final SubLObject pos) {
        final SubLObject insert_pos = random.random(number_utilities.f_1X(pos));
        return ninsert_by_position(item, list, insert_pos);
    }/**
     * Destructively inserts ITEM in LIST somewhere before or at position POS.
     */


    /**
     * Destructively inserts ITEM in LIST somewhere strictly after position POS.
     */
    @LispMethod(comment = "Destructively inserts ITEM in LIST somewhere strictly after position POS.")
    public static final SubLObject ninsert_somewhere_after_alt(SubLObject item, SubLObject list, SubLObject pos) {
        {
            SubLObject len = length(list);
            SubLObject offset = random.random(subtract(len, pos));
            SubLObject insert_pos = add(ONE_INTEGER, pos, offset);
            return com.cyc.cycjava.cycl.list_utilities.ninsert_by_position(item, list, insert_pos);
        }
    }

    @LispMethod(comment = "Destructively inserts ITEM in LIST somewhere strictly after position POS.")
    public static SubLObject ninsert_somewhere_after(final SubLObject item, final SubLObject list, final SubLObject pos) {
        final SubLObject len = length(list);
        final SubLObject offset = random.random(subtract(len, pos));
        final SubLObject insert_pos = add(ONE_INTEGER, pos, offset);
        return ninsert_by_position(item, list, insert_pos);
    }/**
     * Destructively inserts ITEM in LIST somewhere strictly after position POS.
     */


    /**
     * Destructively moves the Nth item of LIST to the front.
     *
     * @unknown ecoppock
     */
    @LispMethod(comment = "Destructively moves the Nth item of LIST to the front.\r\n\r\n@unknown ecoppock")
    public static final SubLObject move_nth_to_front_alt(SubLObject n, SubLObject list) {
        {
            SubLObject elt = nth(n, list);
            return com.cyc.cycjava.cycl.list_utilities.nmove_to_front(elt, list, UNPROVIDED);
        }
    }

    @LispMethod(comment = "Destructively moves the Nth item of LIST to the front.\r\n\r\n@unknown ecoppock")
    public static SubLObject move_nth_to_front(final SubLObject n, final SubLObject list) {
        final SubLObject elt = nth(n, list);
        return nmove_to_front(elt, list, UNPROVIDED);
    }/**
     * Destructively moves the Nth item of LIST to the front.
     *
     * @unknown ecoppock
     */


    /**
     * Destructively moves the Nth item of LIST to NEW-POSITION, shifting any items between N and NEW-POSITION
     * to the right or left depending on whether N is greater than or less than NEW-POSITION.
     *
     * @unknown baxter
     */
    @LispMethod(comment = "Destructively moves the Nth item of LIST to NEW-POSITION, shifting any items between N and NEW-POSITION\r\nto the right or left depending on whether N is greater than or less than NEW-POSITION.\r\n\r\n@unknown baxter\nDestructively moves the Nth item of LIST to NEW-POSITION, shifting any items between N and NEW-POSITION\nto the right or left depending on whether N is greater than or less than NEW-POSITION.")
    public static final SubLObject move_nth_to_position_alt(SubLObject n, SubLObject new_position, SubLObject list) {
        {
            SubLObject elt = nth(n, list);
            if (n.eql(new_position)) {
                return list;
            } else {
                if (new_position.eql(ZERO_INTEGER)) {
                    return com.cyc.cycjava.cycl.list_utilities.nmove_to_front(elt, list, UNPROVIDED);
                } else {
                    if (new_position.eql(number_utilities.f_1_(length(list)))) {
                        return com.cyc.cycjava.cycl.list_utilities.nmove_to_end(elt, list);
                    } else {
                        return com.cyc.cycjava.cycl.list_utilities.ninsert_by_position(elt, com.cyc.cycjava.cycl.list_utilities.delete_nth(n, list), new_position);
                    }
                }
            }
        }
    }

    @LispMethod(comment = "Destructively moves the Nth item of LIST to NEW-POSITION, shifting any items between N and NEW-POSITION\r\nto the right or left depending on whether N is greater than or less than NEW-POSITION.\r\n\r\n@unknown baxter\nDestructively moves the Nth item of LIST to NEW-POSITION, shifting any items between N and NEW-POSITION\nto the right or left depending on whether N is greater than or less than NEW-POSITION.")
    public static SubLObject move_nth_to_position(final SubLObject n, final SubLObject new_position, final SubLObject list) {
        final SubLObject elt = nth(n, list);
        if (n.eql(new_position)) {
            return list;
        }
        if (new_position.eql(ZERO_INTEGER)) {
            return nmove_to_front(elt, list, UNPROVIDED);
        }
        if (new_position.eql(number_utilities.f_1_(length(list)))) {
            return nmove_to_end(elt, list);
        }
        return ninsert_by_position(elt, delete_nth(n, list), new_position);
    }/**
     * Destructively moves the Nth item of LIST to NEW-POSITION, shifting any items between N and NEW-POSITION
     * to the right or left depending on whether N is greater than or less than NEW-POSITION.
     *
     * @unknown baxter
     */


    /**
     * A destructive version of @xref move-to-front.
     */
    @LispMethod(comment = "A destructive version of @xref move-to-front.")
    public static final SubLObject nmove_to_front_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject pcase_var = test;
                if (pcase_var.eql(EQ)) {
                    thread.resetMultipleValues();
                    {
                        SubLObject already_at_frontP = eq(item, list.first());
                        thread.resetMultipleValues();
                        return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                    }
                } else {
                    if (pcase_var.eql(EQL)) {
                        thread.resetMultipleValues();
                        {
                            SubLObject already_at_frontP = eql(item, list.first());
                            thread.resetMultipleValues();
                            return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                        }
                    } else {
                        if (pcase_var.eql(EQUAL)) {
                            thread.resetMultipleValues();
                            {
                                SubLObject already_at_frontP = equal(item, list.first());
                                thread.resetMultipleValues();
                                return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                            }
                        } else {
                            if (pcase_var.eql(EQUALP)) {
                                thread.resetMultipleValues();
                                {
                                    SubLObject already_at_frontP = equalp(item, list.first());
                                    thread.resetMultipleValues();
                                    return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                                }
                            } else {
                                thread.resetMultipleValues();
                                {
                                    SubLObject already_at_frontP = funcall(test, item, list.first());
                                    thread.resetMultipleValues();
                                    return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    @LispMethod(comment = "A destructive version of @xref move-to-front.")
    public static SubLObject nmove_to_front(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject pcase_var = test;
        if (pcase_var.eql(EQ)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = eq(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        if (pcase_var.eql(EQL)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = eql(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        if (pcase_var.eql(EQUAL)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = equal(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        if (pcase_var.eql(EQUALP)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = equalp(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        thread.resetMultipleValues();
        final SubLObject already_at_frontP = funcall(test, item, list.first());
        thread.resetMultipleValues();
        return NIL != already_at_frontP ? list : cons(item, delete(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
    }/**
     * A destructive version of @xref move-to-front.
     */


    /**
     * Non-destructively moves ITEM to the front of LIST.  Prepends ITEM to LIST if it was not already in LIST.
     * Does nothing if ITEM is already the first element of LIST.  Assumes that there is at most one occurrence
     * of ITEM in LIST, otherwise behaviour is undefined.
     *
     * @unknown (move-to-front 4 '(1 2 3 4 5)) (4 1 2 3 5)
     * @unknown pace
     */
    @LispMethod(comment = "Non-destructively moves ITEM to the front of LIST.  Prepends ITEM to LIST if it was not already in LIST.\r\nDoes nothing if ITEM is already the first element of LIST.  Assumes that there is at most one occurrence\r\nof ITEM in LIST, otherwise behaviour is undefined.\r\n\r\n@unknown (move-to-front 4 \'(1 2 3 4 5)) (4 1 2 3 5)\r\n@unknown pace\nNon-destructively moves ITEM to the front of LIST.  Prepends ITEM to LIST if it was not already in LIST.\nDoes nothing if ITEM is already the first element of LIST.  Assumes that there is at most one occurrence\nof ITEM in LIST, otherwise behaviour is undefined.")
    public static final SubLObject move_to_front_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject pcase_var = test;
                if (pcase_var.eql(EQ)) {
                    thread.resetMultipleValues();
                    {
                        SubLObject already_at_frontP = eq(item, list.first());
                        thread.resetMultipleValues();
                        return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                    }
                } else {
                    if (pcase_var.eql(EQL)) {
                        thread.resetMultipleValues();
                        {
                            SubLObject already_at_frontP = eql(item, list.first());
                            thread.resetMultipleValues();
                            return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                        }
                    } else {
                        if (pcase_var.eql(EQUAL)) {
                            thread.resetMultipleValues();
                            {
                                SubLObject already_at_frontP = equal(item, list.first());
                                thread.resetMultipleValues();
                                return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                            }
                        } else {
                            if (pcase_var.eql(EQUALP)) {
                                thread.resetMultipleValues();
                                {
                                    SubLObject already_at_frontP = equalp(item, list.first());
                                    thread.resetMultipleValues();
                                    return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                                }
                            } else {
                                thread.resetMultipleValues();
                                {
                                    SubLObject already_at_frontP = funcall(test, item, list.first());
                                    thread.resetMultipleValues();
                                    return NIL != already_at_frontP ? ((SubLObject) (list)) : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    @LispMethod(comment = "Non-destructively moves ITEM to the front of LIST.  Prepends ITEM to LIST if it was not already in LIST.\r\nDoes nothing if ITEM is already the first element of LIST.  Assumes that there is at most one occurrence\r\nof ITEM in LIST, otherwise behaviour is undefined.\r\n\r\n@unknown (move-to-front 4 \'(1 2 3 4 5)) (4 1 2 3 5)\r\n@unknown pace\nNon-destructively moves ITEM to the front of LIST.  Prepends ITEM to LIST if it was not already in LIST.\nDoes nothing if ITEM is already the first element of LIST.  Assumes that there is at most one occurrence\nof ITEM in LIST, otherwise behaviour is undefined.")
    public static SubLObject move_to_front(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject pcase_var = test;
        if (pcase_var.eql(EQ)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = eq(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        if (pcase_var.eql(EQL)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = eql(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        if (pcase_var.eql(EQUAL)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = equal(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        if (pcase_var.eql(EQUALP)) {
            thread.resetMultipleValues();
            final SubLObject already_at_frontP = equalp(item, list.first());
            thread.resetMultipleValues();
            return NIL != already_at_frontP ? list : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        thread.resetMultipleValues();
        final SubLObject already_at_frontP = funcall(test, item, list.first());
        thread.resetMultipleValues();
        return NIL != already_at_frontP ? list : cons(item, remove(item, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
    }/**
     * Non-destructively moves ITEM to the front of LIST.  Prepends ITEM to LIST if it was not already in LIST.
     * Does nothing if ITEM is already the first element of LIST.  Assumes that there is at most one occurrence
     * of ITEM in LIST, otherwise behaviour is undefined.
     *
     * @unknown (move-to-front 4 '(1 2 3 4 5)) (4 1 2 3 5)
     * @unknown pace
     */


    /**
     * A destructive version of @xref move-to-end.
     */
    @LispMethod(comment = "A destructive version of @xref move-to-end.")
    public static final SubLObject nmove_to_end_alt(SubLObject item, SubLObject list) {
        return nconc(delete(item, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), list(item));
    }

    @LispMethod(comment = "A destructive version of @xref move-to-end.")
    public static SubLObject nmove_to_end(final SubLObject item, final SubLObject list) {
        return nconc(delete(item, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), list(item));
    }/**
     * A destructive version of @xref move-to-end.
     */


    /**
     * Non-destructively moves ITEM to the end of LIST.  Appends ITEM to LIST if it was not already in LIST.
     * Assumes that there is at most one occurrence
     * of ITEM in LIST, otherwise behaviour is undefined.
     *
     * @unknown (move-to-end 4 '(1 2 3 4 5)) (1 2 3 5 4)
     * @unknown pace
     */
    @LispMethod(comment = "Non-destructively moves ITEM to the end of LIST.  Appends ITEM to LIST if it was not already in LIST.\r\nAssumes that there is at most one occurrence\r\nof ITEM in LIST, otherwise behaviour is undefined.\r\n\r\n@unknown (move-to-end 4 \'(1 2 3 4 5)) (1 2 3 5 4)\r\n@unknown pace\nNon-destructively moves ITEM to the end of LIST.  Appends ITEM to LIST if it was not already in LIST.\nAssumes that there is at most one occurrence\nof ITEM in LIST, otherwise behaviour is undefined.")
    public static final SubLObject move_to_end_alt(SubLObject item, SubLObject list) {
        return append(remove(item, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), list(item));
    }

    @LispMethod(comment = "Non-destructively moves ITEM to the end of LIST.  Appends ITEM to LIST if it was not already in LIST.\r\nAssumes that there is at most one occurrence\r\nof ITEM in LIST, otherwise behaviour is undefined.\r\n\r\n@unknown (move-to-end 4 \'(1 2 3 4 5)) (1 2 3 5 4)\r\n@unknown pace\nNon-destructively moves ITEM to the end of LIST.  Appends ITEM to LIST if it was not already in LIST.\nAssumes that there is at most one occurrence\nof ITEM in LIST, otherwise behaviour is undefined.")
    public static SubLObject move_to_end(final SubLObject item, final SubLObject list) {
        return append(remove(item, list, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), list(item));
    }/**
     * Non-destructively moves ITEM to the end of LIST.  Appends ITEM to LIST if it was not already in LIST.
     * Assumes that there is at most one occurrence
     * of ITEM in LIST, otherwise behaviour is undefined.
     *
     * @unknown (move-to-end 4 '(1 2 3 4 5)) (1 2 3 5 4)
     * @unknown pace
     */


    /**
     * replace the Nth item of LIST with NEW (nondestructive)
     *
     * @unknown pace
     */
    @LispMethod(comment = "replace the Nth item of LIST with NEW (nondestructive)\r\n\r\n@unknown pace")
    public static final SubLObject replace_nth_alt(SubLObject n, SubLObject v_new, SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.nreplace_nth(n, v_new, copy_list(list));
    }

    @LispMethod(comment = "replace the Nth item of LIST with NEW (nondestructive)\r\n\r\n@unknown pace")
    public static SubLObject replace_nth(final SubLObject n, final SubLObject v_new, final SubLObject list) {
        return nreplace_nth(n, v_new, copy_list(list));
    }/**
     * replace the Nth item of LIST with NEW (nondestructive)
     *
     * @unknown pace
     */


    /**
     * replace the last item of LIST with NEW (nondestructive)
     *
     * @unknown baxter
     */
    @LispMethod(comment = "replace the last item of LIST with NEW (nondestructive)\r\n\r\n@unknown baxter")
    public static final SubLObject replace_last_alt(SubLObject list, SubLObject v_new) {
        return com.cyc.cycjava.cycl.list_utilities.replace_nth(number_utilities.f_1_(length(list)), v_new, list);
    }

    @LispMethod(comment = "replace the last item of LIST with NEW (nondestructive)\r\n\r\n@unknown baxter")
    public static SubLObject replace_last(final SubLObject list, final SubLObject v_new) {
        return replace_nth(number_utilities.f_1_(length(list)), v_new, list);
    }/**
     * replace the last item of LIST with NEW (nondestructive)
     *
     * @unknown baxter
     */


    /**
     * Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate
     * item remains, and all others later in the list are removed
     *
     * @unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite REMOVE-DUPLICATES.
     * @unknown (remove-duplicates-from-end '(1 a 2 a 3)) -> (1 A 2 3)
     * @unknown sutton
     */
    @LispMethod(comment = "Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem remains, and all others later in the list are removed\r\n\r\n@unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite REMOVE-DUPLICATES.\r\n@unknown (remove-duplicates-from-end \'(1 a 2 a 3)) -> (1 A 2 3)\r\n@unknown sutton\nSame as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\nitem remains, and all others later in the list are removed")
    public static final SubLObject remove_duplicates_from_end_alt(SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return remove_duplicates(list, test, key, start, end);
    }

    @LispMethod(comment = "Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem remains, and all others later in the list are removed\r\n\r\n@unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite REMOVE-DUPLICATES.\r\n@unknown (remove-duplicates-from-end \'(1 a 2 a 3)) -> (1 A 2 3)\r\n@unknown sutton\nSame as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\nitem remains, and all others later in the list are removed")
    public static SubLObject remove_duplicates_from_end(final SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return remove_duplicates(list, test, key, start, end);
    }/**
     * Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate
     * item remains, and all others later in the list are removed
     *
     * @unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite REMOVE-DUPLICATES.
     * @unknown (remove-duplicates-from-end '(1 a 2 a 3)) -> (1 A 2 3)
     * @unknown sutton
     */


    /**
     * Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate
     * item is removed, instead of the last.
     *
     * @unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite REMOVE-DUPLICATES.
     * @unknown (remove-duplicates-from-start '(1 a 2 a 3)) -> (1 2 A 3)
     * @unknown sutton
     */
    @LispMethod(comment = "Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem is removed, instead of the last.\r\n\r\n@unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite REMOVE-DUPLICATES.\r\n@unknown (remove-duplicates-from-start \'(1 a 2 a 3)) -> (1 2 A 3)\r\n@unknown sutton\nSame as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\nitem is removed, instead of the last.")
    public static final SubLObject remove_duplicates_from_start_alt(SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return nreverse(delete_duplicates(reverse(list), test, key, start, end));
    }

    @LispMethod(comment = "Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem is removed, instead of the last.\r\n\r\n@unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite REMOVE-DUPLICATES.\r\n@unknown (remove-duplicates-from-start \'(1 a 2 a 3)) -> (1 2 A 3)\r\n@unknown sutton\nSame as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate\nitem is removed, instead of the last.")
    public static SubLObject remove_duplicates_from_start(final SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return nreverse(delete_duplicates(reverse(list), test, key, start, end));
    }/**
     * Same as @see REMOVE-DUPLICATES, except that the first occurrence of a duplicate
     * item is removed, instead of the last.
     *
     * @unknown ; In CLtL, remove-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite REMOVE-DUPLICATES.
     * @unknown (remove-duplicates-from-start '(1 a 2 a 3)) -> (1 2 A 3)
     * @unknown sutton
     */


    /**
     * Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate
     * item is deleted, instead of the last.
     *
     * @unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite DELETE-DUPLICATES.
     * @unknown sutton
     */
    @LispMethod(comment = "Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem is deleted, instead of the last.\r\n\r\n@unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite DELETE-DUPLICATES.\r\n@unknown sutton\nSame as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\nitem is deleted, instead of the last.")
    public static final SubLObject delete_duplicates_from_end_alt(SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return delete_duplicates(list, test, key, start, end);
    }

    @LispMethod(comment = "Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem is deleted, instead of the last.\r\n\r\n@unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite DELETE-DUPLICATES.\r\n@unknown sutton\nSame as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\nitem is deleted, instead of the last.")
    public static SubLObject delete_duplicates_from_end(final SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return delete_duplicates(list, test, key, start, end);
    }/**
     * Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate
     * item is deleted, instead of the last.
     *
     * @unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite DELETE-DUPLICATES.
     * @unknown sutton
     */


    /**
     * Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate
     * item is deleted, instead of the last.
     *
     * @unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite DELETE-DUPLICATES.
     * @unknown sutton
     */
    @LispMethod(comment = "Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem is deleted, instead of the last.\r\n\r\n@unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite DELETE-DUPLICATES.\r\n@unknown sutton\nSame as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\nitem is deleted, instead of the last.")
    public static final SubLObject delete_duplicates_from_start_alt(SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return nreverse(delete_duplicates(nreverse(list), test, key, start, end));
    }

    @LispMethod(comment = "Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\r\nitem is deleted, instead of the last.\r\n\r\n@unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation\r\nis horribly inefficient, but the only way to make it efficient would be to\r\nbasically rewrite DELETE-DUPLICATES.\r\n@unknown sutton\nSame as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate\nitem is deleted, instead of the last.")
    public static SubLObject delete_duplicates_from_start(final SubLObject list, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return nreverse(delete_duplicates(nreverse(list), test, key, start, end));
    }/**
     * Same as @see DELETE-DUPLICATES, except that the first occurrence of a duplicate
     * item is deleted, instead of the last.
     *
     * @unknown ; In CLtL, delete-duplicates takes a from-end argument.  This implementation
    is horribly inefficient, but the only way to make it efficient would be to
    basically rewrite DELETE-DUPLICATES.
     * @unknown sutton
     */


    public static final SubLObject remove_null_alt(SubLObject list, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        return remove_if(NULL, list, key, start, end, count);
    }

    public static SubLObject remove_null(final SubLObject list, SubLObject key, SubLObject start, SubLObject end, SubLObject count) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        if (count == UNPROVIDED) {
            count = NIL;
        }
        return remove_if(NULL, list, key, start, end, count);
    }

    public static final SubLObject remove_from_end_duplicates_and_those_wXkey_alt(SubLObject list, SubLObject key_value, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return nreverse(remove_duplicates(nreverse(cons(key_value, copy_list(list))), test, key, start, end)).rest();
    }

    public static SubLObject remove_from_end_duplicates_and_those_wXkey(final SubLObject list, final SubLObject key_value, SubLObject test, SubLObject key, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return nreverse(remove_duplicates(nreverse(cons(key_value, copy_list(list))), test, key, start, end)).rest();
    }

    public static final SubLObject skipping_positions_alt(SubLObject list, SubLObject skip_list) {
        {
            SubLObject result = NIL;
            SubLObject cdotimes_end_var = length(list);
            SubLObject n = NIL;
            for (n = ZERO_INTEGER; n.numL(cdotimes_end_var); n = add(n, ONE_INTEGER)) {
                if (NIL == subl_promotions.memberP(n, skip_list, UNPROVIDED, UNPROVIDED)) {
                    result = cons(nth(n, list), result);
                }
            }
            return nreverse(result);
        }
    }

    public static SubLObject skipping_positions(final SubLObject list, final SubLObject skip_list) {
        SubLObject result = NIL;
        SubLObject cdotimes_end_var;
        SubLObject n;
        for (cdotimes_end_var = length(list), n = NIL, n = ZERO_INTEGER; n.numL(cdotimes_end_var); n = add(n, ONE_INTEGER)) {
            if (NIL == subl_promotions.memberP(n, skip_list, UNPROVIDED, UNPROVIDED)) {
                result = cons(nth(n, list), result);
            }
        }
        return nreverse(result);
    }

    /**
     *
     *
     * @return list; a list of length NUM containing the integers START to NUM-1+START.
     * @unknown - The list returned by this function is cached, so unless you're sure it won't
    be modified, use @xref NEW-NUM-LIST instead.
     * @unknown - If you're getting a list of numbers just to iterate over it, use @xref
    DO-NUMBERS instead.
     */
    @LispMethod(comment = "@return list; a list of length NUM containing the integers START to NUM-1+START.\r\n@unknown - The list returned by this function is cached, so unless you\'re sure it won\'t\r\nbe modified, use @xref NEW-NUM-LIST instead.\r\n@unknown - If you\'re getting a list of numbers just to iterate over it, use @xref\r\nDO-NUMBERS instead.")
    public static final SubLObject num_list_alt(SubLObject num, SubLObject start) {
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        {
            SubLObject maybe_cached_list = com.cyc.cycjava.cycl.list_utilities.num_list_cached(num, start);
            SubLObject okP = com.cyc.cycjava.cycl.list_utilities.verify_num_list(maybe_cached_list, num, start);
            if (NIL != okP) {
                return maybe_cached_list;
            } else {
                com.cyc.cycjava.cycl.list_utilities.remove_num_list_cached(num, start);
                return com.cyc.cycjava.cycl.list_utilities.num_list_cached(num, start);
            }
        }
    }

    /**
     *
     *
     * @return list; a list of length NUM containing the integers START to NUM-1+START.
     * @unknown - The list returned by this function is cached, so unless you're sure it won't
    be modified, use @xref NEW-NUM-LIST instead.
     * @unknown - If you're getting a list of numbers just to iterate over it, use @xref
    DO-NUMBERS instead.
     */
    @LispMethod(comment = "@return list; a list of length NUM containing the integers START to NUM-1+START.\r\n@unknown - The list returned by this function is cached, so unless you\'re sure it won\'t\r\nbe modified, use @xref NEW-NUM-LIST instead.\r\n@unknown - If you\'re getting a list of numbers just to iterate over it, use @xref\r\nDO-NUMBERS instead.")
    public static SubLObject num_list(final SubLObject num, SubLObject start) {
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        final SubLObject maybe_cached_list = num_list_cached(num, start);
        final SubLObject okP = verify_num_list(maybe_cached_list, num, start);
        if (NIL != okP) {
            return maybe_cached_list;
        }
        remove_num_list_cached(num, start);
        return num_list_cached(num, start);
    }

    /**
     *
     *
     * @return list; a list of length NUM containing the integers START to NUM-1+START.
     * @unknown - The list returned by this function is NOT cached, so if you're sure it won't
    be modified and you're going to be calling this a lot with the same arguments, use
     * @unknown NUM-LIST or @xref DO-NUMBERS instead.
     */
    @LispMethod(comment = "@return list; a list of length NUM containing the integers START to NUM-1+START.\r\n@unknown - The list returned by this function is NOT cached, so if you\'re sure it won\'t\r\nbe modified and you\'re going to be calling this a lot with the same arguments, use\r\n@unknown NUM-LIST or @xref DO-NUMBERS instead.")
    public static final SubLObject new_num_list_alt(SubLObject num, SubLObject start) {
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        {
            SubLObject ans = NIL;
            SubLObject i = NIL;
            for (i = ZERO_INTEGER; i.numL(num); i = add(i, ONE_INTEGER)) {
                ans = cons(add(start, i), ans);
            }
            return nreverse(ans);
        }
    }

    /**
     *
     *
     * @return list; a list of length NUM containing the integers START to NUM-1+START.
     * @unknown - The list returned by this function is NOT cached, so if you're sure it won't
    be modified and you're going to be calling this a lot with the same arguments, use
     * @unknown NUM-LIST or @xref DO-NUMBERS instead.
     */
    @LispMethod(comment = "@return list; a list of length NUM containing the integers START to NUM-1+START.\r\n@unknown - The list returned by this function is NOT cached, so if you\'re sure it won\'t\r\nbe modified and you\'re going to be calling this a lot with the same arguments, use\r\n@unknown NUM-LIST or @xref DO-NUMBERS instead.")
    public static SubLObject new_num_list(final SubLObject num, SubLObject start) {
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        SubLObject ans = NIL;
        SubLObject i;
        for (i = NIL, i = ZERO_INTEGER; i.numL(num); i = add(i, ONE_INTEGER)) {
            ans = cons(add(start, i), ans);
        }
        return nreverse(ans);
    }

    /**
     *
     *
     * @return BOOLEAN; Is NUM-LIST a list of length LENGTH containing the integers START to LENGTH-1+START?
     */
    @LispMethod(comment = "@return BOOLEAN; Is NUM-LIST a list of length LENGTH containing the integers START to LENGTH-1+START?")
    public static final SubLObject verify_num_list_alt(SubLObject num_list, SubLObject length, SubLObject start) {
        {
            SubLObject badP = makeBoolean(!(((num_list.isList() && length.isInteger()) && start.isInteger()) && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthE(num_list, length, UNPROVIDED))));
            SubLObject list_var = NIL;
            SubLObject num = NIL;
            SubLObject i = NIL;
            for (list_var = num_list, num = list_var.first(), i = ZERO_INTEGER; !((NIL != badP) || (NIL == list_var)); list_var = list_var.rest() , num = list_var.first() , i = add(ONE_INTEGER, i)) {
                if (!num.eql(add(i, start))) {
                    badP = T;
                }
            }
            return makeBoolean(NIL == badP);
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is NUM-LIST a list of length LENGTH containing the integers START to LENGTH-1+START?
     */
    @LispMethod(comment = "@return BOOLEAN; Is NUM-LIST a list of length LENGTH containing the integers START to LENGTH-1+START?")
    public static SubLObject verify_num_list(final SubLObject num_list, final SubLObject length, final SubLObject start) {
        SubLObject badP = makeBoolean((((!num_list.isList()) || (!length.isInteger())) || (!start.isInteger())) || (NIL == lengthE(num_list, length, UNPROVIDED)));
        SubLObject list_var = NIL;
        SubLObject num = NIL;
        SubLObject i = NIL;
        list_var = num_list;
        num = list_var.first();
        for (i = ZERO_INTEGER; (NIL == badP) && (NIL != list_var); list_var = list_var.rest() , num = list_var.first() , i = add(ONE_INTEGER, i)) {
            if (!num.eql(add(i, start))) {
                badP = T;
            }
        }
        return makeBoolean(NIL == badP);
    }

    public static final SubLObject clear_num_list_cached_alt() {
        {
            SubLObject cs = $num_list_cached_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_num_list_cached() {
        final SubLObject cs = $num_list_cached_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_num_list_cached_alt(SubLObject num, SubLObject start) {
        return memoization_state.caching_state_remove_function_results_with_args($num_list_cached_caching_state$.getGlobalValue(), list(num, start), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_num_list_cached(final SubLObject num, final SubLObject start) {
        return memoization_state.caching_state_remove_function_results_with_args($num_list_cached_caching_state$.getGlobalValue(), list(num, start), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return list; a list of length NUM containing the integers START to NUM-1+START.
     * @unknown - We cache this to save space, not time.
     */
    @LispMethod(comment = "@return list; a list of length NUM containing the integers START to NUM-1+START.\r\n@unknown - We cache this to save space, not time.")
    public static final SubLObject num_list_cached_internal_alt(SubLObject num, SubLObject start) {
        return com.cyc.cycjava.cycl.list_utilities.new_num_list(num, start);
    }

    /**
     *
     *
     * @return list; a list of length NUM containing the integers START to NUM-1+START.
     * @unknown - We cache this to save space, not time.
     */
    @LispMethod(comment = "@return list; a list of length NUM containing the integers START to NUM-1+START.\r\n@unknown - We cache this to save space, not time.")
    public static SubLObject num_list_cached_internal(final SubLObject num, final SubLObject start) {
        return new_num_list(num, start);
    }

    public static final SubLObject num_list_cached_alt(SubLObject num, SubLObject start) {
        {
            SubLObject caching_state = $num_list_cached_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(NUM_LIST_CACHED, $num_list_cached_caching_state$, NIL, EQL, TWO_INTEGER, $int$100);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(num, start);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw96$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (num.eql(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && start.eql(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.list_utilities.num_list_cached_internal(num, start)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(num, start));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject num_list_cached(final SubLObject num, final SubLObject start) {
        SubLObject caching_state = $num_list_cached_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(NUM_LIST_CACHED, $num_list_cached_caching_state$, NIL, EQL, TWO_INTEGER, $int$100);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(num, start);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (num.eql(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && start.eql(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(num_list_cached_internal(num, start)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(num, start));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @return list; a list of length LENGTH containing the numbers 0 + START to LENGTH-1 + START.
     */
    @LispMethod(comment = "@return list; a list of length LENGTH containing the numbers 0 + START to LENGTH-1 + START.")
    public static final SubLObject numlist_alt(SubLObject length, SubLObject start) {
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        return com.cyc.cycjava.cycl.list_utilities.num_list(length, start);
    }

    /**
     *
     *
     * @return list; a list of length LENGTH containing the numbers 0 + START to LENGTH-1 + START.
     */
    @LispMethod(comment = "@return list; a list of length LENGTH containing the numbers 0 + START to LENGTH-1 + START.")
    public static SubLObject numlist(final SubLObject length, SubLObject start) {
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        return num_list(length, start);
    }

    public static final SubLObject tree_ancestor_alt(SubLObject node, SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject ancestor = NIL;
            if (tree.isCons()) {
                if (NIL == ancestor) {
                    {
                        SubLObject csome_list_var = tree.rest();
                        SubLObject subtree = NIL;
                        for (subtree = csome_list_var.first(); !((NIL != ancestor) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , subtree = csome_list_var.first()) {
                            if (subtree.isCons() && (NIL != funcall(test, subtree.first(), node))) {
                                ancestor = tree.first();
                            }
                        }
                    }
                }
                if (NIL == ancestor) {
                    {
                        SubLObject csome_list_var = tree.rest();
                        SubLObject subtree = NIL;
                        for (subtree = csome_list_var.first(); !((NIL != ancestor) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , subtree = csome_list_var.first()) {
                            if (subtree.isCons()) {
                                ancestor = com.cyc.cycjava.cycl.list_utilities.tree_ancestor(node, subtree, test);
                            }
                        }
                    }
                }
            }
            return ancestor;
        }
    }

    public static SubLObject tree_ancestor(final SubLObject node, final SubLObject tree, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject ancestor = NIL;
        if (tree.isCons()) {
            if (NIL == ancestor) {
                SubLObject csome_list_var = tree.rest();
                SubLObject subtree = NIL;
                subtree = csome_list_var.first();
                while ((NIL == ancestor) && (NIL != csome_list_var)) {
                    if (subtree.isCons() && (NIL != funcall(test, subtree.first(), node))) {
                        ancestor = tree.first();
                    }
                    csome_list_var = csome_list_var.rest();
                    subtree = csome_list_var.first();
                } 
            }
            if (NIL == ancestor) {
                SubLObject csome_list_var = tree.rest();
                SubLObject subtree = NIL;
                subtree = csome_list_var.first();
                while ((NIL == ancestor) && (NIL != csome_list_var)) {
                    if (subtree.isCons()) {
                        ancestor = tree_ancestor(node, subtree, test);
                    }
                    csome_list_var = csome_list_var.rest();
                    subtree = csome_list_var.first();
                } 
            }
        }
        return ancestor;
    }

    /**
     * An optimized form of (member? ITEM LIST #'eq)
     */
    @LispMethod(comment = "An optimized form of (member? ITEM LIST #\'eq)")
    public static final SubLObject member_eqP_alt(SubLObject item, SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(EQ), UNPROVIDED);
    }

    @LispMethod(comment = "An optimized form of (member? ITEM LIST #\'eq)")
    public static SubLObject member_eqP(final SubLObject item, final SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(EQ), UNPROVIDED);
    }/**
     * An optimized form of (member? ITEM LIST #'eq)
     */


    public static SubLObject member_kbeqP(final SubLObject item, final SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(KBEQ), UNPROVIDED);
    }

    /**
     * An optimized form of (member? ITEM LIST #'equal)
     */
    @LispMethod(comment = "An optimized form of (member? ITEM LIST #\'equal)")
    public static final SubLObject member_equalP_alt(SubLObject item, SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(EQUAL), UNPROVIDED);
    }

    @LispMethod(comment = "An optimized form of (member? ITEM LIST #\'equal)")
    public static SubLObject member_equalP(final SubLObject item, final SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(EQUAL), UNPROVIDED);
    }/**
     * An optimized form of (member? ITEM LIST #'equal)
     */


    public static SubLObject has_member_equalP(final SubLObject list, final SubLObject item) {
        return member_equalP(item, list);
    }

    public static SubLObject not_has_member_equalP(final SubLObject list, final SubLObject item) {
        return makeBoolean(NIL == has_member_equalP(list, item));
    }

    /**
     * An optimized form of (member? ITEM LIST #'equal)
     */
    @LispMethod(comment = "An optimized form of (member? ITEM LIST #\'equal)")
    public static final SubLObject member_equalpP_alt(SubLObject item, SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(EQUALP), UNPROVIDED);
    }

    @LispMethod(comment = "An optimized form of (member? ITEM LIST #\'equal)")
    public static SubLObject member_equalpP(final SubLObject item, final SubLObject list) {
        return subl_promotions.memberP(item, list, symbol_function(EQUALP), UNPROVIDED);
    }/**
     * An optimized form of (member? ITEM LIST #'equal)
     */


    /**
     *
     *
     * @return booleanp; whether ITEM is present in LIST.
    In passing, move ITEM one step closer to the front of LIST,
    unless it is already at the head of LIST or one away from the head.
    This will, in the limit, bring the more frequently accessed elements of LIST to the front.
     * @see alist-nlookup
     */
    @LispMethod(comment = "@return booleanp; whether ITEM is present in LIST.\r\nIn passing, move ITEM one step closer to the front of LIST,\r\nunless it is already at the head of LIST or one away from the head.\r\nThis will, in the limit, bring the more frequently accessed elements of LIST to the front.\r\n@see alist-nlookup")
    public static final SubLObject nmemberP_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if ((test == symbol_function(EQ)) || (test == EQ)) {
            return com.cyc.cycjava.cycl.list_utilities.nmember_eqP(item, list);
        } else {
            if ((test == symbol_function(EQL)) || (test == EQL)) {
                return com.cyc.cycjava.cycl.list_utilities.nmember_eqlP(item, list);
            } else {
                if ((test == symbol_function(EQUAL)) || (test == EQUAL)) {
                    return com.cyc.cycjava.cycl.list_utilities.nmember_equalP(item, list);
                } else {
                    if ((test == symbol_function(EQUALP)) || (test == EQUALP)) {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_equalpP(item, list);
                    } else {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_funcallP(item, list, test);
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return booleanp; whether ITEM is present in LIST.
    In passing, move ITEM one step closer to the front of LIST,
    unless it is already at the head of LIST or one away from the head.
    This will, in the limit, bring the more frequently accessed elements of LIST to the front.
     * @see alist-nlookup
     */
    @LispMethod(comment = "@return booleanp; whether ITEM is present in LIST.\r\nIn passing, move ITEM one step closer to the front of LIST,\r\nunless it is already at the head of LIST or one away from the head.\r\nThis will, in the limit, bring the more frequently accessed elements of LIST to the front.\r\n@see alist-nlookup")
    public static SubLObject nmemberP(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (test.eql(symbol_function(EQ)) || (test == EQ)) {
            return nmember_eqP(item, list);
        }
        if (test.eql(symbol_function(EQL)) || (test == EQL)) {
            return nmember_eqlP(item, list);
        }
        if (test.eql(symbol_function(EQUAL)) || (test == EQUAL)) {
            return nmember_equalP(item, list);
        }
        if (test.eql(symbol_function(EQUALP)) || (test == EQUALP)) {
            return nmember_equalpP(item, list);
        }
        return nmember_funcallP(item, list, test);
    }

    public static final SubLObject nmember_eqP_alt(SubLObject item, SubLObject list) {
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject list_cons = NIL;
            for (list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
                {
                    SubLObject candidate_item = list_cons.first();
                    if (item == candidate_item) {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_success(last_last_cons, last_cons, list_cons);
                    }
                }
                last_last_cons = last_cons;
                last_cons = list_cons;
            }
        }
        return NIL;
    }

    public static SubLObject nmember_eqP(final SubLObject item, final SubLObject list) {
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject list_cons;
        SubLObject candidate_item;
        for (list_cons = NIL, list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
            candidate_item = list_cons.first();
            if (item.eql(candidate_item)) {
                return nmember_success(last_last_cons, last_cons, list_cons);
            }
            last_last_cons = last_cons;
            last_cons = list_cons;
        }
        return NIL;
    }

    public static final SubLObject nmember_eqlP_alt(SubLObject item, SubLObject list) {
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject list_cons = NIL;
            for (list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
                {
                    SubLObject candidate_item = list_cons.first();
                    if (item.eql(candidate_item)) {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_success(last_last_cons, last_cons, list_cons);
                    }
                }
                last_last_cons = last_cons;
                last_cons = list_cons;
            }
        }
        return NIL;
    }

    public static SubLObject nmember_eqlP(final SubLObject item, final SubLObject list) {
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject list_cons;
        SubLObject candidate_item;
        for (list_cons = NIL, list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
            candidate_item = list_cons.first();
            if (item.eql(candidate_item)) {
                return nmember_success(last_last_cons, last_cons, list_cons);
            }
            last_last_cons = last_cons;
            last_cons = list_cons;
        }
        return NIL;
    }

    public static final SubLObject nmember_equalP_alt(SubLObject item, SubLObject list) {
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject list_cons = NIL;
            for (list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
                {
                    SubLObject candidate_item = list_cons.first();
                    if (item.equal(candidate_item)) {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_success(last_last_cons, last_cons, list_cons);
                    }
                }
                last_last_cons = last_cons;
                last_cons = list_cons;
            }
        }
        return NIL;
    }

    public static SubLObject nmember_equalP(final SubLObject item, final SubLObject list) {
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject list_cons;
        SubLObject candidate_item;
        for (list_cons = NIL, list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
            candidate_item = list_cons.first();
            if (item.equal(candidate_item)) {
                return nmember_success(last_last_cons, last_cons, list_cons);
            }
            last_last_cons = last_cons;
            last_cons = list_cons;
        }
        return NIL;
    }

    public static final SubLObject nmember_equalpP_alt(SubLObject item, SubLObject list) {
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject list_cons = NIL;
            for (list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
                {
                    SubLObject candidate_item = list_cons.first();
                    if (item.equalp(candidate_item)) {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_success(last_last_cons, last_cons, list_cons);
                    }
                }
                last_last_cons = last_cons;
                last_cons = list_cons;
            }
        }
        return NIL;
    }

    public static SubLObject nmember_equalpP(final SubLObject item, final SubLObject list) {
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject list_cons;
        SubLObject candidate_item;
        for (list_cons = NIL, list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
            candidate_item = list_cons.first();
            if (item.equalp(candidate_item)) {
                return nmember_success(last_last_cons, last_cons, list_cons);
            }
            last_last_cons = last_cons;
            last_cons = list_cons;
        }
        return NIL;
    }

    public static final SubLObject nmember_funcallP_alt(SubLObject item, SubLObject list, SubLObject test) {
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject list_cons = NIL;
            for (list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
                {
                    SubLObject candidate_item = list_cons.first();
                    if (NIL != funcall(test, item, candidate_item)) {
                        return com.cyc.cycjava.cycl.list_utilities.nmember_success(last_last_cons, last_cons, list_cons);
                    }
                }
                last_last_cons = last_cons;
                last_cons = list_cons;
            }
        }
        return NIL;
    }

    public static SubLObject nmember_funcallP(final SubLObject item, final SubLObject list, final SubLObject test) {
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject list_cons;
        SubLObject candidate_item;
        for (list_cons = NIL, list_cons = list; !list_cons.isAtom(); list_cons = list_cons.rest()) {
            candidate_item = list_cons.first();
            if (NIL != funcall(test, item, candidate_item)) {
                return nmember_success(last_last_cons, last_cons, list_cons);
            }
            last_last_cons = last_cons;
            last_cons = list_cons;
        }
        return NIL;
    }

    /**
     * move list-cons 1 cons earlier
     */
    @LispMethod(comment = "move list-cons 1 cons earlier")
    public static final SubLObject nmember_success_alt(SubLObject last_last_cons, SubLObject last_cons, SubLObject list_cons) {
        if (NIL != last_last_cons) {
            rplacd(last_last_cons, list_cons);
            rplacd(last_cons, list_cons.rest());
            rplacd(list_cons, last_cons);
        }
        return T;
    }

    @LispMethod(comment = "move list-cons 1 cons earlier")
    public static SubLObject nmember_success(final SubLObject last_last_cons, final SubLObject last_cons, final SubLObject list_cons) {
        if (NIL != last_last_cons) {
            rplacd(last_last_cons, list_cons);
            rplacd(last_cons, list_cons.rest());
            rplacd(list_cons, last_cons);
        }
        return T;
    }/**
     * move list-cons 1 cons earlier
     */


    /**
     * A non-consing test for any intersection between LIST1 and LIST2.
     */
    @LispMethod(comment = "A non-consing test for any intersection between LIST1 and LIST2.")
    public static final SubLObject intersectP_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject length1 = length(list1);
            SubLObject length2 = length(list2);
            SubLObject list1_longer = numG(length1, length2);
            SubLObject set1 = (NIL != list1_longer) ? ((SubLObject) (list2)) : list1;
            SubLObject set2 = (NIL != list1_longer) ? ((SubLObject) (list1)) : list2;
            SubLObject intersectP = NIL;
            if ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) {
                if (NIL == intersectP) {
                    {
                        SubLObject csome_list_var = set1;
                        SubLObject element = NIL;
                        for (element = csome_list_var.first(); !((NIL != intersectP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , element = csome_list_var.first()) {
                            if (NIL != subl_promotions.memberP(element, set2, test, key)) {
                                intersectP = T;
                            }
                        }
                    }
                }
            } else {
                if (NIL == intersectP) {
                    {
                        SubLObject csome_list_var = set1;
                        SubLObject element = NIL;
                        for (element = csome_list_var.first(); !((NIL != intersectP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , element = csome_list_var.first()) {
                            if (NIL != subl_promotions.memberP(funcall(key, element), set2, test, key)) {
                                intersectP = T;
                            }
                        }
                    }
                }
            }
            return intersectP;
        }
    }

    @LispMethod(comment = "A non-consing test for any intersection between LIST1 and LIST2.")
    public static SubLObject intersectP(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLObject length1 = length(list1);
        final SubLObject length2 = length(list2);
        final SubLObject list1_longer = numG(length1, length2);
        final SubLObject set1 = (NIL != list1_longer) ? list2 : list1;
        final SubLObject set2 = (NIL != list1_longer) ? list1 : list2;
        SubLObject intersectP = NIL;
        if (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) {
            if (NIL == intersectP) {
                SubLObject csome_list_var = set1;
                SubLObject element = NIL;
                element = csome_list_var.first();
                while ((NIL == intersectP) && (NIL != csome_list_var)) {
                    if (NIL != subl_promotions.memberP(element, set2, test, key)) {
                        intersectP = T;
                    }
                    csome_list_var = csome_list_var.rest();
                    element = csome_list_var.first();
                } 
            }
        } else
            if (NIL == intersectP) {
                SubLObject csome_list_var = set1;
                SubLObject element = NIL;
                element = csome_list_var.first();
                while ((NIL == intersectP) && (NIL != csome_list_var)) {
                    if (NIL != subl_promotions.memberP(funcall(key, element), set2, test, key)) {
                        intersectP = T;
                    }
                    csome_list_var = csome_list_var.rest();
                    element = csome_list_var.first();
                } 
            }

        return intersectP;
    }/**
     * A non-consing test for any intersection between LIST1 and LIST2.
     */


    /**
     * A quick, non-consing test for any intersection between the sorted lists LIST1 and LIST2.
     */
    @LispMethod(comment = "A quick, non-consing test for any intersection between the sorted lists LIST1 and LIST2.")
    public static final SubLObject intersect_sortedP_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) {
            {
                SubLObject elem1 = list1.first();
                SubLObject elem2 = list2.first();
                while ((NIL != list1) && (NIL != list2)) {
                    if (NIL != funcall(test, elem1, elem2)) {
                        list1 = list1.rest();
                        elem1 = list1.first();
                    } else {
                        if (NIL != funcall(test, elem2, elem1)) {
                            list2 = list2.rest();
                            elem2 = list2.first();
                        } else {
                            return T;
                        }
                    }
                } 
            }
        } else {
            {
                SubLObject elem1 = funcall(key, list1.first());
                SubLObject elem2 = funcall(key, list2.first());
                while ((NIL != list1) && (NIL != list2)) {
                    if (NIL != funcall(test, elem1, elem2)) {
                        list1 = list1.rest();
                        elem1 = funcall(key, list1.first());
                    } else {
                        if (NIL != funcall(test, elem2, elem1)) {
                            list2 = list2.rest();
                            elem2 = funcall(key, list2.first());
                        } else {
                            return T;
                        }
                    }
                } 
            }
        }
        return NIL;
    }

    @LispMethod(comment = "A quick, non-consing test for any intersection between the sorted lists LIST1 and LIST2.")
    public static SubLObject intersect_sortedP(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) {
            SubLObject elem1 = list1.first();
            SubLObject elem2 = list2.first();
            while ((NIL != list1) && (NIL != list2)) {
                if (NIL != funcall(test, elem1, elem2)) {
                    list1 = list1.rest();
                    elem1 = list1.first();
                } else {
                    if (NIL == funcall(test, elem2, elem1)) {
                        return T;
                    }
                    list2 = list2.rest();
                    elem2 = list2.first();
                }
            } 
        } else {
            SubLObject elem1 = funcall(key, list1.first());
            SubLObject elem2 = funcall(key, list2.first());
            while ((NIL != list1) && (NIL != list2)) {
                if (NIL != funcall(test, elem1, elem2)) {
                    list1 = list1.rest();
                    elem1 = funcall(key, list1.first());
                } else {
                    if (NIL == funcall(test, elem2, elem1)) {
                        return T;
                    }
                    list2 = list2.rest();
                    elem2 = funcall(key, list2.first());
                }
            } 
        }
        return NIL;
    }/**
     * A quick, non-consing test for any intersection between the sorted lists LIST1 and LIST2.
     */


    /**
     *
     *
     * @param LISTS;
     * 		a list of sorted lists.
     * @param N;
     * 		an index into LISTS.
     * @return list; a list of indices into LISTS which intersect with the Nth element of LISTS.
    The return value will always include at least the element N.
     */
    @LispMethod(comment = "@param LISTS;\r\n\t\ta list of sorted lists.\r\n@param N;\r\n\t\tan index into LISTS.\r\n@return list; a list of indices into LISTS which intersect with the Nth element of LISTS.\r\nThe return value will always include at least the element N.")
    public static final SubLObject which_intersect_element_sorted_alt(SubLObject lists, SubLObject n, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject target_list = nth(n, lists);
            SubLObject result = NIL;
            SubLObject list_var = NIL;
            SubLObject list = NIL;
            SubLObject i = NIL;
            for (list_var = lists, list = list_var.first(), i = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , list = list_var.first() , i = add(ONE_INTEGER, i)) {
                if (NIL != com.cyc.cycjava.cycl.list_utilities.intersect_sortedP(list, target_list, test, key)) {
                    result = cons(i, result);
                }
            }
            return nreverse(result);
        }
    }

    /**
     *
     *
     * @param LISTS;
     * 		a list of sorted lists.
     * @param N;
     * 		an index into LISTS.
     * @return list; a list of indices into LISTS which intersect with the Nth element of LISTS.
    The return value will always include at least the element N.
     */
    @LispMethod(comment = "@param LISTS;\r\n\t\ta list of sorted lists.\r\n@param N;\r\n\t\tan index into LISTS.\r\n@return list; a list of indices into LISTS which intersect with the Nth element of LISTS.\r\nThe return value will always include at least the element N.")
    public static SubLObject which_intersect_element_sorted(final SubLObject lists, final SubLObject n, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLObject target_list = nth(n, lists);
        SubLObject result = NIL;
        SubLObject list_var = NIL;
        SubLObject list = NIL;
        SubLObject i = NIL;
        list_var = lists;
        list = list_var.first();
        for (i = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , list = list_var.first() , i = add(ONE_INTEGER, i)) {
            if (NIL != intersect_sortedP(list, target_list, test, key)) {
                result = cons(i, result);
            }
        }
        return nreverse(result);
    }

    /**
     *
     *
     * @return boolean; t iff the sorted list SMALL-LIST is a subset of the sorted list BIG-LIST.
     * @param SMALL-LIST;
     * 		a list sorted by SORT.
     * @param BIG-LIST;
     * 		a list sorted by SORT.
     */
    @LispMethod(comment = "@return boolean; t iff the sorted list SMALL-LIST is a subset of the sorted list BIG-LIST.\r\n@param SMALL-LIST;\r\n\t\ta list sorted by SORT.\r\n@param BIG-LIST;\r\n\t\ta list sorted by SORT.")
    public static final SubLObject sorted_subsetp_alt(SubLObject small_list, SubLObject big_list, SubLObject test, SubLObject sort, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (sort == UNPROVIDED) {
            sort = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject small_list_rest = small_list.rest();
                SubLObject doneP = NIL;
                SubLObject pcase_var = key;
                if (pcase_var.eql(IDENTITY)) {
                    thread.resetMultipleValues();
                    {
                        SubLObject small_elem = identity(small_list.first());
                        thread.resetMultipleValues();
                        if (NIL == doneP) {
                            {
                                SubLObject csome_list_var = big_list;
                                SubLObject big_elem_raw = NIL;
                                for (big_elem_raw = csome_list_var.first(); !((NIL != doneP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , big_elem_raw = csome_list_var.first()) {
                                    {
                                        SubLObject pcase_var_19 = key;
                                        if (pcase_var_19.eql(IDENTITY)) {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject big_elem = identity(big_elem_raw);
                                                thread.resetMultipleValues();
                                                if (NIL == small_elem) {
                                                    doneP = T;
                                                } else {
                                                    if (NIL != funcall(sort, small_elem, big_elem)) {
                                                        doneP = T;
                                                    } else {
                                                        if (NIL != funcall(test, small_elem, big_elem)) {
                                                            small_elem = funcall(key, small_list_rest.first());
                                                            small_list_rest = small_list_rest.rest();
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject big_elem = funcall(key, big_elem_raw);
                                                thread.resetMultipleValues();
                                                if (NIL == small_elem) {
                                                    doneP = T;
                                                } else {
                                                    if (NIL != funcall(sort, small_elem, big_elem)) {
                                                        doneP = T;
                                                    } else {
                                                        if (NIL != funcall(test, small_elem, big_elem)) {
                                                            small_elem = funcall(key, small_list_rest.first());
                                                            small_list_rest = small_list_rest.rest();
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return sublisp_null(small_elem);
                    }
                } else {
                    thread.resetMultipleValues();
                    {
                        SubLObject small_elem = funcall(key, small_list.first());
                        thread.resetMultipleValues();
                        if (NIL == doneP) {
                            {
                                SubLObject csome_list_var = big_list;
                                SubLObject big_elem_raw = NIL;
                                for (big_elem_raw = csome_list_var.first(); !((NIL != doneP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , big_elem_raw = csome_list_var.first()) {
                                    {
                                        SubLObject pcase_var_20 = key;
                                        if (pcase_var_20.eql(IDENTITY)) {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject big_elem = identity(big_elem_raw);
                                                thread.resetMultipleValues();
                                                if (NIL == small_elem) {
                                                    doneP = T;
                                                } else {
                                                    if (NIL != funcall(sort, small_elem, big_elem)) {
                                                        doneP = T;
                                                    } else {
                                                        if (NIL != funcall(test, small_elem, big_elem)) {
                                                            small_elem = funcall(key, small_list_rest.first());
                                                            small_list_rest = small_list_rest.rest();
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject big_elem = funcall(key, big_elem_raw);
                                                thread.resetMultipleValues();
                                                if (NIL == small_elem) {
                                                    doneP = T;
                                                } else {
                                                    if (NIL != funcall(sort, small_elem, big_elem)) {
                                                        doneP = T;
                                                    } else {
                                                        if (NIL != funcall(test, small_elem, big_elem)) {
                                                            small_elem = funcall(key, small_list_rest.first());
                                                            small_list_rest = small_list_rest.rest();
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return sublisp_null(small_elem);
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return boolean; t iff the sorted list SMALL-LIST is a subset of the sorted list BIG-LIST.
     * @param SMALL-LIST;
     * 		a list sorted by SORT.
     * @param BIG-LIST;
     * 		a list sorted by SORT.
     */
    @LispMethod(comment = "@return boolean; t iff the sorted list SMALL-LIST is a subset of the sorted list BIG-LIST.\r\n@param SMALL-LIST;\r\n\t\ta list sorted by SORT.\r\n@param BIG-LIST;\r\n\t\ta list sorted by SORT.")
    public static SubLObject sorted_subsetp(final SubLObject small_list, final SubLObject big_list, SubLObject test, SubLObject sort, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (sort == UNPROVIDED) {
            sort = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject small_list_rest = small_list.rest();
        SubLObject doneP = NIL;
        final SubLObject pcase_var = key;
        if (pcase_var.eql(IDENTITY)) {
            thread.resetMultipleValues();
            SubLObject small_elem = identity(small_list.first());
            thread.resetMultipleValues();
            if (NIL == doneP) {
                SubLObject csome_list_var = big_list;
                SubLObject big_elem_raw = NIL;
                big_elem_raw = csome_list_var.first();
                while ((NIL == doneP) && (NIL != csome_list_var)) {
                    final SubLObject pcase_var_$21 = key;
                    if (pcase_var_$21.eql(IDENTITY)) {
                        thread.resetMultipleValues();
                        final SubLObject big_elem = identity(big_elem_raw);
                        thread.resetMultipleValues();
                        if (NIL == small_elem) {
                            doneP = T;
                        } else
                            if (NIL != funcall(sort, small_elem, big_elem)) {
                                doneP = T;
                            } else
                                if (NIL != funcall(test, small_elem, big_elem)) {
                                    small_elem = funcall(key, small_list_rest.first());
                                    small_list_rest = small_list_rest.rest();
                                }


                    } else {
                        thread.resetMultipleValues();
                        final SubLObject big_elem = funcall(key, big_elem_raw);
                        thread.resetMultipleValues();
                        if (NIL == small_elem) {
                            doneP = T;
                        } else
                            if (NIL != funcall(sort, small_elem, big_elem)) {
                                doneP = T;
                            } else
                                if (NIL != funcall(test, small_elem, big_elem)) {
                                    small_elem = funcall(key, small_list_rest.first());
                                    small_list_rest = small_list_rest.rest();
                                }


                    }
                    csome_list_var = csome_list_var.rest();
                    big_elem_raw = csome_list_var.first();
                } 
            }
            return sublisp_null(small_elem);
        }
        thread.resetMultipleValues();
        SubLObject small_elem = funcall(key, small_list.first());
        thread.resetMultipleValues();
        if (NIL == doneP) {
            SubLObject csome_list_var = big_list;
            SubLObject big_elem_raw = NIL;
            big_elem_raw = csome_list_var.first();
            while ((NIL == doneP) && (NIL != csome_list_var)) {
                final SubLObject pcase_var_$22 = key;
                if (pcase_var_$22.eql(IDENTITY)) {
                    thread.resetMultipleValues();
                    final SubLObject big_elem = identity(big_elem_raw);
                    thread.resetMultipleValues();
                    if (NIL == small_elem) {
                        doneP = T;
                    } else
                        if (NIL != funcall(sort, small_elem, big_elem)) {
                            doneP = T;
                        } else
                            if (NIL != funcall(test, small_elem, big_elem)) {
                                small_elem = funcall(key, small_list_rest.first());
                                small_list_rest = small_list_rest.rest();
                            }


                } else {
                    thread.resetMultipleValues();
                    final SubLObject big_elem = funcall(key, big_elem_raw);
                    thread.resetMultipleValues();
                    if (NIL == small_elem) {
                        doneP = T;
                    } else
                        if (NIL != funcall(sort, small_elem, big_elem)) {
                            doneP = T;
                        } else
                            if (NIL != funcall(test, small_elem, big_elem)) {
                                small_elem = funcall(key, small_list_rest.first());
                                small_list_rest = small_list_rest.rest();
                            }


                }
                csome_list_var = csome_list_var.rest();
                big_elem_raw = csome_list_var.first();
            } 
        }
        return sublisp_null(small_elem);
    }

    /**
     *
     *
     * @return booleanp; whether LIST is already sorted according to KEY
     */
    @LispMethod(comment = "@return booleanp; whether LIST is already sorted according to KEY")
    public static final SubLObject sortedP_alt(SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function($sym98$__);
        }
        {
            SubLObject previous = list.first();
            SubLObject cdolist_list_var = list.rest();
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (NIL == funcall(key, previous, elem)) {
                    return NIL;
                }
                previous = elem;
            }
        }
        return T;
    }

    /**
     *
     *
     * @return booleanp; whether LIST is already sorted according to KEY
     */
    @LispMethod(comment = "@return booleanp; whether LIST is already sorted according to KEY")
    public static SubLObject sortedP(final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function($sym98$__);
        }
        SubLObject previous = list.first();
        SubLObject cdolist_list_var = list.rest();
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == funcall(key, previous, elem)) {
                return NIL;
            }
            previous = elem;
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return T;
    }

    /**
     * returns t iff ITEM occurs exactly once in LIST.
     */
    @LispMethod(comment = "returns t iff ITEM occurs exactly once in LIST.")
    public static final SubLObject occurs_onceP_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject itemXrest = member(item, list, test, UNPROVIDED);
            return makeBoolean((NIL != itemXrest) && (NIL == subl_promotions.memberP(item, itemXrest.rest(), test, UNPROVIDED)));
        }
    }

    @LispMethod(comment = "returns t iff ITEM occurs exactly once in LIST.")
    public static SubLObject occurs_onceP(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject itemXrest = member(item, list, test, UNPROVIDED);
        return makeBoolean((NIL != itemXrest) && (NIL == subl_promotions.memberP(item, itemXrest.rest(), test, UNPROVIDED)));
    }/**
     * returns t iff ITEM occurs exactly once in LIST.
     */


    public static final SubLObject not_only_elementP_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return makeBoolean(!((NIL != com.cyc.cycjava.cycl.list_utilities.singletonP(list)) && (NIL != funcall(test, item, list.first()))));
    }

    public static SubLObject not_only_elementP(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return makeBoolean((NIL == singletonP(list)) || (NIL == funcall(test, item, list.first())));
    }

    /**
     *
     *
     * @return boolean; t iff ITEM occurs in LIST at least N times.
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3) 0) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3) 1) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3) 2) NIL
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3 2 3 1) 2) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3 2 3 1) 1) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3 2 3 1) 3) NIL
     * @unknown pace
     */
    @LispMethod(comment = "@return boolean; t iff ITEM occurs in LIST at least N times.\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3) 0) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3) 1) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3) 2) NIL\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3 2 3 1) 2) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3 2 3 1) 1) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3 2 3 1) 3) NIL\r\n@unknown pace")
    public static final SubLObject occurs_at_least_n_timesP_alt(SubLObject item, SubLObject list, SubLObject n, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject times = ZERO_INTEGER;
            SubLObject successP = NIL;
            if (NIL == successP) {
                {
                    SubLObject csome_list_var = list;
                    SubLObject elem = NIL;
                    for (elem = csome_list_var.first(); !((NIL != successP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , elem = csome_list_var.first()) {
                        if (NIL != funcall(test, elem, item)) {
                            times = add(times, ONE_INTEGER);
                            if (times.numGE(n)) {
                                successP = T;
                            }
                        }
                    }
                }
            }
            return successP;
        }
    }

    /**
     *
     *
     * @return boolean; t iff ITEM occurs in LIST at least N times.
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3) 0) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3) 1) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3) 2) NIL
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3 2 3 1) 2) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3 2 3 1) 1) T
     * @unknown (occurs-at-least-n-times? 3 '(1 2 3 2 3 1) 3) NIL
     * @unknown pace
     */
    @LispMethod(comment = "@return boolean; t iff ITEM occurs in LIST at least N times.\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3) 0) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3) 1) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3) 2) NIL\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3 2 3 1) 2) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3 2 3 1) 1) T\r\n@unknown (occurs-at-least-n-times? 3 \'(1 2 3 2 3 1) 3) NIL\r\n@unknown pace")
    public static SubLObject occurs_at_least_n_timesP(final SubLObject item, final SubLObject list, final SubLObject n, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject times = ZERO_INTEGER;
        SubLObject successP = NIL;
        if (NIL == successP) {
            SubLObject csome_list_var = list;
            SubLObject elem = NIL;
            elem = csome_list_var.first();
            while ((NIL == successP) && (NIL != csome_list_var)) {
                if (NIL != funcall(test, elem, item)) {
                    times = add(times, ONE_INTEGER);
                    if (times.numGE(n)) {
                        successP = T;
                    }
                }
                csome_list_var = csome_list_var.rest();
                elem = csome_list_var.first();
            } 
        }
        return successP;
    }

    /**
     *
     *
     * @return boolean; t iff ITEM occurs in LIST exactly N times.
     * @unknown (occurs-exactly-n-times? 3 '(1 2 3 2 3 1) 1) NIL
     * @unknown (occurs-exactly-n-times? 3 '(1 2 3 2 3 1) 2) T
     * @unknown (occurs-exactly-n-times? 3 '(1 2 3 2 3 1) 3)
     * @unknown pace
     */
    @LispMethod(comment = "@return boolean; t iff ITEM occurs in LIST exactly N times.\r\n@unknown (occurs-exactly-n-times? 3 \'(1 2 3 2 3 1) 1) NIL\r\n@unknown (occurs-exactly-n-times? 3 \'(1 2 3 2 3 1) 2) T\r\n@unknown (occurs-exactly-n-times? 3 \'(1 2 3 2 3 1) 3)\r\n@unknown pace")
    public static final SubLObject occurs_exactly_n_timesP_alt(SubLObject item, SubLObject list, SubLObject n, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject times = ZERO_INTEGER;
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (NIL != funcall(test, elem, item)) {
                    times = add(times, ONE_INTEGER);
                    if (times.numG(n)) {
                        return NIL;
                    }
                }
            }
            return numE(times, n);
        }
    }

    /**
     *
     *
     * @return boolean; t iff ITEM occurs in LIST exactly N times.
     * @unknown (occurs-exactly-n-times? 3 '(1 2 3 2 3 1) 1) NIL
     * @unknown (occurs-exactly-n-times? 3 '(1 2 3 2 3 1) 2) T
     * @unknown (occurs-exactly-n-times? 3 '(1 2 3 2 3 1) 3)
     * @unknown pace
     */
    @LispMethod(comment = "@return boolean; t iff ITEM occurs in LIST exactly N times.\r\n@unknown (occurs-exactly-n-times? 3 \'(1 2 3 2 3 1) 1) NIL\r\n@unknown (occurs-exactly-n-times? 3 \'(1 2 3 2 3 1) 2) T\r\n@unknown (occurs-exactly-n-times? 3 \'(1 2 3 2 3 1) 3)\r\n@unknown pace")
    public static SubLObject occurs_exactly_n_timesP(final SubLObject item, final SubLObject list, final SubLObject n, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject times = ZERO_INTEGER;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, elem, item)) {
                times = add(times, ONE_INTEGER);
                if (times.numG(n)) {
                    return NIL;
                }
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return numE(times, n);
    }

    /**
     *
     *
     * @return boolean; t iff ITEM occurs in LIST at most N times.
     * @unknown (occurs-at-most-n-times? 3 '(1 2 3 2 3 1) 3) T
     * @unknown (occurs-at-most-n-times? 3 '(1 2 3 2 3 1) 2) T
     * @unknown (occurs-at-most-n-times? 3 '(1 2 3 2 3 1) 1) NIL
     * @unknown pace
     */
    @LispMethod(comment = "@return boolean; t iff ITEM occurs in LIST at most N times.\r\n@unknown (occurs-at-most-n-times? 3 \'(1 2 3 2 3 1) 3) T\r\n@unknown (occurs-at-most-n-times? 3 \'(1 2 3 2 3 1) 2) T\r\n@unknown (occurs-at-most-n-times? 3 \'(1 2 3 2 3 1) 1) NIL\r\n@unknown pace")
    public static final SubLObject occurs_at_most_n_timesP_alt(SubLObject item, SubLObject list, SubLObject n, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject times = ZERO_INTEGER;
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                if (NIL != funcall(test, elem, item)) {
                    times = add(times, ONE_INTEGER);
                    if (times.numG(n)) {
                        return NIL;
                    }
                }
            }
            return T;
        }
    }

    /**
     *
     *
     * @return boolean; t iff ITEM occurs in LIST at most N times.
     * @unknown (occurs-at-most-n-times? 3 '(1 2 3 2 3 1) 3) T
     * @unknown (occurs-at-most-n-times? 3 '(1 2 3 2 3 1) 2) T
     * @unknown (occurs-at-most-n-times? 3 '(1 2 3 2 3 1) 1) NIL
     * @unknown pace
     */
    @LispMethod(comment = "@return boolean; t iff ITEM occurs in LIST at most N times.\r\n@unknown (occurs-at-most-n-times? 3 \'(1 2 3 2 3 1) 3) T\r\n@unknown (occurs-at-most-n-times? 3 \'(1 2 3 2 3 1) 2) T\r\n@unknown (occurs-at-most-n-times? 3 \'(1 2 3 2 3 1) 1) NIL\r\n@unknown pace")
    public static SubLObject occurs_at_most_n_timesP(final SubLObject item, final SubLObject list, final SubLObject n, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject times = ZERO_INTEGER;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, elem, item)) {
                times = add(times, ONE_INTEGER);
                if (times.numG(n)) {
                    return NIL;
                }
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return T;
    }

    public static final SubLObject singletonP_alt(SubLObject list) {
        return makeBoolean(list.isCons() && (NIL == list.rest()));
    }

    public static SubLObject singletonP(final SubLObject list) {
        return makeBoolean(list.isCons() && (NIL == list.rest()));
    }

    public static final SubLObject doubletonP_alt(SubLObject list) {
        return makeBoolean((list.isCons() && (NIL != list.rest())) && (NIL == cddr(list)));
    }

    public static SubLObject doubletonP(final SubLObject list) {
        return makeBoolean((list.isCons() && (NIL != list.rest())) && (NIL == cddr(list)));
    }

    public static final SubLObject tripleP_alt(SubLObject list) {
        return makeBoolean((list.isCons() && (NIL != cddr(list))) && (NIL == com.cyc.cycjava.cycl.list_utilities.cdddr(list)));
    }

    public static SubLObject tripleP(final SubLObject list) {
        return makeBoolean((list.isCons() && (NIL != cddr(list))) && (NIL == cdddr(list)));
    }

    public static final SubLObject list_of_length_p_alt(SubLObject v_object, SubLObject length, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return makeBoolean(v_object.isList() && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthE(v_object, length, count_dotted_listP)));
    }

    public static SubLObject list_of_length_p(final SubLObject v_object, final SubLObject length, SubLObject count_dotted_listP) {
        if (count_dotted_listP == UNPROVIDED) {
            count_dotted_listP = NIL;
        }
        return makeBoolean(v_object.isList() && (NIL != lengthE(v_object, length, count_dotted_listP)));
    }

    public static final SubLObject list_of_doubletonP_alt(SubLObject list) {
        return com.cyc.cycjava.cycl.list_utilities.list_of_type_p(symbol_function($sym79$DOUBLETON_), list);
    }

    public static SubLObject list_of_doubletonP(final SubLObject list) {
        return list_of_type_p(symbol_function($sym79$DOUBLETON_), list);
    }

    public static final SubLObject exactly_one_distinct_memberP_alt(SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != list) {
            {
                SubLObject first = list.first();
                SubLObject cdolist_list_var = list.rest();
                SubLObject elt = NIL;
                for (elt = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elt = cdolist_list_var.first()) {
                    if (NIL == funcall(test, first, elt)) {
                        return NIL;
                    }
                }
                return T;
            }
        }
        return NIL;
    }

    public static SubLObject exactly_one_distinct_memberP(final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != list) {
            final SubLObject first = list.first();
            SubLObject cdolist_list_var = list.rest();
            SubLObject elt = NIL;
            elt = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL == funcall(test, first, elt)) {
                    return NIL;
                }
                cdolist_list_var = cdolist_list_var.rest();
                elt = cdolist_list_var.first();
            } 
            return T;
        }
        return NIL;
    }

    public static final SubLObject duplicatesP_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject ans = NIL;
            SubLObject element = NIL;
            SubLObject rest = NIL;
            for (element = list.first(), rest = list.rest(); !((NIL != ans) || (NIL == rest)); element = rest.first() , rest = rest.rest()) {
                ans = member(funcall(key, element), rest, test, key);
            }
            return ans;
        }
    }

    public static SubLObject duplicatesP(final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject ans;
        SubLObject element;
        SubLObject rest;
        for (ans = NIL, element = NIL, rest = NIL, element = list.first(), rest = list.rest(); (NIL == ans) && (NIL != rest); ans = member(funcall(key, element), rest, test, key) , element = rest.first() , rest = rest.rest()) {
        }
        return ans;
    }

    public static final SubLObject equal_duplicatesP_alt(SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.duplicatesP(list, symbol_function(EQUAL), key);
    }

    public static SubLObject equal_duplicatesP(final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return duplicatesP(list, symbol_function(EQUAL), key);
    }

    public static final SubLObject duplicates_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject ans = NIL;
            SubLObject element = NIL;
            SubLObject rest = NIL;
            for (element = list.first(), rest = list.rest(); NIL != rest; element = rest.first() , rest = rest.rest()) {
                if (NIL != subl_promotions.memberP(funcall(key, element), rest, test, key)) {
                    if (NIL == subl_promotions.memberP(element, ans, UNPROVIDED, UNPROVIDED)) {
                        ans = cons(element, ans);
                    }
                }
            }
            return nreverse(ans);
        }
    }

    public static SubLObject duplicates(final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject ans = NIL;
        SubLObject element = NIL;
        SubLObject rest = NIL;
        element = list.first();
        for (rest = list.rest(); NIL != rest; rest = rest.rest()) {
            if ((NIL != subl_promotions.memberP(funcall(key, element), rest, test, key)) && (NIL == subl_promotions.memberP(element, ans, UNPROVIDED, UNPROVIDED))) {
                ans = cons(element, ans);
            }
            element = rest.first();
        }
        return nreverse(ans);
    }

    /**
     *
     *
     * @unknown ecoppock
     */
    @LispMethod(comment = "@unknown ecoppock")
    public static final SubLObject duplicate_memberP_alt(SubLObject item, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return com.cyc.cycjava.cycl.list_utilities.occurs_at_least_n_timesP(item, list, TWO_INTEGER, test);
    }

    /**
     *
     *
     * @unknown ecoppock
     */
    @LispMethod(comment = "@unknown ecoppock")
    public static SubLObject duplicate_memberP(final SubLObject item, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return occurs_at_least_n_timesP(item, list, TWO_INTEGER, test);
    }

    /**
     *
     *
     * @return BOOLEANP; Does LIST start with a repeating sequence of at least MIN-SEQUENCE-LENGTH
    elements repeating at least MIN-REPETITIONS times?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEANP; Does LIST start with a repeating sequence of at least MIN-SEQUENCE-LENGTH\r\nelements repeating at least MIN-REPETITIONS times?\r\n@unknown baxter")
    public static final SubLObject list_starts_with_repeating_sequenceP_alt(SubLObject list, SubLObject test, SubLObject min_repetitions, SubLObject min_sequence_length) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (min_repetitions == UNPROVIDED) {
            min_repetitions = TWO_INTEGER;
        }
        if (min_sequence_length == UNPROVIDED) {
            min_sequence_length = ONE_INTEGER;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(list, NON_DOTTED_LIST_P);
            SubLTrampolineFile.checkType(min_repetitions, POSITIVE_INTEGER_P);
            if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
                if (!min_repetitions.numG(ONE_INTEGER)) {
                    Errors.error($str_alt99$Number_of_repetitions_must_be_gre, min_repetitions);
                }
            }
            SubLTrampolineFile.checkType(min_sequence_length, POSITIVE_INTEGER_P);
            {
                SubLObject first_item = list.first();
                if (NIL == com.cyc.cycjava.cycl.list_utilities.duplicate_memberP(first_item, list, test)) {
                    return NIL;
                }
            }
            {
                SubLObject sequences = NIL;
                SubLObject length = length(list);
                SubLObject stopP = NIL;
                SubLObject repeating_sequence = NIL;
                SubLObject list_var = NIL;
                SubLObject item = NIL;
                SubLObject i = NIL;
                for (list_var = list, item = list_var.first(), i = ZERO_INTEGER; !((NIL != stopP) || (NIL == list_var)); list_var = list_var.rest() , item = list_var.first() , i = add(ONE_INTEGER, i)) {
                    if (i.isZero()) {
                        {
                            SubLObject new_sequence = make_vector(THREE_INTEGER, UNPROVIDED);
                            set_aref(new_sequence, ZERO_INTEGER, list(item));
                            set_aref(new_sequence, ONE_INTEGER, ZERO_INTEGER);
                            set_aref(new_sequence, TWO_INTEGER, ONE_INTEGER);
                            sequences = cons(new_sequence, sequences);
                        }
                    } else {
                        if (NIL == sequences) {
                            stopP = T;
                        } else {
                            {
                                SubLObject failed_sequences = NIL;
                                SubLObject new_sequences = NIL;
                                if (NIL == repeating_sequence) {
                                    {
                                        SubLObject csome_list_var = sequences;
                                        SubLObject sequence = NIL;
                                        for (sequence = csome_list_var.first(); !((NIL != repeating_sequence) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , sequence = csome_list_var.first()) {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject result = com.cyc.cycjava.cycl.list_utilities.update_repeating_sequence(sequence, item, i, list, length, test, min_repetitions, min_sequence_length);
                                                SubLObject new_sequence = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject pcase_var = result;
                                                    if (pcase_var.eql($FAILED)) {
                                                        failed_sequences = cons(sequence, failed_sequences);
                                                    } else {
                                                        if (pcase_var.eql($SUCCEEDED)) {
                                                            repeating_sequence = sequence;
                                                            stopP = T;
                                                        }
                                                    }
                                                }
                                                if (NIL != new_sequence) {
                                                    new_sequences = cons(new_sequence, new_sequences);
                                                }
                                            }
                                        }
                                    }
                                }
                                {
                                    SubLObject cdolist_list_var = failed_sequences;
                                    SubLObject failed = NIL;
                                    for (failed = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , failed = cdolist_list_var.first()) {
                                        sequences = delete(failed, sequences, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    }
                                }
                                {
                                    SubLObject cdolist_list_var = new_sequences;
                                    SubLObject v_new = NIL;
                                    for (v_new = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , v_new = cdolist_list_var.first()) {
                                        sequences = cons(v_new, sequences);
                                    }
                                }
                            }
                        }
                    }
                }
                return NIL != repeating_sequence ? ((SubLObject) (aref(repeating_sequence, ZERO_INTEGER))) : NIL;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEANP; Does LIST start with a repeating sequence of at least MIN-SEQUENCE-LENGTH
    elements repeating at least MIN-REPETITIONS times?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEANP; Does LIST start with a repeating sequence of at least MIN-SEQUENCE-LENGTH\r\nelements repeating at least MIN-REPETITIONS times?\r\n@unknown baxter")
    public static SubLObject list_starts_with_repeating_sequenceP(final SubLObject list, SubLObject test, SubLObject min_repetitions, SubLObject min_sequence_length) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (min_repetitions == UNPROVIDED) {
            min_repetitions = TWO_INTEGER;
        }
        if (min_sequence_length == UNPROVIDED) {
            min_sequence_length = ONE_INTEGER;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != non_dotted_list_p(list) : "! list_utilities.non_dotted_list_p(list) " + ("list_utilities.non_dotted_list_p(list) " + "CommonSymbols.NIL != list_utilities.non_dotted_list_p(list) ") + list;
        assert NIL != subl_promotions.positive_integer_p(min_repetitions) : "! subl_promotions.positive_integer_p(min_repetitions) " + ("subl_promotions.positive_integer_p(min_repetitions) " + "CommonSymbols.NIL != subl_promotions.positive_integer_p(min_repetitions) ") + min_repetitions;
        if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (!min_repetitions.numG(ONE_INTEGER))) {
            Errors.error($str99$Number_of_repetitions_must_be_gre, min_repetitions);
        }
        assert NIL != subl_promotions.positive_integer_p(min_sequence_length) : "! subl_promotions.positive_integer_p(min_sequence_length) " + ("subl_promotions.positive_integer_p(min_sequence_length) " + "CommonSymbols.NIL != subl_promotions.positive_integer_p(min_sequence_length) ") + min_sequence_length;
        final SubLObject first_item = list.first();
        if (NIL == duplicate_memberP(first_item, list, test)) {
            return NIL;
        }
        SubLObject sequences = NIL;
        final SubLObject length = length(list);
        SubLObject stopP = NIL;
        SubLObject repeating_sequence = NIL;
        SubLObject list_var = NIL;
        SubLObject item = NIL;
        SubLObject i = NIL;
        list_var = list;
        item = list_var.first();
        for (i = ZERO_INTEGER; (NIL == stopP) && (NIL != list_var); list_var = list_var.rest() , item = list_var.first() , i = add(ONE_INTEGER, i)) {
            if (i.isZero()) {
                final SubLObject new_sequence = make_vector(THREE_INTEGER, UNPROVIDED);
                set_aref(new_sequence, ZERO_INTEGER, list(item));
                set_aref(new_sequence, ONE_INTEGER, ZERO_INTEGER);
                set_aref(new_sequence, TWO_INTEGER, ONE_INTEGER);
                sequences = cons(new_sequence, sequences);
            } else
                if (NIL == sequences) {
                    stopP = T;
                } else {
                    SubLObject failed_sequences = NIL;
                    SubLObject new_sequences = NIL;
                    if (NIL == repeating_sequence) {
                        SubLObject csome_list_var = sequences;
                        SubLObject sequence = NIL;
                        sequence = csome_list_var.first();
                        while ((NIL == repeating_sequence) && (NIL != csome_list_var)) {
                            thread.resetMultipleValues();
                            final SubLObject result = update_repeating_sequence(sequence, item, i, list, length, test, min_repetitions, min_sequence_length);
                            final SubLObject new_sequence2 = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            final SubLObject pcase_var = result;
                            if (pcase_var.eql($FAILED)) {
                                failed_sequences = cons(sequence, failed_sequences);
                            } else
                                if (pcase_var.eql($SUCCEEDED)) {
                                    repeating_sequence = sequence;
                                    stopP = T;
                                }

                            if (NIL != new_sequence2) {
                                new_sequences = cons(new_sequence2, new_sequences);
                            }
                            csome_list_var = csome_list_var.rest();
                            sequence = csome_list_var.first();
                        } 
                    }
                    SubLObject cdolist_list_var = failed_sequences;
                    SubLObject failed = NIL;
                    failed = cdolist_list_var.first();
                    while (NIL != cdolist_list_var) {
                        sequences = delete(failed, sequences, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        cdolist_list_var = cdolist_list_var.rest();
                        failed = cdolist_list_var.first();
                    } 
                    cdolist_list_var = new_sequences;
                    SubLObject v_new = NIL;
                    v_new = cdolist_list_var.first();
                    while (NIL != cdolist_list_var) {
                        sequences = cons(v_new, sequences);
                        cdolist_list_var = cdolist_list_var.rest();
                        v_new = cdolist_list_var.first();
                    } 
                }

        }
        return NIL != repeating_sequence ? aref(repeating_sequence, ZERO_INTEGER) : NIL;
    }

    /**
     * We've read (I-1) items of LIST, whose length is LENGTH.
     *
     * @param ITEM;
     * 		the next (i.e. Ith) item on LIST.
     */
    @LispMethod(comment = "We\'ve read (I-1) items of LIST, whose length is LENGTH.\r\n\r\n@param ITEM;\r\n\t\tthe next (i.e. Ith) item on LIST.")
    public static final SubLObject update_repeating_sequence_alt(SubLObject sequence, SubLObject item, SubLObject i, SubLObject list, SubLObject length, SubLObject test, SubLObject min_repetitions, SubLObject min_sequence_length) {
        {
            SubLObject sequence_items = aref(sequence, ZERO_INTEGER);
            SubLObject reps = aref(sequence, ONE_INTEGER);
            SubLObject items_found = aref(sequence, TWO_INTEGER);
            SubLObject result = $FAILED;
            SubLObject new_sequence = NIL;
            if (reps.isZero() && length.numGE(multiply(min_repetitions, number_utilities.f_1X(length(sequence_items))))) {
                new_sequence = make_vector(THREE_INTEGER, UNPROVIDED);
                set_aref(new_sequence, ZERO_INTEGER, com.cyc.cycjava.cycl.list_utilities.first_n(number_utilities.f_1X(i), list));
                set_aref(new_sequence, ONE_INTEGER, ZERO_INTEGER);
                set_aref(new_sequence, TWO_INTEGER, number_utilities.f_1X(length(sequence_items)));
            }
            if (reps.isZero()) {
                if ((NIL != com.cyc.cycjava.cycl.list_utilities.lengthGE(sequence_items, min_sequence_length, UNPROVIDED)) && (NIL != funcall(test, item, sequence_items.first()))) {
                    set_aref(sequence, ONE_INTEGER, ONE_INTEGER);
                    set_aref(sequence, TWO_INTEGER, ONE_INTEGER);
                    result = $UPDATED;
                }
            } else {
                if (ONE_INTEGER.eql(subtract(length(sequence_items), items_found)) && (NIL != funcall(test, item, com.cyc.cycjava.cycl.list_utilities.last_one(sequence_items)))) {
                    set_aref(sequence, ONE_INTEGER, add(aref(sequence, ONE_INTEGER), ONE_INTEGER));
                    set_aref(sequence, TWO_INTEGER, ZERO_INTEGER);
                    if (number_utilities.f_1X(reps).numGE(min_repetitions)) {
                        result = $SUCCEEDED;
                    } else {
                        result = $UPDATED;
                    }
                } else {
                    if (NIL != funcall(test, item, nth(items_found, sequence_items))) {
                        set_aref(sequence, TWO_INTEGER, add(aref(sequence, TWO_INTEGER), ONE_INTEGER));
                        result = $UPDATED;
                    }
                }
            }
            return values(result, new_sequence);
        }
    }

    @LispMethod(comment = "We\'ve read (I-1) items of LIST, whose length is LENGTH.\r\n\r\n@param ITEM;\r\n\t\tthe next (i.e. Ith) item on LIST.")
    public static SubLObject update_repeating_sequence(final SubLObject sequence, final SubLObject item, final SubLObject i, final SubLObject list, final SubLObject length, final SubLObject test, final SubLObject min_repetitions, final SubLObject min_sequence_length) {
        final SubLObject sequence_items = aref(sequence, ZERO_INTEGER);
        final SubLObject reps = aref(sequence, ONE_INTEGER);
        final SubLObject items_found = aref(sequence, TWO_INTEGER);
        SubLObject result = $FAILED;
        SubLObject new_sequence = NIL;
        if (reps.isZero() && length.numGE(multiply(min_repetitions, number_utilities.f_1X(length(sequence_items))))) {
            new_sequence = make_vector(THREE_INTEGER, UNPROVIDED);
            set_aref(new_sequence, ZERO_INTEGER, first_n(number_utilities.f_1X(i), list));
            set_aref(new_sequence, ONE_INTEGER, ZERO_INTEGER);
            set_aref(new_sequence, TWO_INTEGER, number_utilities.f_1X(length(sequence_items)));
        }
        if (reps.isZero()) {
            if ((NIL != lengthGE(sequence_items, min_sequence_length, UNPROVIDED)) && (NIL != funcall(test, item, sequence_items.first()))) {
                set_aref(sequence, ONE_INTEGER, ONE_INTEGER);
                set_aref(sequence, TWO_INTEGER, ONE_INTEGER);
                result = $UPDATED;
            }
        } else
            if (ONE_INTEGER.eql(subtract(length(sequence_items), items_found)) && (NIL != funcall(test, item, last_one(sequence_items)))) {
                set_aref(sequence, ONE_INTEGER, add(aref(sequence, ONE_INTEGER), ONE_INTEGER));
                set_aref(sequence, TWO_INTEGER, ZERO_INTEGER);
                if (number_utilities.f_1X(reps).numGE(min_repetitions)) {
                    result = $SUCCEEDED;
                } else {
                    result = $UPDATED;
                }
            } else
                if (NIL != funcall(test, item, nth(items_found, sequence_items))) {
                    set_aref(sequence, TWO_INTEGER, add(aref(sequence, TWO_INTEGER), ONE_INTEGER));
                    result = $UPDATED;
                }


        return subl_promotions.values2(result, new_sequence);
    }/**
     * We've read (I-1) items of LIST, whose length is LENGTH.
     *
     * @param ITEM;
     * 		the next (i.e. Ith) item on LIST.
     */


    public static final SubLObject multisets_equalP_alt(SubLObject set1, SubLObject set2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject result = NIL;
            SubLObject doneP = NIL;
            if (length(set1) != length(set2)) {
                doneP = T;
            }
            if (NIL == doneP) {
                {
                    SubLObject cdolist_list_var = set1;
                    SubLObject elem = NIL;
                    for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                        if (count(elem, set1, test, UNPROVIDED, UNPROVIDED, UNPROVIDED) != count(elem, set2, test, UNPROVIDED, UNPROVIDED, UNPROVIDED)) {
                            doneP = T;
                        }
                    }
                }
            }
            if (NIL == doneP) {
                result = com.cyc.cycjava.cycl.list_utilities.sets_equalP(set1, set2, test);
            }
            return result;
        }
    }

    public static SubLObject multisets_equalP(final SubLObject set1, final SubLObject set2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject result = NIL;
        SubLObject doneP = NIL;
        if (!length(set1).eql(length(set2))) {
            doneP = T;
        }
        if (NIL == doneP) {
            SubLObject cdolist_list_var = set1;
            SubLObject elem = NIL;
            elem = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (!count(elem, set1, test, UNPROVIDED, UNPROVIDED, UNPROVIDED).eql(count(elem, set2, test, UNPROVIDED, UNPROVIDED, UNPROVIDED))) {
                    doneP = T;
                }
                cdolist_list_var = cdolist_list_var.rest();
                elem = cdolist_list_var.first();
            } 
        }
        if (NIL == doneP) {
            result = sets_equalP(set1, set2, test);
        }
        return result;
    }

    public static final SubLObject sets_equalP_alt(SubLObject set1, SubLObject set2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return makeBoolean(set1.equal(set2) || ((NIL != subsetp(set1, set2, test, UNPROVIDED)) && (NIL != subsetp(set2, set1, test, UNPROVIDED))));
    }

    public static SubLObject sets_equalP(final SubLObject set1, final SubLObject set2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return makeBoolean(set1.equal(set2) || ((NIL != subsetp(set1, set2, test, UNPROVIDED)) && (NIL != subsetp(set2, set1, test, UNPROVIDED))));
    }

    public static SubLObject member_via_sets_equalP(final SubLObject v_set, final SubLObject list_of_sets, SubLObject element_equality_test) {
        if (element_equality_test == UNPROVIDED) {
            element_equality_test = symbol_function(EQL);
        }
        SubLObject cdolist_list_var = list_of_sets;
        SubLObject other_set = NIL;
        other_set = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != sets_equalP(v_set, other_set, element_equality_test)) {
                return T;
            }
            cdolist_list_var = cdolist_list_var.rest();
            other_set = cdolist_list_var.first();
        } 
        return NIL;
    }

    public static SubLObject list_has_member_via_sets_equalP(final SubLObject list_of_sets, final SubLObject v_set, SubLObject element_equality_test) {
        if (element_equality_test == UNPROVIDED) {
            element_equality_test = symbol_function(EQL);
        }
        return member_via_sets_equalP(v_set, list_of_sets, element_equality_test);
    }

    public static SubLObject sets_equalp(final SubLObject set1, final SubLObject set2) {
        return sets_equalP(set1, set2, symbol_function(EQUALP));
    }

    public static final SubLObject fast_sets_equalP_alt(SubLObject set1, SubLObject set2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.fast_subsetP(set1, set2, test)) && (NIL != com.cyc.cycjava.cycl.list_utilities.fast_subsetP(set2, set1, test)));
    }

    public static SubLObject fast_sets_equalP(final SubLObject set1, final SubLObject set2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return makeBoolean((NIL != fast_subsetP(set1, set2, test)) && (NIL != fast_subsetP(set2, set1, test)));
    }

    public static final SubLObject fast_subsetP_alt(SubLObject list1, SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if ((NIL != com.cyc.cycjava.cycl.list_utilities.lengthL(list1, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)) && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthL(list2, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED))) {
                return subsetp(list1, list2, test, UNPROVIDED);
            } else {
                {
                    SubLObject length1 = length(list1);
                    SubLObject length2 = length(list2);
                    if (!length1.numLE(length2)) {
                        return NIL;
                    }
                    {
                        SubLObject hash2 = hash_table_utilities.hash_list_elements(list2, test, length2, UNPROVIDED);
                        SubLObject cdolist_list_var = list1;
                        SubLObject elem1 = NIL;
                        for (elem1 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem1 = cdolist_list_var.first()) {
                            if (NIL == gethash(elem1, hash2, UNPROVIDED)) {
                                return NIL;
                            }
                        }
                    }
                    return T;
                }
            }
        }
    }

    public static SubLObject fast_subsetP(final SubLObject list1, final SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL != lengthL(list1, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)) && (NIL != lengthL(list2, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED))) {
            return subsetp(list1, list2, test, UNPROVIDED);
        }
        final SubLObject length1 = length(list1);
        final SubLObject length2 = length(list2);
        if (!length1.numLE(length2)) {
            return NIL;
        }
        final SubLObject hash2 = hash_table_utilities.hash_list_elements(list2, test, length2, UNPROVIDED);
        SubLObject cdolist_list_var = list1;
        SubLObject elem1 = NIL;
        elem1 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == gethash(elem1, hash2, UNPROVIDED)) {
                return NIL;
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem1 = cdolist_list_var.first();
        } 
        return T;
    }

    public static final SubLObject fast_subset_equalP_alt(SubLObject list1, SubLObject list2) {
        return com.cyc.cycjava.cycl.list_utilities.fast_subsetP(list1, list2, symbol_function(EQUAL));
    }

    public static SubLObject fast_subset_equalP(final SubLObject list1, final SubLObject list2) {
        return fast_subsetP(list1, list2, symbol_function(EQUAL));
    }

    public static final SubLObject fast_supersetP_alt(SubLObject list1, SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return com.cyc.cycjava.cycl.list_utilities.fast_subsetP(list2, list1, test);
    }

    public static SubLObject fast_supersetP(final SubLObject list1, final SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return fast_subsetP(list2, list1, test);
    }

    public static final SubLObject fast_superset_equalP_alt(SubLObject list1, SubLObject list2) {
        return com.cyc.cycjava.cycl.list_utilities.fast_supersetP(list1, list2, symbol_function(EQUAL));
    }

    public static SubLObject fast_superset_equalP(final SubLObject list1, final SubLObject list2) {
        return fast_supersetP(list1, list2, symbol_function(EQUAL));
    }

    /**
     * Like @xref sets-equal? but explicitly uses the test #'equal instead of defaulting to #'eql.
     *
     * @unknown pace
     */
    @LispMethod(comment = "Like @xref sets-equal? but explicitly uses the test #\'equal instead of defaulting to #\'eql.\r\n\r\n@unknown pace")
    public static final SubLObject sets_equal_equalP_alt(SubLObject set1, SubLObject set2) {
        return makeBoolean((NIL != subsetp(set1, set2, symbol_function(EQUAL), UNPROVIDED)) && (NIL != subsetp(set2, set1, symbol_function(EQUAL), UNPROVIDED)));
    }

    @LispMethod(comment = "Like @xref sets-equal? but explicitly uses the test #\'equal instead of defaulting to #\'eql.\r\n\r\n@unknown pace")
    public static SubLObject sets_equal_equalP(final SubLObject set1, final SubLObject set2) {
        return makeBoolean((NIL != subsetp(set1, set2, symbol_function(EQUAL), UNPROVIDED)) && (NIL != subsetp(set2, set1, symbol_function(EQUAL), UNPROVIDED)));
    }/**
     * Like @xref sets-equal? but explicitly uses the test #'equal instead of defaulting to #'eql.
     *
     * @unknown pace
     */


    public static final SubLObject subsetp_equalP_alt(SubLObject small, SubLObject big, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return subsetp(small, big, symbol_function(EQUAL), key);
    }

    public static SubLObject subsetp_equalP(final SubLObject small, final SubLObject big, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return subsetp(small, big, symbol_function(EQUAL), key);
    }

    public static final SubLObject supersetp_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return subsetp(list2, list1, test, key);
    }

    public static SubLObject supersetp(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return subsetp(list2, list1, test, key);
    }

    public static final SubLObject set_differenceP_alt(SubLObject set1, SubLObject set2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject ans = NIL;
            if (NIL == ans) {
                {
                    SubLObject csome_list_var = set1;
                    SubLObject element = NIL;
                    for (element = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , element = csome_list_var.first()) {
                        ans = makeBoolean(NIL == subl_promotions.memberP(element, set2, test, key));
                    }
                }
            }
            return ans;
        }
    }

    public static SubLObject set_differenceP(final SubLObject set1, final SubLObject set2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject ans = NIL;
        if (NIL == ans) {
            SubLObject csome_list_var;
            SubLObject element;
            for (csome_list_var = set1, element = NIL, element = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = makeBoolean(NIL == subl_promotions.memberP(element, set2, test, key)) , csome_list_var = csome_list_var.rest() , element = csome_list_var.first()) {
            }
        }
        return ans;
    }

    public static final SubLObject tree_set_equalP_alt(SubLObject tree1, SubLObject tree2) {
        if (tree1.equal(tree2)) {
            return T;
        } else {
            if (tree1.isCons() && tree2.isCons()) {
                return com.cyc.cycjava.cycl.list_utilities.sets_equalP(tree1, tree2, $sym103$TREE_SET_EQUAL_);
            }
        }
        return NIL;
    }

    public static SubLObject tree_set_equalP(final SubLObject tree1, final SubLObject tree2) {
        if (tree1.equal(tree2)) {
            return T;
        }
        if (tree1.isCons() && tree2.isCons()) {
            return sets_equalP(tree1, tree2, $sym103$TREE_SET_EQUAL_);
        }
        return NIL;
    }

    public static final SubLObject ordered_merge_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject result = NIL;
            {
                SubLObject cdolist_list_var = list1;
                SubLObject element = NIL;
                for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                    {
                        SubLObject item_var = element;
                        if (NIL == member(item_var, result, test, key)) {
                            result = cons(item_var, result);
                        }
                    }
                }
            }
            {
                SubLObject cdolist_list_var = list2;
                SubLObject element = NIL;
                for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                    {
                        SubLObject item_var = element;
                        if (NIL == member(item_var, result, test, key)) {
                            result = cons(item_var, result);
                        }
                    }
                }
            }
            return nreverse(result);
        }
    }

    public static SubLObject ordered_merge(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = list1;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject item_var = element;
            if (NIL == member(item_var, result, test, key)) {
                result = cons(item_var, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        cdolist_list_var = list2;
        element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject item_var = element;
            if (NIL == member(item_var, result, test, key)) {
                result = cons(item_var, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    /**
     * like union only the result preserves the order of elements in the input sets
     */
    @LispMethod(comment = "like union only the result preserves the order of elements in the input sets")
    public static final SubLObject ordered_union_alt(SubLObject set1, SubLObject set2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject tail = NIL;
            SubLObject cdolist_list_var = set2;
            SubLObject element = NIL;
            for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                if (NIL == subl_promotions.memberP(element, set1, test, key)) {
                    tail = cons(element, tail);
                }
            }
            return append(set1, nreverse(tail));
        }
    }

    @LispMethod(comment = "like union only the result preserves the order of elements in the input sets")
    public static SubLObject ordered_union(final SubLObject set1, final SubLObject set2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject tail = NIL;
        SubLObject cdolist_list_var = set2;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == subl_promotions.memberP(element, set1, test, key)) {
                tail = cons(element, tail);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return append(set1, nreverse(tail));
    }/**
     * like union only the result preserves the order of elements in the input sets
     */


    public static final SubLObject union_all_alt(SubLObject list_of_sets, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject result = list_of_sets.first();
            SubLObject cdolist_list_var = list_of_sets.rest();
            SubLObject v_set = NIL;
            for (v_set = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , v_set = cdolist_list_var.first()) {
                result = union(v_set, result, test, key);
            }
            return result;
        }
    }

    public static SubLObject union_all(final SubLObject list_of_sets, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = list_of_sets.first();
        SubLObject cdolist_list_var = list_of_sets.rest();
        SubLObject v_set = NIL;
        v_set = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = union(v_set, result, test, key);
            cdolist_list_var = cdolist_list_var.rest();
            v_set = cdolist_list_var.first();
        } 
        return result;
    }

    /**
     * Like @xref set-difference except the order of returned items is the same order as in LIST1.
     */
    @LispMethod(comment = "Like @xref set-difference except the order of returned items is the same order as in LIST1.")
    public static final SubLObject ordered_set_difference_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = list1;
            SubLObject element = NIL;
            for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                if (NIL == subl_promotions.memberP(element, list2, test, key)) {
                    result = cons(element, result);
                }
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Like @xref set-difference except the order of returned items is the same order as in LIST1.")
    public static SubLObject ordered_set_difference(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = list1;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == subl_promotions.memberP(element, list2, test, key)) {
                result = cons(element, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return nreverse(result);
    }/**
     * Like @xref set-difference except the order of returned items is the same order as in LIST1.
     */


    /**
     * Like @xref set-difference except not slow.
     *
     * @unknown Pace
     */
    @LispMethod(comment = "Like @xref set-difference except not slow.\r\n\r\n@unknown Pace")
    public static final SubLObject hash_set_difference_alt(SubLObject list1, SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return hash_table_utilities.hash_existence_difference(hash_table_utilities.hash_list_elements(list1, test, UNPROVIDED, UNPROVIDED), hash_table_utilities.hash_list_elements(list2, test, UNPROVIDED, UNPROVIDED));
    }

    @LispMethod(comment = "Like @xref set-difference except not slow.\r\n\r\n@unknown Pace")
    public static SubLObject hash_set_difference(final SubLObject list1, final SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return hash_table_utilities.hash_existence_difference(hash_table_utilities.hash_list_elements(list1, test, UNPROVIDED, UNPROVIDED), hash_table_utilities.hash_list_elements(list2, test, UNPROVIDED, UNPROVIDED));
    }/**
     * Like @xref set-difference except not slow.
     *
     * @unknown Pace
     */


    /**
     * Like @xref set-difference except not slow.
     *
     * @unknown Pace
     */
    @LispMethod(comment = "Like @xref set-difference except not slow.\r\n\r\n@unknown Pace")
    public static final SubLObject fast_set_difference_alt(SubLObject list1, SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if ((NIL != com.cyc.cycjava.cycl.list_utilities.lengthLE(list1, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)) && (NIL != com.cyc.cycjava.cycl.list_utilities.lengthLE(list2, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED))) {
                return set_difference(list1, list2, test, UNPROVIDED);
            } else {
                return com.cyc.cycjava.cycl.list_utilities.hash_set_difference(list1, list2, test);
            }
        }
    }

    @LispMethod(comment = "Like @xref set-difference except not slow.\r\n\r\n@unknown Pace")
    public static SubLObject fast_set_difference(final SubLObject list1, final SubLObject list2, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL == hash_table_utilities.valid_hash_test_p(test)) || ((NIL != lengthLE(list1, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)) && (NIL != lengthLE(list2, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)))) {
            return set_difference(list1, list2, test, UNPROVIDED);
        }
        return hash_set_difference(list1, list2, test);
    }/**
     * Like @xref set-difference except not slow.
     *
     * @unknown Pace
     */


    /**
     *
     *
     * @param LIST
    list;
     * 		
     * @param PRED
    function-symbol;
     * 		
     * @param KEY
    function-symbol;
     * 		
     * @return listp; a sorted permutation of list, even if pred only defines a
    partial order, in which case the results of sort are unpredictably scrambled.
    More specifically: for each each element e1 of the sorted list, there is no
    element e2 to the left of the list such that (pred e2 e1) is true.
     * @unknown inefficient and not recommended for longer lists
     */
    @LispMethod(comment = "@param LIST\nlist;\r\n\t\t\r\n@param PRED\nfunction-symbol;\r\n\t\t\r\n@param KEY\nfunction-symbol;\r\n\t\t\r\n@return listp; a sorted permutation of list, even if pred only defines a\r\npartial order, in which case the results of sort are unpredictably scrambled.\r\nMore specifically: for each each element e1 of the sorted list, there is no\r\nelement e2 to the left of the list such that (pred e2 e1) is true.\r\n@unknown inefficient and not recommended for longer lists")
    public static final SubLObject partial_order_sort_alt(SubLObject list, SubLObject pred, SubLObject key) {
        if (key == UNPROVIDED) {
            key = IDENTITY;
        }
        SubLTrampolineFile.checkType(list, LISTP);
        SubLTrampolineFile.checkType(pred, FUNCTION_SYMBOL_P);
        SubLTrampolineFile.checkType(key, FUNCTION_SYMBOL_P);
        {
            SubLObject sorted = list(list.first());
            SubLObject insertedP = NIL;
            SubLObject cdolist_list_var = list.rest();
            SubLObject element = NIL;
            for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                if (NIL != funcall(pred, funcall(key, element), funcall(key, sorted.first()))) {
                    sorted = cons(element, sorted);
                    insertedP = T;
                } else {
                    insertedP = NIL;
                    {
                        SubLObject processed = NIL;
                        SubLObject remaining = NIL;
                        for (processed = NIL, remaining = sorted; !((NIL != insertedP) || (NIL == remaining)); processed = remaining , remaining = remaining.rest()) {
                            if (NIL != funcall(pred, funcall(key, element), funcall(key, remaining.first()))) {
                                rplacd(processed, cons(element, remaining));
                                insertedP = T;
                            }
                        }
                    }
                }
                if (NIL == insertedP) {
                    sorted = append(sorted, list(element));
                }
            }
            return sorted;
        }
    }

    /**
     *
     *
     * @param LIST
    list;
     * 		
     * @param PRED
    function-symbol;
     * 		
     * @param KEY
    function-symbol;
     * 		
     * @return listp; a sorted permutation of list, even if pred only defines a
    partial order, in which case the results of sort are unpredictably scrambled.
    More specifically: for each each element e1 of the sorted list, there is no
    element e2 to the left of the list such that (pred e2 e1) is true.
     * @unknown inefficient and not recommended for longer lists
     */
    @LispMethod(comment = "@param LIST\nlist;\r\n\t\t\r\n@param PRED\nfunction-symbol;\r\n\t\t\r\n@param KEY\nfunction-symbol;\r\n\t\t\r\n@return listp; a sorted permutation of list, even if pred only defines a\r\npartial order, in which case the results of sort are unpredictably scrambled.\r\nMore specifically: for each each element e1 of the sorted list, there is no\r\nelement e2 to the left of the list such that (pred e2 e1) is true.\r\n@unknown inefficient and not recommended for longer lists")
    public static SubLObject partial_order_sort(final SubLObject list, final SubLObject pred, SubLObject key) {
        if (key == UNPROVIDED) {
            key = IDENTITY;
        }
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        assert NIL != subl_promotions.function_symbol_p(pred) : "! subl_promotions.function_symbol_p(pred) " + ("subl_promotions.function_symbol_p(pred) " + "CommonSymbols.NIL != subl_promotions.function_symbol_p(pred) ") + pred;
        assert NIL != subl_promotions.function_symbol_p(key) : "! subl_promotions.function_symbol_p(key) " + ("subl_promotions.function_symbol_p(key) " + "CommonSymbols.NIL != subl_promotions.function_symbol_p(key) ") + key;
        if (NIL == list) {
            return NIL;
        }
        SubLObject sorted = list(list.first());
        SubLObject insertedP = NIL;
        SubLObject cdolist_list_var = list.rest();
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(pred, funcall(key, element), funcall(key, sorted.first()))) {
                sorted = cons(element, sorted);
                insertedP = T;
            } else {
                insertedP = NIL;
                SubLObject processed = NIL;
                SubLObject remaining = NIL;
                processed = NIL;
                for (remaining = sorted; (NIL == insertedP) && (NIL != remaining); remaining = remaining.rest()) {
                    if (NIL != funcall(pred, funcall(key, element), funcall(key, remaining.first()))) {
                        rplacd(processed, cons(element, remaining));
                        insertedP = T;
                    }
                    processed = remaining;
                }
            }
            if (NIL == insertedP) {
                sorted = append(sorted, list(element));
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return sorted;
    }

    /**
     *
     *
     * @return vector; a vector with the same elements as LIST
     * @unknown like (apply #'vector list), but works for very long lists without stack overflow
     */
    @LispMethod(comment = "@return vector; a vector with the same elements as LIST\r\n@unknown like (apply #\'vector list), but works for very long lists without stack overflow")
    public static final SubLObject list2vector_alt(SubLObject list) {
        SubLTrampolineFile.checkType(list, LISTP);
        {
            SubLObject vector = make_vector(length(list), UNPROVIDED);
            SubLObject list_var = NIL;
            SubLObject elem = NIL;
            SubLObject i = NIL;
            for (list_var = list, elem = list_var.first(), i = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , elem = list_var.first() , i = add(ONE_INTEGER, i)) {
                set_aref(vector, i, elem);
            }
            return vector;
        }
    }

    /**
     *
     *
     * @return vector; a vector with the same elements as LIST
     * @unknown like (apply #'vector list), but works for very long lists without stack overflow
     */
    @LispMethod(comment = "@return vector; a vector with the same elements as LIST\r\n@unknown like (apply #\'vector list), but works for very long lists without stack overflow")
    public static SubLObject list2vector(final SubLObject list) {
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        final SubLObject vector = make_vector(length(list), UNPROVIDED);
        SubLObject list_var = NIL;
        SubLObject elem = NIL;
        SubLObject i = NIL;
        list_var = list;
        elem = list_var.first();
        for (i = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , elem = list_var.first() , i = add(ONE_INTEGER, i)) {
            set_aref(vector, i, elem);
        }
        return vector;
    }

    public static final SubLObject vector2list_alt(SubLObject vector) {
        {
            SubLObject l = NIL;
            SubLObject vector_var = vector;
            SubLObject backwardP_var = T;
            SubLObject length = length(vector_var);
            SubLObject v_iteration = NIL;
            for (v_iteration = ZERO_INTEGER; v_iteration.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
                {
                    SubLObject element_num = (NIL != backwardP_var) ? ((SubLObject) (subtract(length, v_iteration, ONE_INTEGER))) : v_iteration;
                    SubLObject elt = aref(vector_var, element_num);
                    l = cons(elt, l);
                }
            }
            return l;
        }
    }

    public static SubLObject vector2list(final SubLObject vector) {
        SubLObject l = NIL;
        final SubLObject backwardP_var = T;
        SubLObject length;
        SubLObject v_iteration;
        SubLObject element_num;
        SubLObject elt;
        for (length = length(vector), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
            element_num = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER) : v_iteration;
            elt = aref(vector, element_num);
            l = cons(elt, l);
        }
        return l;
    }

    public static SubLObject vector2list_reversible(final SubLObject vector, SubLObject marker) {
        if (marker == UNPROVIDED) {
            marker = $listified_vector_marker$.getDynamicValue();
        }
        return cons(marker, vector2list(vector));
    }

    public static SubLObject listified_vector2vector(final SubLObject listified_vector, SubLObject marker) {
        if (marker == UNPROVIDED) {
            marker = $listified_vector_marker$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (!listified_vector.first().eql(marker))) {
            Errors.error($str106$_S_is_not_a_listified_vector_mark, listified_vector, marker);
        }
        return list2vector(listified_vector.rest());
    }

    public static final SubLObject list_without_repetition_p_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(list, LISTP);
        return makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.duplicatesP(list, test, key));
    }

    public static SubLObject list_without_repetition_p(final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        return makeBoolean(NIL == duplicatesP(list, test, key));
    }

    /**
     *
     *
     * @param SEQUENCE
    sequencep
     * 		
     * @param POSITIONS
     * 		list of non-negative-integer-p
     * @return sequencep ; a new sequence of the same type as SEQUENCE.
    Elements in the new sequence are, in order, the items at POSITIONS in SEQUENCE.
     */
    @LispMethod(comment = "@param SEQUENCE\nsequencep\r\n\t\t\r\n@param POSITIONS\r\n\t\tlist of non-negative-integer-p\r\n@return sequencep ; a new sequence of the same type as SEQUENCE.\r\nElements in the new sequence are, in order, the items at POSITIONS in SEQUENCE.")
    public static final SubLObject sequence_elements_alt(SubLObject sequence, SubLObject positions) {
        SubLTrampolineFile.checkType(sequence, SEQUENCEP);
        if (sequence.isList()) {
            {
                SubLObject elements = NIL;
                SubLObject cdolist_list_var = positions;
                SubLObject position = NIL;
                for (position = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , position = cdolist_list_var.first()) {
                    elements = cons(nth(position, sequence), elements);
                }
                return nreverse(elements);
            }
        } else {
            if (sequence.isVector()) {
                {
                    SubLObject elements = make_vector(length(positions), UNPROVIDED);
                    SubLObject list_var = NIL;
                    SubLObject position = NIL;
                    SubLObject index = NIL;
                    for (list_var = positions, position = list_var.first(), index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , position = list_var.first() , index = add(ONE_INTEGER, index)) {
                        set_aref(elements, index, aref(sequence, position));
                    }
                    return elements;
                }
            } else {
                {
                    SubLObject elements = Strings.make_string(length(positions), UNPROVIDED);
                    SubLObject list_var = NIL;
                    SubLObject position = NIL;
                    SubLObject index = NIL;
                    for (list_var = positions, position = list_var.first(), index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , position = list_var.first() , index = add(ONE_INTEGER, index)) {
                        Strings.set_char(elements, index, Strings.sublisp_char(sequence, position));
                    }
                    return elements;
                }
            }
        }
    }

    /**
     *
     *
     * @param SEQUENCE
    sequencep
     * 		
     * @param POSITIONS
     * 		list of non-negative-integer-p
     * @return sequencep ; a new sequence of the same type as SEQUENCE.
    Elements in the new sequence are, in order, the items at POSITIONS in SEQUENCE.
     */
    @LispMethod(comment = "@param SEQUENCE\nsequencep\r\n\t\t\r\n@param POSITIONS\r\n\t\tlist of non-negative-integer-p\r\n@return sequencep ; a new sequence of the same type as SEQUENCE.\r\nElements in the new sequence are, in order, the items at POSITIONS in SEQUENCE.")
    public static SubLObject sequence_elements(final SubLObject sequence, final SubLObject positions) {
        assert NIL != sequencep(sequence) : "! sequencep(sequence) " + ("Types.sequencep(sequence) " + "CommonSymbols.NIL != Types.sequencep(sequence) ") + sequence;
        if (sequence.isList()) {
            SubLObject elements = NIL;
            SubLObject cdolist_list_var = positions;
            SubLObject position = NIL;
            position = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                elements = cons(nth(position, sequence), elements);
                cdolist_list_var = cdolist_list_var.rest();
                position = cdolist_list_var.first();
            } 
            return nreverse(elements);
        }
        if (sequence.isVector()) {
            final SubLObject elements = make_vector(length(positions), UNPROVIDED);
            SubLObject list_var = NIL;
            SubLObject position = NIL;
            SubLObject index = NIL;
            list_var = positions;
            position = list_var.first();
            for (index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , position = list_var.first() , index = add(ONE_INTEGER, index)) {
                set_aref(elements, index, aref(sequence, position));
            }
            return elements;
        }
        final SubLObject elements = Strings.make_string(length(positions), UNPROVIDED);
        SubLObject list_var = NIL;
        SubLObject position = NIL;
        SubLObject index = NIL;
        list_var = positions;
        position = list_var.first();
        for (index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , position = list_var.first() , index = add(ONE_INTEGER, index)) {
            Strings.set_char(elements, index, Strings.sublisp_char(sequence, position));
        }
        return elements;
    }

    /**
     *
     *
     * @return the list of forts in FORTS-1 that are not in FORTS-2
     */
    @LispMethod(comment = "@return the list of forts in FORTS-1 that are not in FORTS-2")
    public static final SubLObject set_difference_forts_alt(SubLObject forts_1, SubLObject forts_2) {
        return com.cyc.cycjava.cycl.list_utilities.fast_set_difference(forts_1, forts_2, UNPROVIDED);
    }

    /**
     *
     *
     * @return the list of forts in FORTS-1 that are not in FORTS-2
     */
    @LispMethod(comment = "@return the list of forts in FORTS-1 that are not in FORTS-2")
    public static SubLObject set_difference_forts(final SubLObject forts_1, final SubLObject forts_2) {
        return fast_set_difference(forts_1, forts_2, UNPROVIDED);
    }

    /**
     * Like intersection, except that the order of intersecting elements in list1
     * is guaranteed to be preserved.  Highly inefficient, but sometimes useful.
     */
    @LispMethod(comment = "Like intersection, except that the order of intersecting elements in list1\r\nis guaranteed to be preserved.  Highly inefficient, but sometimes useful.\nLike intersection, except that the order of intersecting elements in list1\nis guaranteed to be preserved.  Highly inefficient, but sometimes useful.")
    public static final SubLObject ordered_intersection_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = list1;
            SubLObject element = NIL;
            for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                if (NIL != find(element, list2, test, key, UNPROVIDED, UNPROVIDED)) {
                    result = cons(element, result);
                }
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Like intersection, except that the order of intersecting elements in list1\r\nis guaranteed to be preserved.  Highly inefficient, but sometimes useful.\nLike intersection, except that the order of intersecting elements in list1\nis guaranteed to be preserved.  Highly inefficient, but sometimes useful.")
    public static SubLObject ordered_intersection(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = list1;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != find(element, list2, test, key, UNPROVIDED, UNPROVIDED)) {
                result = cons(element, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return nreverse(result);
    }/**
     * Like intersection, except that the order of intersecting elements in list1
     * is guaranteed to be preserved.  Highly inefficient, but sometimes useful.
     */


    public static final SubLObject intersect_all_alt(SubLObject lists, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject result = lists.first();
            SubLObject cdolist_list_var = lists.rest();
            SubLObject list_i = NIL;
            for (list_i = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list_i = cdolist_list_var.first()) {
                result = intersection(result, list_i, test, key);
            }
            return result;
        }
    }

    public static SubLObject intersect_all(final SubLObject lists, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = lists.first();
        SubLObject cdolist_list_var = lists.rest();
        SubLObject list_i = NIL;
        list_i = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = intersection(result, list_i, test, key);
            cdolist_list_var = cdolist_list_var.rest();
            list_i = cdolist_list_var.first();
        } 
        return result;
    }

    /**
     *
     *
     * @return listp: the intersection of the lists in LISTS
    Like @xref INTERSECTION except that it takes a list of lists instead of two lists.
     */
    @LispMethod(comment = "@return listp: the intersection of the lists in LISTS\r\nLike @xref INTERSECTION except that it takes a list of lists instead of two lists.")
    public static final SubLObject fast_intersect_all_alt(SubLObject lists, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject sets = NIL;
            SubLObject cdolist_list_var = lists;
            SubLObject list = NIL;
            for (list = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list = cdolist_list_var.first()) {
                {
                    SubLObject transformed_list = ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) ? ((SubLObject) (list)) : Mapping.mapcar(key, list);
                    sets = cons(set_utilities.construct_set_from_list(transformed_list, test, UNPROVIDED), sets);
                }
            }
            return set.set_element_list(set_utilities.set_intersection(sets, test));
        }
    }

    /**
     *
     *
     * @return listp: the intersection of the lists in LISTS
    Like @xref INTERSECTION except that it takes a list of lists instead of two lists.
     */
    @LispMethod(comment = "@return listp: the intersection of the lists in LISTS\r\nLike @xref INTERSECTION except that it takes a list of lists instead of two lists.")
    public static SubLObject fast_intersect_all(final SubLObject lists, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject sets = NIL;
        SubLObject cdolist_list_var = lists;
        SubLObject list = NIL;
        list = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject transformed_list = (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) ? list : Mapping.mapcar(key, list);
            sets = cons(set_utilities.construct_set_from_list(transformed_list, test, UNPROVIDED), sets);
            cdolist_list_var = cdolist_list_var.rest();
            list = cdolist_list_var.first();
        } 
        return set.set_element_list(set_utilities.set_intersection(sets, test));
    }

    public static final SubLObject safe_pairlis_alt(SubLObject keys, SubLObject data) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.same_length_p(keys, data)) {
            return pairlis(keys, data, UNPROVIDED);
        }
        return NIL;
    }

    public static SubLObject safe_pairlis(final SubLObject keys, final SubLObject data) {
        if (NIL != same_length_p(keys, data)) {
            return pairlis(keys, data, UNPROVIDED);
        }
        return NIL;
    }

    public static final SubLObject flip_alist_alt(SubLObject alist) {
        return Mapping.mapcar(FLIP_CONS, alist);
    }

    public static SubLObject flip_alist(final SubLObject alist) {
        return Mapping.mapcar(FLIP_CONS, alist);
    }

    public static final SubLObject flip_cons_alt(SubLObject cons) {
        return cons(cons.rest(), cons.first());
    }

    public static SubLObject flip_cons(final SubLObject cons) {
        return cons(cons.rest(), cons.first());
    }

    public static final SubLObject flip_doubleton_alt(SubLObject doubleton) {
        return list(second(doubleton), doubleton.first());
    }

    public static SubLObject flip_doubleton(final SubLObject doubleton) {
        return list(second(doubleton), doubleton.first());
    }

    public static final SubLObject substitute_sequence_alt(SubLObject new_seq, SubLObject old_seq, SubLObject sequence) {
        {
            SubLObject old_seq_position = search(old_seq, sequence, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            if (NIL != old_seq_position) {
                return com.cyc.cycjava.cycl.list_utilities.substitute_sequence_1(new_seq, old_seq, old_seq_position, sequence);
            } else {
                return sequence;
            }
        }
    }

    public static SubLObject substitute_sequence(final SubLObject new_seq, final SubLObject old_seq, final SubLObject sequence) {
        final SubLObject old_seq_position = search(old_seq, sequence, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        if (NIL != old_seq_position) {
            return substitute_sequence_1(new_seq, old_seq, old_seq_position, sequence);
        }
        return sequence;
    }

    public static final SubLObject substitute_sequence_1_alt(SubLObject new_seq, SubLObject old_seq, SubLObject old_seq_position, SubLObject sequence) {
        {
            SubLObject old_seq_length = length(old_seq);
            if (old_seq_position.numG(ZERO_INTEGER)) {
                rplacd(nthcdr(subtract(old_seq_position, ONE_INTEGER), sequence), append(new_seq, nthcdr(add(old_seq_position, old_seq_length), sequence)));
                return com.cyc.cycjava.cycl.list_utilities.substitute_sequence(new_seq, old_seq, sequence);
            } else {
                return com.cyc.cycjava.cycl.list_utilities.substitute_sequence(new_seq, old_seq, append(new_seq, nthcdr(add(old_seq_position, old_seq_length), sequence)));
            }
        }
    }

    public static SubLObject substitute_sequence_1(final SubLObject new_seq, final SubLObject old_seq, final SubLObject old_seq_position, final SubLObject sequence) {
        final SubLObject old_seq_length = length(old_seq);
        if (old_seq_position.numG(ZERO_INTEGER)) {
            rplacd(nthcdr(subtract(old_seq_position, ONE_INTEGER), sequence), append(new_seq, nthcdr(add(old_seq_position, old_seq_length), sequence)));
            return substitute_sequence(new_seq, old_seq, sequence);
        }
        return substitute_sequence(new_seq, old_seq, append(new_seq, nthcdr(add(old_seq_position, old_seq_length), sequence)));
    }

    /**
     * Return two values: the elements in list1 not in list2, and the elements in list2 not in list1.
     *
     * @unknown duplicates in either list are supported (i.e. this is not 2 x set-difference)
     * @unknown (compare-lists '(1 3 3 4 4 5 6 6) '(2 3 3 4 5 5 7 7)) -> (1 4 6 6) (2 5 7 7)
     * @unknown (compare-lists '((:a 1) (:b 2) (:c 3) (:c 4)) '((:b 5) (:c 6) (:d 7)) #'equal #'car) -> ((:A 1) (:C 4)) ((:D 7))
     */
    @LispMethod(comment = "Return two values: the elements in list1 not in list2, and the elements in list2 not in list1.\r\n\r\n@unknown duplicates in either list are supported (i.e. this is not 2 x set-difference)\r\n@unknown (compare-lists \'(1 3 3 4 4 5 6 6) \'(2 3 3 4 5 5 7 7)) -> (1 4 6 6) (2 5 7 7)\r\n@unknown (compare-lists \'((:a 1) (:b 2) (:c 3) (:c 4)) \'((:b 5) (:c 6) (:d 7)) #\'equal #\'car) -> ((:A 1) (:C 4)) ((:D 7))")
    public static final SubLObject compare_lists_alt(SubLObject list1, SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL == list1) {
                return values(NIL, list2);
            } else {
                if (NIL == list2) {
                    return values(list1, NIL);
                } else {
                    if (NIL != member(funcall(key, list1.first()), list2, test, key)) {
                        return com.cyc.cycjava.cycl.list_utilities.compare_lists(list1.rest(), remove(funcall(key, list1.first()), list2, test, key, ZERO_INTEGER, NIL, ONE_INTEGER), test, key);
                    } else {
                        thread.resetMultipleValues();
                        {
                            SubLObject list1_extras = com.cyc.cycjava.cycl.list_utilities.compare_lists(list1.rest(), list2, test, key);
                            SubLObject list2_extras = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            return values(cons(list1.first(), list1_extras), list2_extras);
                        }
                    }
                }
            }
        }
    }

    @LispMethod(comment = "Return two values: the elements in list1 not in list2, and the elements in list2 not in list1.\r\n\r\n@unknown duplicates in either list are supported (i.e. this is not 2 x set-difference)\r\n@unknown (compare-lists \'(1 3 3 4 4 5 6 6) \'(2 3 3 4 5 5 7 7)) -> (1 4 6 6) (2 5 7 7)\r\n@unknown (compare-lists \'((:a 1) (:b 2) (:c 3) (:c 4)) \'((:b 5) (:c 6) (:d 7)) #\'equal #\'car) -> ((:A 1) (:C 4)) ((:D 7))")
    public static SubLObject compare_lists(final SubLObject list1, final SubLObject list2, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (NIL == list1) {
            return subl_promotions.values2(NIL, list2);
        }
        if (NIL == list2) {
            return subl_promotions.values2(list1, NIL);
        }
        if (NIL != member(funcall(key, list1.first()), list2, test, key)) {
            return compare_lists(list1.rest(), remove(funcall(key, list1.first()), list2, test, key, ZERO_INTEGER, NIL, ONE_INTEGER), test, key);
        }
        thread.resetMultipleValues();
        final SubLObject list1_extras = compare_lists(list1.rest(), list2, test, key);
        final SubLObject list2_extras = thread.secondMultipleValue();
        thread.resetMultipleValues();
        return subl_promotions.values2(cons(list1.first(), list1_extras), list2_extras);
    }/**
     * Return two values: the elements in list1 not in list2, and the elements in list2 not in list1.
     *
     * @unknown duplicates in either list are supported (i.e. this is not 2 x set-difference)
     * @unknown (compare-lists '(1 3 3 4 4 5 6 6) '(2 3 3 4 5 5 7 7)) -> (1 4 6 6) (2 5 7 7)
     * @unknown (compare-lists '((:a 1) (:b 2) (:c 3) (:c 4)) '((:b 5) (:c 6) (:d 7)) #'equal #'car) -> ((:A 1) (:C 4)) ((:D 7))
     */


    /**
     * Return the unique position at which lists differ, or else NIL
     */
    @LispMethod(comment = "Return the unique position at which lists differ, or else NIL")
    public static final SubLObject unique_difference_among_lists_alt(SubLObject lists) {
        if (!length(lists).numG(ONE_INTEGER)) {
            return NIL;
        }
        {
            SubLObject list1 = lists.first();
            SubLObject rest = lists.rest();
            SubLObject position = NIL;
            SubLObject cdolist_list_var = rest;
            SubLObject list2 = NIL;
            for (list2 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list2 = cdolist_list_var.first()) {
                {
                    SubLObject new_position = com.cyc.cycjava.cycl.list_utilities.unique_difference_between_lists(list1, list2);
                    if (NIL == new_position) {
                        return NIL;
                    }
                    if (NIL == position) {
                        position = new_position;
                    } else {
                        if (!new_position.equal(position)) {
                            return NIL;
                        }
                    }
                }
            }
            return position;
        }
    }

    @LispMethod(comment = "Return the unique position at which lists differ, or else NIL")
    public static SubLObject unique_difference_among_lists(final SubLObject lists) {
        if (!length(lists).numG(ONE_INTEGER)) {
            return NIL;
        }
        final SubLObject list1 = lists.first();
        final SubLObject rest = lists.rest();
        SubLObject position = NIL;
        SubLObject cdolist_list_var = rest;
        SubLObject list2 = NIL;
        list2 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject new_position = unique_difference_between_lists(list1, list2);
            if (NIL == new_position) {
                return NIL;
            }
            if (NIL == position) {
                position = new_position;
            } else
                if (!new_position.equal(position)) {
                    return NIL;
                }

            cdolist_list_var = cdolist_list_var.rest();
            list2 = cdolist_list_var.first();
        } 
        return position;
    }/**
     * Return the unique position at which lists differ, or else NIL
     */


    /**
     * Return the unique position at which lists 1 and 2 differ, or else NIL
     */
    @LispMethod(comment = "Return the unique position at which lists 1 and 2 differ, or else NIL")
    public static final SubLObject unique_difference_between_lists_alt(SubLObject list1, SubLObject list2) {
        if (!length(list1).equal(length(list2))) {
            return NIL;
        }
        {
            SubLObject differences = NIL;
            SubLObject index = ZERO_INTEGER;
            SubLObject elt1 = NIL;
            SubLObject elt1_21 = NIL;
            SubLObject elt2 = NIL;
            SubLObject elt2_22 = NIL;
            for (elt1 = list1, elt1_21 = elt1.first(), elt2 = list2, elt2_22 = elt2.first(); !((NIL == elt2) && (NIL == elt1)); elt1 = elt1.rest() , elt1_21 = elt1.first() , elt2 = elt2.rest() , elt2_22 = elt2.first()) {
                if (!elt1_21.equal(elt2_22)) {
                    differences = cons(index, differences);
                }
                if (length(differences).numG(ONE_INTEGER)) {
                    return NIL;
                }
                index = add(index, ONE_INTEGER);
            }
            if (NIL != differences) {
                return differences.first();
            } else {
                return NIL;
            }
        }
    }

    @LispMethod(comment = "Return the unique position at which lists 1 and 2 differ, or else NIL")
    public static SubLObject unique_difference_between_lists(final SubLObject list1, final SubLObject list2) {
        if (!length(list1).equal(length(list2))) {
            return NIL;
        }
        SubLObject differences = NIL;
        SubLObject index = ZERO_INTEGER;
        SubLObject elt1 = NIL;
        SubLObject elt1_$23 = NIL;
        SubLObject elt2 = NIL;
        SubLObject elt2_$24 = NIL;
        elt1 = list1;
        elt1_$23 = elt1.first();
        elt2 = list2;
        elt2_$24 = elt2.first();
        while ((NIL != elt2) || (NIL != elt1)) {
            if (!elt1_$23.equal(elt2_$24)) {
                differences = cons(index, differences);
            }
            if (length(differences).numG(ONE_INTEGER)) {
                return NIL;
            }
            index = add(index, ONE_INTEGER);
            elt1 = elt1.rest();
            elt1_$23 = elt1.first();
            elt2 = elt2.rest();
            elt2_$24 = elt2.first();
        } 
        if (NIL != differences) {
            return differences.first();
        }
        return NIL;
    }/**
     * Return the unique position at which lists 1 and 2 differ, or else NIL
     */


    /**
     * Replace every occurrence of old-sublist in list with new-sublist
     * and return the modified list.
     */
    @LispMethod(comment = "Replace every occurrence of old-sublist in list with new-sublist\r\nand return the modified list.\nReplace every occurrence of old-sublist in list with new-sublist\nand return the modified list.")
    public static final SubLObject list_subst_alt(SubLObject new_sublist, SubLObject old_sublist, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (old_sublist.equalp(NIL)) {
            return list;
        } else {
            {
                SubLObject slen = length(list);
                SubLObject olen = length(old_sublist);
                SubLObject index = search(old_sublist, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                SubLObject front = (NIL != index) ? ((SubLObject) (subseq(list, ZERO_INTEGER, index))) : NIL;
                SubLObject rest = (NIL != index) ? ((SubLObject) (subseq(list, add(olen, index), slen))) : list;
                if (NIL != index) {
                    return append(front, new_sublist, com.cyc.cycjava.cycl.list_utilities.list_subst(new_sublist, old_sublist, rest, UNPROVIDED));
                } else {
                    return list;
                }
            }
        }
    }

    @LispMethod(comment = "Replace every occurrence of old-sublist in list with new-sublist\r\nand return the modified list.\nReplace every occurrence of old-sublist in list with new-sublist\nand return the modified list.")
    public static SubLObject list_subst(final SubLObject new_sublist, final SubLObject old_sublist, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (old_sublist.equalp(NIL)) {
            return subl_promotions.values2(list, T);
        }
        final SubLObject slen = length(list);
        final SubLObject olen = length(old_sublist);
        final SubLObject index = search(old_sublist, list, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        final SubLObject front = (NIL != index) ? subseq(list, ZERO_INTEGER, index) : NIL;
        final SubLObject rest = (NIL != index) ? subseq(list, add(olen, index), slen) : list;
        if (NIL != index) {
            return subl_promotions.values2(append(front, new_sublist, list_subst(new_sublist, old_sublist, rest, UNPROVIDED)), T);
        }
        return subl_promotions.values2(list, NIL);
    }/**
     * Replace every occurrence of old-sublist in list with new-sublist
     * and return the modified list.
     */


    public static SubLObject list_subst_all_in_tree(final SubLObject new_sublist, final SubLObject old_sublist, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = copy_tree(list);
        SubLObject replacedP = NIL;
        SubLObject list_var = NIL;
        SubLObject sub_list = NIL;
        SubLObject n = NIL;
        list_var = result;
        sub_list = list_var.first();
        for (n = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , sub_list = list_var.first() , n = add(ONE_INTEGER, n)) {
            if (sub_list.isList()) {
                thread.resetMultipleValues();
                final SubLObject new_sub_list = list_subst_all_in_tree(new_sublist, old_sublist, sub_list, test);
                final SubLObject sub_replacedP = thread.secondMultipleValue();
                thread.resetMultipleValues();
                if (NIL != sub_replacedP) {
                    replacedP = T;
                    result = replace_nth(n, new_sub_list, result);
                }
            }
        }
        thread.resetMultipleValues();
        final SubLObject new_result = list_subst(new_sublist, old_sublist, result, test);
        final SubLObject outer_replacedP = thread.secondMultipleValue();
        thread.resetMultipleValues();
        if (NIL != outer_replacedP) {
            replacedP = T;
            result = new_result;
        }
        return values(result, replacedP);
    }

    public static SubLObject subseq_subst(final SubLObject replacement, final SubLObject sequence, final SubLObject start, SubLObject end) {
        if (end == UNPROVIDED) {
            end = length(sequence);
        }
        return append(subseq(sequence, ZERO_INTEGER, start), replacement, subseq(sequence, end, UNPROVIDED));
    }

    /**
     * Return T iff evaluation of OBJECT necessarily returns OBJECT.
     */
    @LispMethod(comment = "Return T iff evaluation of OBJECT necessarily returns OBJECT.")
    public static final SubLObject self_evaluating_form_p_alt(SubLObject v_object) {
        return makeBoolean(v_object.isAtom() && ((((NIL == v_object) || (T == v_object)) || v_object.isKeyword()) || (!v_object.isSymbol())));
    }

    @LispMethod(comment = "Return T iff evaluation of OBJECT necessarily returns OBJECT.")
    public static SubLObject self_evaluating_form_p(final SubLObject v_object) {
        return makeBoolean(v_object.isAtom() && ((((NIL == v_object) || (T == v_object)) || v_object.isKeyword()) || (!v_object.isSymbol())));
    }/**
     * Return T iff evaluation of OBJECT necessarily returns OBJECT.
     */


    /**
     * Return T iff OBJECT is a quoted form.
     */
    @LispMethod(comment = "Return T iff OBJECT is a quoted form.")
    public static final SubLObject quote_form_p_alt(SubLObject v_object) {
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.doubletonP(v_object)) && (QUOTE == v_object.first()));
    }

    @LispMethod(comment = "Return T iff OBJECT is a quoted form.")
    public static SubLObject quote_form_p(final SubLObject v_object) {
        return makeBoolean((NIL != doubletonP(v_object)) && (QUOTE == v_object.first()));
    }/**
     * Return T iff OBJECT is a quoted form.
     */


    /**
     * Return T iff OBJECT is known to not have side-effects when evaluated.
     */
    @LispMethod(comment = "Return T iff OBJECT is known to not have side-effects when evaluated.")
    public static final SubLObject non_side_effecting_form_p_alt(SubLObject v_object) {
        return makeBoolean(v_object.isAtom() || (NIL != com.cyc.cycjava.cycl.list_utilities.quote_form_p(v_object)));
    }

    @LispMethod(comment = "Return T iff OBJECT is known to not have side-effects when evaluated.")
    public static SubLObject non_side_effecting_form_p(final SubLObject v_object) {
        return makeBoolean(v_object.isAtom() || (NIL != quote_form_p(v_object)));
    }/**
     * Return T iff OBJECT is known to not have side-effects when evaluated.
     */


    /**
     * Return an expression which, if evaluated, would return OBJECT.
     */
    @LispMethod(comment = "Return an expression which, if evaluated, would return OBJECT.")
    public static final SubLObject quotify_alt(SubLObject v_object) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.self_evaluating_form_p(v_object)) {
            return v_object;
        } else {
            return list(QUOTE, v_object);
        }
    }

    @LispMethod(comment = "Return an expression which, if evaluated, would return OBJECT.")
    public static SubLObject quotify(final SubLObject v_object) {
        if (NIL != self_evaluating_form_p(v_object)) {
            return v_object;
        }
        return list(QUOTE, v_object);
    }/**
     * Return an expression which, if evaluated, would return OBJECT.
     */


    /**
     * If OBJECT is of the form '<foo>, return <foo> else OBJECT
     */
    @LispMethod(comment = "If OBJECT is of the form \'<foo>, return <foo> else OBJECT")
    public static final SubLObject unquotify_alt(SubLObject v_object) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.quote_form_p(v_object)) {
            return second(v_object);
        } else {
            return v_object;
        }
    }

    @LispMethod(comment = "If OBJECT is of the form \'<foo>, return <foo> else OBJECT")
    public static SubLObject unquotify(final SubLObject v_object) {
        if (NIL != quote_form_p(v_object)) {
            return second(v_object);
        }
        return v_object;
    }/**
     * If OBJECT is of the form '<foo>, return <foo> else OBJECT
     */


    public static final SubLObject sort_adjoin_alt(SubLObject item, SubLObject sorted_list, SubLObject test, SubLObject predicate, SubLObject key) {
        if (test == UNPROVIDED) {
            test = $sym107$STRING_;
        }
        if (predicate == UNPROVIDED) {
            predicate = $sym108$STRING_;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(SYMBOL_NAME);
        }
        if ((key == symbol_function(SYMBOL_NAME)) || (key == SYMBOL_NAME)) {
            if (NIL == sorted_list) {
                return list(item);
            } else {
                if (NIL != funcall(test, symbol_name(item), symbol_name(sorted_list.first()))) {
                    return sorted_list;
                } else {
                    if (NIL != funcall(predicate, symbol_name(item), symbol_name(sorted_list.first()))) {
                        return cons(item, sorted_list);
                    } else {
                        return cons(sorted_list.first(), com.cyc.cycjava.cycl.list_utilities.sort_adjoin(item, sorted_list.rest(), test, predicate, UNPROVIDED));
                    }
                }
            }
        } else {
            if (NIL == sorted_list) {
                return list(item);
            } else {
                if (NIL != funcall(test, funcall(key, item), funcall(key, sorted_list.first()))) {
                    return sorted_list;
                } else {
                    if (NIL != funcall(predicate, funcall(key, item), funcall(key, sorted_list.first()))) {
                        return cons(item, sorted_list);
                    } else {
                        return cons(sorted_list.first(), com.cyc.cycjava.cycl.list_utilities.sort_adjoin(item, sorted_list.rest(), test, predicate, key));
                    }
                }
            }
        }
    }

    public static SubLObject sort_adjoin(final SubLObject item, final SubLObject sorted_list, SubLObject test, SubLObject predicate, SubLObject key) {
        if (test == UNPROVIDED) {
            test = $sym109$STRING_;
        }
        if (predicate == UNPROVIDED) {
            predicate = $sym110$STRING_;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(SYMBOL_NAME);
        }
        if (key.eql(symbol_function(SYMBOL_NAME)) || (key == SYMBOL_NAME)) {
            if (NIL == sorted_list) {
                return list(item);
            }
            if (NIL != funcall(test, symbol_name(item), symbol_name(sorted_list.first()))) {
                return sorted_list;
            }
            if (NIL != funcall(predicate, symbol_name(item), symbol_name(sorted_list.first()))) {
                return cons(item, sorted_list);
            }
            return cons(sorted_list.first(), sort_adjoin(item, sorted_list.rest(), test, predicate, UNPROVIDED));
        } else {
            if (NIL == sorted_list) {
                return list(item);
            }
            if (NIL != funcall(test, funcall(key, item), funcall(key, sorted_list.first()))) {
                return sorted_list;
            }
            if (NIL != funcall(predicate, funcall(key, item), funcall(key, sorted_list.first()))) {
                return cons(item, sorted_list);
            }
            return cons(sorted_list.first(), sort_adjoin(item, sorted_list.rest(), test, predicate, key));
        }
    }

    /**
     * Adds ITEM to SORTED-LIST in a way that preserves its ``sortedness'' according to PREDICATE and KEY.
     *
     * @unknown @xref SORTED-ADD-TO-LIST differs from @xref SORT-ADJOIN in not treating its list argument as
    a set, thereby allowing duplicates.
     */
    @LispMethod(comment = "Adds ITEM to SORTED-LIST in a way that preserves its ``sortedness\'\' according to PREDICATE and KEY.\r\n\r\n@unknown @xref SORTED-ADD-TO-LIST differs from @xref SORT-ADJOIN in not treating its list argument as\r\na set, thereby allowing duplicates.")
    public static final SubLObject sorted_add_to_list_alt(SubLObject item, SubLObject sorted_list, SubLObject predicate, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.splice_into_sorted_list(item, sorted_list, predicate, key);
    }

    @LispMethod(comment = "Adds ITEM to SORTED-LIST in a way that preserves its ``sortedness\'\' according to PREDICATE and KEY.\r\n\r\n@unknown @xref SORTED-ADD-TO-LIST differs from @xref SORT-ADJOIN in not treating its list argument as\r\na set, thereby allowing duplicates.")
    public static SubLObject sorted_add_to_list(final SubLObject item, final SubLObject sorted_list, final SubLObject predicate, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return splice_into_sorted_list(item, sorted_list, predicate, key);
    }/**
     * Adds ITEM to SORTED-LIST in a way that preserves its ``sortedness'' according to PREDICATE and KEY.
     *
     * @unknown @xref SORTED-ADD-TO-LIST differs from @xref SORT-ADJOIN in not treating its list argument as
    a set, thereby allowing duplicates.
     */


    /**
     * Splice OBJECT into SORTED-LIST sorted by PREDICATE.
     */
    @LispMethod(comment = "Splice OBJECT into SORTED-LIST sorted by PREDICATE.")
    public static final SubLObject splice_into_sorted_list_alt(SubLObject v_object, SubLObject sorted_list, SubLObject predicate, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(sorted_list, LISTP);
        {
            SubLObject object_key = funcall(key, v_object);
            SubLObject back = NIL;
            SubLObject node = NIL;
            for (back = NIL, node = sorted_list; NIL != node; back = node , node = node.rest()) {
                {
                    SubLObject item = node.first();
                    SubLObject item_key = funcall(key, item);
                    if (NIL != funcall(predicate, object_key, item_key)) {
                        if (NIL != back) {
                            rplacd(back, cons(v_object, node));
                        } else {
                            sorted_list = cons(v_object, sorted_list);
                        }
                        return sorted_list;
                    }
                }
            }
            if (NIL != back) {
                rplacd(back, cons(v_object, node));
            } else {
                sorted_list = cons(v_object, sorted_list);
            }
            return sorted_list;
        }
    }

    @LispMethod(comment = "Splice OBJECT into SORTED-LIST sorted by PREDICATE.")
    public static SubLObject splice_into_sorted_list(final SubLObject v_object, SubLObject sorted_list, final SubLObject predicate, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(sorted_list) : "! listp(sorted_list) " + ("Types.listp(sorted_list) " + "CommonSymbols.NIL != Types.listp(sorted_list) ") + sorted_list;
        final SubLObject object_key = funcall(key, v_object);
        SubLObject back = NIL;
        SubLObject node = NIL;
        back = NIL;
        for (node = sorted_list; NIL != node; node = node.rest()) {
            final SubLObject item = node.first();
            final SubLObject item_key = funcall(key, item);
            if (NIL != funcall(predicate, object_key, item_key)) {
                if (NIL != back) {
                    rplacd(back, cons(v_object, node));
                } else {
                    sorted_list = cons(v_object, sorted_list);
                }
                return sorted_list;
            }
            back = node;
        }
        if (NIL != back) {
            rplacd(back, cons(v_object, node));
        } else {
            sorted_list = cons(v_object, sorted_list);
        }
        return sorted_list;
    }/**
     * Splice OBJECT into SORTED-LIST sorted by PREDICATE.
     */


    public static final SubLObject safe_splice_into_sorted_list_alt(SubLObject item, SubLObject sorted_list, SubLObject predicate, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.splice_into_sorted_list(item, copy_list(sorted_list), predicate, key);
    }

    public static SubLObject safe_splice_into_sorted_list(final SubLObject item, final SubLObject sorted_list, final SubLObject predicate, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return splice_into_sorted_list(item, copy_list(sorted_list), predicate, key);
    }

    /**
     * Return T iff ELEMENT is a member of SEQUENCE and no OTHER-ELEMENTS precede it.
     *
     * @unknown reed
     */
    @LispMethod(comment = "Return T iff ELEMENT is a member of SEQUENCE and no OTHER-ELEMENTS precede it.\r\n\r\n@unknown reed")
    public static final SubLObject element_precedes_specified_othersP_alt(SubLObject element, SubLObject other_elements, SubLObject sequence, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject cdolist_list_var = sequence;
            SubLObject sequence_element = NIL;
            for (sequence_element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , sequence_element = cdolist_list_var.first()) {
                if (NIL != funcall(test, element, sequence_element)) {
                    return T;
                }
                if (NIL != subl_promotions.memberP(sequence_element, other_elements, test, key)) {
                    return NIL;
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Return T iff ELEMENT is a member of SEQUENCE and no OTHER-ELEMENTS precede it.\r\n\r\n@unknown reed")
    public static SubLObject element_precedes_specified_othersP(final SubLObject element, final SubLObject other_elements, final SubLObject sequence, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject cdolist_list_var = sequence;
        SubLObject sequence_element = NIL;
        sequence_element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, element, sequence_element)) {
                return T;
            }
            if (NIL != subl_promotions.memberP(sequence_element, other_elements, test, key)) {
                return NIL;
            }
            cdolist_list_var = cdolist_list_var.rest();
            sequence_element = cdolist_list_var.first();
        } 
        return NIL;
    }/**
     * Return T iff ELEMENT is a member of SEQUENCE and no OTHER-ELEMENTS precede it.
     *
     * @unknown reed
     */


    /**
     * Return the maximum number of arguments which a function that has
     * FUNCTION-FORMAL-ARGLIST as its arglist can be called with.
     * NIL is returned if there is no maximum.
     */
    @LispMethod(comment = "Return the maximum number of arguments which a function that has\r\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.\r\nNIL is returned if there is no maximum.\nReturn the maximum number of arguments which a function that has\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.\nNIL is returned if there is no maximum.")
    public static final SubLObject function_arglist_max_args_alt(SubLObject function_formal_arglist) {
        SubLTrampolineFile.checkType(function_formal_arglist, LISTP);
        if (NIL != subl_promotions.memberP($sym119$_REST, function_formal_arglist, UNPROVIDED, UNPROVIDED)) {
            return NIL;
        } else {
            {
                SubLObject num = length(function_formal_arglist);
                if (NIL != subl_promotions.memberP($sym62$_OPTIONAL, function_formal_arglist, UNPROVIDED, UNPROVIDED)) {
                    return subtract(num, ONE_INTEGER);
                } else {
                    return num;
                }
            }
        }
    }

    @LispMethod(comment = "Return the maximum number of arguments which a function that has\r\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.\r\nNIL is returned if there is no maximum.\nReturn the maximum number of arguments which a function that has\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.\nNIL is returned if there is no maximum.")
    public static SubLObject function_arglist_max_args(final SubLObject function_formal_arglist) {
        assert NIL != listp(function_formal_arglist) : "! listp(function_formal_arglist) " + ("Types.listp(function_formal_arglist) " + "CommonSymbols.NIL != Types.listp(function_formal_arglist) ") + function_formal_arglist;
        if (NIL != subl_promotions.memberP($sym120$_REST, function_formal_arglist, UNPROVIDED, UNPROVIDED)) {
            return NIL;
        }
        final SubLObject num = length(function_formal_arglist);
        if (NIL != subl_promotions.memberP($sym62$_OPTIONAL, function_formal_arglist, UNPROVIDED, UNPROVIDED)) {
            return subtract(num, ONE_INTEGER);
        }
        return num;
    }/**
     * Return the maximum number of arguments which a function that has
     * FUNCTION-FORMAL-ARGLIST as its arglist can be called with.
     * NIL is returned if there is no maximum.
     */


    /**
     * Return the maximum number of arguments which a function that has
     * FUNCTION-FORMAL-ARGLIST as its arglist can be called with.
     */
    @LispMethod(comment = "Return the maximum number of arguments which a function that has\r\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.\nReturn the maximum number of arguments which a function that has\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.")
    public static final SubLObject function_arglist_min_args_alt(SubLObject function_formal_arglist) {
        SubLTrampolineFile.checkType(function_formal_arglist, LISTP);
        {
            SubLObject min = ZERO_INTEGER;
            SubLObject cdolist_list_var = function_formal_arglist;
            SubLObject arg = NIL;
            for (arg = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , arg = cdolist_list_var.first()) {
                if (NIL != subl_promotions.memberP(arg, $list_alt120, UNPROVIDED, UNPROVIDED)) {
                    return min;
                }
                min = add(min, ONE_INTEGER);
            }
            return min;
        }
    }

    @LispMethod(comment = "Return the maximum number of arguments which a function that has\r\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.\nReturn the maximum number of arguments which a function that has\nFUNCTION-FORMAL-ARGLIST as its arglist can be called with.")
    public static SubLObject function_arglist_min_args(final SubLObject function_formal_arglist) {
        assert NIL != listp(function_formal_arglist) : "! listp(function_formal_arglist) " + ("Types.listp(function_formal_arglist) " + "CommonSymbols.NIL != Types.listp(function_formal_arglist) ") + function_formal_arglist;
        SubLObject min = ZERO_INTEGER;
        SubLObject cdolist_list_var = function_formal_arglist;
        SubLObject arg = NIL;
        arg = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != subl_promotions.memberP(arg, $list121, UNPROVIDED, UNPROVIDED)) {
                return min;
            }
            min = add(min, ONE_INTEGER);
            cdolist_list_var = cdolist_list_var.rest();
            arg = cdolist_list_var.first();
        } 
        return min;
    }/**
     * Return the maximum number of arguments which a function that has
     * FUNCTION-FORMAL-ARGLIST as its arglist can be called with.
     */


    public static final SubLObject remove_self_binds_alt(SubLObject blist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = blist;
            SubLObject bind = NIL;
            for (bind = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , bind = cdolist_list_var.first()) {
                if (NIL == com.cyc.cycjava.cycl.list_utilities.self_bindP(bind, test)) {
                    result = cons(bind, result);
                }
            }
            return nreverse(result);
        }
    }

    public static SubLObject remove_self_binds(final SubLObject blist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = blist;
        SubLObject bind = NIL;
        bind = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == self_bindP(bind, test)) {
                result = cons(bind, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            bind = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    public static final SubLObject self_bindP_alt(SubLObject bind, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (!bind.equal($list_alt121)) {
            return funcall(test, bind.first(), bind.rest());
        }
        return NIL;
    }

    public static SubLObject self_bindP(final SubLObject bind, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (!bind.equal($list122)) {
            return funcall(test, bind.first(), bind.rest());
        }
        return NIL;
    }

    public static final SubLObject bind_for_var_alt(SubLObject var, SubLObject blist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return assoc(var, blist, test, key).rest();
    }

    public static SubLObject bind_for_var(final SubLObject var, final SubLObject blist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return assoc(var, blist, test, key).rest();
    }

    public static final SubLObject remove_bind_alt(SubLObject var, SubLObject blist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return remove(assoc(var, blist, test, key), blist, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_bind(final SubLObject var, final SubLObject blist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return remove(assoc(var, blist, test, key), blist, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject extract_bindings_alt(SubLObject var, SubLObject blists) {
        {
            SubLObject terms = NIL;
            SubLObject cdolist_list_var = blists;
            SubLObject form = NIL;
            for (form = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , form = cdolist_list_var.first()) {
                {
                    SubLObject binding = assoc(var, form, symbol_function(EQUAL), UNPROVIDED).rest();
                    if (NIL != binding) {
                        {
                            SubLObject item_var = binding;
                            if (NIL == member(item_var, terms, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                                terms = cons(item_var, terms);
                            }
                        }
                    }
                }
            }
            return terms;
        }
    }

    public static SubLObject extract_bindings(final SubLObject var, final SubLObject blists) {
        SubLObject terms = NIL;
        SubLObject cdolist_list_var = blists;
        SubLObject form = NIL;
        form = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject binding = assoc(var, form, symbol_function(EQUAL), UNPROVIDED).rest();
            if (NIL != binding) {
                final SubLObject item_var = binding;
                if (NIL == member(item_var, terms, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                    terms = cons(item_var, terms);
                }
            }
            cdolist_list_var = cdolist_list_var.rest();
            form = cdolist_list_var.first();
        } 
        return terms;
    }

    public static final SubLObject car_is_el_varP_alt(SubLObject obj) {
        {
            SubLObject ans = NIL;
            if (obj.isCons() && (NIL != cycl_variables.el_varP(obj.first()))) {
                ans = T;
            }
            return ans;
        }
    }

    public static SubLObject car_is_el_varP(final SubLObject obj) {
        SubLObject ans = NIL;
        if (obj.isCons() && (NIL != cycl_variables.el_varP(obj.first()))) {
            ans = T;
        }
        return ans;
    }

    public static final SubLObject extract_binding_strings_alt(SubLObject varlist, SubLObject blist) {
        {
            SubLObject binding_strings = NIL;
            SubLObject cdolist_list_var = blist;
            SubLObject b = NIL;
            for (b = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , b = cdolist_list_var.first()) {
                {
                    SubLObject pairs = com.cyc.cycjava.cycl.list_utilities.cons_tree_gather(b, $sym122$CAR_IS_EL_VAR_, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    SubLObject temp = NIL;
                    SubLObject cdolist_list_var_23 = varlist;
                    SubLObject var = NIL;
                    for (var = cdolist_list_var_23.first(); NIL != cdolist_list_var_23; cdolist_list_var_23 = cdolist_list_var_23.rest() , var = cdolist_list_var_23.first()) {
                        {
                            SubLObject v_term = assoc(var, pairs, symbol_function(EQUAL), UNPROVIDED).rest();
                            if (NIL != v_term) {
                                temp = cons(format(NIL, $str_alt123$_s____s, var, v_term), temp);
                            }
                        }
                    }
                    if (NIL != temp) {
                        binding_strings = cons(temp, binding_strings);
                    }
                }
            }
            return binding_strings;
        }
    }

    public static SubLObject extract_binding_strings(final SubLObject varlist, final SubLObject blist) {
        SubLObject binding_strings = NIL;
        SubLObject cdolist_list_var = blist;
        SubLObject b = NIL;
        b = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject pairs = cons_tree_gather(b, $sym123$CAR_IS_EL_VAR_, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            SubLObject temp = NIL;
            SubLObject cdolist_list_var_$25 = varlist;
            SubLObject var = NIL;
            var = cdolist_list_var_$25.first();
            while (NIL != cdolist_list_var_$25) {
                final SubLObject v_term = assoc(var, pairs, symbol_function(EQUAL), UNPROVIDED).rest();
                if (NIL != v_term) {
                    temp = cons(format(NIL, $str124$_s____s, var, v_term), temp);
                }
                cdolist_list_var_$25 = cdolist_list_var_$25.rest();
                var = cdolist_list_var_$25.first();
            } 
            if (NIL != temp) {
                binding_strings = cons(temp, binding_strings);
            }
            cdolist_list_var = cdolist_list_var.rest();
            b = cdolist_list_var.first();
        } 
        return binding_strings;
    }

    public static final SubLObject tree_funcall_if_alt(SubLObject test, SubLObject fn, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            funcall(fn, v_object);
        } else {
            if (v_object.isCons()) {
                com.cyc.cycjava.cycl.list_utilities.tree_funcall_if(test, fn, v_object.first(), key);
                com.cyc.cycjava.cycl.list_utilities.tree_funcall_if(test, fn, v_object.rest(), key);
            }
        }
        return NIL;
    }

    public static SubLObject tree_funcall_if(final SubLObject test, final SubLObject fn, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            funcall(fn, v_object);
        } else
            if (v_object.isCons()) {
                tree_funcall_if(test, fn, v_object.first(), key);
                tree_funcall_if(test, fn, v_object.rest(), key);
            }

        return NIL;
    }

    public static final SubLObject tree_find_all_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return list(v_object);
        } else {
            if (v_object.isCons()) {
                return append(com.cyc.cycjava.cycl.list_utilities.tree_find_all_if(test, v_object.first(), key), com.cyc.cycjava.cycl.list_utilities.tree_find_all_if(test, v_object.rest(), key));
            }
        }
        return NIL;
    }

    public static SubLObject tree_find_all_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return v_object;
        }
        if (v_object.isCons()) {
            SubLObject result = NIL;
            SubLObject cons;
            SubLObject current;
            SubLObject datum;
            SubLObject element;
            SubLObject rest;
            SubLObject cdolist_list_var;
            SubLObject result_element;
            for (cons = NIL, cons = v_object; !cons.isAtom(); cons = cons.rest()) {
                datum = current = cons;
                element = NIL;
                rest = NIL;
                destructuring_bind_must_consp(current, datum, $list125);
                element = current.first();
                current = rest = current.rest();
                if (NIL != funcall(test, funcall(key, element))) {
                    result = cons(element, result);
                } else
                    if (element.isCons()) {
                        cdolist_list_var = tree_find_all_if(test, element, key);
                        result_element = NIL;
                        result_element = cdolist_list_var.first();
                        while (NIL != cdolist_list_var) {
                            result = cons(result_element, result);
                            cdolist_list_var = cdolist_list_var.rest();
                            result_element = cdolist_list_var.first();
                        } 
                    }

                if ((!rest.isList()) && (NIL != funcall(test, funcall(key, rest)))) {
                    result = cons(rest, result);
                }
            }
            return nreverse(result);
        }
        return NIL;
    }

    public static final SubLObject tree_remove_all_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
        } else {
            if (v_object.isCons()) {
                return remove(NIL, cons(com.cyc.cycjava.cycl.list_utilities.tree_remove_all_if(test, v_object.first(), key), com.cyc.cycjava.cycl.list_utilities.tree_remove_all_if(test, v_object.rest(), key)), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            } else {
                return v_object;
            }
        }
        return NIL;
    }

    public static SubLObject tree_remove_all_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return NIL;
        }
        if (v_object.isCons()) {
            return remove(NIL, cons(tree_remove_all_if(test, v_object.first(), key), tree_remove_all_if(test, v_object.rest(), key)), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        return v_object;
    }

    public static final SubLObject nswap_tree_alt(SubLObject item1, SubLObject item2, SubLObject v_object, SubLObject test, SubLObject temp) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (temp == UNPROVIDED) {
            temp = $TEMP;
        }
        v_object = nsubst(temp, item2, v_object, test, UNPROVIDED);
        v_object = nsubst(item2, item1, v_object, test, UNPROVIDED);
        v_object = nsubst(item1, temp, v_object, test, UNPROVIDED);
        return v_object;
    }

    public static SubLObject nswap_tree(final SubLObject item1, final SubLObject item2, SubLObject v_object, SubLObject test, SubLObject temp) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (temp == UNPROVIDED) {
            temp = $TEMP;
        }
        v_object = nsubst(temp, item2, v_object, test, UNPROVIDED);
        v_object = nsubst(item2, item1, v_object, test, UNPROVIDED);
        v_object = nsubst(item1, temp, v_object, test, UNPROVIDED);
        return v_object;
    }

    public static final SubLObject swap_tree_alt(SubLObject item1, SubLObject item2, SubLObject v_object, SubLObject test, SubLObject temp) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (temp == UNPROVIDED) {
            temp = $TEMP;
        }
        return com.cyc.cycjava.cycl.list_utilities.nswap_tree(item1, item2, copy_tree(v_object), test, temp);
    }

    public static SubLObject swap_tree(final SubLObject item1, final SubLObject item2, final SubLObject v_object, SubLObject test, SubLObject temp) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (temp == UNPROVIDED) {
            temp = $TEMP;
        }
        return nswap_tree(item1, item2, copy_tree(v_object), test, temp);
    }

    /**
     * Like @xref tree-find-all-if but when it finds OBJECT that satisfies TEST w.r.t. KEY
     * it still descends into OBJECT.
     */
    @LispMethod(comment = "Like @xref tree-find-all-if but when it finds OBJECT that satisfies TEST w.r.t. KEY\r\nit still descends into OBJECT.\nLike @xref tree-find-all-if but when it finds OBJECT that satisfies TEST w.r.t. KEY\nit still descends into OBJECT.")
    public static final SubLObject tree_find_all_nested_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return append(list(v_object), com.cyc.cycjava.cycl.list_utilities.tree_find_all_nested_if_int(test, v_object, key));
        } else {
            return com.cyc.cycjava.cycl.list_utilities.tree_find_all_nested_if_int(test, v_object, key);
        }
    }

    @LispMethod(comment = "Like @xref tree-find-all-if but when it finds OBJECT that satisfies TEST w.r.t. KEY\r\nit still descends into OBJECT.\nLike @xref tree-find-all-if but when it finds OBJECT that satisfies TEST w.r.t. KEY\nit still descends into OBJECT.")
    public static SubLObject tree_find_all_nested_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return append(list(v_object), tree_find_all_nested_if_int(test, v_object, key));
        }
        return tree_find_all_nested_if_int(test, v_object, key);
    }/**
     * Like @xref tree-find-all-if but when it finds OBJECT that satisfies TEST w.r.t. KEY
     * it still descends into OBJECT.
     */


    public static final SubLObject tree_find_all_nested_if_int_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        return v_object.isCons() ? ((SubLObject) (append(com.cyc.cycjava.cycl.list_utilities.tree_find_all_nested_if(test, v_object.first(), key), com.cyc.cycjava.cycl.list_utilities.tree_find_all_nested_if(test, v_object.rest(), key)))) : NIL;
    }

    public static SubLObject tree_find_all_nested_if_int(final SubLObject test, final SubLObject v_object, final SubLObject key) {
        return v_object.isCons() ? append(tree_find_all_nested_if(test, v_object.first(), key), tree_find_all_nested_if(test, v_object.rest(), key)) : NIL;
    }

    public static final SubLObject hash_delete_duplicates_alt(SubLObject sequence, SubLObject hashtable, SubLObject key, SubLObject start, SubLObject end) {
        if (hashtable == UNPROVIDED) {
            hashtable = $remove_duplicates_equal_table$.getGlobalValue();
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        SubLTrampolineFile.checkType(sequence, LISTP);
        SubLTrampolineFile.checkType(hashtable, HASH_TABLE_P);
        {
            SubLObject result = NIL;
            if (hashtable == $remove_duplicates_eq_table$.getGlobalValue()) {
                {
                    SubLObject lock = $remove_duplicates_eq_table_lock$.getGlobalValue();
                    SubLObject release = NIL;
                    try {
                        release = seize_lock(lock);
                        result = com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                    } finally {
                        if (NIL != release) {
                            release_lock(lock);
                        }
                    }
                }
            } else {
                if (hashtable == $remove_duplicates_eql_table$.getGlobalValue()) {
                    {
                        SubLObject lock = $remove_duplicates_eql_table_lock$.getGlobalValue();
                        SubLObject release = NIL;
                        try {
                            release = seize_lock(lock);
                            result = com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                        } finally {
                            if (NIL != release) {
                                release_lock(lock);
                            }
                        }
                    }
                } else {
                    if (hashtable == $remove_duplicates_equal_table$.getGlobalValue()) {
                        {
                            SubLObject lock = $remove_duplicates_equal_table_lock$.getGlobalValue();
                            SubLObject release = NIL;
                            try {
                                release = seize_lock(lock);
                                result = com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                            } finally {
                                if (NIL != release) {
                                    release_lock(lock);
                                }
                            }
                        }
                    } else {
                        if (hashtable == $remove_duplicates_equalp_table$.getGlobalValue()) {
                            {
                                SubLObject lock = $remove_duplicates_equalp_table_lock$.getGlobalValue();
                                SubLObject release = NIL;
                                try {
                                    release = seize_lock(lock);
                                    result = com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                                } finally {
                                    if (NIL != release) {
                                        release_lock(lock);
                                    }
                                }
                            }
                        } else {
                            result = com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                        }
                    }
                }
            }
            return result;
        }
    }

    public static SubLObject hash_delete_duplicates(final SubLObject sequence, SubLObject hashtable, SubLObject key, SubLObject start, SubLObject end) {
        if (hashtable == UNPROVIDED) {
            hashtable = $remove_duplicates_equal_table$.getGlobalValue();
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        assert NIL != listp(sequence) : "! listp(sequence) " + ("Types.listp(sequence) " + "CommonSymbols.NIL != Types.listp(sequence) ") + sequence;
        assert NIL != hash_table_p(hashtable) : "! hash_table_p(hashtable) " + ("Types.hash_table_p(hashtable) " + "CommonSymbols.NIL != Types.hash_table_p(hashtable) ") + hashtable;
        SubLObject result = NIL;
        if (hashtable.eql($remove_duplicates_eq_table$.getGlobalValue())) {
            SubLObject release = NIL;
            try {
                release = seize_lock($remove_duplicates_eq_table_lock$.getGlobalValue());
                result = hash_delete_duplicates_int(sequence, hashtable, key, start, end);
            } finally {
                if (NIL != release) {
                    release_lock($remove_duplicates_eq_table_lock$.getGlobalValue());
                }
            }
        } else
            if (hashtable.eql($remove_duplicates_eql_table$.getGlobalValue())) {
                SubLObject release = NIL;
                try {
                    release = seize_lock($remove_duplicates_eql_table_lock$.getGlobalValue());
                    result = hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                } finally {
                    if (NIL != release) {
                        release_lock($remove_duplicates_eql_table_lock$.getGlobalValue());
                    }
                }
            } else
                if (hashtable.eql($remove_duplicates_equal_table$.getGlobalValue())) {
                    SubLObject release = NIL;
                    try {
                        release = seize_lock($remove_duplicates_equal_table_lock$.getGlobalValue());
                        result = hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                    } finally {
                        if (NIL != release) {
                            release_lock($remove_duplicates_equal_table_lock$.getGlobalValue());
                        }
                    }
                } else
                    if (hashtable.eql($remove_duplicates_equalp_table$.getGlobalValue())) {
                        SubLObject release = NIL;
                        try {
                            release = seize_lock($remove_duplicates_equalp_table_lock$.getGlobalValue());
                            result = hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                        } finally {
                            if (NIL != release) {
                                release_lock($remove_duplicates_equalp_table_lock$.getGlobalValue());
                            }
                        }
                    } else {
                        result = hash_delete_duplicates_int(sequence, hashtable, key, start, end);
                    }



        return result;
    }

    public static final SubLObject hash_delete_duplicates_int_alt(SubLObject sequence, SubLObject hashtable, SubLObject key, SubLObject start, SubLObject end) {
        clrhash(hashtable);
        {
            SubLObject start_seq = nthcdr(start, sequence);
            SubLObject index = start;
            SubLObject done = NIL;
            if (NIL == done) {
                {
                    SubLObject csome_list_var = start_seq;
                    SubLObject item = NIL;
                    for (item = csome_list_var.first(); !((NIL != done) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                        if (end.isInteger() && end.numE(index)) {
                            done = T;
                        } else {
                            sethash(funcall(key, item), hashtable, index);
                        }
                        index = add(index, ONE_INTEGER);
                    }
                }
            }
        }
        {
            SubLObject back = (start.numE(ZERO_INTEGER)) ? ((SubLObject) (NIL)) : nthcdr(subtract(start, ONE_INTEGER), sequence);
            SubLObject done = NIL;
            SubLObject index = NIL;
            SubLObject current = NIL;
            SubLObject item = NIL;
            for (index = start, current = (NIL != back) ? ((SubLObject) (back.rest())) : sequence, item = current.first(); !((NIL != done) || (NIL == current)); index = add(index, ONE_INTEGER) , current = current.rest() , item = current.first()) {
                done = makeBoolean(end.isInteger() && end.numE(index));
                if (NIL == done) {
                    if (index.eql(gethash(funcall(key, item), hashtable, UNPROVIDED))) {
                        back = current;
                    } else {
                        if (NIL != back) {
                            rplacd(back, current.rest());
                        } else {
                            sequence = current.rest();
                        }
                    }
                }
            }
            return sequence;
        }
    }

    public static SubLObject hash_delete_duplicates_int(SubLObject sequence, final SubLObject hashtable, final SubLObject key, final SubLObject start, final SubLObject end) {
        clrhash(hashtable);
        final SubLObject start_seq = nthcdr(start, sequence);
        SubLObject index = start;
        SubLObject done = NIL;
        if (NIL == done) {
            SubLObject csome_list_var = start_seq;
            SubLObject item = NIL;
            item = csome_list_var.first();
            while ((NIL == done) && (NIL != csome_list_var)) {
                if (end.isInteger() && end.numE(index)) {
                    done = T;
                } else {
                    sethash(funcall(key, item), hashtable, index);
                }
                index = add(index, ONE_INTEGER);
                csome_list_var = csome_list_var.rest();
                item = csome_list_var.first();
            } 
        }
        SubLObject back = (start.numE(ZERO_INTEGER)) ? NIL : nthcdr(subtract(start, ONE_INTEGER), sequence);
        SubLObject done2 = NIL;
        SubLObject index2 = NIL;
        SubLObject current = NIL;
        SubLObject item = NIL;
        index2 = start;
        current = (NIL != back) ? back.rest() : sequence;
        item = current.first();
        while ((NIL == done2) && (NIL != current)) {
            done2 = makeBoolean(end.isInteger() && end.numE(index2));
            if (NIL == done2) {
                if (index2.eql(gethash(funcall(key, item), hashtable, UNPROVIDED))) {
                    back = current;
                } else
                    if (NIL != back) {
                        rplacd(back, current.rest());
                    } else {
                        sequence = current.rest();
                    }

            }
            index2 = add(index2, ONE_INTEGER);
            current = current.rest();
            item = current.first();
        } 
        return sequence;
    }

    public static final SubLObject hash_remove_duplicates_alt(SubLObject sequence, SubLObject hashtable, SubLObject key, SubLObject start, SubLObject end) {
        if (hashtable == UNPROVIDED) {
            hashtable = $remove_duplicates_equal_table$.getGlobalValue();
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates(copy_list(sequence), hashtable, key, start, end);
    }

    public static SubLObject hash_remove_duplicates(final SubLObject sequence, SubLObject hashtable, SubLObject key, SubLObject start, SubLObject end) {
        if (hashtable == UNPROVIDED) {
            hashtable = $remove_duplicates_equal_table$.getGlobalValue();
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return hash_delete_duplicates(copy_list(sequence), hashtable, key, start, end);
    }

    public static final SubLObject fast_delete_duplicates_hashtable_alt(SubLObject test) {
        {
            SubLObject symbol = hash_table_utilities.hash_test_to_symbol(test);
            SubLObject pcase_var = symbol;
            if (pcase_var.eql(QUOTE) || pcase_var.eql(EQ)) {
                return $remove_duplicates_eq_table$.getGlobalValue();
            } else {
                if (pcase_var.eql(QUOTE) || pcase_var.eql(EQL)) {
                    return $remove_duplicates_eql_table$.getGlobalValue();
                } else {
                    if (pcase_var.eql(QUOTE) || pcase_var.eql(EQUAL)) {
                        return $remove_duplicates_equal_table$.getGlobalValue();
                    } else {
                        return $remove_duplicates_equalp_table$.getGlobalValue();
                    }
                }
            }
        }
    }

    public static SubLObject fast_delete_duplicates_hashtable(final SubLObject test) {
        final SubLObject pcase_var;
        final SubLObject symbol = pcase_var = hash_table_utilities.hash_test_to_symbol(test);
        if (pcase_var.eql(QUOTE) || pcase_var.eql(EQ)) {
            return $remove_duplicates_eq_table$.getGlobalValue();
        }
        if (pcase_var.eql(QUOTE) || pcase_var.eql(EQL)) {
            return $remove_duplicates_eql_table$.getGlobalValue();
        }
        if (pcase_var.eql(QUOTE) || pcase_var.eql(EQUAL)) {
            return $remove_duplicates_equal_table$.getGlobalValue();
        }
        return $remove_duplicates_equalp_table$.getGlobalValue();
    }

    public static final SubLObject fast_delete_duplicates_alt(SubLObject sequence, SubLObject test, SubLObject key, SubLObject hashtable, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (hashtable == UNPROVIDED) {
            hashtable = NIL;
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(test, FUNCTION_SPEC_P);
            if (NIL != com.cyc.cycjava.cycl.list_utilities.lengthLE(sequence, ONE_INTEGER, UNPROVIDED)) {
                return sequence;
            } else {
                if (NIL != com.cyc.cycjava.cycl.list_utilities.lengthLE(sequence, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)) {
                    return delete_duplicates(sequence, test, key, start, end);
                } else {
                    if (NIL != hashtable) {
                        return com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates(sequence, hashtable, key, start, end);
                    } else {
                        if (NIL != hash_table_utilities.valid_hash_test_p(test)) {
                            return com.cyc.cycjava.cycl.list_utilities.hash_delete_duplicates(sequence, com.cyc.cycjava.cycl.list_utilities.fast_delete_duplicates_hashtable(test), key, start, end);
                        } else {
                            return delete_duplicates(sequence, test, key, start, end);
                        }
                    }
                }
            }
        }
    }

    public static SubLObject fast_delete_duplicates(final SubLObject sequence, SubLObject test, SubLObject key, SubLObject hashtable, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (hashtable == UNPROVIDED) {
            hashtable = NIL;
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != function_spec_p(test) : "! function_spec_p(test) " + ("Types.function_spec_p(test) " + "CommonSymbols.NIL != Types.function_spec_p(test) ") + test;
        if (NIL != lengthLE(sequence, ONE_INTEGER, UNPROVIDED)) {
            return sequence;
        }
        if (NIL != lengthLE(sequence, $magic_hashing_cutoff$.getDynamicValue(thread), UNPROVIDED)) {
            return delete_duplicates(sequence, test, key, start, end);
        }
        if (NIL != hashtable) {
            return hash_delete_duplicates(sequence, hashtable, key, start, end);
        }
        if (NIL != hash_table_utilities.valid_hash_test_p(test)) {
            return hash_delete_duplicates(sequence, fast_delete_duplicates_hashtable(test), key, start, end);
        }
        return delete_duplicates(sequence, test, key, start, end);
    }

    public static final SubLObject fast_remove_duplicates_alt(SubLObject list, SubLObject test, SubLObject key, SubLObject hashtable, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (hashtable == UNPROVIDED) {
            hashtable = NIL;
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return com.cyc.cycjava.cycl.list_utilities.fast_delete_duplicates(copy_list(list), test, key, hashtable, start, end);
    }

    public static SubLObject fast_remove_duplicates(final SubLObject list, SubLObject test, SubLObject key, SubLObject hashtable, SubLObject start, SubLObject end) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (hashtable == UNPROVIDED) {
            hashtable = NIL;
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        return fast_delete_duplicates(copy_list(list), test, key, hashtable, start, end);
    }

    public static SubLObject fast_remove_duplicates_preserving_first(final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLObject first_item = list.first();
        return nmove_to_front(first_item, fast_delete_duplicates(copy_list(list), test, key, UNPROVIDED, UNPROVIDED, UNPROVIDED), test);
    }

    public static SubLObject remove_duplicates_preserving_order(final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == subl_promotions.memberP(elem, result, test, key)) {
                result = cons(elem, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    /**
     *
     *
     * @return the list FORTS with all duplicates removed
     */
    @LispMethod(comment = "@return the list FORTS with all duplicates removed")
    public static final SubLObject remove_duplicate_forts_alt(SubLObject v_forts) {
        return com.cyc.cycjava.cycl.list_utilities.fast_delete_duplicates(v_forts, symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return the list FORTS with all duplicates removed
     */
    @LispMethod(comment = "@return the list FORTS with all duplicates removed")
    public static SubLObject remove_duplicate_forts(final SubLObject v_forts) {
        return fast_delete_duplicates(v_forts, symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return listp; the list FORTS with all duplicates destructively removed
     */
    @LispMethod(comment = "@return listp; the list FORTS with all duplicates destructively removed")
    public static final SubLObject delete_duplicate_forts_alt(SubLObject v_forts) {
        return com.cyc.cycjava.cycl.list_utilities.fast_delete_duplicates(v_forts, symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return listp; the list FORTS with all duplicates destructively removed
     */
    @LispMethod(comment = "@return listp; the list FORTS with all duplicates destructively removed")
    public static SubLObject delete_duplicate_forts(final SubLObject v_forts) {
        return fast_delete_duplicates(v_forts, symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @param test
     * 		function; must be a valid argument to make-hash-table
     * @unknown pace
     */
    @LispMethod(comment = "@param test\r\n\t\tfunction; must be a valid argument to make-hash-table\r\n@unknown pace")
    public static final SubLObject hash_unique_elements_alt(SubLObject list, SubLObject test) {
        {
            SubLObject temp_hash = make_hash_table(length(list), test, UNPROVIDED);
            SubLObject result = NIL;
            {
                SubLObject cdolist_list_var = list;
                SubLObject elem = NIL;
                for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                    {
                        SubLObject val = gethash(elem, temp_hash, UNPROVIDED);
                        if (NIL != val) {
                            if (val != $NOT_UNIQUE) {
                                sethash(elem, temp_hash, $NOT_UNIQUE);
                            }
                        } else {
                            sethash(elem, temp_hash, $UNIQUE);
                        }
                    }
                }
            }
            {
                SubLObject elem = NIL;
                SubLObject val = NIL;
                {
                    final Iterator cdohash_iterator = getEntrySetIterator(temp_hash);
                    try {
                        while (iteratorHasNext(cdohash_iterator)) {
                            final Map.Entry cdohash_entry = iteratorNextEntry(cdohash_iterator);
                            elem = getEntryKey(cdohash_entry);
                            val = getEntryValue(cdohash_entry);
                            if (val == $UNIQUE) {
                                result = cons(elem, result);
                            }
                        } 
                    } finally {
                        releaseEntrySetIterator(cdohash_iterator);
                    }
                }
            }
            return result;
        }
    }

    /**
     *
     *
     * @param test
     * 		function; must be a valid argument to make-hash-table
     * @unknown pace
     */
    @LispMethod(comment = "@param test\r\n\t\tfunction; must be a valid argument to make-hash-table\r\n@unknown pace")
    public static SubLObject hash_unique_elements(final SubLObject list, final SubLObject test) {
        final SubLObject temp_hash = make_hash_table(length(list), test, UNPROVIDED);
        SubLObject result = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject val = gethash(elem, temp_hash, UNPROVIDED);
            if (NIL != val) {
                if (val != $NOT_UNIQUE) {
                    sethash(elem, temp_hash, $NOT_UNIQUE);
                }
            } else {
                sethash(elem, temp_hash, $UNIQUE);
            }
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        SubLObject elem2 = NIL;
        SubLObject val2 = NIL;
        final Iterator cdohash_iterator = getEntrySetIterator(temp_hash);
        try {
            while (iteratorHasNext(cdohash_iterator)) {
                final Map.Entry cdohash_entry = iteratorNextEntry(cdohash_iterator);
                elem2 = getEntryKey(cdohash_entry);
                val2 = getEntryValue(cdohash_entry);
                if (val2 == $UNIQUE) {
                    result = cons(elem2, result);
                }
            } 
        } finally {
            releaseEntrySetIterator(cdohash_iterator);
        }
        return result;
    }

    /**
     * Returns a list of all the unique elements in LIST.  Order is not preserved.
     *
     * @unknown pace
     */
    @LispMethod(comment = "Returns a list of all the unique elements in LIST.  Order is not preserved.\r\n\r\n@unknown pace")
    public static final SubLObject unique_elements_alt(SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != hash_table_utilities.valid_hash_test_p(test)) {
            return com.cyc.cycjava.cycl.list_utilities.hash_unique_elements(list, test);
        } else {
            {
                SubLObject len = length(list);
                SubLObject duplicates = make_hash_table(len, symbol_function(EQL), UNPROVIDED);
                SubLObject result = NIL;
                {
                    SubLObject i = NIL;
                    for (i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
                        if (NIL == gethash(i, duplicates, UNPROVIDED)) {
                            {
                                SubLObject ith_elem = nth(i, list);
                                SubLObject cdotimes_end_var = subtract(len, i, ONE_INTEGER);
                                SubLObject j_i_1 = NIL;
                                for (j_i_1 = ZERO_INTEGER; j_i_1.numL(cdotimes_end_var); j_i_1 = add(j_i_1, ONE_INTEGER)) {
                                    {
                                        SubLObject j = add(j_i_1, i, ONE_INTEGER);
                                        if (NIL == gethash(j, duplicates, UNPROVIDED)) {
                                            {
                                                SubLObject jth_elem = nth(j, list);
                                                if (NIL != funcall(test, ith_elem, jth_elem)) {
                                                    sethash(i, duplicates, T);
                                                    sethash(j, duplicates, T);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject i = NIL;
                    for (i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
                        if (NIL == gethash(i, duplicates, UNPROVIDED)) {
                            result = cons(nth(i, list), result);
                        }
                    }
                }
                return result;
            }
        }
    }

    @LispMethod(comment = "Returns a list of all the unique elements in LIST.  Order is not preserved.\r\n\r\n@unknown pace")
    public static SubLObject unique_elements(final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != hash_table_utilities.valid_hash_test_p(test)) {
            return hash_unique_elements(list, test);
        }
        final SubLObject len = length(list);
        final SubLObject duplicates = make_hash_table(len, symbol_function(EQL), UNPROVIDED);
        SubLObject result = NIL;
        SubLObject i;
        SubLObject ith_elem;
        SubLObject cdotimes_end_var;
        SubLObject j_i_1;
        SubLObject j;
        SubLObject jth_elem;
        for (i = NIL, i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
            if (NIL == gethash(i, duplicates, UNPROVIDED)) {
                ith_elem = nth(i, list);
                for (cdotimes_end_var = subtract(len, i, ONE_INTEGER), j_i_1 = NIL, j_i_1 = ZERO_INTEGER; j_i_1.numL(cdotimes_end_var); j_i_1 = add(j_i_1, ONE_INTEGER)) {
                    j = add(j_i_1, i, ONE_INTEGER);
                    if (NIL == gethash(j, duplicates, UNPROVIDED)) {
                        jth_elem = nth(j, list);
                        if (NIL != funcall(test, ith_elem, jth_elem)) {
                            sethash(i, duplicates, T);
                            sethash(j, duplicates, T);
                        }
                    }
                }
            }
        }
        for (i = NIL, i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
            if (NIL == gethash(i, duplicates, UNPROVIDED)) {
                result = cons(nth(i, list), result);
            }
        }
        return result;
    }/**
     * Returns a list of all the unique elements in LIST.  Order is not preserved.
     *
     * @unknown pace
     */


    /**
     * Returns a list of all elements in LIST which occur N or fewer times.  Order is preserved.
     * Note: unlike remove-duplicates, this removes ALL occurrences of elements occuring N or more times,
     * not just the extra occurrences.
     * For N=1, this is equivalent to @xref unique-elements.
     *
     * @unknown pace
     */
    @LispMethod(comment = "Returns a list of all elements in LIST which occur N or fewer times.  Order is preserved.\r\nNote: unlike remove-duplicates, this removes ALL occurrences of elements occuring N or more times,\r\nnot just the extra occurrences.\r\nFor N=1, this is equivalent to @xref unique-elements.\r\n\r\n@unknown pace\nReturns a list of all elements in LIST which occur N or fewer times.  Order is preserved.\nNote: unlike remove-duplicates, this removes ALL occurrences of elements occuring N or more times,\nnot just the extra occurrences.\nFor N=1, this is equivalent to @xref unique-elements.")
    public static final SubLObject remove_all_n_icates_alt(SubLObject n, SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject len = length(list);
            SubLObject count = make_vector(len, ZERO_INTEGER);
            SubLObject canonical = vector_utilities.num_vector(len);
            SubLObject result = NIL;
            {
                SubLObject i = NIL;
                for (i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
                    if (!aref(count, aref(canonical, i)).numGE(n)) {
                        {
                            SubLObject ith_elem = nth(i, list);
                            SubLObject cdotimes_end_var = subtract(len, i, ONE_INTEGER);
                            SubLObject j_i_1 = NIL;
                            for (j_i_1 = ZERO_INTEGER; j_i_1.numL(cdotimes_end_var); j_i_1 = add(j_i_1, ONE_INTEGER)) {
                                {
                                    SubLObject j = add(j_i_1, i, ONE_INTEGER);
                                    if (!aref(count, aref(canonical, j)).numGE(n)) {
                                        {
                                            SubLObject jth_elem = nth(j, list);
                                            if (NIL != funcall(test, ith_elem, jth_elem)) {
                                                set_aref(canonical, j, aref(canonical, i));
                                                set_aref(count, aref(canonical, i), add(aref(count, aref(canonical, i)), ONE_INTEGER));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                SubLObject i = NIL;
                for (i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
                    if (aref(count, aref(canonical, i)).numL(n)) {
                        result = cons(nth(i, list), result);
                    }
                }
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Returns a list of all elements in LIST which occur N or fewer times.  Order is preserved.\r\nNote: unlike remove-duplicates, this removes ALL occurrences of elements occuring N or more times,\r\nnot just the extra occurrences.\r\nFor N=1, this is equivalent to @xref unique-elements.\r\n\r\n@unknown pace\nReturns a list of all elements in LIST which occur N or fewer times.  Order is preserved.\nNote: unlike remove-duplicates, this removes ALL occurrences of elements occuring N or more times,\nnot just the extra occurrences.\nFor N=1, this is equivalent to @xref unique-elements.")
    public static SubLObject remove_all_n_icates(final SubLObject n, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject len = length(list);
        final SubLObject count = make_vector(len, ZERO_INTEGER);
        final SubLObject canonical = vector_utilities.num_vector(len);
        SubLObject result = NIL;
        SubLObject i;
        SubLObject ith_elem;
        SubLObject cdotimes_end_var;
        SubLObject j_i_1;
        SubLObject j;
        SubLObject jth_elem;
        for (i = NIL, i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
            if (!aref(count, aref(canonical, i)).numGE(n)) {
                ith_elem = nth(i, list);
                for (cdotimes_end_var = subtract(len, i, ONE_INTEGER), j_i_1 = NIL, j_i_1 = ZERO_INTEGER; j_i_1.numL(cdotimes_end_var); j_i_1 = add(j_i_1, ONE_INTEGER)) {
                    j = add(j_i_1, i, ONE_INTEGER);
                    if (!aref(count, aref(canonical, j)).numGE(n)) {
                        jth_elem = nth(j, list);
                        if (NIL != funcall(test, ith_elem, jth_elem)) {
                            set_aref(canonical, j, aref(canonical, i));
                            set_aref(count, aref(canonical, i), add(aref(count, aref(canonical, i)), ONE_INTEGER));
                        }
                    }
                }
            }
        }
        for (i = NIL, i = ZERO_INTEGER; i.numL(len); i = add(i, ONE_INTEGER)) {
            if (aref(count, aref(canonical, i)).numL(n)) {
                result = cons(nth(i, list), result);
            }
        }
        return nreverse(result);
    }/**
     * Returns a list of all elements in LIST which occur N or fewer times.  Order is preserved.
     * Note: unlike remove-duplicates, this removes ALL occurrences of elements occuring N or more times,
     * not just the extra occurrences.
     * For N=1, this is equivalent to @xref unique-elements.
     *
     * @unknown pace
     */


    public static final SubLObject nsort_intersection_alt(SubLObject list_1, SubLObject list_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.intersect_sorted(Sort.sort(list_1, pred, key), Sort.sort(list_2, pred, key), pred, key);
    }

    public static SubLObject nsort_intersection(final SubLObject list_1, final SubLObject list_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return intersect_sorted(Sort.sort(list_1, pred, key), Sort.sort(list_2, pred, key), pred, key);
    }

    public static SubLObject intersect_sorted_all(final SubLObject lists, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject result = lists.first();
        SubLObject cdolist_list_var = lists.rest();
        SubLObject list_i = NIL;
        list_i = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = intersect_sorted(result, list_i, test, key);
            cdolist_list_var = cdolist_list_var.rest();
            list_i = cdolist_list_var.first();
        } 
        return result;
    }

    public static final SubLObject intersect_sorted_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(sort_1, LISTP);
        SubLTrampolineFile.checkType(sort_2, LISTP);
        {
            SubLObject result = NIL;
            while ((NIL != sort_1) && (NIL != sort_2)) {
                {
                    SubLObject item_1 = sort_1.first();
                    SubLObject item_2 = sort_2.first();
                    if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                        sort_1 = sort_1.rest();
                    } else {
                        if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                            sort_2 = sort_2.rest();
                        } else {
                            result = cons(item_1, result);
                            sort_1 = sort_1.rest();
                            sort_2 = sort_2.rest();
                        }
                    }
                }
            } 
            return nreverse(result);
        }
    }

    public static SubLObject intersect_sorted(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(sort_1) : "! listp(sort_1) " + ("Types.listp(sort_1) " + "CommonSymbols.NIL != Types.listp(sort_1) ") + sort_1;
        assert NIL != listp(sort_2) : "! listp(sort_2) " + ("Types.listp(sort_2) " + "CommonSymbols.NIL != Types.listp(sort_2) ") + sort_2;
        SubLObject result = NIL;
        while ((NIL != sort_1) && (NIL != sort_2)) {
            final SubLObject item_1 = sort_1.first();
            final SubLObject item_2 = sort_2.first();
            if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                sort_1 = sort_1.rest();
            } else
                if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                    sort_2 = sort_2.rest();
                } else {
                    result = cons(item_1, result);
                    sort_1 = sort_1.rest();
                    sort_2 = sort_2.rest();
                }

        } 
        return nreverse(result);
    }

    /**
     * May destroy either SORT-1 or SORT-2
     */
    @LispMethod(comment = "May destroy either SORT-1 or SORT-2")
    public static final SubLObject nintersect_sorted_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(sort_1, LISTP);
        SubLTrampolineFile.checkType(sort_2, LISTP);
        if (NIL != com.cyc.cycjava.cycl.list_utilities.lesser_or_same_length_p(sort_1, sort_2)) {
            return com.cyc.cycjava.cycl.list_utilities.nintersect_sorted_int(sort_1, sort_2, pred, key);
        } else {
            return com.cyc.cycjava.cycl.list_utilities.nintersect_sorted_int(sort_2, sort_1, pred, key);
        }
    }

    @LispMethod(comment = "May destroy either SORT-1 or SORT-2")
    public static SubLObject nintersect_sorted(final SubLObject sort_1, final SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(sort_1) : "! listp(sort_1) " + ("Types.listp(sort_1) " + "CommonSymbols.NIL != Types.listp(sort_1) ") + sort_1;
        assert NIL != listp(sort_2) : "! listp(sort_2) " + ("Types.listp(sort_2) " + "CommonSymbols.NIL != Types.listp(sort_2) ") + sort_2;
        if (NIL != lesser_or_same_length_p(sort_1, sort_2)) {
            return nintersect_sorted_int(sort_1, sort_2, pred, key);
        }
        return nintersect_sorted_int(sort_2, sort_1, pred, key);
    }/**
     * May destroy either SORT-1 or SORT-2
     */


    /**
     * Only destroys SORT-1
     */
    @LispMethod(comment = "Only destroys SORT-1")
    public static final SubLObject nintersect_sorted_destroy_first_only_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(sort_1, LISTP);
        SubLTrampolineFile.checkType(sort_2, LISTP);
        return com.cyc.cycjava.cycl.list_utilities.nintersect_sorted_int(sort_1, sort_2, pred, key);
    }

    @LispMethod(comment = "Only destroys SORT-1")
    public static SubLObject nintersect_sorted_destroy_first_only(final SubLObject sort_1, final SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(sort_1) : "! listp(sort_1) " + ("Types.listp(sort_1) " + "CommonSymbols.NIL != Types.listp(sort_1) ") + sort_1;
        assert NIL != listp(sort_2) : "! listp(sort_2) " + ("Types.listp(sort_2) " + "CommonSymbols.NIL != Types.listp(sort_2) ") + sort_2;
        return nintersect_sorted_int(sort_1, sort_2, pred, key);
    }/**
     * Only destroys SORT-1
     */


    public static final SubLObject nintersect_sorted_int_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        {
            SubLObject result = sort_1;
            SubLObject last_good_cons = NIL;
            while ((NIL != sort_1) && (NIL != sort_2)) {
                {
                    SubLObject item_1 = sort_1.first();
                    SubLObject item_2 = sort_2.first();
                    if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                        if (NIL != last_good_cons) {
                            rplacd(last_good_cons, sort_1.rest());
                        } else {
                            result = sort_1.rest();
                        }
                        sort_1 = sort_1.rest();
                    } else {
                        if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                            sort_2 = sort_2.rest();
                        } else {
                            last_good_cons = sort_1;
                            sort_1 = sort_1.rest();
                            sort_2 = sort_2.rest();
                        }
                    }
                }
            } 
            if (NIL != last_good_cons) {
                rplacd(last_good_cons, NIL);
            } else {
                result = NIL;
            }
            return result;
        }
    }

    public static SubLObject nintersect_sorted_int(SubLObject sort_1, SubLObject sort_2, final SubLObject pred, final SubLObject key) {
        SubLObject result = sort_1;
        SubLObject last_good_cons = NIL;
        while ((NIL != sort_1) && (NIL != sort_2)) {
            final SubLObject item_1 = sort_1.first();
            final SubLObject item_2 = sort_2.first();
            if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                if (NIL != last_good_cons) {
                    rplacd(last_good_cons, sort_1.rest());
                } else {
                    result = sort_1.rest();
                }
                sort_1 = sort_1.rest();
            } else
                if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                    sort_2 = sort_2.rest();
                } else {
                    last_good_cons = sort_1;
                    sort_1 = sort_1.rest();
                    sort_2 = sort_2.rest();
                }

        } 
        if (NIL != last_good_cons) {
            rplacd(last_good_cons, NIL);
        } else {
            result = NIL;
        }
        return result;
    }

    public static final SubLObject sort_intersection_alt(SubLObject list_1, SubLObject list_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.nsort_intersection(copy_list(list_1), copy_list(list_2), pred, key);
    }

    public static SubLObject sort_intersection(final SubLObject list_1, final SubLObject list_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return nsort_intersection(copy_list(list_1), copy_list(list_2), pred, key);
    }

    public static final SubLObject union_sorted_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.union_sorted_int(sort_1, sort_2, pred, key, NIL);
    }

    public static SubLObject union_sorted(final SubLObject sort_1, final SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return union_sorted_int(sort_1, sort_2, pred, key, NIL);
    }

    public static final SubLObject nunion_sorted_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.union_sorted_int(sort_1, sort_2, pred, key, T);
    }

    public static SubLObject nunion_sorted(final SubLObject sort_1, final SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return union_sorted_int(sort_1, sort_2, pred, key, T);
    }

    public static final SubLObject union_sorted_int_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key, SubLObject destructiveP) {
        SubLTrampolineFile.checkType(sort_1, LISTP);
        SubLTrampolineFile.checkType(sort_2, LISTP);
        {
            SubLObject result = NIL;
            while ((NIL != sort_1) && (NIL != sort_2)) {
                {
                    SubLObject item_1 = sort_1.first();
                    SubLObject item_2 = sort_2.first();
                    if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                        result = cons(item_1, result);
                        sort_1 = sort_1.rest();
                    } else {
                        if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                            result = cons(item_2, result);
                            sort_2 = sort_2.rest();
                        } else {
                            result = cons(item_1, result);
                            sort_1 = sort_1.rest();
                            sort_2 = sort_2.rest();
                        }
                    }
                }
            } 
            result = nreverse(result);
            if (NIL != sort_1) {
                result = (NIL != destructiveP) ? ((SubLObject) (append(result, sort_1))) : nconc(result, sort_1);
            } else {
                if (NIL != sort_2) {
                    result = (NIL != destructiveP) ? ((SubLObject) (append(result, sort_2))) : nconc(result, sort_2);
                }
            }
            return result;
        }
    }

    public static SubLObject union_sorted_int(SubLObject sort_1, SubLObject sort_2, final SubLObject pred, final SubLObject key, final SubLObject destructiveP) {
        assert NIL != listp(sort_1) : "! listp(sort_1) " + ("Types.listp(sort_1) " + "CommonSymbols.NIL != Types.listp(sort_1) ") + sort_1;
        assert NIL != listp(sort_2) : "! listp(sort_2) " + ("Types.listp(sort_2) " + "CommonSymbols.NIL != Types.listp(sort_2) ") + sort_2;
        SubLObject result = NIL;
        while ((NIL != sort_1) && (NIL != sort_2)) {
            final SubLObject item_1 = sort_1.first();
            final SubLObject item_2 = sort_2.first();
            if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                result = cons(item_1, result);
                sort_1 = sort_1.rest();
            } else
                if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                    result = cons(item_2, result);
                    sort_2 = sort_2.rest();
                } else {
                    result = cons(item_1, result);
                    sort_1 = sort_1.rest();
                    sort_2 = sort_2.rest();
                }

        } 
        result = nreverse(result);
        if (NIL != sort_1) {
            result = (NIL != destructiveP) ? append(result, sort_1) : nconc(result, sort_1);
        } else
            if (NIL != sort_2) {
                result = (NIL != destructiveP) ? append(result, sort_2) : nconc(result, sort_2);
            }

        return result;
    }

    /**
     *
     *
     * @param SORTED-LISTS
     * 		a set of sorted lists.
     * @return set; a set of sorted lists which may be smaller than SORTED-LISTS.
    If there is any intersection between lists in SORTED-LISTS, they are merged.
    This operation is destructive.
     * @unknown (union-of-intersecting-sorted-lists '((1 2 3) (4 5 6) (6 8 9))) ((1 2 3) (4 5 6 8 9))
     * @unknown (union-of-intersecting-sorted-lists '((1 2 6) (4 5 6) (6 8 9))) ((1 2 4 5 6 8 9))
     * @unknown (union-of-intersecting-sorted-lists '((1 2 3) (4 5 6) (1 8 9))) ((4 5 6) (1 2 3 8 9))
     */
    @LispMethod(comment = "@param SORTED-LISTS\r\n\t\ta set of sorted lists.\r\n@return set; a set of sorted lists which may be smaller than SORTED-LISTS.\r\nIf there is any intersection between lists in SORTED-LISTS, they are merged.\r\nThis operation is destructive.\r\n@unknown (union-of-intersecting-sorted-lists \'((1 2 3) (4 5 6) (6 8 9))) ((1 2 3) (4 5 6 8 9))\r\n@unknown (union-of-intersecting-sorted-lists \'((1 2 6) (4 5 6) (6 8 9))) ((1 2 4 5 6 8 9))\r\n@unknown (union-of-intersecting-sorted-lists \'((1 2 3) (4 5 6) (1 8 9))) ((4 5 6) (1 2 3 8 9))")
    public static final SubLObject union_of_intersecting_sorted_lists_alt(SubLObject sorted_lists, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym134$SAFE__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.union_of_intersecting_sorted_lists_recursive(sorted_lists, ZERO_INTEGER, pred, key);
    }

    /**
     *
     *
     * @param SORTED-LISTS
     * 		a set of sorted lists.
     * @return set; a set of sorted lists which may be smaller than SORTED-LISTS.
    If there is any intersection between lists in SORTED-LISTS, they are merged.
    This operation is destructive.
     * @unknown (union-of-intersecting-sorted-lists '((1 2 3) (4 5 6) (6 8 9))) ((1 2 3) (4 5 6 8 9))
     * @unknown (union-of-intersecting-sorted-lists '((1 2 6) (4 5 6) (6 8 9))) ((1 2 4 5 6 8 9))
     * @unknown (union-of-intersecting-sorted-lists '((1 2 3) (4 5 6) (1 8 9))) ((4 5 6) (1 2 3 8 9))
     */
    @LispMethod(comment = "@param SORTED-LISTS\r\n\t\ta set of sorted lists.\r\n@return set; a set of sorted lists which may be smaller than SORTED-LISTS.\r\nIf there is any intersection between lists in SORTED-LISTS, they are merged.\r\nThis operation is destructive.\r\n@unknown (union-of-intersecting-sorted-lists \'((1 2 3) (4 5 6) (6 8 9))) ((1 2 3) (4 5 6 8 9))\r\n@unknown (union-of-intersecting-sorted-lists \'((1 2 6) (4 5 6) (6 8 9))) ((1 2 4 5 6 8 9))\r\n@unknown (union-of-intersecting-sorted-lists \'((1 2 3) (4 5 6) (1 8 9))) ((4 5 6) (1 2 3 8 9))")
    public static SubLObject union_of_intersecting_sorted_lists(final SubLObject sorted_lists, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym136$SAFE__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return union_of_intersecting_sorted_lists_recursive(sorted_lists, ZERO_INTEGER, pred, key);
    }

    public static final SubLObject union_of_intersecting_sorted_lists_recursive_alt(SubLObject sorted_lists, SubLObject index, SubLObject pred, SubLObject key) {
        if (index.numGE(length(sorted_lists))) {
            return sorted_lists;
        } else {
            {
                SubLObject intersection_indices = com.cyc.cycjava.cycl.list_utilities.which_intersect_element_sorted(sorted_lists, index, pred, key);
                SubLObject result = NIL;
                if (NIL != com.cyc.cycjava.cycl.list_utilities.singletonP(intersection_indices)) {
                    return com.cyc.cycjava.cycl.list_utilities.union_of_intersecting_sorted_lists_recursive(sorted_lists, add(index, ONE_INTEGER), pred, key);
                } else {
                    {
                        SubLObject intersected_list = NIL;
                        SubLObject cdolist_list_var = intersection_indices;
                        SubLObject idx = NIL;
                        for (idx = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , idx = cdolist_list_var.first()) {
                            intersected_list = append(nth(idx, sorted_lists), intersected_list);
                        }
                        intersected_list = com.cyc.cycjava.cycl.list_utilities.delete_duplicates_sorted(Sort.sort(intersected_list, pred, key), UNPROVIDED);
                        result = cons(intersected_list, result);
                        {
                            SubLObject list_var = NIL;
                            SubLObject list = NIL;
                            SubLObject i = NIL;
                            for (list_var = sorted_lists, list = list_var.first(), i = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , list = list_var.first() , i = add(ONE_INTEGER, i)) {
                                if (NIL == subl_promotions.memberP(i, intersection_indices, UNPROVIDED, UNPROVIDED)) {
                                    result = cons(list, result);
                                }
                            }
                        }
                        return com.cyc.cycjava.cycl.list_utilities.union_of_intersecting_sorted_lists_recursive(result, ZERO_INTEGER, pred, key);
                    }
                }
            }
        }
    }

    public static SubLObject union_of_intersecting_sorted_lists_recursive(final SubLObject sorted_lists, final SubLObject index, final SubLObject pred, final SubLObject key) {
        if (index.numGE(length(sorted_lists))) {
            return sorted_lists;
        }
        final SubLObject intersection_indices = which_intersect_element_sorted(sorted_lists, index, pred, key);
        SubLObject result = NIL;
        if (NIL != singletonP(intersection_indices)) {
            return union_of_intersecting_sorted_lists_recursive(sorted_lists, add(index, ONE_INTEGER), pred, key);
        }
        SubLObject intersected_list = NIL;
        SubLObject cdolist_list_var = intersection_indices;
        SubLObject idx = NIL;
        idx = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            intersected_list = append(nth(idx, sorted_lists), intersected_list);
            cdolist_list_var = cdolist_list_var.rest();
            idx = cdolist_list_var.first();
        } 
        intersected_list = delete_duplicates_sorted(Sort.sort(intersected_list, pred, key), UNPROVIDED);
        result = cons(intersected_list, result);
        SubLObject list_var = NIL;
        SubLObject list = NIL;
        SubLObject i = NIL;
        list_var = sorted_lists;
        list = list_var.first();
        for (i = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , list = list_var.first() , i = add(ONE_INTEGER, i)) {
            if (NIL == subl_promotions.memberP(i, intersection_indices, UNPROVIDED, UNPROVIDED)) {
                result = cons(list, result);
            }
        }
        return union_of_intersecting_sorted_lists_recursive(result, ZERO_INTEGER, pred, key);
    }

    /**
     * Deletes duplicates from SORTED-LIST.
     */
    @LispMethod(comment = "Deletes duplicates from SORTED-LIST.")
    public static final SubLObject delete_duplicates_sorted_alt(SubLObject sorted_list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject last_cons = sorted_list;
            SubLObject this_cons = sorted_list.rest();
            while (NIL != this_cons) {
                if (NIL != funcall(test, this_cons.first(), last_cons.first())) {
                    rplacd(last_cons, this_cons.rest());
                } else {
                    last_cons = this_cons;
                }
                this_cons = this_cons.rest();
            } 
        }
        return sorted_list;
    }

    @LispMethod(comment = "Deletes duplicates from SORTED-LIST.")
    public static SubLObject delete_duplicates_sorted(final SubLObject sorted_list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject last_cons = sorted_list;
        for (SubLObject this_cons = sorted_list.rest(); NIL != this_cons; this_cons = this_cons.rest()) {
            if (NIL != funcall(test, this_cons.first(), last_cons.first())) {
                rplacd(last_cons, this_cons.rest());
            } else {
                last_cons = this_cons;
            }
        }
        return sorted_list;
    }/**
     * Deletes duplicates from SORTED-LIST.
     */


    public static final SubLObject remove_duplicates_sorted_alt(SubLObject sorted_list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return com.cyc.cycjava.cycl.list_utilities.delete_duplicates_sorted(copy_list(sorted_list), test);
    }

    public static SubLObject remove_duplicates_sorted(final SubLObject sorted_list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        return delete_duplicates_sorted(copy_list(sorted_list), test);
    }

    public static final SubLObject position_wrt_alt(SubLObject item, SubLObject test, SubLObject list, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        SubLTrampolineFile.checkType(start, INTEGERP);
        SubLTrampolineFile.checkType(list, LISTP);
        {
            SubLObject target = funcall(key, item);
            SubLObject index = start;
            SubLObject limit = (end.isInteger()) ? ((SubLObject) (add(ONE_INTEGER, end))) : length(list);
            SubLObject list_item = NIL;
            for (list_item = nth(index, list); !(index.numE(limit) || (NIL != funcall(test, target, funcall(key, list_item)))); list_item = nth(index, list)) {
                index = add(index, ONE_INTEGER);
            }
            if (!index.numE(limit)) {
                return index;
            }
        }
        return NIL;
    }

    public static SubLObject position_wrt(final SubLObject item, final SubLObject test, final SubLObject list, SubLObject key, SubLObject start, SubLObject end) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (start == UNPROVIDED) {
            start = ZERO_INTEGER;
        }
        if (end == UNPROVIDED) {
            end = NIL;
        }
        assert NIL != integerp(start) : "! integerp(start) " + ("Types.integerp(start) " + "CommonSymbols.NIL != Types.integerp(start) ") + start;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        SubLObject target;
        SubLObject index;
        SubLObject limit;
        SubLObject list_item;
        for (target = funcall(key, item), index = start, limit = (end.isInteger()) ? add(ONE_INTEGER, end) : length(list), list_item = NIL, list_item = nth(index, list); (!index.numE(limit)) && (NIL == funcall(test, target, funcall(key, list_item))); index = add(index, ONE_INTEGER) , list_item = nth(index, list)) {
        }
        if (!index.numE(limit)) {
            return index;
        }
        return NIL;
    }

    /**
     *
     *
     * @return LISTP of items on SORT-1 not on SORT-2.
    Assumes SORT-1 and SORT-2 are sorted by PRED.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of items on SORT-1 not on SORT-2.\r\nAssumes SORT-1 and SORT-2 are sorted by PRED.\r\n@unknown baxter")
    public static final SubLObject difference_sorted_alt(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym133$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(sort_1, LISTP);
        SubLTrampolineFile.checkType(sort_2, LISTP);
        {
            SubLObject result = NIL;
            while ((NIL != sort_1) && (NIL != sort_2)) {
                {
                    SubLObject item_1 = sort_1.first();
                    SubLObject item_2 = sort_2.first();
                    if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                        result = cons(item_1, result);
                        sort_1 = sort_1.rest();
                    } else {
                        if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                            sort_2 = sort_2.rest();
                        } else {
                            sort_1 = sort_1.rest();
                            sort_2 = sort_2.rest();
                        }
                    }
                }
            } 
            return append(nreverse(result), sort_1);
        }
    }

    /**
     *
     *
     * @return LISTP of items on SORT-1 not on SORT-2.
    Assumes SORT-1 and SORT-2 are sorted by PRED.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of items on SORT-1 not on SORT-2.\r\nAssumes SORT-1 and SORT-2 are sorted by PRED.\r\n@unknown baxter")
    public static SubLObject difference_sorted(SubLObject sort_1, SubLObject sort_2, SubLObject pred, SubLObject key) {
        if (pred == UNPROVIDED) {
            pred = $sym135$TERM__;
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(sort_1) : "! listp(sort_1) " + ("Types.listp(sort_1) " + "CommonSymbols.NIL != Types.listp(sort_1) ") + sort_1;
        assert NIL != listp(sort_2) : "! listp(sort_2) " + ("Types.listp(sort_2) " + "CommonSymbols.NIL != Types.listp(sort_2) ") + sort_2;
        SubLObject result = NIL;
        while ((NIL != sort_1) && (NIL != sort_2)) {
            final SubLObject item_1 = sort_1.first();
            final SubLObject item_2 = sort_2.first();
            if (NIL != funcall(pred, funcall(key, item_1), funcall(key, item_2))) {
                result = cons(item_1, result);
                sort_1 = sort_1.rest();
            } else
                if (NIL != funcall(pred, funcall(key, item_2), funcall(key, item_1))) {
                    sort_2 = sort_2.rest();
                } else {
                    sort_1 = sort_1.rest();
                    sort_2 = sort_2.rest();
                }

        } 
        return append(nreverse(result), sort_1);
    }

    /**
     * Return T iff OBJECT is an association list.
     */
    @LispMethod(comment = "Return T iff OBJECT is an association list.")
    public static final SubLObject alist_p_alt(SubLObject v_object) {
        return listp(v_object);
    }

    @LispMethod(comment = "Return T iff OBJECT is an association list.")
    public static SubLObject alist_p(final SubLObject v_object) {
        return listp(v_object);
    }/**
     * Return T iff OBJECT is an association list.
     */


    /**
     * Return the value associated with KEY in ALIST (using TEST for key equality).
     * Return DEFAULT if KEY is not present.
     * Return a second value of T iff KEY was found.
     */
    @LispMethod(comment = "Return the value associated with KEY in ALIST (using TEST for key equality).\r\nReturn DEFAULT if KEY is not present.\r\nReturn a second value of T iff KEY was found.\nReturn the value associated with KEY in ALIST (using TEST for key equality).\nReturn DEFAULT if KEY is not present.\nReturn a second value of T iff KEY was found.")
    public static final SubLObject alist_lookup_alt(SubLObject alist, SubLObject key, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                return values(pair.rest(), T);
            } else {
                return values(v_default, NIL);
            }
        }
    }

    @LispMethod(comment = "Return the value associated with KEY in ALIST (using TEST for key equality).\r\nReturn DEFAULT if KEY is not present.\r\nReturn a second value of T iff KEY was found.\nReturn the value associated with KEY in ALIST (using TEST for key equality).\nReturn DEFAULT if KEY is not present.\nReturn a second value of T iff KEY was found.")
    public static SubLObject alist_lookup(final SubLObject alist, final SubLObject key, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            return subl_promotions.values2(pair.rest(), T);
        }
        return subl_promotions.values2(v_default, NIL);
    }/**
     * Return the value associated with KEY in ALIST (using TEST for key equality).
     * Return DEFAULT if KEY is not present.
     * Return a second value of T iff KEY was found.
     */


    /**
     * Return the value associated with KEY in ALIST (using TEST for key equality).
     * Return DEFAULT if KEY is not present.
     * Unlike ALIST-LOOKUP, only 1 value is returned.
     */
    @LispMethod(comment = "Return the value associated with KEY in ALIST (using TEST for key equality).\r\nReturn DEFAULT if KEY is not present.\r\nUnlike ALIST-LOOKUP, only 1 value is returned.\nReturn the value associated with KEY in ALIST (using TEST for key equality).\nReturn DEFAULT if KEY is not present.\nUnlike ALIST-LOOKUP, only 1 value is returned.")
    public static final SubLObject alist_lookup_without_values_alt(SubLObject alist, SubLObject key, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            return NIL != pair ? ((SubLObject) (pair.rest())) : v_default;
        }
    }

    @LispMethod(comment = "Return the value associated with KEY in ALIST (using TEST for key equality).\r\nReturn DEFAULT if KEY is not present.\r\nUnlike ALIST-LOOKUP, only 1 value is returned.\nReturn the value associated with KEY in ALIST (using TEST for key equality).\nReturn DEFAULT if KEY is not present.\nUnlike ALIST-LOOKUP, only 1 value is returned.")
    public static SubLObject alist_lookup_without_values(final SubLObject alist, final SubLObject key, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        return NIL != pair ? pair.rest() : v_default;
    }/**
     * Return the value associated with KEY in ALIST (using TEST for key equality).
     * Return DEFAULT if KEY is not present.
     * Unlike ALIST-LOOKUP, only 1 value is returned.
     */


    /**
     *
     *
     * @return 0 a destructively modified version of ALIST.
     * @return 1 the value associated with KEY in ALIST (using TEST for key equality).
    Return DEFAULT if KEY is not present.
    In passing, move the cons containing the returned value one step closer to the front of ALIST,
    unless it is already at the head of ALIST or one away from the head.
    This will, in the limit, bring the more frequently accessed elements of ALIST to the front.
     * @see nmember?
     */
    @LispMethod(comment = "@return 0 a destructively modified version of ALIST.\r\n@return 1 the value associated with KEY in ALIST (using TEST for key equality).\r\nReturn DEFAULT if KEY is not present.\r\nIn passing, move the cons containing the returned value one step closer to the front of ALIST,\r\nunless it is already at the head of ALIST or one away from the head.\r\nThis will, in the limit, bring the more frequently accessed elements of ALIST to the front.\r\n@see nmember?")
    public static final SubLObject alist_nlookup_without_values_alt(SubLObject alist, SubLObject key, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        if ((test == symbol_function(EQ)) || (test == EQ)) {
            return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_eq(alist, key, v_default);
        } else {
            if ((test == symbol_function(EQL)) || (test == EQL)) {
                return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_eql(alist, key, v_default);
            } else {
                if ((test == symbol_function(EQUAL)) || (test == EQUAL)) {
                    return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_equal(alist, key, v_default);
                } else {
                    if ((test == symbol_function(EQUALP)) || (test == EQUALP)) {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_equalp(alist, key, v_default);
                    } else {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_funcall(alist, key, test, v_default);
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return 0 a destructively modified version of ALIST.
     * @return 1 the value associated with KEY in ALIST (using TEST for key equality).
    Return DEFAULT if KEY is not present.
    In passing, move the cons containing the returned value one step closer to the front of ALIST,
    unless it is already at the head of ALIST or one away from the head.
    This will, in the limit, bring the more frequently accessed elements of ALIST to the front.
     * @see nmember?
     */
    @LispMethod(comment = "@return 0 a destructively modified version of ALIST.\r\n@return 1 the value associated with KEY in ALIST (using TEST for key equality).\r\nReturn DEFAULT if KEY is not present.\r\nIn passing, move the cons containing the returned value one step closer to the front of ALIST,\r\nunless it is already at the head of ALIST or one away from the head.\r\nThis will, in the limit, bring the more frequently accessed elements of ALIST to the front.\r\n@see nmember?")
    public static SubLObject alist_nlookup_without_values(final SubLObject alist, final SubLObject key, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        if (test.eql(symbol_function(EQ)) || (test == EQ)) {
            return alist_nlookup_eq(alist, key, v_default);
        }
        if (test.eql(symbol_function(EQL)) || (test == EQL)) {
            return alist_nlookup_eql(alist, key, v_default);
        }
        if (test.eql(symbol_function(EQUAL)) || (test == EQUAL)) {
            return alist_nlookup_equal(alist, key, v_default);
        }
        if (test.eql(symbol_function(EQUALP)) || (test == EQUALP)) {
            return alist_nlookup_equalp(alist, key, v_default);
        }
        return alist_nlookup_funcall(alist, key, test, v_default);
    }

    public static final SubLObject alist_nlookup_eq_alt(SubLObject alist, SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject alist_cons = NIL;
            for (alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
                {
                    SubLObject pair = alist_cons.first();
                    SubLObject candidate_key = pair.first();
                    if (key == candidate_key) {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
                    }
                }
                last_last_cons = last_cons;
                last_cons = alist_cons;
            }
        }
        return v_default;
    }

    public static SubLObject alist_nlookup_eq(final SubLObject alist, final SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject alist_cons;
        SubLObject pair;
        SubLObject candidate_key;
        for (alist_cons = NIL, alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
            pair = alist_cons.first();
            candidate_key = pair.first();
            if (key.eql(candidate_key)) {
                return alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
            }
            last_last_cons = last_cons;
            last_cons = alist_cons;
        }
        return v_default;
    }

    public static final SubLObject alist_nlookup_eql_alt(SubLObject alist, SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject alist_cons = NIL;
            for (alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
                {
                    SubLObject pair = alist_cons.first();
                    SubLObject candidate_key = pair.first();
                    if (key.eql(candidate_key)) {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
                    }
                }
                last_last_cons = last_cons;
                last_cons = alist_cons;
            }
        }
        return v_default;
    }

    public static SubLObject alist_nlookup_eql(final SubLObject alist, final SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject alist_cons;
        SubLObject pair;
        SubLObject candidate_key;
        for (alist_cons = NIL, alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
            pair = alist_cons.first();
            candidate_key = pair.first();
            if (key.eql(candidate_key)) {
                return alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
            }
            last_last_cons = last_cons;
            last_cons = alist_cons;
        }
        return v_default;
    }

    public static final SubLObject alist_nlookup_equal_alt(SubLObject alist, SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject alist_cons = NIL;
            for (alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
                {
                    SubLObject pair = alist_cons.first();
                    SubLObject candidate_key = pair.first();
                    if (key.equal(candidate_key)) {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
                    }
                }
                last_last_cons = last_cons;
                last_cons = alist_cons;
            }
        }
        return v_default;
    }

    public static SubLObject alist_nlookup_equal(final SubLObject alist, final SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject alist_cons;
        SubLObject pair;
        SubLObject candidate_key;
        for (alist_cons = NIL, alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
            pair = alist_cons.first();
            candidate_key = pair.first();
            if (key.equal(candidate_key)) {
                return alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
            }
            last_last_cons = last_cons;
            last_cons = alist_cons;
        }
        return v_default;
    }

    public static final SubLObject alist_nlookup_equalp_alt(SubLObject alist, SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject alist_cons = NIL;
            for (alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
                {
                    SubLObject pair = alist_cons.first();
                    SubLObject candidate_key = pair.first();
                    if (key.equalp(candidate_key)) {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
                    }
                }
                last_last_cons = last_cons;
                last_cons = alist_cons;
            }
        }
        return v_default;
    }

    public static SubLObject alist_nlookup_equalp(final SubLObject alist, final SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject alist_cons;
        SubLObject pair;
        SubLObject candidate_key;
        for (alist_cons = NIL, alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
            pair = alist_cons.first();
            candidate_key = pair.first();
            if (key.equalp(candidate_key)) {
                return alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
            }
            last_last_cons = last_cons;
            last_cons = alist_cons;
        }
        return v_default;
    }

    public static final SubLObject alist_nlookup_funcall_alt(SubLObject alist, SubLObject key, SubLObject test, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        {
            SubLObject last_last_cons = NIL;
            SubLObject last_cons = NIL;
            SubLObject alist_cons = NIL;
            for (alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
                {
                    SubLObject pair = alist_cons.first();
                    SubLObject candidate_key = pair.first();
                    if (NIL != funcall(test, key, candidate_key)) {
                        return com.cyc.cycjava.cycl.list_utilities.alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
                    }
                }
                last_last_cons = last_cons;
                last_cons = alist_cons;
            }
        }
        return v_default;
    }

    public static SubLObject alist_nlookup_funcall(final SubLObject alist, final SubLObject key, final SubLObject test, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLObject last_last_cons = NIL;
        SubLObject last_cons = NIL;
        SubLObject alist_cons;
        SubLObject pair;
        SubLObject candidate_key;
        for (alist_cons = NIL, alist_cons = alist; !alist_cons.isAtom(); alist_cons = alist_cons.rest()) {
            pair = alist_cons.first();
            candidate_key = pair.first();
            if (NIL != funcall(test, key, candidate_key)) {
                return alist_nlookup_success(last_last_cons, last_cons, alist_cons, pair.rest());
            }
            last_last_cons = last_cons;
            last_cons = alist_cons;
        }
        return v_default;
    }

    /**
     * move alist-cons 1 cons earlier
     */
    @LispMethod(comment = "move alist-cons 1 cons earlier")
    public static final SubLObject alist_nlookup_success_alt(SubLObject last_last_cons, SubLObject last_cons, SubLObject alist_cons, SubLObject value) {
        if (NIL != last_last_cons) {
            rplacd(last_last_cons, alist_cons);
            rplacd(last_cons, alist_cons.rest());
            rplacd(alist_cons, last_cons);
        }
        return value;
    }

    @LispMethod(comment = "move alist-cons 1 cons earlier")
    public static SubLObject alist_nlookup_success(final SubLObject last_last_cons, final SubLObject last_cons, final SubLObject alist_cons, final SubLObject value) {
        if (NIL != last_last_cons) {
            rplacd(last_last_cons, alist_cons);
            rplacd(last_cons, alist_cons.rest());
            rplacd(alist_cons, last_cons);
        }
        return value;
    }/**
     * move alist-cons 1 cons earlier
     */


    /**
     *
     *
     * @return booleanp; whether KEY is a key in the association list ALIST
     */
    @LispMethod(comment = "@return booleanp; whether KEY is a key in the association list ALIST")
    public static final SubLObject alist_has_keyP_alt(SubLObject alist, SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        return subl_promotions.memberP(key, alist, test, symbol_function(CAR));
    }

    /**
     *
     *
     * @return booleanp; whether KEY is a key in the association list ALIST
     */
    @LispMethod(comment = "@return booleanp; whether KEY is a key in the association list ALIST")
    public static SubLObject alist_has_keyP(final SubLObject alist, final SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        return subl_promotions.memberP(key, alist, test, symbol_function(CAR));
    }

    /**
     *
     *
     * @return booleanp; whether VALUE is a value in the association list ALIST
     */
    @LispMethod(comment = "@return booleanp; whether VALUE is a value in the association list ALIST")
    public static final SubLObject alist_has_valueP_alt(SubLObject alist, SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        return subl_promotions.memberP(value, alist, test, symbol_function(CDR));
    }

    /**
     *
     *
     * @return booleanp; whether VALUE is a value in the association list ALIST
     */
    @LispMethod(comment = "@return booleanp; whether VALUE is a value in the association list ALIST")
    public static SubLObject alist_has_valueP(final SubLObject alist, final SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        return subl_promotions.memberP(value, alist, test, symbol_function(CDR));
    }

    /**
     * Return the first key with which VALUE is associated in ALIST (using TEST for value equality).
     * Return DEFAULT if VALUE is not present.
     * Return a second value of T iff VALUE was found.
     */
    @LispMethod(comment = "Return the first key with which VALUE is associated in ALIST (using TEST for value equality).\r\nReturn DEFAULT if VALUE is not present.\r\nReturn a second value of T iff VALUE was found.\nReturn the first key with which VALUE is associated in ALIST (using TEST for value equality).\nReturn DEFAULT if VALUE is not present.\nReturn a second value of T iff VALUE was found.")
    public static final SubLObject alist_reverse_lookup_alt(SubLObject alist, SubLObject value, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = rassoc(value, alist, test, UNPROVIDED);
            if (NIL != pair) {
                return values(pair.first(), T);
            } else {
                return values(v_default, NIL);
            }
        }
    }

    @LispMethod(comment = "Return the first key with which VALUE is associated in ALIST (using TEST for value equality).\r\nReturn DEFAULT if VALUE is not present.\r\nReturn a second value of T iff VALUE was found.\nReturn the first key with which VALUE is associated in ALIST (using TEST for value equality).\nReturn DEFAULT if VALUE is not present.\nReturn a second value of T iff VALUE was found.")
    public static SubLObject alist_reverse_lookup(final SubLObject alist, final SubLObject value, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = rassoc(value, alist, test, UNPROVIDED);
        if (NIL != pair) {
            return subl_promotions.values2(pair.first(), T);
        }
        return subl_promotions.values2(v_default, NIL);
    }/**
     * Return the first key with which VALUE is associated in ALIST (using TEST for value equality).
     * Return DEFAULT if VALUE is not present.
     * Return a second value of T iff VALUE was found.
     */


    /**
     * Return the first key with which VALUE is associated in ALIST (using TEST for value equality).
     * Return DEFAULT if VALUE is not present.
     */
    @LispMethod(comment = "Return the first key with which VALUE is associated in ALIST (using TEST for value equality).\r\nReturn DEFAULT if VALUE is not present.\nReturn the first key with which VALUE is associated in ALIST (using TEST for value equality).\nReturn DEFAULT if VALUE is not present.")
    public static final SubLObject alist_reverse_lookup_without_values_alt(SubLObject alist, SubLObject value, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = rassoc(value, alist, test, UNPROVIDED);
            return NIL != pair ? ((SubLObject) (pair.first())) : v_default;
        }
    }

    @LispMethod(comment = "Return the first key with which VALUE is associated in ALIST (using TEST for value equality).\r\nReturn DEFAULT if VALUE is not present.\nReturn the first key with which VALUE is associated in ALIST (using TEST for value equality).\nReturn DEFAULT if VALUE is not present.")
    public static SubLObject alist_reverse_lookup_without_values(final SubLObject alist, final SubLObject value, SubLObject test, SubLObject v_default) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = rassoc(value, alist, test, UNPROVIDED);
        return NIL != pair ? pair.first() : v_default;
    }/**
     * Return the first key with which VALUE is associated in ALIST (using TEST for value equality).
     * Return DEFAULT if VALUE is not present.
     */


    /**
     * Note that VALUE is associated with KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */
    @LispMethod(comment = "Note that VALUE is associated with KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nNote that VALUE is associated with KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static final SubLObject alist_enter_alt(SubLObject alist, SubLObject key, SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                rplacd(pair, value);
            } else {
                alist = acons(key, value, alist);
            }
            return values(alist, com.cyc.cycjava.cycl.list_utilities.sublisp_boolean(pair));
        }
    }

    @LispMethod(comment = "Note that VALUE is associated with KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nNote that VALUE is associated with KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static SubLObject alist_enter(SubLObject alist, final SubLObject key, final SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            rplacd(pair, value);
        } else {
            alist = acons(key, value, alist);
        }
        return subl_promotions.values2(alist, sublisp_boolean(pair));
    }/**
     * Note that VALUE is associated with KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */


    /**
     * Note that VALUE is associated with KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Unlike ALIST-ENTER, only 1 value is returned.
     */
    @LispMethod(comment = "Note that VALUE is associated with KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nUnlike ALIST-ENTER, only 1 value is returned.\nNote that VALUE is associated with KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nUnlike ALIST-ENTER, only 1 value is returned.")
    public static final SubLObject alist_enter_without_values_alt(SubLObject alist, SubLObject key, SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                rplacd(pair, value);
            } else {
                alist = acons(key, value, alist);
            }
        }
        return alist;
    }

    @LispMethod(comment = "Note that VALUE is associated with KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nUnlike ALIST-ENTER, only 1 value is returned.\nNote that VALUE is associated with KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nUnlike ALIST-ENTER, only 1 value is returned.")
    public static SubLObject alist_enter_without_values(SubLObject alist, final SubLObject key, final SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            rplacd(pair, value);
        } else {
            alist = acons(key, value, alist);
        }
        return alist;
    }/**
     * Note that VALUE is associated with KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Unlike ALIST-ENTER, only 1 value is returned.
     */


    /**
     * Note that VALUE is associated with KEY in ALIST (using TEST for key equality).
     * Any associations above the number CAPACITY are dropped from the end.
     * Return the resulting alist.
     * Unlike ALIST-ENTER, only 1 value is returned.
     */
    @LispMethod(comment = "Note that VALUE is associated with KEY in ALIST (using TEST for key equality).\r\nAny associations above the number CAPACITY are dropped from the end.\r\nReturn the resulting alist.\r\nUnlike ALIST-ENTER, only 1 value is returned.\nNote that VALUE is associated with KEY in ALIST (using TEST for key equality).\nAny associations above the number CAPACITY are dropped from the end.\nReturn the resulting alist.\nUnlike ALIST-ENTER, only 1 value is returned.")
    public static final SubLObject alist_capacity_enter_without_values_alt(SubLObject alist, SubLObject key, SubLObject value, SubLObject capacity, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (capacity.isZero()) {
            return NIL;
        }
        alist = com.cyc.cycjava.cycl.list_utilities.alist_enter_without_values(alist, key, value, test);
        if (NIL != com.cyc.cycjava.cycl.list_utilities.lengthG(alist, capacity, UNPROVIDED)) {
            rplacd(nthcdr(number_utilities.f_1_(capacity), alist), NIL);
        }
        return alist;
    }

    @LispMethod(comment = "Note that VALUE is associated with KEY in ALIST (using TEST for key equality).\r\nAny associations above the number CAPACITY are dropped from the end.\r\nReturn the resulting alist.\r\nUnlike ALIST-ENTER, only 1 value is returned.\nNote that VALUE is associated with KEY in ALIST (using TEST for key equality).\nAny associations above the number CAPACITY are dropped from the end.\nReturn the resulting alist.\nUnlike ALIST-ENTER, only 1 value is returned.")
    public static SubLObject alist_capacity_enter_without_values(SubLObject alist, final SubLObject key, final SubLObject value, final SubLObject capacity, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (capacity.isZero()) {
            return NIL;
        }
        alist = alist_enter_without_values(alist, key, value, test);
        if (NIL != lengthG(alist, capacity, UNPROVIDED)) {
            rplacd(nthcdr(number_utilities.f_1_(capacity), alist), NIL);
        }
        return alist;
    }/**
     * Note that VALUE is associated with KEY in ALIST (using TEST for key equality).
     * Any associations above the number CAPACITY are dropped from the end.
     * Return the resulting alist.
     * Unlike ALIST-ENTER, only 1 value is returned.
     */


    /**
     * Move any associaltion for KEY in ALIST to the front (using TEST for key equality).
     * Return the resulting alist.
     */
    @LispMethod(comment = "Move any associaltion for KEY in ALIST to the front (using TEST for key equality).\r\nReturn the resulting alist.\nMove any associaltion for KEY in ALIST to the front (using TEST for key equality).\nReturn the resulting alist.")
    public static final SubLObject alist_promote_alt(SubLObject alist, SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                if (pair != alist.first()) {
                    alist = cons(pair, com.cyc.cycjava.cycl.list_utilities.delete_first(pair, alist, symbol_function(EQ)));
                }
            }
        }
        return alist;
    }

    @LispMethod(comment = "Move any associaltion for KEY in ALIST to the front (using TEST for key equality).\r\nReturn the resulting alist.\nMove any associaltion for KEY in ALIST to the front (using TEST for key equality).\nReturn the resulting alist.")
    public static SubLObject alist_promote(SubLObject alist, final SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if ((NIL != pair) && (!pair.eql(alist.first()))) {
            alist = cons(pair, delete_first(pair, alist, symbol_function(EQ)));
        }
        return alist;
    }/**
     * Move any associaltion for KEY in ALIST to the front (using TEST for key equality).
     * Return the resulting alist.
     */


    /**
     * Delete any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */
    @LispMethod(comment = "Delete any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nDelete any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static final SubLObject alist_delete_alt(SubLObject alist, SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                alist = com.cyc.cycjava.cycl.list_utilities.delete_first(pair, alist, UNPROVIDED);
            }
            return values(alist, com.cyc.cycjava.cycl.list_utilities.sublisp_boolean(pair));
        }
    }

    @LispMethod(comment = "Delete any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nDelete any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static SubLObject alist_delete(SubLObject alist, final SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            alist = delete_first(pair, alist, UNPROVIDED);
        }
        return subl_promotions.values2(alist, sublisp_boolean(pair));
    }/**
     * Delete any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */


    /**
     * Delete any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Unlike ALIST-DELETE, only 1 value is returned.
     */
    @LispMethod(comment = "Delete any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nUnlike ALIST-DELETE, only 1 value is returned.\nDelete any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nUnlike ALIST-DELETE, only 1 value is returned.")
    public static final SubLObject alist_delete_without_values_alt(SubLObject alist, SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                alist = com.cyc.cycjava.cycl.list_utilities.delete_first(pair, alist, UNPROVIDED);
            }
            return alist;
        }
    }

    @LispMethod(comment = "Delete any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nUnlike ALIST-DELETE, only 1 value is returned.\nDelete any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nUnlike ALIST-DELETE, only 1 value is returned.")
    public static SubLObject alist_delete_without_values(SubLObject alist, final SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            alist = delete_first(pair, alist, UNPROVIDED);
        }
        return alist;
    }/**
     * Delete any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Unlike ALIST-DELETE, only 1 value is returned.
     */


    /**
     * Remove any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */
    @LispMethod(comment = "Remove any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nRemove any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static final SubLObject alist_remove_alt(SubLObject alist, SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                alist = com.cyc.cycjava.cycl.list_utilities.remove_first(pair, alist, UNPROVIDED);
            }
            return values(alist, com.cyc.cycjava.cycl.list_utilities.sublisp_boolean(pair));
        }
    }

    @LispMethod(comment = "Remove any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nRemove any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static SubLObject alist_remove(SubLObject alist, final SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            alist = remove_first(pair, alist, UNPROVIDED);
        }
        return subl_promotions.values2(alist, sublisp_boolean(pair));
    }/**
     * Remove any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */


    /**
     * Remove any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Unlike ALIST-REMOVE, only 1 value is returned.
     */
    @LispMethod(comment = "Remove any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nUnlike ALIST-REMOVE, only 1 value is returned.\nRemove any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nUnlike ALIST-REMOVE, only 1 value is returned.")
    public static final SubLObject alist_remove_without_values_alt(SubLObject alist, SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                alist = com.cyc.cycjava.cycl.list_utilities.remove_first(pair, alist, UNPROVIDED);
            }
            return alist;
        }
    }

    @LispMethod(comment = "Remove any association for KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nUnlike ALIST-REMOVE, only 1 value is returned.\nRemove any association for KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nUnlike ALIST-REMOVE, only 1 value is returned.")
    public static SubLObject alist_remove_without_values(SubLObject alist, final SubLObject key, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            alist = remove_first(pair, alist, UNPROVIDED);
        }
        return alist;
    }/**
     * Remove any association for KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Unlike ALIST-REMOVE, only 1 value is returned.
     */


    /**
     * Note that VALUE is in a list associated with KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */
    @LispMethod(comment = "Note that VALUE is in a list associated with KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nNote that VALUE is in a list associated with KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static final SubLObject alist_push_alt(SubLObject alist, SubLObject key, SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, test, UNPROVIDED);
            if (NIL != pair) {
                rplacd(pair, cons(value, pair.rest()));
            } else {
                alist = acons(key, list(value), alist);
            }
            return values(alist, com.cyc.cycjava.cycl.list_utilities.sublisp_boolean(pair));
        }
    }

    @LispMethod(comment = "Note that VALUE is in a list associated with KEY in ALIST (using TEST for key equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nNote that VALUE is in a list associated with KEY in ALIST (using TEST for key equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static SubLObject alist_push(SubLObject alist, final SubLObject key, final SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, test, UNPROVIDED);
        if (NIL != pair) {
            rplacd(pair, cons(value, pair.rest()));
        } else {
            alist = acons(key, list(value), alist);
        }
        return subl_promotions.values2(alist, sublisp_boolean(pair));
    }/**
     * Note that VALUE is in a list associated with KEY in ALIST (using TEST for key equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */


    /**
     * Note that VALUE is in a list associated with KEY in ALIST (using KEY-TEST for key equality,
     * and VALUE-TEST for value equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */
    @LispMethod(comment = "Note that VALUE is in a list associated with KEY in ALIST (using KEY-TEST for key equality,\r\nand VALUE-TEST for value equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nNote that VALUE is in a list associated with KEY in ALIST (using KEY-TEST for key equality,\nand VALUE-TEST for value equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static final SubLObject alist_pushnew_alt(SubLObject alist, SubLObject key, SubLObject value, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject pair = assoc(key, alist, key_test, UNPROVIDED);
            if (NIL == pair) {
                alist = acons(key, list(value), alist);
            } else {
                if (NIL != member(value, pair.rest(), value_test, UNPROVIDED)) {
                } else {
                    rplacd(pair, cons(value, pair.rest()));
                }
            }
            return values(alist, com.cyc.cycjava.cycl.list_utilities.sublisp_boolean(pair));
        }
    }

    @LispMethod(comment = "Note that VALUE is in a list associated with KEY in ALIST (using KEY-TEST for key equality,\r\nand VALUE-TEST for value equality).\r\nReturn the resulting alist.\r\nReturn a second value of T iff KEY was found.\nNote that VALUE is in a list associated with KEY in ALIST (using KEY-TEST for key equality,\nand VALUE-TEST for value equality).\nReturn the resulting alist.\nReturn a second value of T iff KEY was found.")
    public static SubLObject alist_pushnew(SubLObject alist, final SubLObject key, final SubLObject value, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject pair = assoc(key, alist, key_test, UNPROVIDED);
        if (NIL == pair) {
            alist = acons(key, list(value), alist);
        } else
            if (NIL == member(value, pair.rest(), value_test, UNPROVIDED)) {
                rplacd(pair, cons(value, pair.rest()));
            }

        return subl_promotions.values2(alist, sublisp_boolean(pair));
    }/**
     * Note that VALUE is in a list associated with KEY in ALIST (using KEY-TEST for key equality,
     * and VALUE-TEST for value equality).
     * Return the resulting alist.
     * Return a second value of T iff KEY was found.
     */


    public static final SubLObject alist_remove_from_value_alt(SubLObject alist, SubLObject key, SubLObject value, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        {
            SubLObject pair = assoc(key, alist, key_test, UNPROVIDED);
            if (NIL == pair) {
            } else {
                rplacd(pair, remove(value, pair.rest(), value_test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
            }
            return alist;
        }
    }

    public static SubLObject alist_remove_from_value(final SubLObject alist, final SubLObject key, final SubLObject value, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        final SubLObject pair = assoc(key, alist, key_test, UNPROVIDED);
        if (NIL != pair) {
            rplacd(pair, remove(value, pair.rest(), value_test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED));
        }
        return alist;
    }

    public static final SubLObject pushnew_onto_alist_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject alist_var = NIL;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt136);
            alist_var = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt136);
            key = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt136);
            value = current.first();
            current = current.rest();
            {
                SubLObject key_test = (current.isCons()) ? ((SubLObject) (current.first())) : $list_alt137;
                destructuring_bind_must_listp(current, datum, $list_alt136);
                current = current.rest();
                {
                    SubLObject value_test = (current.isCons()) ? ((SubLObject) (current.first())) : $list_alt137;
                    destructuring_bind_must_listp(current, datum, $list_alt136);
                    current = current.rest();
                    if (NIL == current) {
                        return list(CSETF, alist_var, list(ALIST_PUSHNEW, alist_var, key, value, key_test, value_test));
                    } else {
                        cdestructuring_bind_error(datum, $list_alt136);
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject pushnew_onto_alist(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject alist_var = NIL;
        SubLObject key = NIL;
        SubLObject value = NIL;
        destructuring_bind_must_consp(current, datum, $list138);
        alist_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list138);
        key = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list138);
        value = current.first();
        current = current.rest();
        final SubLObject key_test = (current.isCons()) ? current.first() : $list139;
        destructuring_bind_must_listp(current, datum, $list138);
        current = current.rest();
        final SubLObject value_test = (current.isCons()) ? current.first() : $list139;
        destructuring_bind_must_listp(current, datum, $list138);
        current = current.rest();
        if (NIL == current) {
            return list(CSETF, alist_var, list(ALIST_PUSHNEW, alist_var, key, value, key_test, value_test));
        }
        cdestructuring_bind_error(datum, $list138);
        return NIL;
    }

    public static final SubLObject push_onto_alist_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject alist_var = NIL;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt139);
            alist_var = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt139);
            key = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt139);
            value = current.first();
            current = current.rest();
            {
                SubLObject key_test = (current.isCons()) ? ((SubLObject) (current.first())) : $list_alt137;
                destructuring_bind_must_listp(current, datum, $list_alt139);
                current = current.rest();
                if (NIL == current) {
                    return list(CSETF, alist_var, list(ALIST_PUSH, alist_var, key, value, key_test));
                } else {
                    cdestructuring_bind_error(datum, $list_alt139);
                }
            }
        }
        return NIL;
    }

    public static SubLObject push_onto_alist(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject alist_var = NIL;
        SubLObject key = NIL;
        SubLObject value = NIL;
        destructuring_bind_must_consp(current, datum, $list141);
        alist_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list141);
        key = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list141);
        value = current.first();
        current = current.rest();
        final SubLObject key_test = (current.isCons()) ? current.first() : $list139;
        destructuring_bind_must_listp(current, datum, $list141);
        current = current.rest();
        if (NIL == current) {
            return list(CSETF, alist_var, list(ALIST_PUSH, alist_var, key, value, key_test));
        }
        cdestructuring_bind_error(datum, $list141);
        return NIL;
    }

    public static final SubLObject enter_into_alist_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject alist_var = NIL;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt141);
            alist_var = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt141);
            key = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt141);
            value = current.first();
            current = current.rest();
            {
                SubLObject test = (current.isCons()) ? ((SubLObject) (current.first())) : $list_alt137;
                destructuring_bind_must_listp(current, datum, $list_alt141);
                current = current.rest();
                if (NIL == current) {
                    return list(CSETF, alist_var, list(ALIST_ENTER, alist_var, key, value, test));
                } else {
                    cdestructuring_bind_error(datum, $list_alt141);
                }
            }
        }
        return NIL;
    }

    public static SubLObject enter_into_alist(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject alist_var = NIL;
        SubLObject key = NIL;
        SubLObject value = NIL;
        destructuring_bind_must_consp(current, datum, $list143);
        alist_var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list143);
        key = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list143);
        value = current.first();
        current = current.rest();
        final SubLObject test = (current.isCons()) ? current.first() : $list139;
        destructuring_bind_must_listp(current, datum, $list143);
        current = current.rest();
        if (NIL == current) {
            return list(CSETF, alist_var, list(ALIST_ENTER, alist_var, key, value, test));
        }
        cdestructuring_bind_error(datum, $list143);
        return NIL;
    }

    /**
     * Return a list of all the keys of ALIST.
     */
    @LispMethod(comment = "Return a list of all the keys of ALIST.")
    public static final SubLObject alist_keys_alt(SubLObject alist) {
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject v_answer = NIL;
            SubLObject cdolist_list_var = alist;
            SubLObject cons = NIL;
            for (cons = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cons = cdolist_list_var.first()) {
                {
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt143);
                    key = current.first();
                    current = current.rest();
                    value = current;
                    v_answer = cons(key, v_answer);
                }
            }
            return nreverse(v_answer);
        }
    }

    @LispMethod(comment = "Return a list of all the keys of ALIST.")
    public static SubLObject alist_keys(final SubLObject alist) {
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        SubLObject v_answer = NIL;
        SubLObject cdolist_list_var = alist;
        SubLObject cons = NIL;
        cons = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current;
            final SubLObject datum = current = cons;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list145);
            key = current.first();
            current = value = current.rest();
            v_answer = cons(key, v_answer);
            cdolist_list_var = cdolist_list_var.rest();
            cons = cdolist_list_var.first();
        } 
        return nreverse(v_answer);
    }/**
     * Return a list of all the keys of ALIST.
     */


    /**
     * Return a list of all the values of ALIST.
     */
    @LispMethod(comment = "Return a list of all the values of ALIST.")
    public static final SubLObject alist_values_alt(SubLObject alist) {
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject v_answer = NIL;
            SubLObject cdolist_list_var = alist;
            SubLObject cons = NIL;
            for (cons = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cons = cdolist_list_var.first()) {
                {
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt143);
                    key = current.first();
                    current = current.rest();
                    value = current;
                    v_answer = cons(value, v_answer);
                }
            }
            return nreverse(v_answer);
        }
    }

    @LispMethod(comment = "Return a list of all the values of ALIST.")
    public static SubLObject alist_values(final SubLObject alist) {
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        SubLObject v_answer = NIL;
        SubLObject cdolist_list_var = alist;
        SubLObject cons = NIL;
        cons = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current;
            final SubLObject datum = current = cons;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list145);
            key = current.first();
            current = value = current.rest();
            v_answer = cons(value, v_answer);
            cdolist_list_var = cdolist_list_var.rest();
            cons = cdolist_list_var.first();
        } 
        return nreverse(v_answer);
    }/**
     * Return a list of all the values of ALIST.
     */


    /**
     * Return a copy of ALIST where the order of the keys have been optimized (sorted)
     * via the preference PREDICATE.
     */
    @LispMethod(comment = "Return a copy of ALIST where the order of the keys have been optimized (sorted)\r\nvia the preference PREDICATE.\nReturn a copy of ALIST where the order of the keys have been optimized (sorted)\nvia the preference PREDICATE.")
    public static final SubLObject alist_optimize_alt(SubLObject alist, SubLObject predicate) {
        SubLTrampolineFile.checkType(alist, ALIST_P);
        return copy_alist(Sort.stable_sort(copy_list(alist), predicate, symbol_function(CAR)));
    }

    @LispMethod(comment = "Return a copy of ALIST where the order of the keys have been optimized (sorted)\r\nvia the preference PREDICATE.\nReturn a copy of ALIST where the order of the keys have been optimized (sorted)\nvia the preference PREDICATE.")
    public static SubLObject alist_optimize(final SubLObject alist, final SubLObject predicate) {
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        return copy_alist(Sort.stable_sort(copy_list(alist), predicate, symbol_function(CAR)));
    }/**
     * Return a copy of ALIST where the order of the keys have been optimized (sorted)
     * via the preference PREDICATE.
     */


    /**
     *
     *
     * @param KEY-TEST;
     * 		Determines whether two keys are equal.
     * @param VALUE-TEST;
     * 		Determines whether two values are equal.
     * @return BOOLEAN; Do ALIST1 and ALIST2 contain exactly the same mappings?
     */
    @LispMethod(comment = "@param KEY-TEST;\r\n\t\tDetermines whether two keys are equal.\r\n@param VALUE-TEST;\r\n\t\tDetermines whether two values are equal.\r\n@return BOOLEAN; Do ALIST1 and ALIST2 contain exactly the same mappings?")
    public static final SubLObject alist_E_alt(SubLObject alist1, SubLObject alist2, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.alist_subsumesP(alist1, alist2, key_test, value_test)) && (NIL != com.cyc.cycjava.cycl.list_utilities.alist_subsumesP(alist2, alist1, key_test, value_test)));
    }

    /**
     *
     *
     * @param KEY-TEST;
     * 		Determines whether two keys are equal.
     * @param VALUE-TEST;
     * 		Determines whether two values are equal.
     * @return BOOLEAN; Do ALIST1 and ALIST2 contain exactly the same mappings?
     */
    @LispMethod(comment = "@param KEY-TEST;\r\n\t\tDetermines whether two keys are equal.\r\n@param VALUE-TEST;\r\n\t\tDetermines whether two values are equal.\r\n@return BOOLEAN; Do ALIST1 and ALIST2 contain exactly the same mappings?")
    public static SubLObject alist_E(final SubLObject alist1, final SubLObject alist2, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        return makeBoolean((NIL != alist_subsumesP(alist1, alist2, key_test, value_test)) && (NIL != alist_subsumesP(alist2, alist1, key_test, value_test)));
    }

    /**
     *
     *
     * @param KEY-TEST;
     * 		Determines whether two keys are equal.
     * @param VALUE-TEST;
     * 		Determines whether two values are equal.
     * @return BOOLEAN; Does ALIST1 contain every mapping that ALIST2 contains?
     * @unknown - For the case where ALIST1 is over a certain length, it would be more
    efficient to first convert it into a hashtable.
     */
    @LispMethod(comment = "@param KEY-TEST;\r\n\t\tDetermines whether two keys are equal.\r\n@param VALUE-TEST;\r\n\t\tDetermines whether two values are equal.\r\n@return BOOLEAN; Does ALIST1 contain every mapping that ALIST2 contains?\r\n@unknown - For the case where ALIST1 is over a certain length, it would be more\r\nefficient to first convert it into a hashtable.")
    public static final SubLObject alist_subsumesP_alt(SubLObject alist1, SubLObject alist2, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        {
            SubLObject failP = NIL;
            SubLObject rest = NIL;
            for (rest = alist2; !((NIL != failP) || (NIL == rest)); rest = rest.rest()) {
                {
                    SubLObject cons = rest.first();
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt143);
                    key = current.first();
                    current = current.rest();
                    value = current;
                    failP = makeBoolean(NIL == funcall(value_test, value, com.cyc.cycjava.cycl.list_utilities.alist_lookup(alist1, key, key_test, UNPROVIDED)));
                }
            }
            return makeBoolean(NIL == failP);
        }
    }

    /**
     *
     *
     * @param KEY-TEST;
     * 		Determines whether two keys are equal.
     * @param VALUE-TEST;
     * 		Determines whether two values are equal.
     * @return BOOLEAN; Does ALIST1 contain every mapping that ALIST2 contains?
     * @unknown - For the case where ALIST1 is over a certain length, it would be more
    efficient to first convert it into a hashtable.
     */
    @LispMethod(comment = "@param KEY-TEST;\r\n\t\tDetermines whether two keys are equal.\r\n@param VALUE-TEST;\r\n\t\tDetermines whether two values are equal.\r\n@return BOOLEAN; Does ALIST1 contain every mapping that ALIST2 contains?\r\n@unknown - For the case where ALIST1 is over a certain length, it would be more\r\nefficient to first convert it into a hashtable.")
    public static SubLObject alist_subsumesP(final SubLObject alist1, final SubLObject alist2, SubLObject key_test, SubLObject value_test) {
        if (key_test == UNPROVIDED) {
            key_test = symbol_function(EQL);
        }
        if (value_test == UNPROVIDED) {
            value_test = symbol_function(EQL);
        }
        SubLObject failP;
        SubLObject rest;
        SubLObject cons;
        SubLObject current;
        SubLObject datum;
        SubLObject key;
        SubLObject value;
        for (failP = NIL, rest = NIL, rest = alist2; (NIL == failP) && (NIL != rest); failP = makeBoolean(NIL == funcall(value_test, value, alist_lookup(alist1, key, key_test, UNPROVIDED))) , rest = rest.rest()) {
            cons = rest.first();
            datum = current = cons;
            key = NIL;
            value = NIL;
            destructuring_bind_must_consp(current, datum, $list145);
            key = current.first();
            current = value = current.rest();
        }
        return makeBoolean(NIL == failP);
    }

    /**
     * Return a hashtable of all the (key . value) entries in ALIST.
     * TEST is the equality test for keys in ALIST.
     */
    @LispMethod(comment = "Return a hashtable of all the (key . value) entries in ALIST.\r\nTEST is the equality test for keys in ALIST.\nReturn a hashtable of all the (key . value) entries in ALIST.\nTEST is the equality test for keys in ALIST.")
    public static final SubLObject alist_to_hash_table_alt(SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject hashtable = make_hash_table(length(alist), test, UNPROVIDED);
            SubLObject cdolist_list_var = alist;
            SubLObject cons = NIL;
            for (cons = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cons = cdolist_list_var.first()) {
                {
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt143);
                    key = current.first();
                    current = current.rest();
                    value = current;
                    sethash(key, hashtable, value);
                }
            }
            return hashtable;
        }
    }

    @LispMethod(comment = "Return a hashtable of all the (key . value) entries in ALIST.\r\nTEST is the equality test for keys in ALIST.\nReturn a hashtable of all the (key . value) entries in ALIST.\nTEST is the equality test for keys in ALIST.")
    public static SubLObject alist_to_hash_table(final SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject hashtable = make_hash_table(length(alist), test, UNPROVIDED);
        SubLObject cdolist_list_var = alist;
        SubLObject cons = NIL;
        cons = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current;
            final SubLObject datum = current = cons;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list145);
            key = current.first();
            current = value = current.rest();
            sethash(key, hashtable, value);
            cdolist_list_var = cdolist_list_var.rest();
            cons = cdolist_list_var.first();
        } 
        return hashtable;
    }/**
     * Return a hashtable of all the (key . value) entries in ALIST.
     * TEST is the equality test for keys in ALIST.
     */


    /**
     * Return a hashtable of all the (key . value) entries in ALIST
     * using the value as the key and the key as the value.
     * TEST is the equality test for values in ALIST.
     */
    @LispMethod(comment = "Return a hashtable of all the (key . value) entries in ALIST\r\nusing the value as the key and the key as the value.\r\nTEST is the equality test for values in ALIST.\nReturn a hashtable of all the (key . value) entries in ALIST\nusing the value as the key and the key as the value.\nTEST is the equality test for values in ALIST.")
    public static final SubLObject alist_to_reverse_hash_table_alt(SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLTrampolineFile.checkType(alist, ALIST_P);
        {
            SubLObject hashtable = make_hash_table(length(alist), test, UNPROVIDED);
            SubLObject cdolist_list_var = alist;
            SubLObject cons = NIL;
            for (cons = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cons = cdolist_list_var.first()) {
                {
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt143);
                    key = current.first();
                    current = current.rest();
                    value = current;
                    sethash(value, hashtable, key);
                }
            }
            return hashtable;
        }
    }

    @LispMethod(comment = "Return a hashtable of all the (key . value) entries in ALIST\r\nusing the value as the key and the key as the value.\r\nTEST is the equality test for values in ALIST.\nReturn a hashtable of all the (key . value) entries in ALIST\nusing the value as the key and the key as the value.\nTEST is the equality test for values in ALIST.")
    public static SubLObject alist_to_reverse_hash_table(final SubLObject alist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        assert NIL != alist_p(alist) : "! list_utilities.alist_p(alist) " + ("list_utilities.alist_p(alist) " + "CommonSymbols.NIL != list_utilities.alist_p(alist) ") + alist;
        final SubLObject hashtable = make_hash_table(length(alist), test, UNPROVIDED);
        SubLObject cdolist_list_var = alist;
        SubLObject cons = NIL;
        cons = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current;
            final SubLObject datum = current = cons;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list145);
            key = current.first();
            current = value = current.rest();
            sethash(value, hashtable, key);
            cdolist_list_var = cdolist_list_var.rest();
            cons = cdolist_list_var.first();
        } 
        return hashtable;
    }/**
     * Return a hashtable of all the (key . value) entries in ALIST
     * using the value as the key and the key as the value.
     * TEST is the equality test for values in ALIST.
     */


    /**
     *
     *
     * @unknown (sort-alist-by-keys '(("c" . 2) ("a" . 3) ("b" . 1)) #'string<)
    (("a" . 3) ("b" . 1) ("c" . 2))
     */
    @LispMethod(comment = "@unknown (sort-alist-by-keys \'((\"c\" . 2) (\"a\" . 3) (\"b\" . 1)) #\'string<)\r\n((\"a\" . 3) (\"b\" . 1) (\"c\" . 2))")
    public static final SubLObject sort_alist_by_keys_alt(SubLObject alist, SubLObject predicate) {
        return Sort.sort(alist, predicate, symbol_function(CAR));
    }

    /**
     *
     *
     * @unknown (sort-alist-by-keys '(("c" . 2) ("a" . 3) ("b" . 1)) #'string<)
    (("a" . 3) ("b" . 1) ("c" . 2))
     */
    @LispMethod(comment = "@unknown (sort-alist-by-keys \'((\"c\" . 2) (\"a\" . 3) (\"b\" . 1)) #\'string<)\r\n((\"a\" . 3) (\"b\" . 1) (\"c\" . 2))")
    public static SubLObject sort_alist_by_keys(final SubLObject alist, final SubLObject predicate) {
        return Sort.sort(alist, predicate, symbol_function(CAR));
    }

    /**
     *
     *
     * @unknown (sort-alist-by-values '(("c" . 2) ("a" . 3) ("b" . 1)) #'<)
    (("b" . 1) ("c" . 2) ("a" . 3))
     */
    @LispMethod(comment = "@unknown (sort-alist-by-values \'((\"c\" . 2) (\"a\" . 3) (\"b\" . 1)) #\'<)\r\n((\"b\" . 1) (\"c\" . 2) (\"a\" . 3))")
    public static final SubLObject sort_alist_by_values_alt(SubLObject alist, SubLObject predicate) {
        return Sort.sort(alist, predicate, symbol_function(CDR));
    }

    /**
     *
     *
     * @unknown (sort-alist-by-values '(("c" . 2) ("a" . 3) ("b" . 1)) #'<)
    (("b" . 1) ("c" . 2) ("a" . 3))
     */
    @LispMethod(comment = "@unknown (sort-alist-by-values \'((\"c\" . 2) (\"a\" . 3) (\"b\" . 1)) #\'<)\r\n((\"b\" . 1) (\"c\" . 2) (\"a\" . 3))")
    public static SubLObject sort_alist_by_values(final SubLObject alist, final SubLObject predicate) {
        return Sort.sort(alist, predicate, symbol_function(CDR));
    }

    public static SubLObject cons_to_tuple(final SubLObject cons) {
        SubLObject car = NIL;
        SubLObject cdr = NIL;
        destructuring_bind_must_consp(cons, cons, $list146);
        car = cons.first();
        final SubLObject current = cdr = cons.rest();
        return list(car, cdr);
    }

    public static SubLObject tuple_to_cons(final SubLObject tuple) {
        SubLObject first = NIL;
        SubLObject second = NIL;
        destructuring_bind_must_consp(tuple, tuple, $list147);
        first = tuple.first();
        SubLObject current = tuple.rest();
        destructuring_bind_must_consp(current, tuple, $list147);
        second = current.first();
        current = current.rest();
        if (NIL == current) {
            return cons(first, second);
        }
        cdestructuring_bind_error(tuple, $list147);
        return NIL;
    }

    public static SubLObject alist_to_tuples(final SubLObject alist) {
        return Mapping.mapcar(symbol_function(CONS_TO_TUPLE), alist);
    }

    /**
     * Return T iff OBJECT is a property list.
     */
    @LispMethod(comment = "Return T iff OBJECT is a property list.")
    public static final SubLObject property_list_p_alt(SubLObject v_object) {
        return makeBoolean((NIL == v_object) || ((NIL != com.cyc.cycjava.cycl.list_utilities.proper_list_p(v_object)) && (NIL != evenp(length(v_object)))));
    }

    @LispMethod(comment = "Return T iff OBJECT is a property list.")
    public static SubLObject property_list_p(final SubLObject v_object) {
        return makeBoolean((NIL == v_object) || ((NIL != proper_list_p(v_object)) && (NIL != evenp(length(v_object)))));
    }/**
     * Return T iff OBJECT is a property list.
     */


    public static final SubLObject non_empty_property_list_p_alt(SubLObject obj) {
        return makeBoolean((NIL != obj) && (NIL != com.cyc.cycjava.cycl.list_utilities.proper_list_p(obj)));
    }

    public static SubLObject non_empty_property_list_p(final SubLObject obj) {
        return makeBoolean((NIL != obj) && (NIL != proper_list_p(obj)));
    }

    /**
     * Creates a new plist based on PLIST, but only including properties
     * which pass PRED.
     */
    @LispMethod(comment = "Creates a new plist based on PLIST, but only including properties\r\nwhich pass PRED.\nCreates a new plist based on PLIST, but only including properties\nwhich pass PRED.")
    public static final SubLObject filter_plist_alt(SubLObject plist, SubLObject pred) {
        {
            SubLObject new_plist = NIL;
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (NIL != funcall(pred, property)) {
                        new_plist = cons(property, new_plist);
                        new_plist = cons(value, new_plist);
                    }
                }
            }
            return nreverse(new_plist);
        }
    }

    @LispMethod(comment = "Creates a new plist based on PLIST, but only including properties\r\nwhich pass PRED.\nCreates a new plist based on PLIST, but only including properties\nwhich pass PRED.")
    public static SubLObject filter_plist(final SubLObject plist, final SubLObject pred) {
        SubLObject new_plist = NIL;
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            if (NIL != funcall(pred, property)) {
                new_plist = cons(property, new_plist);
                new_plist = cons(value, new_plist);
            }
        }
        return nreverse(new_plist);
    }/**
     * Creates a new plist based on PLIST, but only including properties
     * which pass PRED.
     */


    /**
     * Creates a new plist based on PLIST, but removes indicator-value pairs
     * where TEST (by default: EQ) holds between the indicator and the value.
     */
    @LispMethod(comment = "Creates a new plist based on PLIST, but removes indicator-value pairs\r\nwhere TEST (by default: EQ) holds between the indicator and the value.\nCreates a new plist based on PLIST, but removes indicator-value pairs\nwhere TEST (by default: EQ) holds between the indicator and the value.")
    public static final SubLObject prune_plist_alt(SubLObject plist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        {
            SubLObject new_plist = NIL;
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (NIL == funcall(test, property, value)) {
                        new_plist = cons(property, new_plist);
                        new_plist = cons(value, new_plist);
                    }
                }
            }
            return nreverse(new_plist);
        }
    }

    @LispMethod(comment = "Creates a new plist based on PLIST, but removes indicator-value pairs\r\nwhere TEST (by default: EQ) holds between the indicator and the value.\nCreates a new plist based on PLIST, but removes indicator-value pairs\nwhere TEST (by default: EQ) holds between the indicator and the value.")
    public static SubLObject prune_plist(final SubLObject plist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        SubLObject new_plist = NIL;
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            if (NIL == funcall(test, property, value)) {
                new_plist = cons(property, new_plist);
                new_plist = cons(value, new_plist);
            }
        }
        return nreverse(new_plist);
    }/**
     * Creates a new plist based on PLIST, but removes indicator-value pairs
     * where TEST (by default: EQ) holds between the indicator and the value.
     */


    /**
     *
     *
     * @return boolean; t iff PLIST is a property-list-p
    such that all of its properties pass PRED.
     */
    @LispMethod(comment = "@return boolean; t iff PLIST is a property-list-p\r\nsuch that all of its properties pass PRED.")
    public static final SubLObject plist_of_type_p_alt(SubLObject v_object, SubLObject pred) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.property_list_p(v_object)) {
            return NIL;
        }
        {
            SubLObject remainder = NIL;
            for (remainder = v_object; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (NIL == funcall(pred, property)) {
                        return NIL;
                    }
                }
            }
        }
        return T;
    }

    /**
     *
     *
     * @return boolean; t iff PLIST is a property-list-p
    such that all of its properties pass PRED.
     */
    @LispMethod(comment = "@return boolean; t iff PLIST is a property-list-p\r\nsuch that all of its properties pass PRED.")
    public static SubLObject plist_of_type_p(final SubLObject v_object, final SubLObject pred) {
        if (NIL == property_list_p(v_object)) {
            return NIL;
        }
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = v_object; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            if (NIL == funcall(pred, property)) {
                return NIL;
            }
        }
        return T;
    }

    /**
     *
     *
     * @return boolean; t iff PLIST is a property-list-p
    such that all of its values pass PRED.
     */
    @LispMethod(comment = "@return boolean; t iff PLIST is a property-list-p\r\nsuch that all of its values pass PRED.")
    public static final SubLObject plist_of_value_type_p_alt(SubLObject v_object, SubLObject pred) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.property_list_p(v_object)) {
            return NIL;
        }
        {
            SubLObject remainder = NIL;
            for (remainder = v_object; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (NIL == funcall(pred, value)) {
                        return NIL;
                    }
                }
            }
        }
        return T;
    }

    /**
     *
     *
     * @return boolean; t iff PLIST is a property-list-p
    such that all of its values pass PRED.
     */
    @LispMethod(comment = "@return boolean; t iff PLIST is a property-list-p\r\nsuch that all of its values pass PRED.")
    public static SubLObject plist_of_value_type_p(final SubLObject v_object, final SubLObject pred) {
        if (NIL == property_list_p(v_object)) {
            return NIL;
        }
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = v_object; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            if (NIL == funcall(pred, value)) {
                return NIL;
            }
        }
        return T;
    }

    /**
     * Returns a property list where each element on KEYS is associated with the element on DATA with the same index.
     * KEYS and DATA must be of the same length.
     */
    @LispMethod(comment = "Returns a property list where each element on KEYS is associated with the element on DATA with the same index.\r\nKEYS and DATA must be of the same length.\nReturns a property list where each element on KEYS is associated with the element on DATA with the same index.\nKEYS and DATA must be of the same length.")
    public static final SubLObject make_plist_alt(SubLObject keys, SubLObject data) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.same_length_p(keys, data)) {
            Errors.error($str_alt78$The_lists_of_keys_and_data_are_of);
        }
        {
            SubLObject result = NIL;
            SubLObject key = NIL;
            SubLObject key_24 = NIL;
            SubLObject datum = NIL;
            SubLObject datum_25 = NIL;
            for (key = keys, key_24 = key.first(), datum = data, datum_25 = datum.first(); !((NIL == datum) && (NIL == key)); key = key.rest() , key_24 = key.first() , datum = datum.rest() , datum_25 = datum.first()) {
                result = putf(result, key_24, datum_25);
            }
            return result;
        }
    }

    @LispMethod(comment = "Returns a property list where each element on KEYS is associated with the element on DATA with the same index.\r\nKEYS and DATA must be of the same length.\nReturns a property list where each element on KEYS is associated with the element on DATA with the same index.\nKEYS and DATA must be of the same length.")
    public static SubLObject make_plist(final SubLObject keys, final SubLObject data) {
        if (NIL == same_length_p(keys, data)) {
            Errors.error($str78$The_lists_of_keys_and_data_are_of);
        }
        SubLObject result = NIL;
        SubLObject key = NIL;
        SubLObject key_$26 = NIL;
        SubLObject datum = NIL;
        SubLObject datum_$27 = NIL;
        key = keys;
        key_$26 = key.first();
        datum = data;
        datum_$27 = datum.first();
        while ((NIL != datum) || (NIL != key)) {
            result = putf(result, key_$26, datum_$27);
            key = key.rest();
            key_$26 = key.first();
            datum = datum.rest();
            datum_$27 = datum.first();
        } 
        return result;
    }/**
     * Returns a property list where each element on KEYS is associated with the element on DATA with the same index.
     * KEYS and DATA must be of the same length.
     */


    /**
     * add INDICATOR VALUE pair to PLIST
     */
    @LispMethod(comment = "add INDICATOR VALUE pair to PLIST")
    public static final SubLObject plist_enter_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject plist = NIL;
            SubLObject indicator = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt144);
            plist = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt144);
            indicator = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt144);
            value = current.first();
            current = current.rest();
            if (NIL == current) {
                return list(CSETQ, plist, list(PUTF, plist, indicator, value));
            } else {
                cdestructuring_bind_error(datum, $list_alt144);
            }
        }
        return NIL;
    }

    @LispMethod(comment = "add INDICATOR VALUE pair to PLIST")
    public static SubLObject plist_enter(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject plist = NIL;
        SubLObject indicator = NIL;
        SubLObject value = NIL;
        destructuring_bind_must_consp(current, datum, $list149);
        plist = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list149);
        indicator = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list149);
        value = current.first();
        current = current.rest();
        if (NIL == current) {
            return list(CSETQ, plist, list(PUTF, plist, indicator, value));
        }
        cdestructuring_bind_error(datum, $list149);
        return NIL;
    }/**
     * add INDICATOR VALUE pair to PLIST
     */


    public static final SubLObject plist_lookup_alt(SubLObject plist, SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        return getf(plist, key, v_default);
    }

    public static SubLObject plist_lookup(final SubLObject plist, final SubLObject key, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = NIL;
        }
        return getf(plist, key, v_default);
    }

    public static final SubLObject plist_increment_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject plist = NIL;
            SubLObject key = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt146);
            plist = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt146);
            key = current.first();
            current = current.rest();
            {
                SubLObject allow_other_keys_p = NIL;
                SubLObject rest = current;
                SubLObject bad = NIL;
                SubLObject current_26 = NIL;
                for (; NIL != rest;) {
                    destructuring_bind_must_consp(rest, datum, $list_alt146);
                    current_26 = rest.first();
                    rest = rest.rest();
                    destructuring_bind_must_consp(rest, datum, $list_alt146);
                    if (NIL == member(current_26, $list_alt147, UNPROVIDED, UNPROVIDED)) {
                        bad = T;
                    }
                    if (current_26 == $ALLOW_OTHER_KEYS) {
                        allow_other_keys_p = rest.first();
                    }
                    rest = rest.rest();
                }
                if ((NIL != bad) && (NIL == allow_other_keys_p)) {
                    cdestructuring_bind_error(datum, $list_alt146);
                }
                {
                    SubLObject increment_tail = property_list_member($INCREMENT, current);
                    SubLObject increment = (NIL != increment_tail) ? ((SubLObject) (cadr(increment_tail))) : ONE_INTEGER;
                    return list(PLIST_ENTER, plist, key, list($sym34$_, listS(PLIST_LOOKUP, plist, key, $list_alt25), increment));
                }
            }
        }
    }

    public static SubLObject plist_increment(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject plist = NIL;
        SubLObject key = NIL;
        destructuring_bind_must_consp(current, datum, $list151);
        plist = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list151);
        key = current.first();
        current = current.rest();
        SubLObject allow_other_keys_p = NIL;
        SubLObject rest = current;
        SubLObject bad = NIL;
        SubLObject current_$28 = NIL;
        while (NIL != rest) {
            destructuring_bind_must_consp(rest, datum, $list151);
            current_$28 = rest.first();
            rest = rest.rest();
            destructuring_bind_must_consp(rest, datum, $list151);
            if (NIL == member(current_$28, $list152, UNPROVIDED, UNPROVIDED)) {
                bad = T;
            }
            if (current_$28 == $ALLOW_OTHER_KEYS) {
                allow_other_keys_p = rest.first();
            }
            rest = rest.rest();
        } 
        if ((NIL != bad) && (NIL == allow_other_keys_p)) {
            cdestructuring_bind_error(datum, $list151);
        }
        final SubLObject increment_tail = property_list_member($INCREMENT, current);
        final SubLObject increment = (NIL != increment_tail) ? cadr(increment_tail) : ONE_INTEGER;
        return list(PLIST_ENTER, plist, key, list($sym34$_, listS(PLIST_LOOKUP, plist, key, $list25), increment));
    }

    public static final SubLObject plist_push_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            SubLObject plist = NIL;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list_alt151);
            plist = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt151);
            key = current.first();
            current = current.rest();
            destructuring_bind_must_consp(current, datum, $list_alt151);
            value = current.first();
            current = current.rest();
            if (NIL == current) {
                return list(PLIST_ENTER, plist, key, list(CONS, value, listS(PLIST_LOOKUP, plist, key, $list_alt72)));
            } else {
                cdestructuring_bind_error(datum, $list_alt151);
            }
        }
        return NIL;
    }

    public static SubLObject plist_push(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject plist = NIL;
        SubLObject key = NIL;
        SubLObject value = NIL;
        destructuring_bind_must_consp(current, datum, $list156);
        plist = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list156);
        key = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list156);
        value = current.first();
        current = current.rest();
        if (NIL == current) {
            return list(PLIST_ENTER, plist, key, list(CONS, value, listS(PLIST_LOOKUP, plist, key, $list72)));
        }
        cdestructuring_bind_error(datum, $list156);
        return NIL;
    }

    public static SubLObject plist_remove(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        SubLObject plist = NIL;
        SubLObject indicator_to_remove = NIL;
        destructuring_bind_must_consp(current, datum, $list157);
        plist = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list157);
        indicator_to_remove = current.first();
        current = current.rest();
        if (NIL == current) {
            return list(CSETQ, plist, list(PLIST_EXCEPT, plist, list(LIST, indicator_to_remove)));
        }
        cdestructuring_bind_error(datum, $list157);
        return NIL;
    }

    public static final SubLObject alist_to_plist_alt(SubLObject alist) {
        {
            SubLObject plist = NIL;
            SubLObject cdolist_list_var = reverse(alist);
            SubLObject cons = NIL;
            for (cons = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , cons = cdolist_list_var.first()) {
                {
                    SubLObject datum = cons;
                    SubLObject current = datum;
                    SubLObject key = NIL;
                    SubLObject value = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt143);
                    key = current.first();
                    current = current.rest();
                    value = current;
                    plist = cons(value, plist);
                    plist = cons(key, plist);
                }
            }
            return plist;
        }
    }

    public static SubLObject alist_to_plist(final SubLObject alist) {
        SubLObject plist = NIL;
        SubLObject cdolist_list_var = reverse(alist);
        SubLObject cons = NIL;
        cons = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject current;
            final SubLObject datum = current = cons;
            SubLObject key = NIL;
            SubLObject value = NIL;
            destructuring_bind_must_consp(current, datum, $list145);
            key = current.first();
            current = value = current.rest();
            plist = cons(value, plist);
            plist = cons(key, plist);
            cdolist_list_var = cdolist_list_var.rest();
            cons = cdolist_list_var.first();
        } 
        return plist;
    }

    public static final SubLObject plist_to_alist_alt(SubLObject plist) {
        {
            SubLObject alist = NIL;
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject key = remainder.first();
                    SubLObject value = cadr(remainder);
                    alist = com.cyc.cycjava.cycl.list_utilities.alist_enter(alist, key, value, UNPROVIDED);
                }
            }
            return nreverse(alist);
        }
    }

    public static SubLObject plist_to_alist(final SubLObject plist) {
        SubLObject alist = NIL;
        SubLObject remainder;
        SubLObject key;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            key = remainder.first();
            value = cadr(remainder);
            alist = alist_enter(alist, key, value, UNPROVIDED);
        }
        return nreverse(alist);
    }

    /**
     * Place all of the values of list B onto list A destructively and return
     * the resulting PLIST.
     */
    @LispMethod(comment = "Place all of the values of list B onto list A destructively and return\r\nthe resulting PLIST.\nPlace all of the values of list B onto list A destructively and return\nthe resulting PLIST.")
    public static final SubLObject nmerge_plist_alt(SubLObject plist_a, SubLObject plist_b) {
        SubLTrampolineFile.checkType(plist_a, PROPERTY_LIST_P);
        SubLTrampolineFile.checkType(plist_b, PROPERTY_LIST_P);
        if (NIL == plist_b) {
            return plist_a;
        }
        if (NIL == plist_a) {
            return copy_list(plist_b);
        }
        {
            SubLObject remainder = NIL;
            for (remainder = plist_b; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject param = remainder.first();
                    SubLObject value = cadr(remainder);
                    plist_a = putf(plist_a, param, value);
                }
            }
        }
        return plist_a;
    }

    @LispMethod(comment = "Place all of the values of list B onto list A destructively and return\r\nthe resulting PLIST.\nPlace all of the values of list B onto list A destructively and return\nthe resulting PLIST.")
    public static SubLObject nmerge_plist(SubLObject mutate_plist, final SubLObject overrides_plist) {
        assert NIL != property_list_p(mutate_plist) : "! list_utilities.property_list_p(mutate_plist) " + ("list_utilities.property_list_p(mutate_plist) " + "CommonSymbols.NIL != list_utilities.property_list_p(mutate_plist) ") + mutate_plist;
        assert NIL != property_list_p(overrides_plist) : "! list_utilities.property_list_p(overrides_plist) " + ("list_utilities.property_list_p(overrides_plist) " + "CommonSymbols.NIL != list_utilities.property_list_p(overrides_plist) ") + overrides_plist;
        if (NIL == overrides_plist) {
            return mutate_plist;
        }
        if (NIL == mutate_plist) {
            return copy_list(overrides_plist);
        }
        SubLObject remainder;
        SubLObject param;
        SubLObject value;
        for (remainder = NIL, remainder = overrides_plist; NIL != remainder; remainder = cddr(remainder)) {
            param = remainder.first();
            value = cadr(remainder);
            mutate_plist = putf(mutate_plist, param, value);
        }
        return mutate_plist;
    }/**
     * Place all of the values of list B onto list A destructively and return
     * the resulting PLIST.
     */


    /**
     * Place all of the values of list B onto a copy of list A and return
     * the resulting PLIST.
     */
    @LispMethod(comment = "Place all of the values of list B onto a copy of list A and return\r\nthe resulting PLIST.\nPlace all of the values of list B onto a copy of list A and return\nthe resulting PLIST.")
    public static final SubLObject merge_plist_alt(SubLObject plist_a, SubLObject plist_b) {
        return com.cyc.cycjava.cycl.list_utilities.nmerge_plist(copy_list(plist_a), plist_b);
    }

    @LispMethod(comment = "Place all of the values of list B onto a copy of list A and return\r\nthe resulting PLIST.\nPlace all of the values of list B onto a copy of list A and return\nthe resulting PLIST.")
    public static SubLObject merge_plist(final SubLObject start_plist, final SubLObject overrides_plist) {
        return nmerge_plist(copy_list(start_plist), overrides_plist);
    }/**
     * Place all of the values of list B onto a copy of list A and return
     * the resulting PLIST.
     */


    /**
     * Sort PLIST by its properties.
     */
    @LispMethod(comment = "Sort PLIST by its properties.")
    public static final SubLObject sort_plist_by_properties_alt(SubLObject plist, SubLObject predicate) {
        return com.cyc.cycjava.cycl.list_utilities.alist_to_plist(com.cyc.cycjava.cycl.list_utilities.sort_alist_by_keys(com.cyc.cycjava.cycl.list_utilities.plist_to_alist(plist), predicate));
    }

    @LispMethod(comment = "Sort PLIST by its properties.")
    public static SubLObject sort_plist_by_properties(final SubLObject plist, final SubLObject predicate) {
        return alist_to_plist(sort_alist_by_keys(plist_to_alist(plist), predicate));
    }/**
     * Sort PLIST by its properties.
     */


    public static SubLObject sort_plist_by_values(final SubLObject plist, final SubLObject predicate) {
        return alist_to_plist(sort_alist_by_values(plist_to_alist(plist), predicate));
    }

    /**
     * Sort the properties of PLIST via position in GUIDE-SEQ, with the values tagging along.
     */
    @LispMethod(comment = "Sort the properties of PLIST via position in GUIDE-SEQ, with the values tagging along.")
    public static final SubLObject sort_plist_via_position_alt(SubLObject plist, SubLObject guide_seq, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject alist = com.cyc.cycjava.cycl.list_utilities.plist_to_alist(plist);
            SubLObject sorted_alist = com.cyc.cycjava.cycl.list_utilities.sort_via_position(alist, guide_seq, test, symbol_function(CAR));
            SubLObject sorted_plist = com.cyc.cycjava.cycl.list_utilities.alist_to_plist(sorted_alist);
            return sorted_plist;
        }
    }

    @LispMethod(comment = "Sort the properties of PLIST via position in GUIDE-SEQ, with the values tagging along.")
    public static SubLObject sort_plist_via_position(final SubLObject plist, final SubLObject guide_seq, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject alist = plist_to_alist(plist);
        final SubLObject sorted_alist = sort_via_position(alist, guide_seq, test, symbol_function(CAR));
        final SubLObject sorted_plist = alist_to_plist(sorted_alist);
        return sorted_plist;
    }/**
     * Sort the properties of PLIST via position in GUIDE-SEQ, with the values tagging along.
     */


    /**
     *
     *
     * @return booleanp; whether INDICATOR explicitly occurs as an indicator in PLIST.
     */
    @LispMethod(comment = "@return booleanp; whether INDICATOR explicitly occurs as an indicator in PLIST.")
    public static final SubLObject indicator_presentP_alt(SubLObject plist, SubLObject indicator) {
        {
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (indicator == property) {
                        return T;
                    }
                }
            }
        }
        return NIL;
    }

    /**
     *
     *
     * @return booleanp; whether INDICATOR explicitly occurs as an indicator in PLIST.
     */
    @LispMethod(comment = "@return booleanp; whether INDICATOR explicitly occurs as an indicator in PLIST.")
    public static SubLObject indicator_presentP(final SubLObject plist, final SubLObject indicator) {
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            if (indicator.eql(property)) {
                return T;
            }
        }
        return NIL;
    }

    public static final SubLObject plist_has_keyP_alt(SubLObject plist, SubLObject key) {
        return com.cyc.cycjava.cycl.list_utilities.indicator_presentP(plist, key);
    }

    public static SubLObject plist_has_keyP(final SubLObject plist, final SubLObject key) {
        return indicator_presentP(plist, key);
    }

    public static SubLObject plist_has_keysP(final SubLObject plist, final SubLObject keys) {
        return equal(length(keys), length(intersection(keys, plist_keys(plist), UNPROVIDED, UNPROVIDED)));
    }

    /**
     * Searches plist for key in the key position. ~
     * The plist must be a valid property list. ~
     *
     * @unknown sdevoy
     */
    @LispMethod(comment = "Searches plist for key in the key position. ~\r\nThe plist must be a valid property list. ~\r\n\r\n@unknown sdevoy\nSearches plist for key in the key position. ~\nThe plist must be a valid property list. ~")
    public static final SubLObject member_plist_key_p_alt(SubLObject key, SubLObject plist) {
        return com.cyc.cycjava.cycl.list_utilities.indicator_presentP(plist, key);
    }

    @LispMethod(comment = "Searches plist for key in the key position. ~\r\nThe plist must be a valid property list. ~\r\n\r\n@unknown sdevoy\nSearches plist for key in the key position. ~\nThe plist must be a valid property list. ~")
    public static SubLObject member_plist_key_p(final SubLObject key, final SubLObject plist) {
        return indicator_presentP(plist, key);
    }/**
     * Searches plist for key in the key position. ~
     * The plist must be a valid property list. ~
     *
     * @unknown sdevoy
     */


    /**
     *
     *
     * @return booleanp; if INDICATOR is present in PLIST and its associated value is non nil, t is returned;  otherwise, nil.
     */
    @LispMethod(comment = "@return booleanp; if INDICATOR is present in PLIST and its associated value is non nil, t is returned;  otherwise, nil.")
    public static final SubLObject non_nil_plist_valueP_alt(SubLObject plist, SubLObject indicator) {
        if (NIL != getf(plist, indicator, UNPROVIDED)) {
            return T;
        } else {
            return NIL;
        }
    }

    /**
     *
     *
     * @return booleanp; if INDICATOR is present in PLIST and its associated value is non nil, t is returned;  otherwise, nil.
     */
    @LispMethod(comment = "@return booleanp; if INDICATOR is present in PLIST and its associated value is non nil, t is returned;  otherwise, nil.")
    public static SubLObject non_nil_plist_valueP(final SubLObject plist, final SubLObject indicator) {
        if (NIL != getf(plist, indicator, UNPROVIDED)) {
            return T;
        }
        return NIL;
    }

    /**
     * Returns the value for PROPERTY from PROPERTY-LIST;
     * if not found in PROPERTY-LIST, checks DEFAULT-PROPERTY-LIST.
     * Assumes that DEFAULT (by default :NO-VALUE) will not appear
     * as a value in PROPERTY-LIST.
     */
    @LispMethod(comment = "Returns the value for PROPERTY from PROPERTY-LIST;\r\nif not found in PROPERTY-LIST, checks DEFAULT-PROPERTY-LIST.\r\nAssumes that DEFAULT (by default :NO-VALUE) will not appear\r\nas a value in PROPERTY-LIST.\nReturns the value for PROPERTY from PROPERTY-LIST;\nif not found in PROPERTY-LIST, checks DEFAULT-PROPERTY-LIST.\nAssumes that DEFAULT (by default :NO-VALUE) will not appear\nas a value in PROPERTY-LIST.")
    public static final SubLObject get_property_with_defaults_alt(SubLObject property, SubLObject property_list, SubLObject default_property_list, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = $NO_VALUE;
        }
        {
            SubLObject value = getf(property_list, property, v_default);
            if (value == v_default) {
                value = getf(default_property_list, property, UNPROVIDED);
            }
            return value;
        }
    }

    @LispMethod(comment = "Returns the value for PROPERTY from PROPERTY-LIST;\r\nif not found in PROPERTY-LIST, checks DEFAULT-PROPERTY-LIST.\r\nAssumes that DEFAULT (by default :NO-VALUE) will not appear\r\nas a value in PROPERTY-LIST.\nReturns the value for PROPERTY from PROPERTY-LIST;\nif not found in PROPERTY-LIST, checks DEFAULT-PROPERTY-LIST.\nAssumes that DEFAULT (by default :NO-VALUE) will not appear\nas a value in PROPERTY-LIST.")
    public static SubLObject get_property_with_defaults(final SubLObject property, final SubLObject property_list, final SubLObject default_property_list, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = $NO_VALUE;
        }
        SubLObject value = getf(property_list, property, v_default);
        if (value.eql(v_default)) {
            value = getf(default_property_list, property, UNPROVIDED);
        }
        return value;
    }/**
     * Returns the value for PROPERTY from PROPERTY-LIST;
     * if not found in PROPERTY-LIST, checks DEFAULT-PROPERTY-LIST.
     * Assumes that DEFAULT (by default :NO-VALUE) will not appear
     * as a value in PROPERTY-LIST.
     */


    /**
     * Add indicator/value pairs from DEFAULT-PLIST iff there is no value for indicator in ORIGINAL-PLIST
     */
    @LispMethod(comment = "Add indicator/value pairs from DEFAULT-PLIST iff there is no value for indicator in ORIGINAL-PLIST")
    public static final SubLObject augment_plist_with_defaults_alt(SubLObject original_plist, SubLObject default_plist) {
        {
            SubLObject plist_to_return = copy_list(original_plist);
            SubLObject remainder = NIL;
            for (remainder = default_plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject prop = remainder.first();
                    SubLObject val = cadr(remainder);
                    plist_to_return = com.cyc.cycjava.cycl.list_utilities.maybe_putf(plist_to_return, prop, val);
                }
            }
            return plist_to_return;
        }
    }

    @LispMethod(comment = "Add indicator/value pairs from DEFAULT-PLIST iff there is no value for indicator in ORIGINAL-PLIST")
    public static SubLObject augment_plist_with_defaults(final SubLObject original_plist, final SubLObject default_plist) {
        SubLObject plist_to_return = copy_list(original_plist);
        SubLObject remainder;
        SubLObject prop;
        SubLObject val;
        for (remainder = NIL, remainder = default_plist; NIL != remainder; remainder = cddr(remainder)) {
            prop = remainder.first();
            val = cadr(remainder);
            plist_to_return = maybe_putf(plist_to_return, prop, val);
        }
        return plist_to_return;
    }/**
     * Add indicator/value pairs from DEFAULT-PLIST iff there is no value for indicator in ORIGINAL-PLIST
     */


    /**
     * is OBJ a plist that only contains indicators that are INDICATOR-LIST?
     */
    @LispMethod(comment = "is OBJ a plist that only contains indicators that are INDICATOR-LIST?")
    public static final SubLObject plist_restricted_to_indicatorsP_alt(SubLObject obj, SubLObject indicator_list) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.property_list_p(obj)) {
            return NIL;
        }
        {
            SubLObject remainder = NIL;
            for (remainder = obj; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject key = remainder.first();
                    SubLObject val = cadr(remainder);
                    if (NIL == subl_promotions.memberP(key, indicator_list, UNPROVIDED, UNPROVIDED)) {
                        return NIL;
                    }
                }
            }
        }
        return T;
    }

    @LispMethod(comment = "is OBJ a plist that only contains indicators that are INDICATOR-LIST?")
    public static SubLObject plist_restricted_to_indicatorsP(final SubLObject obj, final SubLObject indicator_list) {
        if (NIL == property_list_p(obj)) {
            return NIL;
        }
        SubLObject remainder;
        SubLObject key;
        SubLObject val;
        for (remainder = NIL, remainder = obj; NIL != remainder; remainder = cddr(remainder)) {
            key = remainder.first();
            val = cadr(remainder);
            if (NIL == subl_promotions.memberP(key, indicator_list, UNPROVIDED, UNPROVIDED)) {
                return NIL;
            }
        }
        return T;
    }/**
     * is OBJ a plist that only contains indicators that are INDICATOR-LIST?
     */


    /**
     * if INDICATOR is not present in plist, add the appropriate indicator-value pair
     */
    @LispMethod(comment = "if INDICATOR is not present in plist, add the appropriate indicator-value pair")
    public static final SubLObject maybe_putf_alt(SubLObject plist, SubLObject indicator, SubLObject value) {
        if (NIL == com.cyc.cycjava.cycl.list_utilities.indicator_presentP(plist, indicator)) {
            plist = putf(plist, indicator, value);
        }
        return plist;
    }

    @LispMethod(comment = "if INDICATOR is not present in plist, add the appropriate indicator-value pair")
    public static SubLObject maybe_putf(SubLObject plist, final SubLObject indicator, final SubLObject value) {
        if (NIL == indicator_presentP(plist, indicator)) {
            plist = putf(plist, indicator, value);
        }
        return plist;
    }/**
     * if INDICATOR is not present in plist, add the appropriate indicator-value pair
     */


    public static final SubLObject plist_properties_alt(SubLObject plist) {
        {
            SubLObject v_properties = NIL;
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    v_properties = cons(property, v_properties);
                }
            }
            return nreverse(v_properties);
        }
    }

    public static SubLObject plist_properties(final SubLObject plist) {
        SubLObject v_properties = NIL;
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            v_properties = cons(property, v_properties);
        }
        return nreverse(v_properties);
    }

    public static final SubLObject plist_keys_alt(SubLObject plist) {
        return com.cyc.cycjava.cycl.list_utilities.plist_properties(plist);
    }

    public static SubLObject plist_keys(final SubLObject plist) {
        return plist_properties(plist);
    }

    /**
     *
     *
     * @unknown jantos
     */
    @LispMethod(comment = "@unknown jantos")
    public static final SubLObject plist_values_alt(SubLObject plist) {
        {
            SubLObject values = NIL;
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject key = remainder.first();
                    SubLObject value = cadr(remainder);
                    values = cons(value, values);
                }
            }
            return nreverse(values);
        }
    }

    /**
     *
     *
     * @unknown jantos
     */
    @LispMethod(comment = "@unknown jantos")
    public static SubLObject plist_values(final SubLObject plist) {
        SubLObject values = NIL;
        SubLObject remainder;
        SubLObject key;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            key = remainder.first();
            value = cadr(remainder);
            values = cons(value, values);
        }
        return nreverse(values);
    }

    /**
     *
     *
     * @return a copy of PLIST with just INDICATORS-TO-KEEP and their values present
     */
    @LispMethod(comment = "@return a copy of PLIST with just INDICATORS-TO-KEEP and their values present")
    public static final SubLObject plist_restricted_to_indicators_alt(SubLObject plist, SubLObject indicators_to_keep) {
        {
            SubLObject new_plist = NIL;
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject key = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (NIL != subl_promotions.memberP(key, indicators_to_keep, UNPROVIDED, UNPROVIDED)) {
                        new_plist = putf(new_plist, key, value);
                    }
                }
            }
            return new_plist;
        }
    }

    /**
     *
     *
     * @return a copy of PLIST with just INDICATORS-TO-KEEP and their values present
     */
    @LispMethod(comment = "@return a copy of PLIST with just INDICATORS-TO-KEEP and their values present")
    public static SubLObject plist_restricted_to_indicators(final SubLObject plist, final SubLObject indicators_to_keep) {
        SubLObject new_plist = NIL;
        SubLObject remainder;
        SubLObject key;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            key = remainder.first();
            value = cadr(remainder);
            if (NIL != subl_promotions.memberP(key, indicators_to_keep, UNPROVIDED, UNPROVIDED)) {
                new_plist = putf(new_plist, key, value);
            }
        }
        return new_plist;
    }

    /**
     *
     *
     * @return a copy of PLIST with INDICATORS-TO-REMOVE and their values removed.
     */
    @LispMethod(comment = "@return a copy of PLIST with INDICATORS-TO-REMOVE and their values removed.")
    public static final SubLObject plist_except_alt(SubLObject plist, SubLObject indicators_to_remove) {
        {
            SubLObject new_plist = copy_list(plist);
            SubLObject cdolist_list_var = indicators_to_remove;
            SubLObject indicator_to_remove = NIL;
            for (indicator_to_remove = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , indicator_to_remove = cdolist_list_var.first()) {
                new_plist = remf(new_plist, indicator_to_remove);
            }
            return new_plist;
        }
    }

    /**
     *
     *
     * @return a copy of PLIST with INDICATORS-TO-REMOVE and their values removed.
     */
    @LispMethod(comment = "@return a copy of PLIST with INDICATORS-TO-REMOVE and their values removed.")
    public static SubLObject plist_except(final SubLObject plist, final SubLObject indicators_to_remove) {
        SubLObject new_plist = copy_list(plist);
        SubLObject cdolist_list_var = indicators_to_remove;
        SubLObject indicator_to_remove = NIL;
        indicator_to_remove = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            new_plist = remf(new_plist, indicator_to_remove);
            cdolist_list_var = cdolist_list_var.rest();
            indicator_to_remove = cdolist_list_var.first();
        } 
        return new_plist;
    }

    public static final SubLObject plistlist_if_getf_alt(SubLObject plistlist, SubLObject indicator, SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = plistlist;
            SubLObject plist = NIL;
            for (plist = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , plist = cdolist_list_var.first()) {
                if (NIL != funcall(test, getf(plist, indicator, UNPROVIDED), value)) {
                    result = cons(plist, result);
                }
            }
            result = nreverse(result);
            return result;
        }
    }

    public static SubLObject plistlist_if_getf(final SubLObject plistlist, final SubLObject indicator, final SubLObject value, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = plistlist;
        SubLObject plist = NIL;
        plist = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, getf(plist, indicator, UNPROVIDED), value)) {
                result = cons(plist, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            plist = cdolist_list_var.first();
        } 
        result = nreverse(result);
        return result;
    }

    public static final SubLObject plistlist_sort_alt(SubLObject plistlist, SubLObject indicator, SubLObject test) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                {
                    SubLObject _prev_bind_0 = $plistlist_sort_indicator$.currentBinding(thread);
                    try {
                        $plistlist_sort_indicator$.bind(indicator, thread);
                        result = Sort.sort(copy_list(plistlist), test, PLISTLIST_SORT_KEY);
                    } finally {
                        $plistlist_sort_indicator$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    public static SubLObject plistlist_sort(final SubLObject plistlist, final SubLObject indicator, final SubLObject test) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        final SubLObject _prev_bind_0 = $plistlist_sort_indicator$.currentBinding(thread);
        try {
            $plistlist_sort_indicator$.bind(indicator, thread);
            result = Sort.sort(copy_list(plistlist), test, PLISTLIST_SORT_KEY);
        } finally {
            $plistlist_sort_indicator$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    public static final SubLObject plistlist_sort_key_alt(SubLObject plist) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            return getf(plist, $plistlist_sort_indicator$.getDynamicValue(thread), UNPROVIDED);
        }
    }

    public static SubLObject plistlist_sort_key(final SubLObject plist) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        return getf(plist, $plistlist_sort_indicator$.getDynamicValue(thread), UNPROVIDED);
    }

    /**
     * is every key-value pair in SUB-PLIST also present in SUPER-PLIST?
     *
     * @unknown N^2 implementation, on the assumption that if you have a big list, you won't use a plist.
    If this assumption changes, use of a non-n^2 algorithm would be warranted.
     */
    @LispMethod(comment = "is every key-value pair in SUB-PLIST also present in SUPER-PLIST?\r\n\r\n@unknown N^2 implementation, on the assumption that if you have a big list, you won\'t use a plist.\r\nIf this assumption changes, use of a non-n^2 algorithm would be warranted.")
    public static final SubLObject sub_plistP_alt(SubLObject sub_plist, SubLObject super_plist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = EQL;
        }
        {
            SubLObject failP = NIL;
            SubLObject remainder = NIL;
            for (remainder = sub_plist; !((NIL != failP) || (NIL == remainder)); remainder = cddr(remainder)) {
                {
                    SubLObject key = remainder.first();
                    SubLObject value = cadr(remainder);
                    if (!((NIL != com.cyc.cycjava.cycl.list_utilities.plist_has_keyP(super_plist, key)) && (NIL != funcall(test, value, getf(super_plist, key, UNPROVIDED))))) {
                        failP = T;
                    }
                }
            }
            return makeBoolean(NIL == failP);
        }
    }

    @LispMethod(comment = "is every key-value pair in SUB-PLIST also present in SUPER-PLIST?\r\n\r\n@unknown N^2 implementation, on the assumption that if you have a big list, you won\'t use a plist.\r\nIf this assumption changes, use of a non-n^2 algorithm would be warranted.")
    public static SubLObject sub_plistP(final SubLObject sub_plist, final SubLObject super_plist, SubLObject test) {
        if (test == UNPROVIDED) {
            test = EQL;
        }
        SubLObject failP;
        SubLObject remainder;
        SubLObject key;
        SubLObject value;
        for (failP = NIL, remainder = NIL, remainder = sub_plist; (NIL == failP) && (NIL != remainder); remainder = cddr(remainder)) {
            key = remainder.first();
            value = cadr(remainder);
            if ((NIL == plist_has_keyP(super_plist, key)) || (NIL == funcall(test, value, getf(super_plist, key, UNPROVIDED)))) {
                failP = T;
            }
        }
        return makeBoolean(NIL == failP);
    }/**
     * is every key-value pair in SUB-PLIST also present in SUPER-PLIST?
     *
     * @unknown N^2 implementation, on the assumption that if you have a big list, you won't use a plist.
    If this assumption changes, use of a non-n^2 algorithm would be warranted.
     */


    /**
     * Determine whether two PLISTs are equal by determining whether they are
     * sublists of each other. This is slow, because it calls a slow SUB-PLIST?
     * implementation.
     */
    @LispMethod(comment = "Determine whether two PLISTs are equal by determining whether they are\r\nsublists of each other. This is slow, because it calls a slow SUB-PLIST?\r\nimplementation.\nDetermine whether two PLISTs are equal by determining whether they are\nsublists of each other. This is slow, because it calls a slow SUB-PLIST?\nimplementation.")
    public static final SubLObject slow_plists_equalP_alt(SubLObject plist_a, SubLObject plist_b, SubLObject value_test) {
        if (value_test == UNPROVIDED) {
            value_test = EQL;
        }
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.sub_plistP(plist_a, plist_b, value_test)) && (NIL != com.cyc.cycjava.cycl.list_utilities.sub_plistP(plist_b, plist_a, value_test)));
    }

    @LispMethod(comment = "Determine whether two PLISTs are equal by determining whether they are\r\nsublists of each other. This is slow, because it calls a slow SUB-PLIST?\r\nimplementation.\nDetermine whether two PLISTs are equal by determining whether they are\nsublists of each other. This is slow, because it calls a slow SUB-PLIST?\nimplementation.")
    public static SubLObject slow_plists_equalP(final SubLObject plist_a, final SubLObject plist_b, SubLObject value_test) {
        if (value_test == UNPROVIDED) {
            value_test = EQL;
        }
        return makeBoolean((NIL != sub_plistP(plist_a, plist_b, value_test)) && (NIL != sub_plistP(plist_b, plist_a, value_test)));
    }/**
     * Determine whether two PLISTs are equal by determining whether they are
     * sublists of each other. This is slow, because it calls a slow SUB-PLIST?
     * implementation.
     */


    public static final SubLObject format_item_list_alt(SubLObject list) {
        {
            SubLObject pcase_var = length(list);
            if (pcase_var.eql(ZERO_INTEGER)) {
                return $str_alt64$;
            } else {
                if (pcase_var.eql(ONE_INTEGER)) {
                    return princ_to_string(list.first());
                } else {
                    if (pcase_var.eql(TWO_INTEGER)) {
                        return format(NIL, $str_alt155$_A_and__A, list.first(), second(list));
                    } else {
                        {
                            SubLObject strings = Mapping.mapcar(PRINC_TO_STRING, list);
                            SubLObject length = add(multiply(TWO_INTEGER, subtract(length(strings), ONE_INTEGER)), FOUR_INTEGER);
                            {
                                SubLObject cdolist_list_var = strings;
                                SubLObject string = NIL;
                                for (string = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , string = cdolist_list_var.first()) {
                                    length = add(length, length(string));
                                }
                            }
                            {
                                SubLObject ans = Strings.make_string(length, UNPROVIDED);
                                SubLObject i = ZERO_INTEGER;
                                SubLObject rest = NIL;
                                SubLObject string = NIL;
                                for (rest = strings, string = rest.first(); NIL != rest; rest = rest.rest() , string = rest.first()) {
                                    {
                                        SubLObject cdotimes_end_var = length(string);
                                        SubLObject j = NIL;
                                        for (j = ZERO_INTEGER; j.numL(cdotimes_end_var); j = add(j, ONE_INTEGER)) {
                                            Strings.set_char(ans, i, Strings.sublisp_char(string, j));
                                            i = add(i, ONE_INTEGER);
                                        }
                                    }
                                    if (NIL != rest.rest()) {
                                        if (NIL != rest.rest().rest()) {
                                            {
                                                SubLObject j = NIL;
                                                for (j = ZERO_INTEGER; j.numL(TWO_INTEGER); j = add(j, ONE_INTEGER)) {
                                                    Strings.set_char(ans, i, Strings.sublisp_char($str_alt157$__, j));
                                                    i = add(i, ONE_INTEGER);
                                                }
                                            }
                                        } else {
                                            {
                                                SubLObject j = NIL;
                                                for (j = ZERO_INTEGER; j.numL(SIX_INTEGER); j = add(j, ONE_INTEGER)) {
                                                    Strings.set_char(ans, i, Strings.sublisp_char($str_alt158$__and_, j));
                                                    i = add(i, ONE_INTEGER);
                                                }
                                            }
                                        }
                                    }
                                }
                                return ans;
                            }
                        }
                    }
                }
            }
        }
    }

    public static SubLObject format_item_list(final SubLObject list) {
        final SubLObject pcase_var = length(list);
        if (pcase_var.eql(ZERO_INTEGER)) {
            return $str64$;
        }
        if (pcase_var.eql(ONE_INTEGER)) {
            return princ_to_string(list.first());
        }
        if (pcase_var.eql(TWO_INTEGER)) {
            return format(NIL, $str162$_A_and__A, list.first(), second(list));
        }
        final SubLObject strings = Mapping.mapcar(PRINC_TO_STRING, list);
        SubLObject length = add(multiply(TWO_INTEGER, subtract(length(strings), ONE_INTEGER)), FOUR_INTEGER);
        SubLObject cdolist_list_var = strings;
        SubLObject string = NIL;
        string = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            length = add(length, length(string));
            cdolist_list_var = cdolist_list_var.rest();
            string = cdolist_list_var.first();
        } 
        final SubLObject ans = Strings.make_string(length, UNPROVIDED);
        SubLObject i = ZERO_INTEGER;
        SubLObject rest = NIL;
        SubLObject string2 = NIL;
        rest = strings;
        string2 = rest.first();
        while (NIL != rest) {
            SubLObject cdotimes_end_var;
            SubLObject j;
            for (cdotimes_end_var = length(string2), j = NIL, j = ZERO_INTEGER; j.numL(cdotimes_end_var); j = add(j, ONE_INTEGER)) {
                Strings.set_char(ans, i, Strings.sublisp_char(string2, j));
                i = add(i, ONE_INTEGER);
            }
            if (NIL != rest.rest()) {
                if (NIL != rest.rest().rest()) {
                    SubLObject k;
                    for (k = NIL, k = ZERO_INTEGER; k.numL(TWO_INTEGER); k = add(k, ONE_INTEGER)) {
                        Strings.set_char(ans, i, Strings.sublisp_char($str164$__, k));
                        i = add(i, ONE_INTEGER);
                    }
                } else {
                    SubLObject k;
                    for (k = NIL, k = ZERO_INTEGER; k.numL(SIX_INTEGER); k = add(k, ONE_INTEGER)) {
                        Strings.set_char(ans, i, Strings.sublisp_char($str165$__and_, k));
                        i = add(i, ONE_INTEGER);
                    }
                }
            }
            rest = rest.rest();
            string2 = rest.first();
        } 
        return ans;
    }

    public static final SubLObject print_plist_readably_alt(SubLObject plist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        SubLTrampolineFile.checkType(plist, PROPERTY_LIST_P);
        {
            SubLObject remainder = NIL;
            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                {
                    SubLObject property = remainder.first();
                    SubLObject value = cadr(remainder);
                    format(stream, $str_alt159$_a_____a__, property, value);
                }
            }
        }
        return plist;
    }

    public static SubLObject print_plist_readably(final SubLObject plist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        assert NIL != property_list_p(plist) : "! list_utilities.property_list_p(plist) " + ("list_utilities.property_list_p(plist) " + "CommonSymbols.NIL != list_utilities.property_list_p(plist) ") + plist;
        SubLObject remainder;
        SubLObject property;
        SubLObject value;
        for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
            property = remainder.first();
            value = cadr(remainder);
            format(stream, $str166$_a_____a__, property, value);
        }
        return plist;
    }

    public static final SubLObject pretty_print_plist_alt(SubLObject plist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(plist, PROPERTY_LIST_P);
            if (NIL != plist) {
                {
                    SubLObject _prev_bind_0 = $read_default_float_format$.currentBinding(thread);
                    try {
                        $read_default_float_format$.bind(DOUBLE_FLOAT, thread);
                        {
                            SubLObject max_length = number_utilities.maximum(Mapping.mapcar(symbol_function(LENGTH), Mapping.mapcar(symbol_function(STR), com.cyc.cycjava.cycl.list_utilities.plist_properties(plist))), UNPROVIDED);
                            SubLObject remainder = NIL;
                            for (remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                                {
                                    SubLObject property = remainder.first();
                                    SubLObject value = cadr(remainder);
                                    if (value.isDouble()) {
                                        format(stream, $str_alt162$_a___4_2f__, string_utilities.to_string_of_length(property, max_length), value);
                                    } else {
                                        format(stream, $str_alt163$_a___a__, string_utilities.to_string_of_length(property, max_length), value);
                                    }
                                }
                            }
                        }
                    } finally {
                        $read_default_float_format$.rebind(_prev_bind_0, thread);
                    }
                }
            }
            return plist;
        }
    }

    public static SubLObject pretty_print_plist(final SubLObject plist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != property_list_p(plist) : "! list_utilities.property_list_p(plist) " + ("list_utilities.property_list_p(plist) " + "CommonSymbols.NIL != list_utilities.property_list_p(plist) ") + plist;
        if (NIL != plist) {
            final SubLObject _prev_bind_0 = $read_default_float_format$.currentBinding(thread);
            try {
                $read_default_float_format$.bind(DOUBLE_FLOAT, thread);
                final SubLObject max_length = number_utilities.maximum(Mapping.mapcar(symbol_function(LENGTH), Mapping.mapcar(symbol_function(STR), plist_properties(plist))), UNPROVIDED);
                SubLObject remainder;
                SubLObject property;
                SubLObject value;
                for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                    property = remainder.first();
                    value = cadr(remainder);
                    if (value.isDouble()) {
                        format(stream, $str169$_a___4_2f__, string_utilities.to_string_of_length(property, max_length), value);
                    } else {
                        format(stream, $str170$_a___a__, string_utilities.to_string_of_length(property, max_length), value);
                    }
                }
            } finally {
                $read_default_float_format$.rebind(_prev_bind_0, thread);
            }
        }
        return plist;
    }

    public static SubLObject pretty_prin1_plist(final SubLObject plist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != property_list_p(plist) : "! list_utilities.property_list_p(plist) " + ("list_utilities.property_list_p(plist) " + "CommonSymbols.NIL != list_utilities.property_list_p(plist) ") + plist;
        if (NIL != plist) {
            final SubLObject _prev_bind_0 = $read_default_float_format$.currentBinding(thread);
            try {
                $read_default_float_format$.bind(DOUBLE_FLOAT, thread);
                final SubLObject max_length = number_utilities.maximum(Mapping.mapcar(symbol_function(LENGTH), Mapping.mapcar(symbol_function(STR), plist_properties(plist))), UNPROVIDED);
                SubLObject remainder;
                SubLObject property;
                SubLObject value;
                for (remainder = NIL, remainder = plist; NIL != remainder; remainder = cddr(remainder)) {
                    property = remainder.first();
                    value = cadr(remainder);
                    if (value.isDouble()) {
                        format(stream, $str169$_a___4_2f__, string_utilities.to_string_of_length(property, max_length), value);
                    } else {
                        format(stream, $str171$_a___s__, string_utilities.to_string_of_length(property, max_length), value);
                    }
                }
            } finally {
                $read_default_float_format$.rebind(_prev_bind_0, thread);
            }
        }
        return plist;
    }

    public static final SubLObject pretty_print_alist_alt(SubLObject alist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.list_utilities.pretty_print_plist(com.cyc.cycjava.cycl.list_utilities.alist_to_plist(alist), stream);
    }

    public static SubLObject pretty_print_alist(final SubLObject alist, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = StreamsLow.$standard_output$.getDynamicValue();
        }
        return pretty_print_plist(alist_to_plist(alist), stream);
    }

    /**
     * Print LIST-OF-LISTS to STREAM in a human-readable table format,
     * with each sublist as a row in the table.
     */
    @LispMethod(comment = "Print LIST-OF-LISTS to STREAM in a human-readable table format,\r\nwith each sublist as a row in the table.\nPrint LIST-OF-LISTS to STREAM in a human-readable table format,\nwith each sublist as a row in the table.")
    public static final SubLObject print_list_of_lists_as_table_alt(SubLObject list_of_lists, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = T;
        }
        {
            SubLObject list_var = list_of_lists;
            SubLTrampolineFile.checkType(list_var, NON_DOTTED_LIST_P);
            {
                SubLObject cdolist_list_var = list_var;
                SubLObject elem = NIL;
                for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                    SubLTrampolineFile.checkType(elem, LISTP);
                }
            }
        }
        {
            SubLObject list_of_string_lists = NIL;
            {
                SubLObject cdolist_list_var = list_of_lists;
                SubLObject list = NIL;
                for (list = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list = cdolist_list_var.first()) {
                    list_of_string_lists = cons(Mapping.mapcar(symbol_function(TO_STRING), list), list_of_string_lists);
                }
            }
            list_of_string_lists = nreverse(list_of_string_lists);
            {
                SubLObject num_cols = number_utilities.maximum(Mapping.mapcar(symbol_function(LENGTH), list_of_string_lists), UNPROVIDED);
                SubLObject column_widths = NIL;
                SubLObject index = NIL;
                for (index = ZERO_INTEGER; index.numL(num_cols); index = add(index, ONE_INTEGER)) {
                    {
                        SubLObject width = ZERO_INTEGER;
                        SubLObject cdolist_list_var = list_of_string_lists;
                        SubLObject list = NIL;
                        for (list = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list = cdolist_list_var.first()) {
                            {
                                SubLObject string_length = length(nth(index, list));
                                width = max(width, string_length);
                            }
                        }
                        column_widths = cons(width, column_widths);
                    }
                }
                column_widths = nreverse(column_widths);
                {
                    SubLObject cdolist_list_var = list_of_string_lists;
                    SubLObject list = NIL;
                    for (list = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list = cdolist_list_var.first()) {
                        terpri(stream);
                        {
                            SubLObject string = NIL;
                            SubLObject string_27 = NIL;
                            SubLObject column_width = NIL;
                            SubLObject column_width_28 = NIL;
                            for (string = list, string_27 = string.first(), column_width = column_widths, column_width_28 = column_width.first(); !((NIL == column_width) && (NIL == string)); string = string.rest() , string_27 = string.first() , column_width = column_width.rest() , column_width_28 = column_width.first()) {
                                princ($str_alt165$___, stream);
                                if (NIL != string_27) {
                                    princ(string_utilities.to_string_of_length(string_27, column_width_28), stream);
                                } else {
                                    princ(Strings.make_string(column_width_28, UNPROVIDED), stream);
                                }
                            }
                        }
                    }
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Print LIST-OF-LISTS to STREAM in a human-readable table format,\r\nwith each sublist as a row in the table.\nPrint LIST-OF-LISTS to STREAM in a human-readable table format,\nwith each sublist as a row in the table.")
    public static SubLObject print_list_of_lists_as_table(final SubLObject list_of_lists, SubLObject stream) {
        if (stream == UNPROVIDED) {
            stream = T;
        }
        assert NIL != non_dotted_list_p(list_of_lists) : "! list_utilities.non_dotted_list_p(list_of_lists) " + ("list_utilities.non_dotted_list_p(list_of_lists) " + "CommonSymbols.NIL != list_utilities.non_dotted_list_p(list_of_lists) ") + list_of_lists;
        SubLObject cdolist_list_var = list_of_lists;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            assert NIL != listp(elem) : "! listp(elem) " + ("Types.listp(elem) " + "CommonSymbols.NIL != Types.listp(elem) ") + elem;
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        SubLObject list_of_string_lists = NIL;
        cdolist_list_var = list_of_lists;
        SubLObject list = NIL;
        list = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            list_of_string_lists = cons(Mapping.mapcar(symbol_function(TO_STRING), list), list_of_string_lists);
            cdolist_list_var = cdolist_list_var.rest();
            list = cdolist_list_var.first();
        } 
        list_of_string_lists = nreverse(list_of_string_lists);
        final SubLObject num_cols = number_utilities.maximum(Mapping.mapcar(symbol_function(LENGTH), list_of_string_lists), UNPROVIDED);
        SubLObject column_widths = NIL;
        SubLObject index;
        SubLObject width;
        SubLObject cdolist_list_var2;
        SubLObject list2;
        SubLObject string_length;
        for (index = NIL, index = ZERO_INTEGER; index.numL(num_cols); index = add(index, ONE_INTEGER)) {
            width = ZERO_INTEGER;
            cdolist_list_var2 = list_of_string_lists;
            list2 = NIL;
            list2 = cdolist_list_var2.first();
            while (NIL != cdolist_list_var2) {
                string_length = length(nth(index, list2));
                width = max(width, string_length);
                cdolist_list_var2 = cdolist_list_var2.rest();
                list2 = cdolist_list_var2.first();
            } 
            column_widths = cons(width, column_widths);
        }
        column_widths = nreverse(column_widths);
        SubLObject cdolist_list_var3 = list_of_string_lists;
        SubLObject list3 = NIL;
        list3 = cdolist_list_var3.first();
        while (NIL != cdolist_list_var3) {
            terpri(stream);
            SubLObject string = NIL;
            SubLObject string_$29 = NIL;
            SubLObject column_width = NIL;
            SubLObject column_width_$30 = NIL;
            string = list3;
            string_$29 = string.first();
            column_width = column_widths;
            column_width_$30 = column_width.first();
            while ((NIL != column_width) || (NIL != string)) {
                princ($str173$___, stream);
                if (NIL != string_$29) {
                    princ(string_utilities.to_string_of_length(string_$29, column_width_$30), stream);
                } else {
                    princ(Strings.make_string(column_width_$30, UNPROVIDED), stream);
                }
                string = string.rest();
                string_$29 = string.first();
                column_width = column_width.rest();
                column_width_$30 = column_width.first();
            } 
            cdolist_list_var3 = cdolist_list_var3.rest();
            list3 = cdolist_list_var3.first();
        } 
        return NIL;
    }/**
     * Print LIST-OF-LISTS to STREAM in a human-readable table format,
     * with each sublist as a row in the table.
     */


    /**
     * Print a list as a delimited line (e.g. to output to a CSV file).
     */
    @LispMethod(comment = "Print a list as a delimited line (e.g. to output to a CSV file).")
    public static final SubLObject print_list_as_delimited_line_alt(SubLObject list, SubLObject delimiter, SubLObject stream) {
        if (delimiter == UNPROVIDED) {
            delimiter = CHAR_comma;
        }
        if (stream == UNPROVIDED) {
            stream = T;
        }
        SubLTrampolineFile.checkType(list, LISTP);
        prin1(list.first(), stream);
        {
            SubLObject cdolist_list_var = list.rest();
            SubLObject value = NIL;
            for (value = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , value = cdolist_list_var.first()) {
                princ(delimiter, stream);
                prin1(value, stream);
            }
        }
        return list;
    }

    @LispMethod(comment = "Print a list as a delimited line (e.g. to output to a CSV file).")
    public static SubLObject print_list_as_delimited_line(final SubLObject list, SubLObject delimiter, SubLObject stream) {
        if (delimiter == UNPROVIDED) {
            delimiter = CHAR_comma;
        }
        if (stream == UNPROVIDED) {
            stream = T;
        }
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        prin1(list.first(), stream);
        SubLObject cdolist_list_var = list.rest();
        SubLObject value = NIL;
        value = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            princ(delimiter, stream);
            prin1(value, stream);
            cdolist_list_var = cdolist_list_var.rest();
            value = cdolist_list_var.first();
        } 
        return list;
    }/**
     * Print a list as a delimited line (e.g. to output to a CSV file).
     */


    public static final SubLObject any_in_list_alt(SubLObject predicate, SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject ans = NIL;
            if ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) {
                if (NIL == ans) {
                    {
                        SubLObject csome_list_var = list;
                        SubLObject item = NIL;
                        for (item = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                            ans = funcall(predicate, item);
                        }
                    }
                }
            } else {
                if (NIL == ans) {
                    {
                        SubLObject csome_list_var = list;
                        SubLObject item = NIL;
                        for (item = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                            ans = funcall(predicate, funcall(key, item));
                        }
                    }
                }
            }
            return ans;
        }
    }

    public static SubLObject any_in_list(final SubLObject predicate, final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject ans = NIL;
        if (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) {
            if (NIL == ans) {
                SubLObject csome_list_var;
                SubLObject item;
                for (csome_list_var = list, item = NIL, item = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = funcall(predicate, item) , csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                }
            }
        } else
            if (NIL == ans) {
                SubLObject csome_list_var;
                SubLObject item;
                for (csome_list_var = list, item = NIL, item = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = funcall(predicate, funcall(key, item)) , csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                }
            }

        return ans;
    }

    public static final SubLObject every_in_list_alt(SubLObject predicate, SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject ans = NIL;
            if ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) {
                if (NIL == ans) {
                    {
                        SubLObject csome_list_var = list;
                        SubLObject item = NIL;
                        for (item = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                            ans = makeBoolean(NIL == funcall(predicate, item));
                        }
                    }
                }
            } else {
                if (NIL == ans) {
                    {
                        SubLObject csome_list_var = list;
                        SubLObject item = NIL;
                        for (item = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                            ans = makeBoolean(NIL == funcall(predicate, funcall(key, item)));
                        }
                    }
                }
            }
            return makeBoolean(NIL == ans);
        }
    }

    public static SubLObject every_in_list(final SubLObject predicate, final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject ans = NIL;
        if (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) {
            if (NIL == ans) {
                SubLObject csome_list_var;
                SubLObject item;
                for (csome_list_var = list, item = NIL, item = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = makeBoolean(NIL == funcall(predicate, item)) , csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                }
            }
        } else
            if (NIL == ans) {
                SubLObject csome_list_var;
                SubLObject item;
                for (csome_list_var = list, item = NIL, item = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = makeBoolean(NIL == funcall(predicate, funcall(key, item))) , csome_list_var = csome_list_var.rest() , item = csome_list_var.first()) {
                }
            }

        return makeBoolean(NIL == ans);
    }

    public static final SubLObject not_any_in_list_alt(SubLObject predicate, SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.any_in_list(predicate, list, key));
    }

    public static SubLObject not_any_in_list(final SubLObject predicate, final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean(NIL == any_in_list(predicate, list, key));
    }

    public static final SubLObject not_every_in_list_alt(SubLObject predicate, SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.every_in_list(predicate, list, key));
    }

    public static SubLObject not_every_in_list(final SubLObject predicate, final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return makeBoolean(NIL == every_in_list(predicate, list, key));
    }

    public static final SubLObject plist_difference_alt(SubLObject plist_a, SubLObject plist_b, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject plus_a = NIL;
            SubLObject plus_b = NIL;
            {
                SubLObject remainder = NIL;
                for (remainder = plist_a; NIL != remainder; remainder = cddr(remainder)) {
                    {
                        SubLObject indicator = remainder.first();
                        SubLObject value = cadr(remainder);
                        if (NIL == funcall(test, value, getf(plist_b, indicator, UNPROVIDED))) {
                            plus_a = putf(plus_a, indicator, value);
                        }
                    }
                }
            }
            {
                SubLObject remainder = NIL;
                for (remainder = plist_b; NIL != remainder; remainder = cddr(remainder)) {
                    {
                        SubLObject indicator = remainder.first();
                        SubLObject value = cadr(remainder);
                        if (NIL == funcall(test, value, getf(plist_a, indicator, UNPROVIDED))) {
                            plus_b = putf(plus_b, indicator, value);
                        }
                    }
                }
            }
            return values(plus_a, plus_b);
        }
    }

    public static SubLObject plist_difference(final SubLObject plist_a, final SubLObject plist_b, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject plus_a = NIL;
        SubLObject plus_b = NIL;
        SubLObject remainder;
        SubLObject indicator;
        SubLObject value;
        for (remainder = NIL, remainder = plist_a; NIL != remainder; remainder = cddr(remainder)) {
            indicator = remainder.first();
            value = cadr(remainder);
            if (NIL == funcall(test, value, getf(plist_b, indicator, UNPROVIDED))) {
                plus_a = putf(plus_a, indicator, value);
            }
        }
        for (remainder = NIL, remainder = plist_b; NIL != remainder; remainder = cddr(remainder)) {
            indicator = remainder.first();
            value = cadr(remainder);
            if (NIL == funcall(test, value, getf(plist_a, indicator, UNPROVIDED))) {
                plus_b = putf(plus_b, indicator, value);
            }
        }
        return subl_promotions.values2(plus_a, plus_b);
    }

    public static final SubLObject list_subseq_subst_combos_alt(SubLObject list, SubLObject subseq_subst_spec) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(list, LISTP);
            SubLTrampolineFile.checkType(subseq_subst_spec, LISTP);
            if (NIL == subseq_subst_spec) {
                return list(list);
            } else {
                {
                    SubLObject ans = NIL;
                    {
                        SubLObject _prev_bind_0 = $subseq_subst_recursive_answers$.currentBinding(thread);
                        try {
                            $subseq_subst_recursive_answers$.bind(NIL, thread);
                            ans = com.cyc.cycjava.cycl.list_utilities.list_subseq_subst_combos_internal(list, subseq_subst_spec, ZERO_INTEGER);
                        } finally {
                            $subseq_subst_recursive_answers$.rebind(_prev_bind_0, thread);
                        }
                    }
                    return ans;
                }
            }
        }
    }

    public static SubLObject list_subseq_subst_combos(final SubLObject list, final SubLObject subseq_subst_spec) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        assert NIL != listp(subseq_subst_spec) : "! listp(subseq_subst_spec) " + ("Types.listp(subseq_subst_spec) " + "CommonSymbols.NIL != Types.listp(subseq_subst_spec) ") + subseq_subst_spec;
        if (NIL == subseq_subst_spec) {
            return list(list);
        }
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = $subseq_subst_recursive_answers$.currentBinding(thread);
        try {
            $subseq_subst_recursive_answers$.bind(NIL, thread);
            ans = list_subseq_subst_combos_internal(list, subseq_subst_spec, ZERO_INTEGER);
        } finally {
            $subseq_subst_recursive_answers$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject list_subseq_subst_combos_internal_alt(SubLObject list, SubLObject subseq_subst_spec, SubLObject index) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject sub_answer = assoc(list, $subseq_subst_recursive_answers$.getDynamicValue(thread), UNPROVIDED, UNPROVIDED).rest();
                if (NIL != sub_answer) {
                    return sub_answer;
                }
                {
                    SubLObject answer_combos = NIL;
                    if (NIL == list) {
                        answer_combos = list(NIL);
                    } else {
                        {
                            SubLObject item = list.first();
                            SubLObject rest = list.rest();
                            SubLObject rest_index = add(index, ONE_INTEGER);
                            SubLObject rest_spec = member(rest_index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
                            SubLObject recursive_combos = com.cyc.cycjava.cycl.list_utilities.list_subseq_subst_combos_internal(rest, rest_spec, rest_index);
                            {
                                SubLObject cdolist_list_var = recursive_combos;
                                SubLObject recursive_combo = NIL;
                                for (recursive_combo = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , recursive_combo = cdolist_list_var.first()) {
                                    answer_combos = cons(cons(item, recursive_combo), answer_combos);
                                }
                            }
                            {
                                SubLObject substs = member(index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
                                SubLObject done = NIL;
                                if (NIL == done) {
                                    {
                                        SubLObject csome_list_var = substs;
                                        SubLObject subst = NIL;
                                        for (subst = csome_list_var.first(); !((NIL != done) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , subst = csome_list_var.first()) {
                                            {
                                                SubLObject datum = subst;
                                                SubLObject current = datum;
                                                SubLObject subst_index = NIL;
                                                SubLObject subst_length = NIL;
                                                SubLObject subst_item = NIL;
                                                destructuring_bind_must_consp(current, datum, $list_alt166);
                                                subst_index = current.first();
                                                current = current.rest();
                                                destructuring_bind_must_consp(current, datum, $list_alt166);
                                                subst_length = current.first();
                                                current = current.rest();
                                                destructuring_bind_must_consp(current, datum, $list_alt166);
                                                subst_item = current.first();
                                                current = current.rest();
                                                if (NIL == current) {
                                                    if (index.numE(subst_index)) {
                                                        {
                                                            SubLObject subst_rest = nthcdr(subst_length, list);
                                                            SubLObject subst_rest_index = add(index, subst_length);
                                                            SubLObject subst_rest_spec = member(subst_rest_index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
                                                            SubLObject subst_recursive_combos = com.cyc.cycjava.cycl.list_utilities.list_subseq_subst_combos_internal(subst_rest, subst_rest_spec, subst_rest_index);
                                                            SubLObject cdolist_list_var = subst_recursive_combos;
                                                            SubLObject subst_recursive_combo = NIL;
                                                            for (subst_recursive_combo = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , subst_recursive_combo = cdolist_list_var.first()) {
                                                                answer_combos = cons(cons(subst_item, subst_recursive_combo), answer_combos);
                                                            }
                                                        }
                                                    } else {
                                                        done = T;
                                                    }
                                                } else {
                                                    cdestructuring_bind_error(datum, $list_alt166);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            answer_combos = nreverse(answer_combos);
                        }
                    }
                    $subseq_subst_recursive_answers$.setDynamicValue(cons(cons(list, answer_combos), $subseq_subst_recursive_answers$.getDynamicValue(thread)), thread);
                    return answer_combos;
                }
            }
        }
    }

    public static SubLObject list_subseq_subst_combos_internal(final SubLObject list, final SubLObject subseq_subst_spec, final SubLObject index) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject sub_answer = assoc(list, $subseq_subst_recursive_answers$.getDynamicValue(thread), UNPROVIDED, UNPROVIDED).rest();
        if (NIL != sub_answer) {
            return sub_answer;
        }
        SubLObject answer_combos = NIL;
        if (NIL == list) {
            answer_combos = list(NIL);
        } else {
            final SubLObject item = list.first();
            final SubLObject rest = list.rest();
            final SubLObject rest_index = add(index, ONE_INTEGER);
            final SubLObject rest_spec = member(rest_index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
            SubLObject cdolist_list_var;
            final SubLObject recursive_combos = cdolist_list_var = list_subseq_subst_combos_internal(rest, rest_spec, rest_index);
            SubLObject recursive_combo = NIL;
            recursive_combo = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                answer_combos = cons(cons(item, recursive_combo), answer_combos);
                cdolist_list_var = cdolist_list_var.rest();
                recursive_combo = cdolist_list_var.first();
            } 
            final SubLObject substs = member(index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
            SubLObject done = NIL;
            if (NIL == done) {
                SubLObject csome_list_var = substs;
                SubLObject subst = NIL;
                subst = csome_list_var.first();
                while ((NIL == done) && (NIL != csome_list_var)) {
                    SubLObject current;
                    final SubLObject datum = current = subst;
                    SubLObject subst_index = NIL;
                    SubLObject subst_length = NIL;
                    SubLObject subst_item = NIL;
                    destructuring_bind_must_consp(current, datum, $list174);
                    subst_index = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list174);
                    subst_length = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list174);
                    subst_item = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        if (index.numE(subst_index)) {
                            final SubLObject subst_rest = nthcdr(subst_length, list);
                            final SubLObject subst_rest_index = add(index, subst_length);
                            final SubLObject subst_rest_spec = member(subst_rest_index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
                            SubLObject cdolist_list_var2;
                            final SubLObject subst_recursive_combos = cdolist_list_var2 = list_subseq_subst_combos_internal(subst_rest, subst_rest_spec, subst_rest_index);
                            SubLObject subst_recursive_combo = NIL;
                            subst_recursive_combo = cdolist_list_var2.first();
                            while (NIL != cdolist_list_var2) {
                                answer_combos = cons(cons(subst_item, subst_recursive_combo), answer_combos);
                                cdolist_list_var2 = cdolist_list_var2.rest();
                                subst_recursive_combo = cdolist_list_var2.first();
                            } 
                        } else {
                            done = T;
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list174);
                    }
                    csome_list_var = csome_list_var.rest();
                    subst = csome_list_var.first();
                } 
            }
            answer_combos = nreverse(answer_combos);
        }
        $subseq_subst_recursive_answers$.setDynamicValue(cons(cons(list, answer_combos), $subseq_subst_recursive_answers$.getDynamicValue(thread)), thread);
        return answer_combos;
    }

    public static final SubLObject greedy_list_subseq_subst_alt(SubLObject list, SubLObject subseq_subst_spec) {
        SubLTrampolineFile.checkType(list, LISTP);
        SubLTrampolineFile.checkType(subseq_subst_spec, LISTP);
        if (NIL == subseq_subst_spec) {
            return list;
        } else {
            return com.cyc.cycjava.cycl.list_utilities.greedy_list_subseq_subst_internal(list, subseq_subst_spec, ZERO_INTEGER);
        }
    }

    public static SubLObject greedy_list_subseq_subst(final SubLObject list, final SubLObject subseq_subst_spec) {
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        assert NIL != listp(subseq_subst_spec) : "! listp(subseq_subst_spec) " + ("Types.listp(subseq_subst_spec) " + "CommonSymbols.NIL != Types.listp(subseq_subst_spec) ") + subseq_subst_spec;
        if (NIL == subseq_subst_spec) {
            return list;
        }
        return greedy_list_subseq_subst_internal(list, subseq_subst_spec, ZERO_INTEGER);
    }

    public static final SubLObject greedy_list_subseq_subst_internal_alt(SubLObject list, SubLObject subseq_subst_spec, SubLObject index) {
        if (NIL == list) {
            return NIL;
        } else {
            {
                SubLObject next_substs = member(index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
                SubLObject later_substs = member(index, next_substs, symbol_function($sym97$_), symbol_function(CAR));
                if (next_substs == later_substs) {
                    return cons(list.first(), com.cyc.cycjava.cycl.list_utilities.greedy_list_subseq_subst_internal(list.rest(), later_substs, add(index, ONE_INTEGER)));
                } else {
                    while ((NIL != next_substs.rest()) && index.numE(caar(next_substs.rest()))) {
                        next_substs = next_substs.rest();
                    } 
                    {
                        SubLObject datum = next_substs.first();
                        SubLObject current = datum;
                        SubLObject subst_index = NIL;
                        SubLObject subst_length = NIL;
                        SubLObject subst_item = NIL;
                        destructuring_bind_must_consp(current, datum, $list_alt166);
                        subst_index = current.first();
                        current = current.rest();
                        destructuring_bind_must_consp(current, datum, $list_alt166);
                        subst_length = current.first();
                        current = current.rest();
                        destructuring_bind_must_consp(current, datum, $list_alt166);
                        subst_item = current.first();
                        current = current.rest();
                        if (NIL == current) {
                            {
                                SubLObject subst_rest = nthcdr(subst_length, list);
                                SubLObject subst_rest_index = add(index, subst_length);
                                SubLObject subst_rest_spec = member(subst_rest_index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
                                return cons(subst_item, com.cyc.cycjava.cycl.list_utilities.greedy_list_subseq_subst_internal(subst_rest, subst_rest_spec, subst_rest_index));
                            }
                        } else {
                            cdestructuring_bind_error(datum, $list_alt166);
                        }
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject greedy_list_subseq_subst_internal(final SubLObject list, final SubLObject subseq_subst_spec, final SubLObject index) {
        if (NIL == list) {
            return NIL;
        }
        SubLObject next_substs = member(index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
        final SubLObject later_substs = member(index, next_substs, symbol_function($sym97$_), symbol_function(CAR));
        if (next_substs.eql(later_substs)) {
            return cons(list.first(), greedy_list_subseq_subst_internal(list.rest(), later_substs, add(index, ONE_INTEGER)));
        }
        while ((NIL != next_substs.rest()) && index.numE(caar(next_substs.rest()))) {
            next_substs = next_substs.rest();
        } 
        SubLObject current;
        final SubLObject datum = current = next_substs.first();
        SubLObject subst_index = NIL;
        SubLObject subst_length = NIL;
        SubLObject subst_item = NIL;
        destructuring_bind_must_consp(current, datum, $list174);
        subst_index = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list174);
        subst_length = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list174);
        subst_item = current.first();
        current = current.rest();
        if (NIL == current) {
            final SubLObject subst_rest = nthcdr(subst_length, list);
            final SubLObject subst_rest_index = add(index, subst_length);
            final SubLObject subst_rest_spec = member(subst_rest_index, subseq_subst_spec, symbol_function($sym98$__), symbol_function(CAR));
            return cons(subst_item, greedy_list_subseq_subst_internal(subst_rest, subst_rest_spec, subst_rest_index));
        }
        cdestructuring_bind_error(datum, $list174);
        return NIL;
    }

    /**
     * Return the first item in LIST which maximizes TEST
     */
    @LispMethod(comment = "Return the first item in LIST which maximizes TEST")
    public static final SubLObject extremal_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(list, LISTP);
        if (NIL == list) {
            return NIL;
        } else {
            {
                SubLObject best = list.first();
                SubLObject rest = list.rest();
                if ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) {
                    {
                        SubLObject cdolist_list_var = rest;
                        SubLObject item = NIL;
                        for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                            if (NIL != funcall(test, item, best)) {
                                best = item;
                            }
                        }
                    }
                } else {
                    {
                        SubLObject cdolist_list_var = rest;
                        SubLObject item = NIL;
                        for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                            if (NIL != funcall(test, funcall(key, item), funcall(key, best))) {
                                best = item;
                            }
                        }
                    }
                }
                return best;
            }
        }
    }

    @LispMethod(comment = "Return the first item in LIST which maximizes TEST")
    public static SubLObject extremal(final SubLObject list, final SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (NIL == list) {
            return NIL;
        }
        SubLObject best = list.first();
        final SubLObject rest = list.rest();
        if (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) {
            SubLObject cdolist_list_var = rest;
            SubLObject item = NIL;
            item = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != funcall(test, item, best)) {
                    best = item;
                }
                cdolist_list_var = cdolist_list_var.rest();
                item = cdolist_list_var.first();
            } 
        } else {
            SubLObject cdolist_list_var = rest;
            SubLObject item = NIL;
            item = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != funcall(test, funcall(key, item), funcall(key, best))) {
                    best = item;
                }
                cdolist_list_var = cdolist_list_var.rest();
                item = cdolist_list_var.first();
            } 
        }
        return best;
    }/**
     * Return the first item in LIST which maximizes TEST
     */


    /**
     * Return the items in LIST which maximize TEST
     */
    @LispMethod(comment = "Return the items in LIST which maximize TEST")
    public static final SubLObject extremals_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(list, LISTP);
        if (NIL == list) {
            return NIL;
        } else {
            {
                SubLObject bests = list(list.first());
                SubLObject rest = list.rest();
                if ((key == symbol_function(IDENTITY)) || (key == IDENTITY)) {
                    {
                        SubLObject cdolist_list_var = rest;
                        SubLObject item = NIL;
                        for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                            if (NIL != funcall(test, item, bests.first())) {
                                bests = list(item);
                            } else {
                                if (NIL == funcall(test, bests.first(), item)) {
                                    bests = cons(item, bests);
                                }
                            }
                        }
                    }
                } else {
                    {
                        SubLObject cdolist_list_var = rest;
                        SubLObject item = NIL;
                        for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                            if (NIL != funcall(test, funcall(key, item), funcall(key, bests.first()))) {
                                bests = list(item);
                            } else {
                                if (NIL == funcall(test, funcall(key, bests.first()), funcall(key, item))) {
                                    bests = cons(item, bests);
                                }
                            }
                        }
                    }
                }
                return bests;
            }
        }
    }

    @LispMethod(comment = "Return the items in LIST which maximize TEST")
    public static SubLObject extremals(final SubLObject list, final SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (NIL == list) {
            return NIL;
        }
        SubLObject bests = list(list.first());
        final SubLObject rest = list.rest();
        if (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY)) {
            SubLObject cdolist_list_var = rest;
            SubLObject item = NIL;
            item = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != funcall(test, item, bests.first())) {
                    bests = list(item);
                } else
                    if (NIL == funcall(test, bests.first(), item)) {
                        bests = cons(item, bests);
                    }

                cdolist_list_var = cdolist_list_var.rest();
                item = cdolist_list_var.first();
            } 
        } else {
            SubLObject cdolist_list_var = rest;
            SubLObject item = NIL;
            item = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != funcall(test, funcall(key, item), funcall(key, bests.first()))) {
                    bests = list(item);
                } else
                    if (NIL == funcall(test, funcall(key, bests.first()), funcall(key, item))) {
                        bests = cons(item, bests);
                    }

                cdolist_list_var = cdolist_list_var.rest();
                item = cdolist_list_var.first();
            } 
        }
        return bests;
    }/**
     * Return the items in LIST which maximize TEST
     */


    /**
     * Given a LIST of sorted items, return a list of items which are tied for RANK ranking in the list.
     * TEST is used to determine ties.  KEY provides access to the item to compare.
     */
    @LispMethod(comment = "Given a LIST of sorted items, return a list of items which are tied for RANK ranking in the list.\r\nTEST is used to determine ties.  KEY provides access to the item to compare.\nGiven a LIST of sorted items, return a list of items which are tied for RANK ranking in the list.\nTEST is used to determine ties.  KEY provides access to the item to compare.")
    public static final SubLObject nth_rank_items_alt(SubLObject rank, SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLTrampolineFile.checkType(rank, INTEGERP);
        SubLTrampolineFile.checkType(rank, PLUSP);
        SubLTrampolineFile.checkType(list, LISTP);
        if (NIL == list) {
            return NIL;
        } else {
            {
                SubLObject current_rank = ONE_INTEGER;
                SubLObject index = ONE_INTEGER;
                SubLObject obj = funcall(key, list.first());
                SubLObject v_answer = NIL;
                SubLObject done = NIL;
                if (current_rank.numE(rank)) {
                    v_answer = cons(list.first(), v_answer);
                }
                if (NIL == done) {
                    {
                        SubLObject csome_list_var = list.rest();
                        SubLObject list_item = NIL;
                        for (list_item = csome_list_var.first(); !((NIL != done) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , list_item = csome_list_var.first()) {
                            index = add(index, ONE_INTEGER);
                            {
                                SubLObject item_obj = funcall(key, list_item);
                                if (NIL == funcall(test, obj, item_obj)) {
                                    current_rank = index;
                                }
                                if (current_rank.numE(rank)) {
                                    v_answer = cons(list_item, v_answer);
                                }
                                obj = item_obj;
                                done = numG(current_rank, rank);
                            }
                        }
                    }
                }
                return nreverse(v_answer);
            }
        }
    }

    @LispMethod(comment = "Given a LIST of sorted items, return a list of items which are tied for RANK ranking in the list.\r\nTEST is used to determine ties.  KEY provides access to the item to compare.\nGiven a LIST of sorted items, return a list of items which are tied for RANK ranking in the list.\nTEST is used to determine ties.  KEY provides access to the item to compare.")
    public static SubLObject nth_rank_items(final SubLObject rank, final SubLObject list, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        assert NIL != integerp(rank) : "! integerp(rank) " + ("Types.integerp(rank) " + "CommonSymbols.NIL != Types.integerp(rank) ") + rank;
        assert NIL != plusp(rank) : "! Numbers.plusp(rank) " + ("Numbers.plusp(rank) " + "CommonSymbols.NIL != Numbers.plusp(rank) ") + rank;
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        if (NIL == list) {
            return NIL;
        }
        SubLObject current_rank = ONE_INTEGER;
        SubLObject index = ONE_INTEGER;
        SubLObject obj = funcall(key, list.first());
        SubLObject v_answer = NIL;
        SubLObject done = NIL;
        if (current_rank.numE(rank)) {
            v_answer = cons(list.first(), v_answer);
        }
        if (NIL == done) {
            SubLObject csome_list_var = list.rest();
            SubLObject list_item = NIL;
            list_item = csome_list_var.first();
            while ((NIL == done) && (NIL != csome_list_var)) {
                index = add(index, ONE_INTEGER);
                final SubLObject item_obj = funcall(key, list_item);
                if (NIL == funcall(test, obj, item_obj)) {
                    current_rank = index;
                }
                if (current_rank.numE(rank)) {
                    v_answer = cons(list_item, v_answer);
                }
                obj = item_obj;
                done = numG(current_rank, rank);
                csome_list_var = csome_list_var.rest();
                list_item = csome_list_var.first();
            } 
        }
        return nreverse(v_answer);
    }/**
     * Given a LIST of sorted items, return a list of items which are tied for RANK ranking in the list.
     * TEST is used to determine ties.  KEY provides access to the item to compare.
     */


    /**
     * Given two lists representing two ways of ranking the same items, rerank the list such that
     * BASE-WEIGHT of importance is given to the first and ALTERNATE-WEIGHT to the second.
     * The algorithm proceeds by multiplying the position of each item in each list by the list's
     * weight, and then summing these weights. Finally the list is resorted based on the combined
     * weights in ascending order. Item identity is established via TEST.
     * Note that ALTERNATE-RANKING is treated as if it were a strict subset of ORDERED-ITEMS;
     * any value in ALTERNATE-RANKING that is not found in ORDERED-ITEMS will be ignored.
     *
     * @return a newly ranked list of items from ORDERED-ITEMS
     */
    @LispMethod(comment = "Given two lists representing two ways of ranking the same items, rerank the list such that\r\nBASE-WEIGHT of importance is given to the first and ALTERNATE-WEIGHT to the second.\r\nThe algorithm proceeds by multiplying the position of each item in each list by the list\'s\r\nweight, and then summing these weights. Finally the list is resorted based on the combined\r\nweights in ascending order. Item identity is established via TEST.\r\nNote that ALTERNATE-RANKING is treated as if it were a strict subset of ORDERED-ITEMS;\r\nany value in ALTERNATE-RANKING that is not found in ORDERED-ITEMS will be ignored.\r\n\r\n@return a newly ranked list of items from ORDERED-ITEMS\nGiven two lists representing two ways of ranking the same items, rerank the list such that\nBASE-WEIGHT of importance is given to the first and ALTERNATE-WEIGHT to the second.\nThe algorithm proceeds by multiplying the position of each item in each list by the list\'s\nweight, and then summing these weights. Finally the list is resorted based on the combined\nweights in ascending order. Item identity is established via TEST.\nNote that ALTERNATE-RANKING is treated as if it were a strict subset of ORDERED-ITEMS;\nany value in ALTERNATE-RANKING that is not found in ORDERED-ITEMS will be ignored.")
    public static final SubLObject rerank_alt(SubLObject ordered_items, SubLObject alternate_ranking, SubLObject test, SubLObject base_weight, SubLObject alternate_weight) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (base_weight == UNPROVIDED) {
            base_weight = $float$0_5;
        }
        if (alternate_weight == UNPROVIDED) {
            alternate_weight = $float$0_5;
        }
        {
            SubLObject num_of_items = length(ordered_items);
            SubLObject rank_values = dictionary.new_dictionary(test, num_of_items);
            {
                SubLObject list_var = NIL;
                SubLObject item = NIL;
                SubLObject index = NIL;
                for (list_var = ordered_items, item = list_var.first(), index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , item = list_var.first() , index = add(ONE_INTEGER, index)) {
                    dictionary.dictionary_enter(rank_values, item, multiply(index, base_weight));
                }
            }
            {
                SubLObject list_var = NIL;
                SubLObject item = NIL;
                SubLObject index = NIL;
                for (list_var = alternate_ranking, item = list_var.first(), index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , item = list_var.first() , index = add(ONE_INTEGER, index)) {
                    {
                        SubLObject base_weight_29 = dictionary.dictionary_lookup(rank_values, item, UNPROVIDED);
                        if (base_weight_29.isNumber()) {
                            {
                                SubLObject adjusted = add(base_weight_29, multiply(index, alternate_weight));
                                dictionary.dictionary_enter(rank_values, item, adjusted);
                            }
                        }
                    }
                }
            }
            return dictionary_utilities.dictionary_keys_sorted_by_values(rank_values, symbol_function($sym97$_), UNPROVIDED);
        }
    }

    @LispMethod(comment = "Given two lists representing two ways of ranking the same items, rerank the list such that\r\nBASE-WEIGHT of importance is given to the first and ALTERNATE-WEIGHT to the second.\r\nThe algorithm proceeds by multiplying the position of each item in each list by the list\'s\r\nweight, and then summing these weights. Finally the list is resorted based on the combined\r\nweights in ascending order. Item identity is established via TEST.\r\nNote that ALTERNATE-RANKING is treated as if it were a strict subset of ORDERED-ITEMS;\r\nany value in ALTERNATE-RANKING that is not found in ORDERED-ITEMS will be ignored.\r\n\r\n@return a newly ranked list of items from ORDERED-ITEMS\nGiven two lists representing two ways of ranking the same items, rerank the list such that\nBASE-WEIGHT of importance is given to the first and ALTERNATE-WEIGHT to the second.\nThe algorithm proceeds by multiplying the position of each item in each list by the list\'s\nweight, and then summing these weights. Finally the list is resorted based on the combined\nweights in ascending order. Item identity is established via TEST.\nNote that ALTERNATE-RANKING is treated as if it were a strict subset of ORDERED-ITEMS;\nany value in ALTERNATE-RANKING that is not found in ORDERED-ITEMS will be ignored.")
    public static SubLObject rerank(final SubLObject ordered_items, final SubLObject alternate_ranking, SubLObject test, SubLObject base_weight, SubLObject alternate_weight) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (base_weight == UNPROVIDED) {
            base_weight = $float$0_5;
        }
        if (alternate_weight == UNPROVIDED) {
            alternate_weight = $float$0_5;
        }
        final SubLObject num_of_items = length(ordered_items);
        final SubLObject rank_values = dictionary.new_dictionary(test, num_of_items);
        SubLObject list_var = NIL;
        SubLObject item = NIL;
        SubLObject index = NIL;
        list_var = ordered_items;
        item = list_var.first();
        for (index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , item = list_var.first() , index = add(ONE_INTEGER, index)) {
            dictionary.dictionary_enter(rank_values, item, multiply(index, base_weight));
        }
        list_var = NIL;
        item = NIL;
        index = NIL;
        list_var = alternate_ranking;
        item = list_var.first();
        for (index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , item = list_var.first() , index = add(ONE_INTEGER, index)) {
            final SubLObject base_weight_$31 = dictionary.dictionary_lookup(rank_values, item, UNPROVIDED);
            if (base_weight_$31.isNumber()) {
                final SubLObject adjusted = add(base_weight_$31, multiply(index, alternate_weight));
                dictionary.dictionary_enter(rank_values, item, adjusted);
            }
        }
        return dictionary_utilities.dictionary_keys_sorted_by_values(rank_values, symbol_function($sym97$_), UNPROVIDED);
    }/**
     * Given two lists representing two ways of ranking the same items, rerank the list such that
     * BASE-WEIGHT of importance is given to the first and ALTERNATE-WEIGHT to the second.
     * The algorithm proceeds by multiplying the position of each item in each list by the list's
     * weight, and then summing these weights. Finally the list is resorted based on the combined
     * weights in ascending order. Item identity is established via TEST.
     * Note that ALTERNATE-RANKING is treated as if it were a strict subset of ORDERED-ITEMS;
     * any value in ALTERNATE-RANKING that is not found in ORDERED-ITEMS will be ignored.
     *
     * @return a newly ranked list of items from ORDERED-ITEMS
     */


    /**
     * Return the set of all subsets of SET.  O(2^N)
     */
    @LispMethod(comment = "Return the set of all subsets of SET.  O(2^N)")
    public static final SubLObject powerset_alt(SubLObject v_set) {
        if (NIL == v_set) {
            return list(v_set);
        } else {
            {
                SubLObject item = v_set.first();
                SubLObject rest_powerset = com.cyc.cycjava.cycl.list_utilities.powerset(v_set.rest());
                SubLObject copy_powerset = copy_list(rest_powerset);
                SubLObject rest = NIL;
                SubLObject copy_item = NIL;
                for (rest = copy_powerset, copy_item = rest.first(); NIL != rest; rest = rest.rest() , copy_item = rest.first()) {
                    rplaca(rest, cons(item, copy_item));
                }
                return nconc(rest_powerset, copy_powerset);
            }
        }
    }

    @LispMethod(comment = "Return the set of all subsets of SET.  O(2^N)")
    public static SubLObject powerset(final SubLObject v_set) {
        if (NIL == v_set) {
            return list(v_set);
        }
        final SubLObject item = v_set.first();
        final SubLObject rest_powerset = powerset(v_set.rest());
        final SubLObject copy_powerset = copy_list(rest_powerset);
        SubLObject rest = NIL;
        SubLObject copy_item = NIL;
        rest = copy_powerset;
        copy_item = rest.first();
        while (NIL != rest) {
            rplaca(rest, cons(item, copy_item));
            rest = rest.rest();
            copy_item = rest.first();
        } 
        return nconc(rest_powerset, copy_powerset);
    }/**
     * Return the set of all subsets of SET.  O(2^N)
     */


    /**
     * Return the subsets of SET of size SIZE.
     *
     * @unknown kknight
     */
    @LispMethod(comment = "Return the subsets of SET of size SIZE.\r\n\r\n@unknown kknight")
    public static final SubLObject subsets_of_size_alt(SubLObject v_set, SubLObject size) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.lengthE(v_set, size, UNPROVIDED)) {
            return list(v_set);
        } else {
            if (NIL != com.cyc.cycjava.cycl.list_utilities.lengthG(v_set, size, UNPROVIDED)) {
                return com.cyc.cycjava.cycl.list_utilities.subsets_of_size_int(v_set, size);
            } else {
                return NIL;
            }
        }
    }

    @LispMethod(comment = "Return the subsets of SET of size SIZE.\r\n\r\n@unknown kknight")
    public static SubLObject subsets_of_size(final SubLObject v_set, final SubLObject size) {
        if (NIL != lengthE(v_set, size, UNPROVIDED)) {
            return list(v_set);
        }
        if (NIL != lengthG(v_set, size, UNPROVIDED)) {
            return subsets_of_size_int(v_set, size);
        }
        return NIL;
    }/**
     * Return the subsets of SET of size SIZE.
     *
     * @unknown kknight
     */


    public static final SubLObject subsets_of_size_int_alt(SubLObject v_set, SubLObject size) {
        if (size.numE(ZERO_INTEGER)) {
            return $list_alt72;
        } else {
            if (size.numGE(ONE_INTEGER)) {
                if (NIL == v_set) {
                    return NIL;
                } else {
                    {
                        SubLObject to_be_consed = com.cyc.cycjava.cycl.list_utilities.subsets_of_size_int(v_set.rest(), subtract(size, ONE_INTEGER));
                        SubLObject subsets = NIL;
                        SubLObject cdolist_list_var = to_be_consed;
                        SubLObject to_be = NIL;
                        for (to_be = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , to_be = cdolist_list_var.first()) {
                            subsets = cons(cons(v_set.first(), to_be), subsets);
                        }
                        return append(subsets, com.cyc.cycjava.cycl.list_utilities.subsets_of_size_int(v_set.rest(), size));
                    }
                }
            } else {
                return NIL;
            }
        }
    }

    public static SubLObject subsets_of_size_int(final SubLObject v_set, final SubLObject size) {
        if (size.numE(ZERO_INTEGER)) {
            return $list72;
        }
        if (!size.numGE(ONE_INTEGER)) {
            return NIL;
        }
        if (NIL == v_set) {
            return NIL;
        }
        final SubLObject to_be_consed = subsets_of_size_int(v_set.rest(), subtract(size, ONE_INTEGER));
        SubLObject subsets = NIL;
        SubLObject cdolist_list_var = to_be_consed;
        SubLObject to_be = NIL;
        to_be = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            subsets = cons(cons(v_set.first(), to_be), subsets);
            cdolist_list_var = cdolist_list_var.rest();
            to_be = cdolist_list_var.first();
        } 
        return append(subsets, subsets_of_size_int(v_set.rest(), size));
    }

    /**
     * Return T iff the position of ITEM1 in GUIDE-SEQ is less than that of ITEM2.
     * All objects not in the GUIDE-SEQ are considered to be after all those that are,
     * and are themselves considered equivalent by this test.
     */
    @LispMethod(comment = "Return T iff the position of ITEM1 in GUIDE-SEQ is less than that of ITEM2.\r\nAll objects not in the GUIDE-SEQ are considered to be after all those that are,\r\nand are themselves considered equivalent by this test.\nReturn T iff the position of ITEM1 in GUIDE-SEQ is less than that of ITEM2.\nAll objects not in the GUIDE-SEQ are considered to be after all those that are,\nand are themselves considered equivalent by this test.")
    public static final SubLObject position_L_alt(SubLObject item1, SubLObject item2, SubLObject guide_seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject position1 = position(item1, guide_seq, test, key, UNPROVIDED, UNPROVIDED);
            SubLObject position2 = position(item2, guide_seq, test, key, UNPROVIDED, UNPROVIDED);
            if (position1.isInteger()) {
                if (position2.isInteger()) {
                    return numL(position1, position2);
                } else {
                    return T;
                }
            } else {
                return NIL;
            }
        }
    }

    @LispMethod(comment = "Return T iff the position of ITEM1 in GUIDE-SEQ is less than that of ITEM2.\r\nAll objects not in the GUIDE-SEQ are considered to be after all those that are,\r\nand are themselves considered equivalent by this test.\nReturn T iff the position of ITEM1 in GUIDE-SEQ is less than that of ITEM2.\nAll objects not in the GUIDE-SEQ are considered to be after all those that are,\nand are themselves considered equivalent by this test.")
    public static SubLObject position_L(final SubLObject item1, final SubLObject item2, final SubLObject guide_seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLObject position1 = position(item1, guide_seq, test, key, UNPROVIDED, UNPROVIDED);
        final SubLObject position2 = position(item2, guide_seq, test, key, UNPROVIDED, UNPROVIDED);
        if (!position1.isInteger()) {
            return NIL;
        }
        if (position2.isInteger()) {
            return numL(position1, position2);
        }
        return T;
    }/**
     * Return T iff the position of ITEM1 in GUIDE-SEQ is less than that of ITEM2.
     * All objects not in the GUIDE-SEQ are considered to be after all those that are,
     * and are themselves considered equivalent by this test.
     */


    /**
     * Sort SEQ using GUIDE-SEQ as a positional guide.
     * Objects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.
     * Objects not in GUIDE-SEQ all appear after those that do.
     */
    @LispMethod(comment = "Sort SEQ using GUIDE-SEQ as a positional guide.\r\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\r\nObjects not in GUIDE-SEQ all appear after those that do.\nSort SEQ using GUIDE-SEQ as a positional guide.\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\nObjects not in GUIDE-SEQ all appear after those that do.")
    public static final SubLObject sort_via_position_alt(SubLObject seq, SubLObject guide_seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(seq, SEQUENCEP);
            SubLTrampolineFile.checkType(guide_seq, SEQUENCEP);
            {
                SubLObject v_answer = NIL;
                {
                    SubLObject _prev_bind_0 = $sort_via_position_guide$.currentBinding(thread);
                    SubLObject _prev_bind_1 = $sort_via_position_test$.currentBinding(thread);
                    try {
                        $sort_via_position_guide$.bind(guide_seq, thread);
                        $sort_via_position_test$.bind(test, thread);
                        v_answer = Sort.sort(seq, SORT_VIA_POSITION_EARLIER, key);
                    } finally {
                        $sort_via_position_test$.rebind(_prev_bind_1, thread);
                        $sort_via_position_guide$.rebind(_prev_bind_0, thread);
                    }
                }
                return v_answer;
            }
        }
    }

    @LispMethod(comment = "Sort SEQ using GUIDE-SEQ as a positional guide.\r\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\r\nObjects not in GUIDE-SEQ all appear after those that do.\nSort SEQ using GUIDE-SEQ as a positional guide.\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\nObjects not in GUIDE-SEQ all appear after those that do.")
    public static SubLObject sort_via_position(final SubLObject seq, final SubLObject guide_seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != sequencep(seq) : "! sequencep(seq) " + ("Types.sequencep(seq) " + "CommonSymbols.NIL != Types.sequencep(seq) ") + seq;
        assert NIL != sequencep(guide_seq) : "! sequencep(guide_seq) " + ("Types.sequencep(guide_seq) " + "CommonSymbols.NIL != Types.sequencep(guide_seq) ") + guide_seq;
        SubLObject v_answer = NIL;
        final SubLObject _prev_bind_0 = $sort_via_position_guide$.currentBinding(thread);
        final SubLObject _prev_bind_2 = $sort_via_position_test$.currentBinding(thread);
        try {
            $sort_via_position_guide$.bind(guide_seq, thread);
            $sort_via_position_test$.bind(test, thread);
            v_answer = Sort.sort(seq, SORT_VIA_POSITION_EARLIER, key);
        } finally {
            $sort_via_position_test$.rebind(_prev_bind_2, thread);
            $sort_via_position_guide$.rebind(_prev_bind_0, thread);
        }
        return v_answer;
    }/**
     * Sort SEQ using GUIDE-SEQ as a positional guide.
     * Objects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.
     * Objects not in GUIDE-SEQ all appear after those that do.
     */


    /**
     * Stably sort SEQ using GUIDE-SEQ as a positional guide.
     * Objects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.
     * Objects not in GUIDE-SEQ all appear after those that do.
     */
    @LispMethod(comment = "Stably sort SEQ using GUIDE-SEQ as a positional guide.\r\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\r\nObjects not in GUIDE-SEQ all appear after those that do.\nStably sort SEQ using GUIDE-SEQ as a positional guide.\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\nObjects not in GUIDE-SEQ all appear after those that do.")
    public static final SubLObject stable_sort_via_position_alt(SubLObject seq, SubLObject guide_seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(seq, SEQUENCEP);
            SubLTrampolineFile.checkType(guide_seq, SEQUENCEP);
            {
                SubLObject v_answer = NIL;
                {
                    SubLObject _prev_bind_0 = $sort_via_position_guide$.currentBinding(thread);
                    SubLObject _prev_bind_1 = $sort_via_position_test$.currentBinding(thread);
                    try {
                        $sort_via_position_guide$.bind(guide_seq, thread);
                        $sort_via_position_test$.bind(test, thread);
                        v_answer = Sort.stable_sort(seq, SORT_VIA_POSITION_EARLIER, key);
                    } finally {
                        $sort_via_position_test$.rebind(_prev_bind_1, thread);
                        $sort_via_position_guide$.rebind(_prev_bind_0, thread);
                    }
                }
                return v_answer;
            }
        }
    }

    @LispMethod(comment = "Stably sort SEQ using GUIDE-SEQ as a positional guide.\r\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\r\nObjects not in GUIDE-SEQ all appear after those that do.\nStably sort SEQ using GUIDE-SEQ as a positional guide.\nObjects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.\nObjects not in GUIDE-SEQ all appear after those that do.")
    public static SubLObject stable_sort_via_position(final SubLObject seq, final SubLObject guide_seq, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != sequencep(seq) : "! sequencep(seq) " + ("Types.sequencep(seq) " + "CommonSymbols.NIL != Types.sequencep(seq) ") + seq;
        assert NIL != sequencep(guide_seq) : "! sequencep(guide_seq) " + ("Types.sequencep(guide_seq) " + "CommonSymbols.NIL != Types.sequencep(guide_seq) ") + guide_seq;
        SubLObject v_answer = NIL;
        final SubLObject _prev_bind_0 = $sort_via_position_guide$.currentBinding(thread);
        final SubLObject _prev_bind_2 = $sort_via_position_test$.currentBinding(thread);
        try {
            $sort_via_position_guide$.bind(guide_seq, thread);
            $sort_via_position_test$.bind(test, thread);
            v_answer = Sort.stable_sort(seq, SORT_VIA_POSITION_EARLIER, key);
        } finally {
            $sort_via_position_test$.rebind(_prev_bind_2, thread);
            $sort_via_position_guide$.rebind(_prev_bind_0, thread);
        }
        return v_answer;
    }/**
     * Stably sort SEQ using GUIDE-SEQ as a positional guide.
     * Objects in GUIDE-SEQ appear in the order they are in GUIDE-SEQ.
     * Objects not in GUIDE-SEQ all appear after those that do.
     */


    public static final SubLObject sort_via_position_earlier_alt(SubLObject item1, SubLObject item2) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            return com.cyc.cycjava.cycl.list_utilities.position_L(item1, item2, $sort_via_position_guide$.getDynamicValue(thread), $sort_via_position_test$.getDynamicValue(thread), UNPROVIDED);
        }
    }

    public static SubLObject sort_via_position_earlier(final SubLObject item1, final SubLObject item2) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        return position_L(item1, item2, $sort_via_position_guide$.getDynamicValue(thread), $sort_via_position_test$.getDynamicValue(thread), UNPROVIDED);
    }

    /**
     * Sort SEQ using a boolean TEST to determine the position.
     * Objects satisfying TEST will appear before objects which do not.
     */
    @LispMethod(comment = "Sort SEQ using a boolean TEST to determine the position.\r\nObjects satisfying TEST will appear before objects which do not.\nSort SEQ using a boolean TEST to determine the position.\nObjects satisfying TEST will appear before objects which do not.")
    public static final SubLObject sort_via_test_alt(SubLObject seq, SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_answer = NIL;
                {
                    SubLObject _prev_bind_0 = $sort_via_test_function$.currentBinding(thread);
                    try {
                        $sort_via_test_function$.bind(test, thread);
                        v_answer = Sort.sort(seq, SORT_VIA_TEST_EARLIER, key);
                    } finally {
                        $sort_via_test_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return v_answer;
            }
        }
    }

    @LispMethod(comment = "Sort SEQ using a boolean TEST to determine the position.\r\nObjects satisfying TEST will appear before objects which do not.\nSort SEQ using a boolean TEST to determine the position.\nObjects satisfying TEST will appear before objects which do not.")
    public static SubLObject sort_via_test(final SubLObject seq, final SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject v_answer = NIL;
        final SubLObject _prev_bind_0 = $sort_via_test_function$.currentBinding(thread);
        try {
            $sort_via_test_function$.bind(test, thread);
            v_answer = Sort.sort(seq, SORT_VIA_TEST_EARLIER, key);
        } finally {
            $sort_via_test_function$.rebind(_prev_bind_0, thread);
        }
        return v_answer;
    }/**
     * Sort SEQ using a boolean TEST to determine the position.
     * Objects satisfying TEST will appear before objects which do not.
     */


    /**
     * Stably sort SEQ using boolean TEST to determine the position.
     * Objects satisfying TEST will appear before objects which do not.
     */
    @LispMethod(comment = "Stably sort SEQ using boolean TEST to determine the position.\r\nObjects satisfying TEST will appear before objects which do not.\nStably sort SEQ using boolean TEST to determine the position.\nObjects satisfying TEST will appear before objects which do not.")
    public static final SubLObject stable_sort_via_test_alt(SubLObject seq, SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_answer = NIL;
                {
                    SubLObject _prev_bind_0 = $sort_via_test_function$.currentBinding(thread);
                    try {
                        $sort_via_test_function$.bind(test, thread);
                        v_answer = Sort.stable_sort(seq, SORT_VIA_TEST_EARLIER, key);
                    } finally {
                        $sort_via_test_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return v_answer;
            }
        }
    }

    @LispMethod(comment = "Stably sort SEQ using boolean TEST to determine the position.\r\nObjects satisfying TEST will appear before objects which do not.\nStably sort SEQ using boolean TEST to determine the position.\nObjects satisfying TEST will appear before objects which do not.")
    public static SubLObject stable_sort_via_test(final SubLObject seq, final SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject v_answer = NIL;
        final SubLObject _prev_bind_0 = $sort_via_test_function$.currentBinding(thread);
        try {
            $sort_via_test_function$.bind(test, thread);
            v_answer = Sort.stable_sort(seq, SORT_VIA_TEST_EARLIER, key);
        } finally {
            $sort_via_test_function$.rebind(_prev_bind_0, thread);
        }
        return v_answer;
    }/**
     * Stably sort SEQ using boolean TEST to determine the position.
     * Objects satisfying TEST will appear before objects which do not.
     */


    public static final SubLObject sort_via_test_earlier_alt(SubLObject obj1, SubLObject obj2) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            return makeBoolean((NIL != funcall($sort_via_test_function$.getDynamicValue(thread), obj1)) && (NIL == funcall($sort_via_test_function$.getDynamicValue(thread), obj2)));
        }
    }

    public static SubLObject sort_via_test_earlier(final SubLObject obj1, final SubLObject obj2) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        return makeBoolean((NIL != funcall($sort_via_test_function$.getDynamicValue(thread), obj1)) && (NIL == funcall($sort_via_test_function$.getDynamicValue(thread), obj2)));
    }

    public static final SubLObject sort_L_alt(SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym97$_), key);
    }

    public static SubLObject sort_L(final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym97$_), key);
    }

    public static final SubLObject sort_G_alt(SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym171$_), key);
    }

    public static SubLObject sort_G(final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym179$_), key);
    }

    public static final SubLObject safe_sort_L_alt(SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym134$SAFE__), key);
    }

    public static SubLObject safe_sort_L(final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym136$SAFE__), key);
    }

    public static final SubLObject safe_sort_G_alt(SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym172$SAFE__), key);
    }

    public static SubLObject safe_sort_G(final SubLObject list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return Sort.sort(list, symbol_function($sym180$SAFE__), key);
    }

    public static final SubLObject sets_of_sets_L_alt(SubLObject sets_of_sets1, SubLObject sets_of_sets2, SubLObject elem_lt_test) {
        if (elem_lt_test == UNPROVIDED) {
            elem_lt_test = $sym173$SAFE_TREE__;
        }
        {
            SubLObject sorted_sets_of_sets1 = NIL;
            SubLObject sorted_sets_of_sets2 = NIL;
            {
                SubLObject cdolist_list_var = sets_of_sets1;
                SubLObject sets1 = NIL;
                for (sets1 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , sets1 = cdolist_list_var.first()) {
                    {
                        SubLObject sorted_sets1 = NIL;
                        SubLObject cdolist_list_var_30 = sets1;
                        SubLObject set1 = NIL;
                        for (set1 = cdolist_list_var_30.first(); NIL != cdolist_list_var_30; cdolist_list_var_30 = cdolist_list_var_30.rest() , set1 = cdolist_list_var_30.first()) {
                            sorted_sets1 = cons(Sort.sort(set1, elem_lt_test, UNPROVIDED), sorted_sets1);
                        }
                        sorted_sets_of_sets1 = cons(Sort.sort(sorted_sets1, $sym174$SET__, UNPROVIDED), sorted_sets_of_sets1);
                    }
                }
            }
            {
                SubLObject cdolist_list_var = sets_of_sets2;
                SubLObject sets2 = NIL;
                for (sets2 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , sets2 = cdolist_list_var.first()) {
                    {
                        SubLObject sorted_sets2 = NIL;
                        SubLObject cdolist_list_var_31 = sets2;
                        SubLObject set2 = NIL;
                        for (set2 = cdolist_list_var_31.first(); NIL != cdolist_list_var_31; cdolist_list_var_31 = cdolist_list_var_31.rest() , set2 = cdolist_list_var_31.first()) {
                            sorted_sets2 = cons(Sort.sort(set2, elem_lt_test, UNPROVIDED), sorted_sets2);
                        }
                        sorted_sets_of_sets2 = cons(Sort.sort(sorted_sets2, $sym174$SET__, UNPROVIDED), sorted_sets_of_sets2);
                    }
                }
            }
            return com.cyc.cycjava.cycl.list_utilities.sets_L(sorted_sets_of_sets1, sorted_sets_of_sets2, elem_lt_test);
        }
    }

    public static SubLObject sets_of_sets_L(final SubLObject sets_of_sets1, final SubLObject sets_of_sets2, SubLObject elem_lt_test) {
        if (elem_lt_test == UNPROVIDED) {
            elem_lt_test = $sym181$SAFE_TREE__;
        }
        SubLObject sorted_sets_of_sets1 = NIL;
        SubLObject sorted_sets_of_sets2 = NIL;
        SubLObject cdolist_list_var = sets_of_sets1;
        SubLObject sets1 = NIL;
        sets1 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject sorted_sets1 = NIL;
            SubLObject cdolist_list_var_$32 = sets1;
            SubLObject set1 = NIL;
            set1 = cdolist_list_var_$32.first();
            while (NIL != cdolist_list_var_$32) {
                sorted_sets1 = cons(Sort.sort(set1, elem_lt_test, UNPROVIDED), sorted_sets1);
                cdolist_list_var_$32 = cdolist_list_var_$32.rest();
                set1 = cdolist_list_var_$32.first();
            } 
            sorted_sets_of_sets1 = cons(Sort.sort(sorted_sets1, $sym182$SET__, UNPROVIDED), sorted_sets_of_sets1);
            cdolist_list_var = cdolist_list_var.rest();
            sets1 = cdolist_list_var.first();
        } 
        cdolist_list_var = sets_of_sets2;
        SubLObject sets2 = NIL;
        sets2 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject sorted_sets2 = NIL;
            SubLObject cdolist_list_var_$33 = sets2;
            SubLObject set2 = NIL;
            set2 = cdolist_list_var_$33.first();
            while (NIL != cdolist_list_var_$33) {
                sorted_sets2 = cons(Sort.sort(set2, elem_lt_test, UNPROVIDED), sorted_sets2);
                cdolist_list_var_$33 = cdolist_list_var_$33.rest();
                set2 = cdolist_list_var_$33.first();
            } 
            sorted_sets_of_sets2 = cons(Sort.sort(sorted_sets2, $sym182$SET__, UNPROVIDED), sorted_sets_of_sets2);
            cdolist_list_var = cdolist_list_var.rest();
            sets2 = cdolist_list_var.first();
        } 
        return sets_L(sorted_sets_of_sets1, sorted_sets_of_sets2, elem_lt_test);
    }

    public static final SubLObject sets_L_alt(SubLObject sets1, SubLObject sets2, SubLObject elem_lt_test) {
        if (elem_lt_test == UNPROVIDED) {
            elem_lt_test = $sym173$SAFE_TREE__;
        }
        {
            SubLObject sorted_sets1 = NIL;
            SubLObject sorted_sets2 = NIL;
            {
                SubLObject cdolist_list_var = sets1;
                SubLObject set1 = NIL;
                for (set1 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , set1 = cdolist_list_var.first()) {
                    sorted_sets1 = cons(Sort.sort(set1, elem_lt_test, UNPROVIDED), sorted_sets1);
                }
            }
            {
                SubLObject cdolist_list_var = sets2;
                SubLObject set2 = NIL;
                for (set2 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , set2 = cdolist_list_var.first()) {
                    sorted_sets2 = cons(Sort.sort(set2, elem_lt_test, UNPROVIDED), sorted_sets2);
                }
            }
            return com.cyc.cycjava.cycl.list_utilities.set_L(sorted_sets1, sorted_sets2, elem_lt_test);
        }
    }

    public static SubLObject sets_L(final SubLObject sets1, final SubLObject sets2, SubLObject elem_lt_test) {
        if (elem_lt_test == UNPROVIDED) {
            elem_lt_test = $sym181$SAFE_TREE__;
        }
        SubLObject sorted_sets1 = NIL;
        SubLObject sorted_sets2 = NIL;
        SubLObject cdolist_list_var = sets1;
        SubLObject set1 = NIL;
        set1 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            sorted_sets1 = cons(Sort.sort(set1, elem_lt_test, UNPROVIDED), sorted_sets1);
            cdolist_list_var = cdolist_list_var.rest();
            set1 = cdolist_list_var.first();
        } 
        cdolist_list_var = sets2;
        SubLObject set2 = NIL;
        set2 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            sorted_sets2 = cons(Sort.sort(set2, elem_lt_test, UNPROVIDED), sorted_sets2);
            cdolist_list_var = cdolist_list_var.rest();
            set2 = cdolist_list_var.first();
        } 
        return set_L(sorted_sets1, sorted_sets2, elem_lt_test);
    }

    public static final SubLObject set_L_alt(SubLObject set1, SubLObject set2, SubLObject elem_lt_test) {
        if (elem_lt_test == UNPROVIDED) {
            elem_lt_test = $sym173$SAFE_TREE__;
        }
        return funcall(elem_lt_test, Sort.sort(set1, elem_lt_test, UNPROVIDED), Sort.sort(set2, elem_lt_test, UNPROVIDED));
    }

    public static SubLObject set_L(final SubLObject set1, final SubLObject set2, SubLObject elem_lt_test) {
        if (elem_lt_test == UNPROVIDED) {
            elem_lt_test = $sym181$SAFE_TREE__;
        }
        return funcall(elem_lt_test, Sort.sort(set1, elem_lt_test, UNPROVIDED), Sort.sort(set2, elem_lt_test, UNPROVIDED));
    }

    /**
     *
     *
     * @return list; the list structure of LIST.
    All non-cons things are replaced by FILLER.
     */
    @LispMethod(comment = "@return list; the list structure of LIST.\r\nAll non-cons things are replaced by FILLER.")
    public static final SubLObject list_structure_alt(SubLObject list, SubLObject filler) {
        if (filler == UNPROVIDED) {
            filler = NIL;
        }
        {
            SubLObject list_structure = copy_tree(list);
            SubLObject stuff = com.cyc.cycjava.cycl.list_utilities.tree_gather(list, NOT_CONSP, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            SubLObject cdolist_list_var = stuff;
            SubLObject thingy = NIL;
            for (thingy = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , thingy = cdolist_list_var.first()) {
                list_structure = subst(filler, thingy, list_structure, UNPROVIDED, UNPROVIDED);
            }
            return list_structure;
        }
    }

    /**
     *
     *
     * @return list; the list structure of LIST.
    All non-cons things are replaced by FILLER.
     */
    @LispMethod(comment = "@return list; the list structure of LIST.\r\nAll non-cons things are replaced by FILLER.")
    public static SubLObject list_structure(final SubLObject list, SubLObject filler) {
        if (filler == UNPROVIDED) {
            filler = NIL;
        }
        SubLObject list_structure = copy_tree(list);
        SubLObject cdolist_list_var;
        final SubLObject stuff = cdolist_list_var = tree_gather(list, NOT_CONSP, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        SubLObject thingy = NIL;
        thingy = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            list_structure = subst(filler, thingy, list_structure, UNPROVIDED, UNPROVIDED);
            cdolist_list_var = cdolist_list_var.rest();
            thingy = cdolist_list_var.first();
        } 
        return list_structure;
    }

    /**
     * finds the minimum of a bunch of list structures (lists with all the same terminals in them)
     */
    @LispMethod(comment = "finds the minimum of a bunch of list structures (lists with all the same terminals in them)")
    public static final SubLObject list_structure_min_alt(SubLObject list_structures) {
        return Sort.sort(list_structures, $sym176$LIST_STRUCTURE__, UNPROVIDED).first();
    }

    @LispMethod(comment = "finds the minimum of a bunch of list structures (lists with all the same terminals in them)")
    public static SubLObject list_structure_min(final SubLObject list_structures) {
        return Sort.sort(list_structures, $sym184$LIST_STRUCTURE__, UNPROVIDED).first();
    }/**
     * finds the minimum of a bunch of list structures (lists with all the same terminals in them)
     */


    public static final SubLObject list_structure_L_alt(SubLObject ls1, SubLObject ls2) {
        return com.cyc.cycjava.cycl.list_utilities.tree_L(ls1, ls2, FALSE, symbol_function(EQL));
    }

    public static SubLObject list_structure_L(final SubLObject ls1, final SubLObject ls2) {
        return tree_L(ls1, ls2, FALSE, symbol_function(EQL));
    }

    public static final SubLObject tree_min_alt(SubLObject tree) {
        return Sort.sort(tree, $sym173$SAFE_TREE__, UNPROVIDED).first();
    }

    public static SubLObject tree_min(final SubLObject tree) {
        return Sort.sort(tree, $sym181$SAFE_TREE__, UNPROVIDED).first();
    }

    public static final SubLObject safe_tree_L_alt(SubLObject tree1, SubLObject tree2) {
        return com.cyc.cycjava.cycl.list_utilities.tree_L(tree1, tree2, $sym134$SAFE__, symbol_function(EQL));
    }

    public static SubLObject safe_tree_L(final SubLObject tree1, final SubLObject tree2) {
        return tree_L(tree1, tree2, $sym136$SAFE__, symbol_function(EQL));
    }

    public static final SubLObject safe_L_alt(SubLObject object1, SubLObject object2) {
        return object1.isNumber() ? ((SubLObject) (object2.isNumber() ? ((SubLObject) (numL(object1, object2))) : NIL)) : object2.isNumber() ? ((SubLObject) (T)) : NIL;
    }

    public static SubLObject safe_L(final SubLObject object1, final SubLObject object2) {
        return object1.isNumber() ? object2.isNumber() ? numL(object1, object2) : NIL : object2.isNumber() ? T : NIL;
    }

    public static final SubLObject safe_G_alt(SubLObject object1, SubLObject object2) {
        return makeBoolean(!(object1.eql(object2) || (NIL != com.cyc.cycjava.cycl.list_utilities.safe_L(object1, object2))));
    }

    public static SubLObject safe_G(final SubLObject object1, final SubLObject object2) {
        return makeBoolean((!object1.eql(object2)) && (NIL == safe_L(object1, object2)));
    }

    public static final SubLObject safe_GE_alt(SubLObject object1, SubLObject object2) {
        return makeBoolean(object1.eql(object2) || (NIL == com.cyc.cycjava.cycl.list_utilities.safe_L(object1, object2)));
    }

    public static SubLObject safe_GE(final SubLObject object1, final SubLObject object2) {
        return makeBoolean(object1.eql(object2) || (NIL == safe_L(object1, object2)));
    }

    public static final SubLObject safe_LE_alt(SubLObject object1, SubLObject object2) {
        return makeBoolean(object1.eql(object2) || (NIL != com.cyc.cycjava.cycl.list_utilities.safe_L(object1, object2)));
    }

    public static SubLObject safe_LE(final SubLObject object1, final SubLObject object2) {
        return makeBoolean(object1.eql(object2) || (NIL != safe_L(object1, object2)));
    }

    public static final SubLObject safe_max_alt(SubLObject list, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = ZERO_INTEGER;
        }
        {
            SubLObject result = com.cyc.cycjava.cycl.list_utilities.extremal(list, $sym172$SAFE__, UNPROVIDED);
            return result.isNumber() ? ((SubLObject) (result)) : v_default;
        }
    }

    public static SubLObject safe_max(final SubLObject list, SubLObject v_default) {
        if (v_default == UNPROVIDED) {
            v_default = ZERO_INTEGER;
        }
        final SubLObject result = extremal(list, $sym180$SAFE__, UNPROVIDED);
        return result.isNumber() ? result : v_default;
    }

    public static final SubLObject safe_difference_alt(SubLObject object1, SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return subtract(object1, object2);
        } else {
            return NIL;
        }
    }

    public static SubLObject safe_difference(final SubLObject object1, final SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return subtract(object1, object2);
        }
        return NIL;
    }

    public static final SubLObject safe_quotient_alt(SubLObject object1, SubLObject object2) {
        if ((object1.isNumber() && object2.isNumber()) && (!ZERO_INTEGER.numE(object2))) {
            return divide(object1, object2);
        } else {
            return NIL;
        }
    }

    public static SubLObject safe_quotient(final SubLObject object1, final SubLObject object2) {
        if ((object1.isNumber() && object2.isNumber()) && (!ZERO_INTEGER.numE(object2))) {
            return divide(object1, object2);
        }
        return NIL;
    }

    public static final SubLObject safe_product_alt(SubLObject object1, SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return multiply(object1, object2);
        } else {
            return NIL;
        }
    }

    public static SubLObject safe_product(final SubLObject object1, final SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return multiply(object1, object2);
        }
        return NIL;
    }

    public static final SubLObject safe_sum_alt(SubLObject object1, SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return add(object1, object2);
        } else {
            return NIL;
        }
    }

    public static SubLObject safe_sum(final SubLObject object1, final SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return add(object1, object2);
        }
        return NIL;
    }

    public static final SubLObject safe_E_alt(SubLObject object1, SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return numE(object1, object2);
        } else {
            return NIL;
        }
    }

    public static SubLObject safe_E(final SubLObject object1, final SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return numE(object1, object2);
        }
        return NIL;
    }

    public static SubLObject absL(final SubLObject object1, final SubLObject object2) {
        return numL(abs(object1), abs(object2));
    }

    public static SubLObject absG(final SubLObject object1, final SubLObject object2) {
        return numG(abs(object1), abs(object2));
    }

    /**
     * Like @xref equal, but uses = comparison for numbers.
     */
    @LispMethod(comment = "Like @xref equal, but uses = comparison for numbers.")
    public static final SubLObject equalE_alt(SubLObject object1, SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return numE(object1, object2);
        } else {
            return equal(object1, object2);
        }
    }

    @LispMethod(comment = "Like @xref equal, but uses = comparison for numbers.")
    public static SubLObject equalE(final SubLObject object1, final SubLObject object2) {
        if (object1.isNumber() && object2.isNumber()) {
            return numE(object1, object2);
        }
        return equal(object1, object2);
    }/**
     * Like @xref equal, but uses = comparison for numbers.
     */


    public static final SubLObject tree_L_alt(SubLObject tree1, SubLObject tree2, SubLObject test, SubLObject equal_test) {
        if (test == UNPROVIDED) {
            test = symbol_function($sym97$_);
        }
        if (equal_test == UNPROVIDED) {
            equal_test = symbol_function($sym178$_);
        }
        return eq($LESS, com.cyc.cycjava.cycl.list_utilities.tree_lt_intP(tree1, tree2, test, equal_test));
    }

    public static SubLObject tree_L(final SubLObject tree1, final SubLObject tree2, SubLObject test, SubLObject equal_test) {
        if (test == UNPROVIDED) {
            test = symbol_function($sym97$_);
        }
        if (equal_test == UNPROVIDED) {
            equal_test = symbol_function($sym186$_);
        }
        return eq($LESS, tree_lt_intP(tree1, tree2, test, equal_test));
    }

    public static final SubLObject tree_lt_intP_alt(SubLObject tree1, SubLObject tree2, SubLObject test, SubLObject equal_test) {
        if (tree1.isCons()) {
            if (tree2.isCons()) {
                {
                    SubLObject status = $EQUAL;
                    SubLObject rest_tree1 = NIL;
                    SubLObject subtree1 = NIL;
                    SubLObject rest_tree2 = NIL;
                    SubLObject subtree2 = NIL;
                    for (rest_tree1 = tree1, subtree1 = rest_tree1.first(), rest_tree2 = tree2, subtree2 = rest_tree2.first(); !(((status != $EQUAL) || (NIL == rest_tree1)) || (NIL == rest_tree2)); rest_tree1 = rest_tree1.rest() , subtree1 = rest_tree1.first() , rest_tree2 = rest_tree2.rest() , subtree2 = rest_tree2.first()) {
                        status = com.cyc.cycjava.cycl.list_utilities.tree_lt_intP(subtree1, subtree2, test, equal_test);
                    }
                    if ((NIL == rest_tree1) && (NIL != rest_tree2)) {
                        return $LESS;
                    }
                    if ((NIL == rest_tree2) && (NIL != rest_tree1)) {
                        return $GREATER;
                    }
                    return status;
                }
            } else {
                return $LESS;
            }
        } else {
            if (tree2.isCons()) {
                return $GREATER;
            } else {
                return NIL != funcall(test, tree1, tree2) ? ((SubLObject) ($LESS)) : NIL != funcall(equal_test, tree1, tree2) ? ((SubLObject) ($EQUAL)) : $GREATER;
            }
        }
    }

    public static SubLObject tree_lt_intP(final SubLObject tree1, final SubLObject tree2, final SubLObject test, final SubLObject equal_test) {
        if (tree1.isCons()) {
            if (!tree2.isCons()) {
                return $LESS;
            }
            SubLObject status;
            SubLObject rest_tree1;
            SubLObject subtree1;
            SubLObject rest_tree2;
            SubLObject subtree2;
            for (status = $EQUAL, rest_tree1 = NIL, subtree1 = NIL, rest_tree2 = NIL, subtree2 = NIL, rest_tree1 = tree1, subtree1 = rest_tree1.first(), rest_tree2 = tree2, subtree2 = rest_tree2.first(); ((status == $EQUAL) && (NIL != rest_tree1)) && (NIL != rest_tree2); status = tree_lt_intP(subtree1, subtree2, test, equal_test) , rest_tree1 = rest_tree1.rest() , subtree1 = rest_tree1.first() , rest_tree2 = rest_tree2.rest() , subtree2 = rest_tree2.first()) {
            }
            if ((NIL == rest_tree1) && (NIL != rest_tree2)) {
                return $LESS;
            }
            if ((NIL == rest_tree2) && (NIL != rest_tree1)) {
                return $GREATER;
            }
            return status;
        } else {
            if (tree2.isCons()) {
                return $GREATER;
            }
            return NIL != funcall(test, tree1, tree2) ? $LESS : NIL != funcall(equal_test, tree1, tree2) ? $EQUAL : $GREATER;
        }
    }

    /**
     * returns the median of a list, after sorting by SORT-PRED.
     * It picks the larger if the median falls in the middle.
     *
     * @unknown (parametrized-median '(1 2 3 4 5) #'<) 3
     * @unknown (parametrized-median '(4 1 2 5 3) #'<) 3
     * @unknown (parametrized-median '(4 1 2 5)   #'<) 4
     * @unknown pace
     */
    @LispMethod(comment = "returns the median of a list, after sorting by SORT-PRED.\r\nIt picks the larger if the median falls in the middle.\r\n\r\n@unknown (parametrized-median \'(1 2 3 4 5) #\'<) 3\r\n@unknown (parametrized-median \'(4 1 2 5 3) #\'<) 3\r\n@unknown (parametrized-median \'(4 1 2 5)   #\'<) 4\r\n@unknown pace\nreturns the median of a list, after sorting by SORT-PRED.\nIt picks the larger if the median falls in the middle.")
    public static final SubLObject parametrized_median_alt(SubLObject list, SubLObject sort_pred) {
        {
            SubLObject sorted_list = Sort.sort(copy_list(list), sort_pred, UNPROVIDED);
            SubLObject len = length(sorted_list);
            SubLObject pos = integerDivide(len, TWO_INTEGER);
            return nth(pos, sorted_list);
        }
    }

    @LispMethod(comment = "returns the median of a list, after sorting by SORT-PRED.\r\nIt picks the larger if the median falls in the middle.\r\n\r\n@unknown (parametrized-median \'(1 2 3 4 5) #\'<) 3\r\n@unknown (parametrized-median \'(4 1 2 5 3) #\'<) 3\r\n@unknown (parametrized-median \'(4 1 2 5)   #\'<) 4\r\n@unknown pace\nreturns the median of a list, after sorting by SORT-PRED.\nIt picks the larger if the median falls in the middle.")
    public static SubLObject parametrized_median(final SubLObject list, final SubLObject sort_pred) {
        final SubLObject sorted_list = Sort.sort(copy_list(list), sort_pred, UNPROVIDED);
        final SubLObject len = length(sorted_list);
        final SubLObject pos = integerDivide(len, TWO_INTEGER);
        return nth(pos, sorted_list);
    }/**
     * returns the median of a list, after sorting by SORT-PRED.
     * It picks the larger if the median falls in the middle.
     *
     * @unknown (parametrized-median '(1 2 3 4 5) #'<) 3
     * @unknown (parametrized-median '(4 1 2 5 3) #'<) 3
     * @unknown (parametrized-median '(4 1 2 5)   #'<) 4
     * @unknown pace
     */


    /**
     *
     *
     * @return the shortest list in LISTS.
     */
    @LispMethod(comment = "@return the shortest list in LISTS.")
    public static final SubLObject shortest_alt(SubLObject lists) {
        return com.cyc.cycjava.cycl.list_utilities.extremal(lists, symbol_function($sym97$_), symbol_function(LENGTH));
    }

    /**
     *
     *
     * @return the shortest list in LISTS.
     */
    @LispMethod(comment = "@return the shortest list in LISTS.")
    public static SubLObject shortest(final SubLObject lists) {
        return extremal(lists, symbol_function($sym97$_), symbol_function(LENGTH));
    }

    /**
     *
     *
     * @return the longest list in LISTS.
     */
    @LispMethod(comment = "@return the longest list in LISTS.")
    public static final SubLObject longest_alt(SubLObject lists) {
        return com.cyc.cycjava.cycl.list_utilities.extremal(lists, symbol_function($sym171$_), symbol_function(LENGTH));
    }

    /**
     *
     *
     * @return the longest list in LISTS.
     */
    @LispMethod(comment = "@return the longest list in LISTS.")
    public static SubLObject longest(final SubLObject lists) {
        return extremal(lists, symbol_function($sym179$_), symbol_function(LENGTH));
    }

    /**
     * Return the total number of cons cells in TREE.
     */
    @LispMethod(comment = "Return the total number of cons cells in TREE.")
    public static final SubLObject cons_count_alt(SubLObject tree) {
        if (tree.isAtom()) {
            return ZERO_INTEGER;
        }
        {
            SubLObject total = ZERO_INTEGER;
            SubLObject rest = NIL;
            for (rest = tree; !rest.isAtom(); rest = rest.rest()) {
                total = add(total, ONE_INTEGER);
                total = add(total, com.cyc.cycjava.cycl.list_utilities.cons_count(rest.first()));
            }
            if (NIL != rest) {
                total = add(total, com.cyc.cycjava.cycl.list_utilities.cons_count(rest));
            }
            return total;
        }
    }

    @LispMethod(comment = "Return the total number of cons cells in TREE.")
    public static SubLObject cons_count(final SubLObject tree) {
        if (tree.isAtom()) {
            return ZERO_INTEGER;
        }
        SubLObject total = ZERO_INTEGER;
        SubLObject rest;
        for (rest = NIL, rest = tree; !rest.isAtom(); rest = rest.rest()) {
            total = add(total, ONE_INTEGER);
            total = add(total, cons_count(rest.first()));
        }
        if (NIL != rest) {
            total = add(total, cons_count(rest));
        }
        return total;
    }/**
     * Return the total number of cons cells in TREE.
     */


    public static final SubLObject tree_delete_alt(SubLObject item, SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, item, funcall(key, v_object))) {
            return NIL;
        } else {
            if (v_object.isCons()) {
                if (NIL != funcall(test, item, funcall(key, v_object.first()))) {
                    return com.cyc.cycjava.cycl.list_utilities.tree_delete(item, v_object.rest(), test, key);
                } else {
                    return rplacd(rplaca(v_object, com.cyc.cycjava.cycl.list_utilities.tree_delete(item, v_object.first(), test, key)), com.cyc.cycjava.cycl.list_utilities.tree_delete(item, v_object.rest(), test, key));
                }
            } else {
                return v_object;
            }
        }
    }

    public static SubLObject tree_delete(final SubLObject item, final SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, item, funcall(key, v_object))) {
            return NIL;
        }
        if (!v_object.isCons()) {
            return v_object;
        }
        if (NIL != funcall(test, item, funcall(key, v_object.first()))) {
            return tree_delete(item, v_object.rest(), test, key);
        }
        return rplacd(rplaca(v_object, tree_delete(item, v_object.first(), test, key)), tree_delete(item, v_object.rest(), test, key));
    }

    /**
     * Map over each element in TREE, applying FUNCTION to the
     * value returned by KEY applied to the element.
     *
     * @unknown If the tree is hyper-deep or circular, you might loose
    if the side-effect is not on your side.
     * @return TREE
     */
    @LispMethod(comment = "Map over each element in TREE, applying FUNCTION to the\r\nvalue returned by KEY applied to the element.\r\n\r\n@unknown If the tree is hyper-deep or circular, you might loose\r\nif the side-effect is not on your side.\r\n@return TREE\nMap over each element in TREE, applying FUNCTION to the\nvalue returned by KEY applied to the element.")
    public static final SubLObject tree_map_alt(SubLObject function, SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (!tree.isCons()) {
            funcall(function, funcall(key, tree));
        } else {
            {
                SubLObject rest = NIL;
                for (rest = tree; !rest.isAtom(); rest = rest.rest()) {
                    com.cyc.cycjava.cycl.list_utilities.tree_map(function, rest.first(), key);
                }
                if (NIL != rest) {
                    funcall(function, funcall(key, rest));
                }
            }
        }
        return tree;
    }

    @LispMethod(comment = "Map over each element in TREE, applying FUNCTION to the\r\nvalue returned by KEY applied to the element.\r\n\r\n@unknown If the tree is hyper-deep or circular, you might loose\r\nif the side-effect is not on your side.\r\n@return TREE\nMap over each element in TREE, applying FUNCTION to the\nvalue returned by KEY applied to the element.")
    public static SubLObject tree_map(final SubLObject function, final SubLObject tree, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (!tree.isCons()) {
            funcall(function, funcall(key, tree));
        } else {
            SubLObject rest;
            for (rest = NIL, rest = tree; !rest.isAtom(); rest = rest.rest()) {
                tree_map(function, rest.first(), key);
            }
            if (NIL != rest) {
                funcall(function, funcall(key, rest));
            }
        }
        return tree;
    }/**
     * Map over each element in TREE, applying FUNCTION to the
     * value returned by KEY applied to the element.
     *
     * @unknown If the tree is hyper-deep or circular, you might loose
    if the side-effect is not on your side.
     * @return TREE
     */


    /**
     * Recursively tests PRED on OBJECT and its elements/subtrees. If PRED applies to
     * OBJECT or an element/subtree of OBJECT, then TRANSFORM-FUNCTION is called on
     * OBJECT or that element/subtree and the result of this transformation replaces
     * the original thing (in OBJECT). Note that this is a destructive function.
     *
     * @unknown (tree-ntransform-if '(1 2 3 4) 'even-integer-p '1+)
    (1 3 3 5)
    where (define even-integer-p (x)
    (ret (cand (integerp x)
    (evenp x))))
     * @unknown zelal
     */
    @LispMethod(comment = "Recursively tests PRED on OBJECT and its elements/subtrees. If PRED applies to\r\nOBJECT or an element/subtree of OBJECT, then TRANSFORM-FUNCTION is called on\r\nOBJECT or that element/subtree and the result of this transformation replaces\r\nthe original thing (in OBJECT). Note that this is a destructive function.\r\n\r\n@unknown (tree-ntransform-if \'(1 2 3 4) \'even-integer-p \'1+)\r\n(1 3 3 5)\r\nwhere (define even-integer-p (x)\r\n(ret (cand (integerp x)\r\n(evenp x))))\r\n@unknown zelal\nRecursively tests PRED on OBJECT and its elements/subtrees. If PRED applies to\nOBJECT or an element/subtree of OBJECT, then TRANSFORM-FUNCTION is called on\nOBJECT or that element/subtree and the result of this transformation replaces\nthe original thing (in OBJECT). Note that this is a destructive function.")
    public static final SubLObject tree_ntransform_if_alt(SubLObject v_object, SubLObject pred, SubLObject transform_function, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (v_object.isAtom()) {
            if (NIL != funcall(pred, funcall(key, v_object))) {
                return funcall(transform_function, v_object);
            } else {
                return v_object;
            }
        } else {
            if (v_object.isCons()) {
                {
                    SubLObject rest = NIL;
                    for (rest = v_object; NIL != rest; rest = rest.rest()) {
                        rplaca(rest, com.cyc.cycjava.cycl.list_utilities.tree_ntransform_if(rest.first(), pred, transform_function, key));
                    }
                }
                if (NIL != funcall(pred, funcall(key, v_object))) {
                    return funcall(transform_function, v_object);
                } else {
                    return v_object;
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Recursively tests PRED on OBJECT and its elements/subtrees. If PRED applies to\r\nOBJECT or an element/subtree of OBJECT, then TRANSFORM-FUNCTION is called on\r\nOBJECT or that element/subtree and the result of this transformation replaces\r\nthe original thing (in OBJECT). Note that this is a destructive function.\r\n\r\n@unknown (tree-ntransform-if \'(1 2 3 4) \'even-integer-p \'1+)\r\n(1 3 3 5)\r\nwhere (define even-integer-p (x)\r\n(ret (cand (integerp x)\r\n(evenp x))))\r\n@unknown zelal\nRecursively tests PRED on OBJECT and its elements/subtrees. If PRED applies to\nOBJECT or an element/subtree of OBJECT, then TRANSFORM-FUNCTION is called on\nOBJECT or that element/subtree and the result of this transformation replaces\nthe original thing (in OBJECT). Note that this is a destructive function.")
    public static SubLObject tree_ntransform_if(final SubLObject v_object, final SubLObject pred, final SubLObject transform_function, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (v_object.isAtom()) {
            if (NIL != funcall(pred, funcall(key, v_object))) {
                return funcall(transform_function, v_object);
            }
            return v_object;
        } else {
            if (!v_object.isCons()) {
                return NIL;
            }
            SubLObject rest;
            for (rest = NIL, rest = v_object; rest.isCons(); rest = rest.rest()) {
                rplaca(rest, tree_ntransform_if(rest.first(), pred, transform_function, key));
                if (!rest.rest().isCons()) {
                    rplacd(rest, tree_ntransform_if(rest.rest(), pred, transform_function, key));
                }
            }
            if (NIL != funcall(pred, funcall(key, v_object))) {
                return funcall(transform_function, v_object);
            }
            return v_object;
        }
    }/**
     * Recursively tests PRED on OBJECT and its elements/subtrees. If PRED applies to
     * OBJECT or an element/subtree of OBJECT, then TRANSFORM-FUNCTION is called on
     * OBJECT or that element/subtree and the result of this transformation replaces
     * the original thing (in OBJECT). Note that this is a destructive function.
     *
     * @unknown (tree-ntransform-if '(1 2 3 4) 'even-integer-p '1+)
    (1 3 3 5)
    where (define even-integer-p (x)
    (ret (cand (integerp x)
    (evenp x))))
     * @unknown zelal
     */


    /**
     * Non-destructive version of @xref TREE-NTRANSFORM-IF.
     *
     * @unknown zelal
     */
    @LispMethod(comment = "Non-destructive version of @xref TREE-NTRANSFORM-IF.\r\n\r\n@unknown zelal")
    public static final SubLObject tree_transform_if_alt(SubLObject v_object, SubLObject pred, SubLObject transform_function, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_ntransform_if(copy_tree(v_object), pred, transform_function, key);
    }

    @LispMethod(comment = "Non-destructive version of @xref TREE-NTRANSFORM-IF.\r\n\r\n@unknown zelal")
    public static SubLObject tree_transform_if(final SubLObject v_object, final SubLObject pred, final SubLObject transform_function, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_ntransform_if(copy_tree(v_object), pred, transform_function, key);
    }/**
     * Non-destructive version of @xref TREE-NTRANSFORM-IF.
     *
     * @unknown zelal
     */


    /**
     * Obsolete -- use tree-find
     */
    @LispMethod(comment = "Obsolete -- use tree-find")
    public static final SubLObject cons_tree_find_alt(SubLObject item, SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_find(item, v_object, test, key);
    }

    @LispMethod(comment = "Obsolete -- use tree-find")
    public static SubLObject cons_tree_find(final SubLObject item, final SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_find(item, v_object, test, key);
    }/**
     * Obsolete -- use tree-find
     */


    /**
     * For the first sub-object in OBJECT (including OBJECT) that satisfies TEST applied to KEY of it and ITEM, return the sub-object.
     *
     * @return 0 the found sub-object.
     * @return 1 T if a sub-object is found.
     * @unknown jantos ;; added second return argument
     */
    @LispMethod(comment = "For the first sub-object in OBJECT (including OBJECT) that satisfies TEST applied to KEY of it and ITEM, return the sub-object.\r\n\r\n@return 0 the found sub-object.\r\n@return 1 T if a sub-object is found.\r\n@unknown jantos ;; added second return argument")
    public static final SubLObject tree_find_alt(SubLObject item, SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL != funcall(test, item, funcall(key, v_object))) {
                return values(v_object, T);
            }
            if (v_object.isCons()) {
                {
                    SubLObject list = NIL;
                    SubLObject sub = NIL;
                    for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                        thread.resetMultipleValues();
                        {
                            SubLObject ans = com.cyc.cycjava.cycl.list_utilities.tree_find(item, sub, test, key);
                            SubLObject foundP = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            if (NIL != foundP) {
                                return values(ans, foundP);
                            }
                        }
                    }
                    thread.resetMultipleValues();
                    {
                        SubLObject ans = com.cyc.cycjava.cycl.list_utilities.tree_find(item, list.first(), test, key);
                        SubLObject foundP = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        if (NIL != foundP) {
                            return values(ans, foundP);
                        }
                    }
                    if (NIL != list.rest()) {
                        thread.resetMultipleValues();
                        {
                            SubLObject ans = com.cyc.cycjava.cycl.list_utilities.tree_find(item, list.rest(), test, key);
                            SubLObject foundP = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            if (NIL != foundP) {
                                return values(ans, foundP);
                            }
                        }
                    }
                    return values(NIL, NIL);
                }
            }
            return values(NIL, NIL);
        }
    }

    @LispMethod(comment = "For the first sub-object in OBJECT (including OBJECT) that satisfies TEST applied to KEY of it and ITEM, return the sub-object.\r\n\r\n@return 0 the found sub-object.\r\n@return 1 T if a sub-object is found.\r\n@unknown jantos ;; added second return argument")
    public static SubLObject tree_find(final SubLObject item, final SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        SubLObject foundP = NIL;
        if ((NIL != item) && (key.eql(symbol_function(IDENTITY)) || (key == IDENTITY))) {
            if (test.eql(symbol_function(EQ)) || (test == EQ)) {
                result = simple_tree_find(item, v_object);
                foundP = sublisp_boolean(result);
            } else
                if (test.eql(symbol_function(EQL)) || (test == EQL)) {
                    result = simple_tree_find_via_eql(item, v_object);
                    foundP = sublisp_boolean(result);
                } else
                    if (test.eql(symbol_function(EQUAL)) || (test == EQUAL)) {
                        result = simple_tree_find_via_equal(item, v_object);
                        foundP = sublisp_boolean(result);
                    } else {
                        result = tree_find_without_values_int(item, v_object, test, key);
                        foundP = sublisp_boolean(result);
                    }


        } else {
            thread.resetMultipleValues();
            final SubLObject result_$34 = tree_find_int(item, v_object, test, key);
            final SubLObject foundP_$35 = thread.secondMultipleValue();
            thread.resetMultipleValues();
            result = result_$34;
            foundP = foundP_$35;
        }
        return subl_promotions.values2(result, foundP);
    }/**
     * For the first sub-object in OBJECT (including OBJECT) that satisfies TEST applied to KEY of it and ITEM, return the sub-object.
     *
     * @return 0 the found sub-object.
     * @return 1 T if a sub-object is found.
     * @unknown jantos ;; added second return argument
     */


    public static SubLObject tree_find_int(final SubLObject item, final SubLObject v_object, final SubLObject test, final SubLObject key) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (NIL != funcall(test, item, funcall(key, v_object))) {
            return subl_promotions.values2(v_object, T);
        }
        if (!v_object.isCons()) {
            return subl_promotions.values2(NIL, NIL);
        }
        SubLObject list = NIL;
        SubLObject sub = NIL;
        list = v_object;
        sub = list.first();
        while (list.rest().isCons()) {
            thread.resetMultipleValues();
            final SubLObject ans = tree_find_int(item, sub, test, key);
            final SubLObject foundP = thread.secondMultipleValue();
            thread.resetMultipleValues();
            if (NIL != foundP) {
                return subl_promotions.values2(ans, foundP);
            }
            list = list.rest();
            sub = list.first();
        } 
        thread.resetMultipleValues();
        SubLObject ans = tree_find_int(item, list.first(), test, key);
        SubLObject foundP = thread.secondMultipleValue();
        thread.resetMultipleValues();
        if (NIL != foundP) {
            return subl_promotions.values2(ans, foundP);
        }
        if (NIL != list.rest()) {
            thread.resetMultipleValues();
            ans = tree_find_int(item, list.rest(), test, key);
            foundP = thread.secondMultipleValue();
            thread.resetMultipleValues();
            if (NIL != foundP) {
                return subl_promotions.values2(ans, foundP);
            }
        }
        return subl_promotions.values2(NIL, NIL);
    }

    public static SubLObject tree_find_without_values_int(final SubLObject item, final SubLObject v_object, final SubLObject test, final SubLObject key) {
        if (NIL != funcall(test, item, funcall(key, v_object))) {
            return v_object;
        }
        if (!v_object.isCons()) {
            return NIL;
        }
        SubLObject list = NIL;
        SubLObject sub = NIL;
        list = v_object;
        sub = list.first();
        while (list.rest().isCons()) {
            final SubLObject ans = tree_find_without_values_int(item, sub, test, key);
            if (NIL != ans) {
                return ans;
            }
            list = list.rest();
            sub = list.first();
        } 
        SubLObject ans = tree_find_without_values_int(item, list.first(), test, key);
        if (NIL != ans) {
            return ans;
        }
        if (NIL != list.rest()) {
            ans = tree_find_without_values_int(item, list.rest(), test, key);
            if (NIL != ans) {
                return ans;
            }
        }
        return NIL;
    }

    /**
     * Return T iff the non-nil ITEM is found in OBJECT (via EQ)
     */
    @LispMethod(comment = "Return T iff the non-nil ITEM is found in OBJECT (via EQ)")
    public static final SubLObject simple_tree_findP_alt(SubLObject item, SubLObject v_object) {
        if (item == v_object) {
            return T;
        }
        if (v_object.isCons()) {
            {
                SubLObject list = NIL;
                SubLObject sub = NIL;
                for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                    {
                        SubLObject foundP = com.cyc.cycjava.cycl.list_utilities.simple_tree_findP(item, sub);
                        if (NIL != foundP) {
                            return T;
                        }
                    }
                }
                {
                    SubLObject foundP = com.cyc.cycjava.cycl.list_utilities.simple_tree_findP(item, list.first());
                    if (NIL != foundP) {
                        return T;
                    }
                }
                if (NIL != list.rest()) {
                    {
                        SubLObject foundP = com.cyc.cycjava.cycl.list_utilities.simple_tree_findP(item, list.rest());
                        if (NIL != foundP) {
                            return T;
                        }
                    }
                }
                return NIL;
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Return T iff the non-nil ITEM is found in OBJECT (via EQ)")
    public static SubLObject simple_tree_findP(final SubLObject item, final SubLObject v_object) {
        return sublisp_boolean(simple_tree_find(item, v_object));
    }/**
     * Return T iff the non-nil ITEM is found in OBJECT (via EQ)
     */


    public static SubLObject simple_tree_find(final SubLObject item, final SubLObject v_object) {
        if (item.eql(v_object)) {
            return item;
        }
        if (!v_object.isCons()) {
            return NIL;
        }
        SubLObject list = NIL;
        SubLObject sub = NIL;
        list = v_object;
        sub = list.first();
        while (list.rest().isCons()) {
            final SubLObject foundP = simple_tree_find(item, sub);
            if (NIL != foundP) {
                return item;
            }
            list = list.rest();
            sub = list.first();
        } 
        SubLObject foundP = simple_tree_find(item, list.first());
        if (NIL != foundP) {
            return item;
        }
        if (NIL != list.rest()) {
            foundP = simple_tree_find(item, list.rest());
            if (NIL != foundP) {
                return item;
            }
        }
        return NIL;
    }

    public static SubLObject simple_tree_find_via_eqlP(final SubLObject item, final SubLObject v_object) {
        return sublisp_boolean(simple_tree_find_via_eql(item, v_object));
    }

    public static SubLObject simple_tree_find_via_eql(final SubLObject item, final SubLObject v_object) {
        if (item.eql(v_object)) {
            return item;
        }
        if (!v_object.isCons()) {
            return NIL;
        }
        SubLObject list = NIL;
        SubLObject sub = NIL;
        list = v_object;
        sub = list.first();
        while (list.rest().isCons()) {
            final SubLObject foundP = simple_tree_find_via_eql(item, sub);
            if (NIL != foundP) {
                return item;
            }
            list = list.rest();
            sub = list.first();
        } 
        SubLObject foundP = simple_tree_find_via_eql(item, list.first());
        if (NIL != foundP) {
            return item;
        }
        if (NIL != list.rest()) {
            foundP = simple_tree_find_via_eql(item, list.rest());
            if (NIL != foundP) {
                return item;
            }
        }
        return NIL;
    }

    /**
     * Return T iff the non-nil ITEM is found in OBJECT (via EQUAL)
     */
    @LispMethod(comment = "Return T iff the non-nil ITEM is found in OBJECT (via EQUAL)")
    public static final SubLObject simple_tree_find_via_equalP_alt(SubLObject item, SubLObject v_object) {
        if (item.equal(v_object)) {
            return T;
        }
        if (v_object.isCons()) {
            {
                SubLObject list = NIL;
                SubLObject sub = NIL;
                for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                    {
                        SubLObject foundP = com.cyc.cycjava.cycl.list_utilities.simple_tree_find_via_equalP(item, sub);
                        if (NIL != foundP) {
                            return T;
                        }
                    }
                }
                {
                    SubLObject foundP = com.cyc.cycjava.cycl.list_utilities.simple_tree_find_via_equalP(item, list.first());
                    if (NIL != foundP) {
                        return T;
                    }
                }
                if (NIL != list.rest()) {
                    {
                        SubLObject foundP = com.cyc.cycjava.cycl.list_utilities.simple_tree_find_via_equalP(item, list.rest());
                        if (NIL != foundP) {
                            return T;
                        }
                    }
                }
                return NIL;
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Return T iff the non-nil ITEM is found in OBJECT (via EQUAL)")
    public static SubLObject simple_tree_find_via_equalP(final SubLObject item, final SubLObject v_object) {
        return sublisp_boolean(simple_tree_find_via_equal(item, v_object));
    }/**
     * Return T iff the non-nil ITEM is found in OBJECT (via EQUAL)
     */


    public static SubLObject simple_tree_find_via_equal(final SubLObject item, final SubLObject v_object) {
        if (item.equal(v_object)) {
            return item;
        }
        if (!v_object.isCons()) {
            return NIL;
        }
        SubLObject list = NIL;
        SubLObject sub = NIL;
        list = v_object;
        sub = list.first();
        while (list.rest().isCons()) {
            final SubLObject foundP = simple_tree_find_via_equal(item, sub);
            if (NIL != foundP) {
                return item;
            }
            list = list.rest();
            sub = list.first();
        } 
        SubLObject foundP = simple_tree_find_via_equal(item, list.first());
        if (NIL != foundP) {
            return item;
        }
        if (NIL != list.rest()) {
            foundP = simple_tree_find_via_equal(item, list.rest());
            if (NIL != foundP) {
                return item;
            }
        }
        return NIL;
    }

    /**
     * Look for any of ITEMS in the tree OBJECT.  Return the first item found, or NIL if none found.
     */
    @LispMethod(comment = "Look for any of ITEMS in the tree OBJECT.  Return the first item found, or NIL if none found.")
    public static final SubLObject tree_find_any_alt(SubLObject items, SubLObject tree, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject cdolist_list_var = items;
            SubLObject item = NIL;
            for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                if (NIL != com.cyc.cycjava.cycl.list_utilities.tree_find(item, tree, test, key)) {
                    return item;
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Look for any of ITEMS in the tree OBJECT.  Return the first item found, or NIL if none found.")
    public static SubLObject tree_find_any(final SubLObject items, final SubLObject tree, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject cdolist_list_var = items;
        SubLObject item = NIL;
        item = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != tree_find(item, tree, test, key)) {
                return item;
            }
            cdolist_list_var = cdolist_list_var.rest();
            item = cdolist_list_var.first();
        } 
        return NIL;
    }/**
     * Look for any of ITEMS in the tree OBJECT.  Return the first item found, or NIL if none found.
     */


    /**
     * Obsolete -- use tree-find-if
     */
    @LispMethod(comment = "Obsolete -- use tree-find-if")
    public static final SubLObject cons_tree_find_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_find_if(test, v_object, key);
    }

    @LispMethod(comment = "Obsolete -- use tree-find-if")
    public static SubLObject cons_tree_find_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_find_if(test, v_object, key);
    }/**
     * Obsolete -- use tree-find-if
     */


    public static final SubLObject tree_find_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return v_object;
        }
        if (v_object.isCons()) {
            {
                SubLObject ans = NIL;
                SubLObject list = NIL;
                SubLObject sub = NIL;
                for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                    ans = com.cyc.cycjava.cycl.list_utilities.tree_find_if(test, sub, key);
                    if (NIL != ans) {
                        return ans;
                    }
                }
                ans = com.cyc.cycjava.cycl.list_utilities.tree_find_if(test, list.first(), key);
                if (NIL != ans) {
                    return ans;
                }
                if (NIL != list.rest()) {
                    ans = com.cyc.cycjava.cycl.list_utilities.tree_find_if(test, list.rest(), key);
                }
                return ans;
            }
        }
        return NIL;
    }

    public static SubLObject tree_find_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return v_object;
        }
        if (!v_object.isCons()) {
            return NIL;
        }
        SubLObject ans = NIL;
        SubLObject list = NIL;
        SubLObject sub = NIL;
        list = v_object;
        sub = list.first();
        while (list.rest().isCons()) {
            ans = tree_find_if(test, sub, key);
            if (NIL != ans) {
                return ans;
            }
            list = list.rest();
            sub = list.first();
        } 
        ans = tree_find_if(test, list.first(), key);
        if (NIL != ans) {
            return ans;
        }
        if (NIL != list.rest()) {
            ans = tree_find_if(test, list.rest(), key);
        }
        return ans;
    }

    /**
     * Obsolete -- use tree-count
     */
    @LispMethod(comment = "Obsolete -- use tree-count")
    public static final SubLObject cons_tree_count_alt(SubLObject item, SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_count(item, v_object, test, key);
    }

    @LispMethod(comment = "Obsolete -- use tree-count")
    public static SubLObject cons_tree_count(final SubLObject item, final SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_count(item, v_object, test, key);
    }/**
     * Obsolete -- use tree-count
     */


    /**
     *
     *
     * @unknown NON-NEGATIVE-INTEGER-P; How many times does ITEM appear in OBJECT?
     */
    @LispMethod(comment = "@unknown NON-NEGATIVE-INTEGER-P; How many times does ITEM appear in OBJECT?")
    public static final SubLObject tree_count_alt(SubLObject item, SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, NIL, UNPROVIDED);
    }

    /**
     *
     *
     * @unknown NON-NEGATIVE-INTEGER-P; How many times does ITEM appear in OBJECT?
     */
    @LispMethod(comment = "@unknown NON-NEGATIVE-INTEGER-P; How many times does ITEM appear in OBJECT?")
    public static SubLObject tree_count(final SubLObject item, final SubLObject v_object, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_count_internal(item, v_object, test, key, NIL, UNPROVIDED);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT more than COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT more than COUNT times?")
    public static final SubLObject tree_countG_alt(SubLObject item, SubLObject v_object, SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numG(com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT more than COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT more than COUNT times?")
    public static SubLObject tree_countG(final SubLObject item, final SubLObject v_object, final SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numG(tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT at least COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT at least COUNT times?")
    public static final SubLObject tree_countGE_alt(SubLObject item, SubLObject v_object, SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numGE(com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT at least COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT at least COUNT times?")
    public static SubLObject tree_countGE(final SubLObject item, final SubLObject v_object, final SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numGE(tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT fewer than COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT fewer than COUNT times?")
    public static final SubLObject tree_countL_alt(SubLObject item, SubLObject v_object, SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numL(com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT fewer than COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT fewer than COUNT times?")
    public static SubLObject tree_countL(final SubLObject item, final SubLObject v_object, final SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numL(tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT no more than COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT no more than COUNT times?")
    public static final SubLObject tree_countLE_alt(SubLObject item, SubLObject v_object, SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numLE(com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT no more than COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT no more than COUNT times?")
    public static SubLObject tree_countLE(final SubLObject item, final SubLObject v_object, final SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numLE(tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT exactly COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT exactly COUNT times?")
    public static final SubLObject tree_countE_alt(SubLObject item, SubLObject v_object, SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numE(com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    /**
     *
     *
     * @unknown BOOLEANP; Does ITEM appear in OBJECT exactly COUNT times?
     */
    @LispMethod(comment = "@unknown BOOLEANP; Does ITEM appear in OBJECT exactly COUNT times?")
    public static SubLObject tree_countE(final SubLObject item, final SubLObject v_object, final SubLObject count, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return numE(tree_count_internal(item, v_object, test, key, count, UNPROVIDED), count);
    }

    public static final SubLObject tree_count_internal_alt(SubLObject item, SubLObject v_object, SubLObject test, SubLObject key, SubLObject max, SubLObject sofar) {
        if (sofar == UNPROVIDED) {
            sofar = ZERO_INTEGER;
        }
        if (NIL != funcall(test, item, funcall(key, v_object))) {
            return number_utilities.f_1X(sofar);
        } else {
            if (v_object.isCons()) {
                {
                    SubLObject first_sub_tree = NIL;
                    while (v_object.isCons() && ((!max.isNumber()) || sofar.numLE(max))) {
                        {
                            SubLObject datum_evaluated_var = v_object;
                            first_sub_tree = datum_evaluated_var.first();
                            v_object = datum_evaluated_var.rest();
                        }
                        sofar = com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, first_sub_tree, test, key, max, sofar);
                    } 
                    if ((NIL != v_object) && ((!max.isNumber()) || sofar.numLE(max))) {
                        sofar = com.cyc.cycjava.cycl.list_utilities.tree_count_internal(item, v_object, test, key, max, sofar);
                    }
                    return sofar;
                }
            } else {
                return sofar;
            }
        }
    }

    public static SubLObject tree_count_internal(final SubLObject item, SubLObject v_object, final SubLObject test, final SubLObject key, final SubLObject max, SubLObject sofar) {
        if (sofar == UNPROVIDED) {
            sofar = ZERO_INTEGER;
        }
        if (NIL != funcall(test, item, funcall(key, v_object))) {
            return number_utilities.f_1X(sofar);
        }
        if (v_object.isCons()) {
            SubLObject datum_evaluated_var;
            for (SubLObject first_sub_tree = NIL; v_object.isCons() && ((!max.isNumber()) || sofar.numLE(max)); v_object = datum_evaluated_var.rest() , sofar = tree_count_internal(item, first_sub_tree, test, key, max, sofar)) {
                datum_evaluated_var = v_object;
                first_sub_tree = datum_evaluated_var.first();
            }
            if ((NIL != v_object) && ((!max.isNumber()) || sofar.numLE(max))) {
                sofar = tree_count_internal(item, v_object, test, key, max, sofar);
            }
            return sofar;
        }
        return sofar;
    }

    /**
     *
     *
     * @unknown NON-NEGATIVE-INTEGER-P; The number of times ITEM appears in OBJECT (via EQ)
     */
    @LispMethod(comment = "@unknown NON-NEGATIVE-INTEGER-P; The number of times ITEM appears in OBJECT (via EQ)")
    public static final SubLObject simple_tree_count_alt(SubLObject item, SubLObject v_object) {
        return com.cyc.cycjava.cycl.list_utilities.simple_tree_count_recursive(item, v_object, ZERO_INTEGER);
    }

    /**
     *
     *
     * @unknown NON-NEGATIVE-INTEGER-P; The number of times ITEM appears in OBJECT (via EQ)
     */
    @LispMethod(comment = "@unknown NON-NEGATIVE-INTEGER-P; The number of times ITEM appears in OBJECT (via EQ)")
    public static SubLObject simple_tree_count(final SubLObject item, final SubLObject v_object) {
        return simple_tree_count_recursive(item, v_object, ZERO_INTEGER);
    }

    public static final SubLObject simple_tree_count_recursive_alt(SubLObject item, SubLObject v_object, SubLObject sofar) {
        if (item == v_object) {
            sofar = add(sofar, ONE_INTEGER);
        } else {
            if (v_object.isCons()) {
                {
                    SubLObject list = NIL;
                    SubLObject sub = NIL;
                    for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                        sofar = com.cyc.cycjava.cycl.list_utilities.simple_tree_count_recursive(item, sub, sofar);
                    }
                    sofar = com.cyc.cycjava.cycl.list_utilities.simple_tree_count_recursive(item, list.first(), sofar);
                    if (NIL != list.rest()) {
                        sofar = com.cyc.cycjava.cycl.list_utilities.simple_tree_count_recursive(item, list.rest(), sofar);
                    }
                }
            }
        }
        return sofar;
    }

    public static SubLObject simple_tree_count_recursive(final SubLObject item, final SubLObject v_object, SubLObject sofar) {
        if (item.eql(v_object)) {
            sofar = add(sofar, ONE_INTEGER);
        } else
            if (v_object.isCons()) {
                SubLObject list = NIL;
                SubLObject sub = NIL;
                list = v_object;
                sub = list.first();
                while (list.rest().isCons()) {
                    sofar = simple_tree_count_recursive(item, sub, sofar);
                    list = list.rest();
                    sub = list.first();
                } 
                sofar = simple_tree_count_recursive(item, list.first(), sofar);
                if (NIL != list.rest()) {
                    sofar = simple_tree_count_recursive(item, list.rest(), sofar);
                }
            }

        return sofar;
    }

    /**
     * Obsolete -- use tree-count-if
     */
    @LispMethod(comment = "Obsolete -- use tree-count-if")
    public static final SubLObject cons_tree_count_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_count_if(test, v_object, key);
    }

    @LispMethod(comment = "Obsolete -- use tree-count-if")
    public static SubLObject cons_tree_count_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return tree_count_if(test, v_object, key);
    }/**
     * Obsolete -- use tree-count-if
     */


    public static final SubLObject tree_count_if_alt(SubLObject test, SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return ONE_INTEGER;
        }
        if (v_object.isCons()) {
            {
                SubLObject total = ZERO_INTEGER;
                SubLObject list = NIL;
                SubLObject sub = NIL;
                for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                    total = add(total, com.cyc.cycjava.cycl.list_utilities.tree_count_if(test, sub, key));
                }
                total = add(total, com.cyc.cycjava.cycl.list_utilities.tree_count_if(test, list.first(), key));
                if (NIL != list.rest()) {
                    total = add(total, com.cyc.cycjava.cycl.list_utilities.tree_count_if(test, list.rest(), key));
                }
                return total;
            }
        }
        return ZERO_INTEGER;
    }

    public static SubLObject tree_count_if(final SubLObject test, final SubLObject v_object, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL != funcall(test, funcall(key, v_object))) {
            return ONE_INTEGER;
        }
        if (v_object.isCons()) {
            SubLObject total = ZERO_INTEGER;
            SubLObject list = NIL;
            SubLObject sub = NIL;
            list = v_object;
            sub = list.first();
            while (list.rest().isCons()) {
                total = add(total, tree_count_if(test, sub, key));
                list = list.rest();
                sub = list.first();
            } 
            total = add(total, tree_count_if(test, list.first(), key));
            if (NIL != list.rest()) {
                total = add(total, tree_count_if(test, list.rest(), key));
            }
            return total;
        }
        return ZERO_INTEGER;
    }

    /**
     * Counts the number of unique elements in TREE that pass PREDICATE.
     */
    @LispMethod(comment = "Counts the number of unique elements in TREE that pass PREDICATE.")
    public static final SubLObject tree_count_if_unique_alt(SubLObject tree, SubLObject predicate, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject elements = com.cyc.cycjava.cycl.list_utilities.tree_gather(tree, predicate, NIL, UNPROVIDED, UNPROVIDED);
            SubLObject v_set = set_utilities.construct_set_from_list(elements, test, UNPROVIDED);
            return set.set_size(v_set);
        }
    }

    @LispMethod(comment = "Counts the number of unique elements in TREE that pass PREDICATE.")
    public static SubLObject tree_count_if_unique(final SubLObject tree, final SubLObject predicate, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        final SubLObject elements = tree_gather(tree, predicate, NIL, UNPROVIDED, UNPROVIDED);
        final SubLObject v_set = set_utilities.construct_set_from_list(elements, test, UNPROVIDED);
        return set.set_size(v_set);
    }/**
     * Counts the number of unique elements in TREE that pass PREDICATE.
     */


    /**
     * Obsolete -- use tree-gather
     */
    @LispMethod(comment = "Obsolete -- use tree-gather")
    public static final SubLObject cons_tree_gather_alt(SubLObject v_object, SubLObject predicate, SubLObject test, SubLObject key, SubLObject subs_tooP) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (subs_tooP == UNPROVIDED) {
            subs_tooP = T;
        }
        return com.cyc.cycjava.cycl.list_utilities.tree_gather(v_object, predicate, test, key, subs_tooP);
    }

    @LispMethod(comment = "Obsolete -- use tree-gather")
    public static SubLObject cons_tree_gather(final SubLObject v_object, final SubLObject predicate, SubLObject test, SubLObject key, SubLObject subs_tooP) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (subs_tooP == UNPROVIDED) {
            subs_tooP = T;
        }
        return tree_gather(v_object, predicate, test, key, subs_tooP);
    }/**
     * Obsolete -- use tree-gather
     */


    public static final SubLObject tree_gather_alt(SubLObject v_object, SubLObject predicate, SubLObject test, SubLObject key, SubLObject subs_tooP) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (subs_tooP == UNPROVIDED) {
            subs_tooP = T;
        }
        return nreverse(com.cyc.cycjava.cycl.list_utilities.tree_gather_internal(v_object, predicate, test, key, subs_tooP, NIL));
    }

    public static SubLObject tree_gather(final SubLObject v_object, final SubLObject predicate, SubLObject test, SubLObject key, SubLObject subs_tooP) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (subs_tooP == UNPROVIDED) {
            subs_tooP = T;
        }
        return nreverse(tree_gather_internal(v_object, predicate, test, key, subs_tooP, NIL));
    }

    public static final SubLObject tree_gather_internal_alt(SubLObject v_object, SubLObject predicate, SubLObject test, SubLObject key, SubLObject subs_tooP, SubLObject so_far) {
        {
            SubLObject result = so_far;
            if (NIL != funcall(predicate, funcall(key, v_object))) {
                if (NIL != test) {
                    {
                        SubLObject item_var = v_object;
                        if (NIL == member(item_var, result, test, symbol_function(IDENTITY))) {
                            result = cons(item_var, result);
                        }
                    }
                } else {
                    result = cons(v_object, result);
                }
                if (NIL == subs_tooP) {
                    return result;
                }
            }
            if (v_object.isCons()) {
                {
                    SubLObject list = NIL;
                    SubLObject sub = NIL;
                    for (list = v_object, sub = list.first(); list.rest().isCons(); list = list.rest() , sub = list.first()) {
                        result = com.cyc.cycjava.cycl.list_utilities.tree_gather_internal(sub, predicate, test, key, subs_tooP, result);
                    }
                    result = com.cyc.cycjava.cycl.list_utilities.tree_gather_internal(list.first(), predicate, test, key, subs_tooP, result);
                    if (NIL != list.rest()) {
                        result = com.cyc.cycjava.cycl.list_utilities.tree_gather_internal(list.rest(), predicate, test, key, subs_tooP, result);
                    }
                }
            }
            return result;
        }
    }

    public static SubLObject tree_gather_internal(final SubLObject v_object, final SubLObject predicate, final SubLObject test, final SubLObject key, final SubLObject subs_tooP, final SubLObject so_far) {
        SubLObject result = so_far;
        if (NIL != funcall(predicate, funcall(key, v_object))) {
            if (NIL != test) {
                if (NIL == member(v_object, result, test, symbol_function(IDENTITY))) {
                    result = cons(v_object, result);
                }
            } else {
                result = cons(v_object, result);
            }
            if (NIL == subs_tooP) {
                return result;
            }
        }
        if (v_object.isCons()) {
            SubLObject list = NIL;
            SubLObject sub = NIL;
            list = v_object;
            sub = list.first();
            while (list.rest().isCons()) {
                result = tree_gather_internal(sub, predicate, test, key, subs_tooP, result);
                list = list.rest();
                sub = list.first();
            } 
            result = tree_gather_internal(list.first(), predicate, test, key, subs_tooP, result);
            if (NIL != list.rest()) {
                result = tree_gather_internal(list.rest(), predicate, test, key, subs_tooP, result);
            }
        }
        return result;
    }

    /**
     * This gathers all elements of OBJECT of which PREDICATE is true.  The elements are
     * returned in order from left to right, including duplicates.  If KEY is explicitly
     * specified, then KEY is applied to the element of OBJECT before testing PREDICATE.
     * If SUBS-TOO? is NIL, then once it is determined that PREDICATE applies to an
     * element, no further recursion is done on that element.
     *
     * @unknown kknight
     */
    @LispMethod(comment = "This gathers all elements of OBJECT of which PREDICATE is true.  The elements are\r\nreturned in order from left to right, including duplicates.  If KEY is explicitly\r\nspecified, then KEY is applied to the element of OBJECT before testing PREDICATE.\r\nIf SUBS-TOO? is NIL, then once it is determined that PREDICATE applies to an\r\nelement, no further recursion is done on that element.\r\n\r\n@unknown kknight\nThis gathers all elements of OBJECT of which PREDICATE is true.  The elements are\nreturned in order from left to right, including duplicates.  If KEY is explicitly\nspecified, then KEY is applied to the element of OBJECT before testing PREDICATE.\nIf SUBS-TOO? is NIL, then once it is determined that PREDICATE applies to an\nelement, no further recursion is done on that element.")
    public static final SubLObject tree_gather_ordered_alt(SubLObject v_object, SubLObject predicate, SubLObject key, SubLObject subs_tooP) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (subs_tooP == UNPROVIDED) {
            subs_tooP = T;
        }
        return NIL != subs_tooP ? ((SubLObject) (com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_subs(v_object, predicate, key))) : com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_no_subs(v_object, predicate, key);
    }

    @LispMethod(comment = "This gathers all elements of OBJECT of which PREDICATE is true.  The elements are\r\nreturned in order from left to right, including duplicates.  If KEY is explicitly\r\nspecified, then KEY is applied to the element of OBJECT before testing PREDICATE.\r\nIf SUBS-TOO? is NIL, then once it is determined that PREDICATE applies to an\r\nelement, no further recursion is done on that element.\r\n\r\n@unknown kknight\nThis gathers all elements of OBJECT of which PREDICATE is true.  The elements are\nreturned in order from left to right, including duplicates.  If KEY is explicitly\nspecified, then KEY is applied to the element of OBJECT before testing PREDICATE.\nIf SUBS-TOO? is NIL, then once it is determined that PREDICATE applies to an\nelement, no further recursion is done on that element.")
    public static SubLObject tree_gather_ordered(final SubLObject v_object, final SubLObject predicate, SubLObject key, SubLObject subs_tooP) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (subs_tooP == UNPROVIDED) {
            subs_tooP = T;
        }
        return NIL != subs_tooP ? tree_gather_ordered_subs(v_object, predicate, key) : tree_gather_ordered_no_subs(v_object, predicate, key);
    }/**
     * This gathers all elements of OBJECT of which PREDICATE is true.  The elements are
     * returned in order from left to right, including duplicates.  If KEY is explicitly
     * specified, then KEY is applied to the element of OBJECT before testing PREDICATE.
     * If SUBS-TOO? is NIL, then once it is determined that PREDICATE applies to an
     * element, no further recursion is done on that element.
     *
     * @unknown kknight
     */


    /**
     *
     *
     * @unknown kknight
     */
    @LispMethod(comment = "@unknown kknight")
    public static final SubLObject tree_gather_ordered_subs_alt(SubLObject v_object, SubLObject predicate, SubLObject key) {
        return NIL != funcall(predicate, funcall(key, v_object)) ? ((SubLObject) (v_object.isCons() ? ((SubLObject) (cons(v_object, nconc(com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_subs(v_object.first(), predicate, key), com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_subs(v_object.rest(), predicate, key))))) : cons(v_object, NIL))) : v_object.isCons() ? ((SubLObject) (nconc(com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_subs(v_object.first(), predicate, key), com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_subs(v_object.rest(), predicate, key)))) : NIL;
    }

    /**
     *
     *
     * @unknown kknight
     */
    @LispMethod(comment = "@unknown kknight")
    public static SubLObject tree_gather_ordered_subs(final SubLObject v_object, final SubLObject predicate, final SubLObject key) {
        return NIL != funcall(predicate, funcall(key, v_object)) ? v_object.isCons() ? cons(v_object, nconc(tree_gather_ordered_subs(v_object.first(), predicate, key), tree_gather_ordered_subs(v_object.rest(), predicate, key))) : cons(v_object, NIL) : v_object.isCons() ? nconc(tree_gather_ordered_subs(v_object.first(), predicate, key), tree_gather_ordered_subs(v_object.rest(), predicate, key)) : NIL;
    }

    /**
     *
     *
     * @unknown kknight
     */
    @LispMethod(comment = "@unknown kknight")
    public static final SubLObject tree_gather_ordered_no_subs_alt(SubLObject v_object, SubLObject predicate, SubLObject key) {
        return NIL != funcall(predicate, funcall(key, v_object)) ? ((SubLObject) (cons(v_object, NIL))) : v_object.isCons() ? ((SubLObject) (nconc(com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_no_subs(v_object.first(), predicate, key), com.cyc.cycjava.cycl.list_utilities.tree_gather_ordered_no_subs(v_object.rest(), predicate, key)))) : NIL;
    }

    /**
     *
     *
     * @unknown kknight
     */
    @LispMethod(comment = "@unknown kknight")
    public static SubLObject tree_gather_ordered_no_subs(final SubLObject v_object, final SubLObject predicate, final SubLObject key) {
        return NIL != funcall(predicate, funcall(key, v_object)) ? cons(v_object, NIL) : v_object.isCons() ? nconc(tree_gather_ordered_no_subs(v_object.first(), predicate, key), tree_gather_ordered_no_subs(v_object.rest(), predicate, key)) : NIL;
    }

    /**
     * Duplicate the tree and replace all occurrences of tree with new-item.
     */
    @LispMethod(comment = "Duplicate the tree and replace all occurrences of tree with new-item.")
    public static final SubLObject tree_substitute_alt(SubLObject tree, SubLObject old_item, SubLObject new_item) {
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = tree;
            SubLObject branch = NIL;
            for (branch = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , branch = cdolist_list_var.first()) {
                if (branch.equal(old_item)) {
                    result = cons(new_item, result);
                } else {
                    if (branch.isList()) {
                        result = cons(com.cyc.cycjava.cycl.list_utilities.tree_substitute(branch, old_item, new_item), result);
                    } else {
                        result = cons(branch, result);
                    }
                }
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Duplicate the tree and replace all occurrences of tree with new-item.")
    public static SubLObject tree_substitute(final SubLObject tree, final SubLObject old_item, final SubLObject new_item) {
        SubLObject result = NIL;
        SubLObject cdolist_list_var = tree;
        SubLObject branch = NIL;
        branch = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (branch.equal(old_item)) {
                result = cons(new_item, result);
            } else
                if (branch.isList()) {
                    result = cons(tree_substitute(branch, old_item, new_item), result);
                } else {
                    result = cons(branch, result);
                }

            cdolist_list_var = cdolist_list_var.rest();
            branch = cdolist_list_var.first();
        } 
        return nreverse(result);
    }/**
     * Duplicate the tree and replace all occurrences of tree with new-item.
     */


    /**
     * Duplicate the tree and replace all occurrences of tree with new-item.
     */
    @LispMethod(comment = "Duplicate the tree and replace all occurrences of tree with new-item.")
    public static final SubLObject tree_substitute_using_dictionary_alt(SubLObject tree, SubLObject old_item_to_new_item_dictionary) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                SubLObject cdolist_list_var = tree;
                SubLObject branch = NIL;
                for (branch = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , branch = cdolist_list_var.first()) {
                    thread.resetMultipleValues();
                    {
                        SubLObject possible_new_branch = dictionary.dictionary_lookup(old_item_to_new_item_dictionary, branch, UNPROVIDED);
                        SubLObject foundP = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        if (NIL != foundP) {
                            result = cons(possible_new_branch, result);
                        } else {
                            if (branch.isList()) {
                                result = cons(com.cyc.cycjava.cycl.list_utilities.tree_substitute_using_dictionary(branch, old_item_to_new_item_dictionary), result);
                            } else {
                                result = cons(branch, result);
                            }
                        }
                    }
                }
                return nreverse(result);
            }
        }
    }

    @LispMethod(comment = "Duplicate the tree and replace all occurrences of tree with new-item.")
    public static SubLObject tree_substitute_using_dictionary(final SubLObject tree, final SubLObject old_item_to_new_item_dictionary) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        SubLObject cdolist_list_var = tree;
        SubLObject branch = NIL;
        branch = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            thread.resetMultipleValues();
            final SubLObject possible_new_branch = dictionary.dictionary_lookup(old_item_to_new_item_dictionary, branch, UNPROVIDED);
            final SubLObject foundP = thread.secondMultipleValue();
            thread.resetMultipleValues();
            if (NIL != foundP) {
                result = cons(possible_new_branch, result);
            } else
                if (branch.isList()) {
                    result = cons(tree_substitute_using_dictionary(branch, old_item_to_new_item_dictionary), result);
                } else {
                    result = cons(branch, result);
                }

            cdolist_list_var = cdolist_list_var.rest();
            branch = cdolist_list_var.first();
        } 
        return nreverse(result);
    }/**
     * Duplicate the tree and replace all occurrences of tree with new-item.
     */


    /**
     * Duplicate the TREE and replace all occurrences of OLD-ITEM in tree by splicing in all NEW-ITEMS.
     */
    @LispMethod(comment = "Duplicate the TREE and replace all occurrences of OLD-ITEM in tree by splicing in all NEW-ITEMS.")
    public static final SubLObject tree_splice_alt(SubLObject tree, SubLObject old_item, SubLObject new_items) {
        {
            SubLObject result = NIL;
            if (!new_items.isList()) {
                new_items = list(new_items);
            }
            {
                SubLObject cdolist_list_var = tree;
                SubLObject branch = NIL;
                for (branch = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , branch = cdolist_list_var.first()) {
                    if (branch.equal(old_item)) {
                        {
                            SubLObject cdolist_list_var_32 = new_items;
                            SubLObject new_item = NIL;
                            for (new_item = cdolist_list_var_32.first(); NIL != cdolist_list_var_32; cdolist_list_var_32 = cdolist_list_var_32.rest() , new_item = cdolist_list_var_32.first()) {
                                result = cons(new_item, result);
                            }
                        }
                    } else {
                        if (branch.isList()) {
                            result = cons(com.cyc.cycjava.cycl.list_utilities.tree_splice(branch, old_item, new_items), result);
                        } else {
                            result = cons(branch, result);
                        }
                    }
                }
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Duplicate the TREE and replace all occurrences of OLD-ITEM in tree by splicing in all NEW-ITEMS.")
    public static SubLObject tree_splice(final SubLObject tree, final SubLObject old_item, SubLObject new_items) {
        SubLObject result = NIL;
        if (!new_items.isList()) {
            new_items = list(new_items);
        }
        SubLObject cdolist_list_var = tree;
        SubLObject branch = NIL;
        branch = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (branch.equal(old_item)) {
                SubLObject cdolist_list_var_$36 = new_items;
                SubLObject new_item = NIL;
                new_item = cdolist_list_var_$36.first();
                while (NIL != cdolist_list_var_$36) {
                    result = cons(new_item, result);
                    cdolist_list_var_$36 = cdolist_list_var_$36.rest();
                    new_item = cdolist_list_var_$36.first();
                } 
            } else
                if (branch.isList()) {
                    result = cons(tree_splice(branch, old_item, new_items), result);
                } else {
                    result = cons(branch, result);
                }

            cdolist_list_var = cdolist_list_var.rest();
            branch = cdolist_list_var.first();
        } 
        return nreverse(result);
    }/**
     * Duplicate the TREE and replace all occurrences of OLD-ITEM in tree by splicing in all NEW-ITEMS.
     */


    /**
     * For every sub-object in OBJECT (including OBJECT) that satisfies PREDICATE, apply FUNCTION to KEY of the sub-object,
     *
     * @return 0 the transformed OBJECT
     * @return 1 a list of transformations made
     * @unknown jantos
     */
    @LispMethod(comment = "For every sub-object in OBJECT (including OBJECT) that satisfies PREDICATE, apply FUNCTION to KEY of the sub-object,\r\n\r\n@return 0 the transformed OBJECT\r\n@return 1 a list of transformations made\r\n@unknown jantos")
    public static final SubLObject tree_gather_transformations_alt(SubLObject function, SubLObject v_object, SubLObject predicate, SubLObject key, SubLObject mappings) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (mappings == UNPROVIDED) {
            mappings = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL != funcall(predicate, v_object)) {
                {
                    SubLObject new_object = funcall(function, funcall(key, v_object));
                    mappings = cons(list(v_object, new_object), mappings);
                    return values(new_object, mappings);
                }
            } else {
                if (v_object.isCons()) {
                    {
                        SubLObject new_object = NIL;
                        SubLObject cdolist_list_var = v_object;
                        SubLObject object_member = NIL;
                        for (object_member = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , object_member = cdolist_list_var.first()) {
                            thread.resetMultipleValues();
                            {
                                SubLObject new_object_member = com.cyc.cycjava.cycl.list_utilities.tree_gather_transformations(function, object_member, predicate, key, UNPROVIDED);
                                SubLObject new_mappings = thread.secondMultipleValue();
                                thread.resetMultipleValues();
                                new_object = cons(new_object_member, new_object);
                                mappings = append(mappings, new_mappings);
                            }
                        }
                        return values(nreverse(new_object), mappings);
                    }
                } else {
                    return values(v_object, mappings);
                }
            }
        }
    }

    @LispMethod(comment = "For every sub-object in OBJECT (including OBJECT) that satisfies PREDICATE, apply FUNCTION to KEY of the sub-object,\r\n\r\n@return 0 the transformed OBJECT\r\n@return 1 a list of transformations made\r\n@unknown jantos")
    public static SubLObject tree_gather_transformations(final SubLObject function, final SubLObject v_object, final SubLObject predicate, SubLObject key, SubLObject mappings) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (mappings == UNPROVIDED) {
            mappings = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (NIL != funcall(predicate, v_object)) {
            final SubLObject new_object = funcall(function, funcall(key, v_object));
            mappings = cons(list(v_object, new_object), mappings);
            return subl_promotions.values2(new_object, mappings);
        }
        if (v_object.isCons()) {
            SubLObject new_object = NIL;
            SubLObject cdolist_list_var = v_object;
            SubLObject object_member = NIL;
            object_member = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                thread.resetMultipleValues();
                final SubLObject new_object_member = tree_gather_transformations(function, object_member, predicate, key, UNPROVIDED);
                final SubLObject new_mappings = thread.secondMultipleValue();
                thread.resetMultipleValues();
                new_object = cons(new_object_member, new_object);
                mappings = append(mappings, new_mappings);
                cdolist_list_var = cdolist_list_var.rest();
                object_member = cdolist_list_var.first();
            } 
            return subl_promotions.values2(nreverse(new_object), mappings);
        }
        return subl_promotions.values2(v_object, mappings);
    }/**
     * For every sub-object in OBJECT (including OBJECT) that satisfies PREDICATE, apply FUNCTION to KEY of the sub-object,
     *
     * @return 0 the transformed OBJECT
     * @return 1 a list of transformations made
     * @unknown jantos
     */


    /**
     * Remove all items from LIST which don't contain every item in OBJECTS
     */
    @LispMethod(comment = "Remove all items from LIST which don\'t contain every item in OBJECTS")
    public static final SubLObject remove_if_doesnt_include_alt(SubLObject list, SubLObject objects) {
        SubLTrampolineFile.checkType(list, LISTP);
        {
            SubLObject ans = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject item = NIL;
            for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                {
                    SubLObject missing = NIL;
                    if (NIL == missing) {
                        {
                            SubLObject csome_list_var = objects;
                            SubLObject v_object = NIL;
                            for (v_object = csome_list_var.first(); !((NIL != missing) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , v_object = csome_list_var.first()) {
                                missing = makeBoolean(NIL == com.cyc.cycjava.cycl.list_utilities.cons_tree_find(v_object, item, UNPROVIDED, UNPROVIDED));
                            }
                        }
                    }
                    if (NIL == missing) {
                        ans = cons(item, ans);
                    }
                }
            }
            return nreverse(ans);
        }
    }

    @LispMethod(comment = "Remove all items from LIST which don\'t contain every item in OBJECTS")
    public static SubLObject remove_if_doesnt_include(final SubLObject list, final SubLObject objects) {
        assert NIL != listp(list) : "! listp(list) " + ("Types.listp(list) " + "CommonSymbols.NIL != Types.listp(list) ") + list;
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject item = NIL;
        item = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject missing = NIL;
            if (NIL == missing) {
                SubLObject csome_list_var;
                SubLObject v_object;
                for (csome_list_var = objects, v_object = NIL, v_object = csome_list_var.first(); (NIL == missing) && (NIL != csome_list_var); missing = makeBoolean(NIL == cons_tree_find(v_object, item, UNPROVIDED, UNPROVIDED)) , csome_list_var = csome_list_var.rest() , v_object = csome_list_var.first()) {
                }
            }
            if (NIL == missing) {
                ans = cons(item, ans);
            }
            cdolist_list_var = cdolist_list_var.rest();
            item = cdolist_list_var.first();
        } 
        return nreverse(ans);
    }/**
     * Remove all items from LIST which don't contain every item in OBJECTS
     */


    /**
     * if a and b are in LIST, and (TEST (KEY a) (KEY b)) is true, don't include b in the result
     */
    @LispMethod(comment = "if a and b are in LIST, and (TEST (KEY a) (KEY b)) is true, don\'t include b in the result")
    public static final SubLObject delete_subsumed_items_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL == list) {
            return NIL;
        } else {
            return com.cyc.cycjava.cycl.list_utilities.delete_subsumed_items_internal(list, test, key);
        }
    }

    @LispMethod(comment = "if a and b are in LIST, and (TEST (KEY a) (KEY b)) is true, don\'t include b in the result")
    public static SubLObject delete_subsumed_items(final SubLObject list, final SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL == list) {
            return NIL;
        }
        return delete_subsumed_items_internal(list, test, key);
    }/**
     * if a and b are in LIST, and (TEST (KEY a) (KEY b)) is true, don't include b in the result
     */


    public static final SubLObject delete_subsumed_items_internal_alt(SubLObject list, SubLObject test, SubLObject key) {
        {
            SubLObject remaining = list;
            while (!((NIL == remaining) || (NIL != com.cyc.cycjava.cycl.list_utilities.singletonP(remaining)))) {
                {
                    SubLObject this_one = nth(ONE_INTEGER, remaining);
                    SubLObject other_items = list;
                    SubLObject subsumedP = NIL;
                    while (!((NIL != subsumedP) || (NIL == other_items))) {
                        if (other_items == remaining.rest()) {
                        } else {
                            if (NIL != com.cyc.cycjava.cycl.list_utilities.subsumedP(this_one, nth(ZERO_INTEGER, other_items), test, key)) {
                                subsumedP = T;
                                com.cyc.cycjava.cycl.list_utilities.delete_nth(ONE_INTEGER, remaining);
                            } else {
                                if (((other_items != remaining) && (NIL != other_items.rest())) && (NIL != com.cyc.cycjava.cycl.list_utilities.subsumesP(this_one, nth(ONE_INTEGER, other_items), test, key))) {
                                    com.cyc.cycjava.cycl.list_utilities.delete_nth(ONE_INTEGER, other_items);
                                }
                            }
                        }
                        other_items = other_items.rest();
                    } 
                    if (NIL == subsumedP) {
                        remaining = remaining.rest();
                    }
                }
            } 
        }
        {
            SubLObject first_item = list.first();
            SubLObject first_item_subsumedP = NIL;
            if (NIL == first_item_subsumedP) {
                {
                    SubLObject csome_list_var = list.rest();
                    SubLObject other_item = NIL;
                    for (other_item = csome_list_var.first(); !((NIL != first_item_subsumedP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , other_item = csome_list_var.first()) {
                        first_item_subsumedP = com.cyc.cycjava.cycl.list_utilities.subsumedP(first_item, other_item, test, key);
                    }
                }
            }
            return NIL != first_item_subsumedP ? ((SubLObject) (list.rest())) : list;
        }
    }

    public static SubLObject delete_subsumed_items_internal(final SubLObject list, final SubLObject test, final SubLObject key) {
        for (SubLObject remaining = list; (NIL != remaining) && (NIL == singletonP(remaining)); remaining = remaining.rest()) {
            final SubLObject this_one = nth(ONE_INTEGER, remaining);
            SubLObject other_items;
            SubLObject subsumedP;
            for (other_items = list, subsumedP = NIL; (NIL == subsumedP) && (NIL != other_items); other_items = other_items.rest()) {
                if (!other_items.eql(remaining.rest())) {
                    if (NIL != subsumedP(this_one, nth(ZERO_INTEGER, other_items), test, key)) {
                        subsumedP = T;
                        delete_nth(ONE_INTEGER, remaining);
                    } else
                        if (((!other_items.eql(remaining)) && (NIL != other_items.rest())) && (NIL != subsumesP(this_one, nth(ONE_INTEGER, other_items), test, key))) {
                            delete_nth(ONE_INTEGER, other_items);
                        }

                }
            }
            if (NIL == subsumedP) {
            }
        }
        final SubLObject first_item = list.first();
        SubLObject first_item_subsumedP = NIL;
        if (NIL == first_item_subsumedP) {
            SubLObject csome_list_var;
            SubLObject other_item;
            for (csome_list_var = list.rest(), other_item = NIL, other_item = csome_list_var.first(); (NIL == first_item_subsumedP) && (NIL != csome_list_var); first_item_subsumedP = subsumedP(first_item, other_item, test, key) , csome_list_var = csome_list_var.rest() , other_item = csome_list_var.first()) {
            }
        }
        return NIL != first_item_subsumedP ? list.rest() : list;
    }

    public static final SubLObject subsumedP_alt(SubLObject item1, SubLObject item2, SubLObject test, SubLObject key) {
        return com.cyc.cycjava.cycl.list_utilities.subsumesP_internal(item2, item1, test, key);
    }

    public static SubLObject subsumedP(final SubLObject item1, final SubLObject item2, final SubLObject test, final SubLObject key) {
        return subsumesP_internal(item2, item1, test, key);
    }

    public static final SubLObject subsumesP_alt(SubLObject item1, SubLObject item2, SubLObject test, SubLObject key) {
        return com.cyc.cycjava.cycl.list_utilities.subsumesP_internal(item1, item2, test, key);
    }

    public static SubLObject subsumesP(final SubLObject item1, final SubLObject item2, final SubLObject test, final SubLObject key) {
        return subsumesP_internal(item1, item2, test, key);
    }

    public static final SubLObject subsumesP_internal_alt(SubLObject item1, SubLObject item2, SubLObject test, SubLObject key) {
        return com.cyc.cycjava.cycl.list_utilities.sublisp_boolean(funcall(test, funcall(key, item1), funcall(key, item2)));
    }

    public static SubLObject subsumesP_internal(final SubLObject item1, final SubLObject item2, final SubLObject test, final SubLObject key) {
        return sublisp_boolean(funcall(test, funcall(key, item1), funcall(key, item2)));
    }

    public static final SubLObject remove_subsumed_items_alt(SubLObject list, SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return com.cyc.cycjava.cycl.list_utilities.delete_subsumed_items(copy_list(list), test, key);
    }

    public static SubLObject remove_subsumed_items(final SubLObject list, final SubLObject test, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        return delete_subsumed_items(copy_list(list), test, key);
    }

    public static final SubLObject cross_products_alt(SubLObject sets) {
        if (length(sets) == ONE_INTEGER) {
            return Mapping.mapcar(symbol_function(LIST), sets.first());
        } else {
            {
                SubLObject sets1 = reverse(sets);
                SubLObject result = com.cyc.cycjava.cycl.list_utilities.map_pairs(second(sets1), sets1.first(), LIST);
                SubLObject cdolist_list_var = cddr(sets1);
                SubLObject v_set = NIL;
                for (v_set = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , v_set = cdolist_list_var.first()) {
                    result = com.cyc.cycjava.cycl.list_utilities.map_pairs(v_set, result, CONS);
                }
                return result;
            }
        }
    }

    public static SubLObject cross_products(final SubLObject sets) {
        if (length(sets).eql(ONE_INTEGER)) {
            return Mapping.mapcar(symbol_function(LIST), sets.first());
        }
        final SubLObject sets2 = reverse(sets);
        SubLObject result = map_pairs(second(sets2), sets2.first(), LIST);
        SubLObject cdolist_list_var = cddr(sets2);
        SubLObject v_set = NIL;
        v_set = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = map_pairs(v_set, result, CONS);
            cdolist_list_var = cdolist_list_var.rest();
            v_set = cdolist_list_var.first();
        } 
        return result;
    }

    public static final SubLObject map_pairs_alt(SubLObject set1, SubLObject set2, SubLObject fn) {
        {
            SubLObject ans = NIL;
            SubLObject cdolist_list_var = set1;
            SubLObject old = NIL;
            for (old = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , old = cdolist_list_var.first()) {
                {
                    SubLObject cdolist_list_var_33 = com.cyc.cycjava.cycl.list_utilities.fn_with_each(old, set2, fn);
                    SubLObject v_new = NIL;
                    for (v_new = cdolist_list_var_33.first(); NIL != cdolist_list_var_33; cdolist_list_var_33 = cdolist_list_var_33.rest() , v_new = cdolist_list_var_33.first()) {
                        ans = cons(v_new, ans);
                    }
                }
            }
            return nreverse(ans);
        }
    }

    public static SubLObject map_pairs(final SubLObject set1, final SubLObject set2, final SubLObject fn) {
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = set1;
        SubLObject old = NIL;
        old = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$37 = fn_with_each(old, set2, fn);
            SubLObject v_new = NIL;
            v_new = cdolist_list_var_$37.first();
            while (NIL != cdolist_list_var_$37) {
                ans = cons(v_new, ans);
                cdolist_list_var_$37 = cdolist_list_var_$37.rest();
                v_new = cdolist_list_var_$37.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            old = cdolist_list_var.first();
        } 
        return nreverse(ans);
    }

    public static final SubLObject fn_with_each_alt(SubLObject sym, SubLObject v_set, SubLObject fn) {
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = v_set;
            SubLObject e = NIL;
            for (e = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , e = cdolist_list_var.first()) {
                result = cons(funcall(fn, sym, e), result);
            }
            return nreverse(result);
        }
    }

    public static SubLObject fn_with_each(final SubLObject sym, final SubLObject v_set, final SubLObject fn) {
        SubLObject result = NIL;
        SubLObject cdolist_list_var = v_set;
        SubLObject e = NIL;
        e = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            result = cons(funcall(fn, sym, e), result);
            cdolist_list_var = cdolist_list_var.rest();
            e = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    public static final SubLObject indexed_products_alt(SubLObject lists) {
        if (NIL != lists) {
            return apply(MAPCAR, cons(LIST, lists));
        }
        return NIL;
    }

    public static SubLObject indexed_products(final SubLObject lists) {
        if (NIL != lists) {
            return apply(MAPCAR, cons(LIST, lists));
        }
        return NIL;
    }

    public static final SubLObject explicate_permutations_alt(SubLObject sets, SubLObject tag) {
        if (tag == UNPROVIDED) {
            tag = NIL;
        }
        {
            SubLObject translation = com.cyc.cycjava.cycl.list_utilities.translate_elements_to_tagged_sets(tag, sets);
            SubLObject permutations = com.cyc.cycjava.cycl.list_utilities.cross_products(translation);
            SubLObject result = com.cyc.cycjava.cycl.list_utilities.untranslate_elements_from_tagged_sets(tag, permutations, UNPROVIDED);
            return result;
        }
    }

    public static SubLObject explicate_permutations(final SubLObject sets, SubLObject tag) {
        if (tag == UNPROVIDED) {
            tag = NIL;
        }
        final SubLObject translation = translate_elements_to_tagged_sets(tag, sets);
        final SubLObject permutations = cross_products(translation);
        final SubLObject result = untranslate_elements_from_tagged_sets(tag, permutations, UNPROVIDED);
        return result;
    }

    public static final SubLObject untranslate_elements_from_tagged_sets_alt(SubLObject tag, SubLObject v_set, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = v_set;
            SubLObject element = NIL;
            for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                if (NIL != subl_promotions.memberP(tag, element, test, UNPROVIDED)) {
                    result = cons(com.cyc.cycjava.cycl.list_utilities.remove_from_end(tag, element, test), result);
                } else {
                    result = cons(element, result);
                }
            }
            return nreverse(result);
        }
    }

    public static SubLObject untranslate_elements_from_tagged_sets(final SubLObject tag, final SubLObject v_set, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        SubLObject result = NIL;
        SubLObject cdolist_list_var = v_set;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != subl_promotions.memberP(tag, element, test, UNPROVIDED)) {
                result = cons(remove_from_end(tag, element, test), result);
            } else {
                result = cons(element, result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    public static final SubLObject translate_elements_to_tagged_sets_alt(SubLObject tag, SubLObject v_set) {
        {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = v_set;
            SubLObject element = NIL;
            for (element = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , element = cdolist_list_var.first()) {
                if (element.isCons()) {
                    result = cons(com.cyc.cycjava.cycl.list_utilities.adjoin_to_end(tag, element, UNPROVIDED), result);
                } else {
                    result = cons(list(element), result);
                }
            }
            return nreverse(result);
        }
    }

    public static SubLObject translate_elements_to_tagged_sets(final SubLObject tag, final SubLObject v_set) {
        SubLObject result = NIL;
        SubLObject cdolist_list_var = v_set;
        SubLObject element = NIL;
        element = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (element.isCons()) {
                result = cons(adjoin_to_end(tag, element, UNPROVIDED), result);
            } else {
                result = cons(list(element), result);
            }
            cdolist_list_var = cdolist_list_var.rest();
            element = cdolist_list_var.first();
        } 
        return nreverse(result);
    }

    /**
     * Return a list of all possible distinct ordered lists of the elements in ELEMENTS.
     * By convention, (permute-list NIL) -> NIL.
     * By convention, if TEST is NIL, the check for duplicates is skipped.
     */
    @LispMethod(comment = "Return a list of all possible distinct ordered lists of the elements in ELEMENTS.\r\nBy convention, (permute-list NIL) -> NIL.\r\nBy convention, if TEST is NIL, the check for duplicates is skipped.\nReturn a list of all possible distinct ordered lists of the elements in ELEMENTS.\nBy convention, (permute-list NIL) -> NIL.\nBy convention, if TEST is NIL, the check for duplicates is skipped.")
    public static final SubLObject permute_list_alt(SubLObject elements, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (NIL == elements) {
            return NIL;
        }
        {
            SubLObject number_of_elements = length(elements);
            SubLObject result = NIL;
            if (NIL == test) {
                {
                    SubLObject cdolist_list_var = com.cyc.cycjava.cycl.list_utilities.all_permutations(length(elements));
                    SubLObject permutation = NIL;
                    for (permutation = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , permutation = cdolist_list_var.first()) {
                        result = cons(com.cyc.cycjava.cycl.list_utilities.permute(elements, permutation), result);
                    }
                }
            } else {
                if (number_of_elements.numL(FIVE_INTEGER)) {
                    {
                        SubLObject cdolist_list_var = com.cyc.cycjava.cycl.list_utilities.all_permutations(length(elements));
                        SubLObject permutation = NIL;
                        for (permutation = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , permutation = cdolist_list_var.first()) {
                            {
                                SubLObject item_var = com.cyc.cycjava.cycl.list_utilities.permute(elements, permutation);
                                if (NIL == member(item_var, result, test, symbol_function(IDENTITY))) {
                                    result = cons(item_var, result);
                                }
                            }
                        }
                    }
                } else {
                    {
                        SubLObject cdolist_list_var = com.cyc.cycjava.cycl.list_utilities.all_permutations(length(elements));
                        SubLObject permutation = NIL;
                        for (permutation = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , permutation = cdolist_list_var.first()) {
                            result = cons(com.cyc.cycjava.cycl.list_utilities.permute(elements, permutation), result);
                        }
                    }
                    result = com.cyc.cycjava.cycl.list_utilities.fast_delete_duplicates(result, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                }
            }
            return result;
        }
    }

    @LispMethod(comment = "Return a list of all possible distinct ordered lists of the elements in ELEMENTS.\r\nBy convention, (permute-list NIL) -> NIL.\r\nBy convention, if TEST is NIL, the check for duplicates is skipped.\nReturn a list of all possible distinct ordered lists of the elements in ELEMENTS.\nBy convention, (permute-list NIL) -> NIL.\nBy convention, if TEST is NIL, the check for duplicates is skipped.")
    public static SubLObject permute_list(final SubLObject elements, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQUAL);
        }
        if (NIL == elements) {
            return NIL;
        }
        final SubLObject number_of_elements = length(elements);
        SubLObject result = NIL;
        if (NIL == test) {
            SubLObject cdolist_list_var = all_permutations(length(elements));
            SubLObject permutation = NIL;
            permutation = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                result = cons(permute(elements, permutation), result);
                cdolist_list_var = cdolist_list_var.rest();
                permutation = cdolist_list_var.first();
            } 
        } else
            if (number_of_elements.numL(FIVE_INTEGER)) {
                SubLObject cdolist_list_var = all_permutations(length(elements));
                SubLObject permutation = NIL;
                permutation = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    final SubLObject item_var = permute(elements, permutation);
                    if (NIL == member(item_var, result, test, symbol_function(IDENTITY))) {
                        result = cons(item_var, result);
                    }
                    cdolist_list_var = cdolist_list_var.rest();
                    permutation = cdolist_list_var.first();
                } 
            } else {
                SubLObject cdolist_list_var = all_permutations(length(elements));
                SubLObject permutation = NIL;
                permutation = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    result = cons(permute(elements, permutation), result);
                    cdolist_list_var = cdolist_list_var.rest();
                    permutation = cdolist_list_var.first();
                } 
                result = fast_delete_duplicates(result, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            }

        return result;
    }/**
     * Return a list of all possible distinct ordered lists of the elements in ELEMENTS.
     * By convention, (permute-list NIL) -> NIL.
     * By convention, if TEST is NIL, the check for duplicates is skipped.
     */


    /**
     * Given a list of elements, return all permutations of the elements
     *
     * @unknown Assumes no two elements are equal with respect to TEST.
     */
    @LispMethod(comment = "Given a list of elements, return all permutations of the elements\r\n\r\n@unknown Assumes no two elements are equal with respect to TEST.")
    public static final SubLObject permute_list_int_alt(SubLObject elements, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        if (NIL == elements) {
            return NIL;
        } else {
            if (elements.isAtom()) {
                return list(elements);
            } else {
                if (NIL == elements.rest()) {
                    return list(elements);
                } else {
                    if (NIL == elements.rest().rest()) {
                        return list(elements, reverse(elements));
                    } else {
                        {
                            SubLObject perms = NIL;
                            SubLObject cdolist_list_var = elements;
                            SubLObject elem = NIL;
                            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                                {
                                    SubLObject cdolist_list_var_34 = com.cyc.cycjava.cycl.list_utilities.permute_list_int(remove(elem, elements, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), UNPROVIDED);
                                    SubLObject perm = NIL;
                                    for (perm = cdolist_list_var_34.first(); NIL != cdolist_list_var_34; cdolist_list_var_34 = cdolist_list_var_34.rest() , perm = cdolist_list_var_34.first()) {
                                        perms = cons(cons(elem, perm), perms);
                                    }
                                }
                            }
                            return perms;
                        }
                    }
                }
            }
        }
    }

    @LispMethod(comment = "Given a list of elements, return all permutations of the elements\r\n\r\n@unknown Assumes no two elements are equal with respect to TEST.")
    public static SubLObject permute_list_int(final SubLObject elements, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        if (NIL == elements) {
            return NIL;
        }
        if (elements.isAtom()) {
            return list(elements);
        }
        if (NIL == elements.rest()) {
            return list(elements);
        }
        if (NIL == elements.rest().rest()) {
            return list(elements, reverse(elements));
        }
        SubLObject perms = NIL;
        SubLObject cdolist_list_var = elements;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$38 = permute_list_int(remove(elem, elements, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), UNPROVIDED);
            SubLObject perm = NIL;
            perm = cdolist_list_var_$38.first();
            while (NIL != cdolist_list_var_$38) {
                perms = cons(cons(elem, perm), perms);
                cdolist_list_var_$38 = cdolist_list_var_$38.rest();
                perm = cdolist_list_var_$38.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        return perms;
    }/**
     * Given a list of elements, return all permutations of the elements
     *
     * @unknown Assumes no two elements are equal with respect to TEST.
     */


    /**
     * Returns all permutations of the numbers from 0 to N-1.
     * By convention, (all-permutations 0) -> (NIL).
     */
    @LispMethod(comment = "Returns all permutations of the numbers from 0 to N-1.\r\nBy convention, (all-permutations 0) -> (NIL).\nReturns all permutations of the numbers from 0 to N-1.\nBy convention, (all-permutations 0) -> (NIL).")
    public static final SubLObject all_permutations_alt(SubLObject n) {
        if (n.numE(ZERO_INTEGER)) {
            return list(NIL);
        } else {
            return com.cyc.cycjava.cycl.list_utilities.permute_list_int(com.cyc.cycjava.cycl.list_utilities.num_list(n, UNPROVIDED), UNPROVIDED);
        }
    }

    @LispMethod(comment = "Returns all permutations of the numbers from 0 to N-1.\r\nBy convention, (all-permutations 0) -> (NIL).\nReturns all permutations of the numbers from 0 to N-1.\nBy convention, (all-permutations 0) -> (NIL).")
    public static SubLObject all_permutations(final SubLObject n) {
        if (n.numE(ZERO_INTEGER)) {
            return list(NIL);
        }
        return permute_list_int(num_list(n, UNPROVIDED), UNPROVIDED);
    }/**
     * Returns all permutations of the numbers from 0 to N-1.
     * By convention, (all-permutations 0) -> (NIL).
     */


    /**
     * A destructive version of @xref sublis-permute.
     */
    @LispMethod(comment = "A destructive version of @xref sublis-permute.")
    public static final SubLObject nsublis_permute_alt(SubLObject list, SubLObject permutation, SubLObject tree) {
        {
            SubLObject alist = NIL;
            SubLObject cdotimes_end_var = length(permutation);
            SubLObject i = NIL;
            for (i = ZERO_INTEGER; i.numL(cdotimes_end_var); i = add(i, ONE_INTEGER)) {
                {
                    SubLObject j = nth(i, permutation);
                    if (!i.numE(j)) {
                        {
                            SubLObject old = nth(i, list);
                            SubLObject v_new = nth(j, list);
                            alist = cons(cons(old, v_new), alist);
                        }
                    }
                }
            }
            return nsublis(alist, tree, UNPROVIDED, UNPROVIDED);
        }
    }

    @LispMethod(comment = "A destructive version of @xref sublis-permute.")
    public static SubLObject nsublis_permute(final SubLObject list, final SubLObject permutation, final SubLObject tree) {
        SubLObject alist = NIL;
        SubLObject cdotimes_end_var;
        SubLObject i;
        SubLObject j;
        SubLObject old;
        SubLObject v_new;
        for (cdotimes_end_var = length(permutation), i = NIL, i = ZERO_INTEGER; i.numL(cdotimes_end_var); i = add(i, ONE_INTEGER)) {
            j = nth(i, permutation);
            if (!i.numE(j)) {
                old = nth(i, list);
                v_new = nth(j, list);
                alist = cons(cons(old, v_new), alist);
            }
        }
        return nsublis(alist, tree, UNPROVIDED, UNPROVIDED);
    }/**
     * A destructive version of @xref sublis-permute.
     */


    /**
     * e.g. (sublis-permute '(a b c) '(2 0 1) '(a b c d)) -> (c a b d)
     */
    @LispMethod(comment = "e.g. (sublis-permute \'(a b c) \'(2 0 1) \'(a b c d)) -> (c a b d)")
    public static final SubLObject sublis_permute_alt(SubLObject list, SubLObject permutation, SubLObject tree) {
        return com.cyc.cycjava.cycl.list_utilities.nsublis_permute(list, permutation, copy_tree(tree));
    }

    @LispMethod(comment = "e.g. (sublis-permute \'(a b c) \'(2 0 1) \'(a b c d)) -> (c a b d)")
    public static SubLObject sublis_permute(final SubLObject list, final SubLObject permutation, final SubLObject tree) {
        return nsublis_permute(list, permutation, copy_tree(tree));
    }/**
     * e.g. (sublis-permute '(a b c) '(2 0 1) '(a b c d)) -> (c a b d)
     */


    /**
     * e.g. (permute '(a b c) '(2 0 1)) -> (c a b)
     * By convention, (permute X NIL) -> X.
     */
    @LispMethod(comment = "e.g. (permute \'(a b c) \'(2 0 1)) -> (c a b)\r\nBy convention, (permute X NIL) -> X.\ne.g. (permute \'(a b c) \'(2 0 1)) -> (c a b)\nBy convention, (permute X NIL) -> X.")
    public static final SubLObject permute_alt(SubLObject list, SubLObject permutation) {
        if (NIL != permutation) {
            {
                SubLObject result = NIL;
                SubLObject cdolist_list_var = permutation;
                SubLObject elem = NIL;
                for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                    result = cons(nth(elem, list), result);
                }
                return nreverse(result);
            }
        } else {
            return list;
        }
    }

    @LispMethod(comment = "e.g. (permute \'(a b c) \'(2 0 1)) -> (c a b)\r\nBy convention, (permute X NIL) -> X.\ne.g. (permute \'(a b c) \'(2 0 1)) -> (c a b)\nBy convention, (permute X NIL) -> X.")
    public static SubLObject permute(final SubLObject list, final SubLObject permutation) {
        if (NIL != permutation) {
            SubLObject result = NIL;
            SubLObject cdolist_list_var = permutation;
            SubLObject elem = NIL;
            elem = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                result = cons(nth(elem, list), result);
                cdolist_list_var = cdolist_list_var.rest();
                elem = cdolist_list_var.first();
            } 
            return nreverse(result);
        }
        return list;
    }/**
     * e.g. (permute '(a b c) '(2 0 1)) -> (c a b)
     * By convention, (permute X NIL) -> X.
     */


    /**
     * Return a random ordering of LIST without recursion.
     */
    @LispMethod(comment = "Return a random ordering of LIST without recursion.")
    public static final SubLObject random_permutation_alt(SubLObject list) {
        {
            SubLObject random_index = NIL;
            SubLObject remaining_list = list;
            SubLObject permuted_list = NIL;
            if (NIL == list) {
                return NIL;
            }
            while (true) {
                if (NIL != com.cyc.cycjava.cycl.list_utilities.singletonP(remaining_list)) {
                    return cons(remaining_list.first(), permuted_list);
                }
                random_index = random.random(length(remaining_list));
                permuted_list = cons(nth(random_index, remaining_list), permuted_list);
                remaining_list = com.cyc.cycjava.cycl.list_utilities.remove_nth(random_index, remaining_list);
            } 
        }
    }

    @LispMethod(comment = "Return a random ordering of LIST without recursion.")
    public static SubLObject random_permutation(final SubLObject list) {
        SubLObject random_index = NIL;
        SubLObject remaining_list = list;
        SubLObject permuted_list = NIL;
        if (NIL == list) {
            return NIL;
        }
        while (NIL == singletonP(remaining_list)) {
            random_index = random.random(length(remaining_list));
            permuted_list = cons(nth(random_index, remaining_list), permuted_list);
            remaining_list = remove_nth(random_index, remaining_list);
        } 
        return cons(remaining_list.first(), permuted_list);
    }/**
     * Return a random ordering of LIST without recursion.
     */


    /**
     *
     *
     * @return listp; a list of lists.
    Each element is a list of length N containing unique numbers between 0 and MAX-1.
    All possible such lists are returned.
     */
    @LispMethod(comment = "@return listp; a list of lists.\r\nEach element is a list of length N containing unique numbers between 0 and MAX-1.\r\nAll possible such lists are returned.")
    public static final SubLObject choose_n_between_alt(SubLObject n, SubLObject max) {
        {
            SubLObject result = NIL;
            if (n.numE(ONE_INTEGER)) {
                {
                    SubLObject i = NIL;
                    for (i = ZERO_INTEGER; i.numL(max); i = add(i, ONE_INTEGER)) {
                        result = cons(list(i), result);
                    }
                }
            } else {
                {
                    SubLObject shorter_lists = com.cyc.cycjava.cycl.list_utilities.choose_n_between(number_utilities.f_1_(n), max);
                    SubLObject cdolist_list_var = shorter_lists;
                    SubLObject list = NIL;
                    for (list = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , list = cdolist_list_var.first()) {
                        {
                            SubLObject i = NIL;
                            for (i = ZERO_INTEGER; i.numL(max); i = add(i, ONE_INTEGER)) {
                                if (NIL == subl_promotions.memberP(i, list, UNPROVIDED, UNPROVIDED)) {
                                    result = cons(append(list, list(i)), result);
                                }
                            }
                        }
                    }
                }
            }
            return nreverse(result);
        }
    }

    /**
     *
     *
     * @return listp; a list of lists.
    Each element is a list of length N containing unique numbers between 0 and MAX-1.
    All possible such lists are returned.
     */
    @LispMethod(comment = "@return listp; a list of lists.\r\nEach element is a list of length N containing unique numbers between 0 and MAX-1.\r\nAll possible such lists are returned.")
    public static SubLObject choose_n_between(final SubLObject n, final SubLObject max) {
        SubLObject result = NIL;
        if (n.numE(ONE_INTEGER)) {
            SubLObject i;
            for (i = NIL, i = ZERO_INTEGER; i.numL(max); i = add(i, ONE_INTEGER)) {
                result = cons(list(i), result);
            }
        } else {
            SubLObject cdolist_list_var;
            final SubLObject shorter_lists = cdolist_list_var = choose_n_between(number_utilities.f_1_(n), max);
            SubLObject list = NIL;
            list = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject j;
                for (j = NIL, j = ZERO_INTEGER; j.numL(max); j = add(j, ONE_INTEGER)) {
                    if (NIL == subl_promotions.memberP(j, list, UNPROVIDED, UNPROVIDED)) {
                        result = cons(append(list, list(j)), result);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                list = cdolist_list_var.first();
            } 
        }
        return nreverse(result);
    }

    /**
     * Performs trigram transformation using TRIGRAM-RULES on OBJECT-LIST.
     * START-TOKEN and END-TOKEN are the tokens the rules expect around the object list
     */
    @LispMethod(comment = "Performs trigram transformation using TRIGRAM-RULES on OBJECT-LIST.\r\nSTART-TOKEN and END-TOKEN are the tokens the rules expect around the object list\nPerforms trigram transformation using TRIGRAM-RULES on OBJECT-LIST.\nSTART-TOKEN and END-TOKEN are the tokens the rules expect around the object list")
    public static final SubLObject trigram_transform_alt(SubLObject object_list, SubLObject trigram_rules, SubLObject start_token, SubLObject end_token) {
        if (start_token == UNPROVIDED) {
            start_token = NIL;
        }
        if (end_token == UNPROVIDED) {
            end_token = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(object_list, LISTP);
            if (NIL != object_list) {
                {
                    SubLObject expanded_object_list = cons(start_token, object_list);
                    try {
                        rplacd(last(expanded_object_list, UNPROVIDED), cons(end_token, NIL));
                        while (NIL != cddr(expanded_object_list)) {
                            {
                                SubLObject datum = expanded_object_list;
                                SubLObject current = datum;
                                SubLObject one = NIL;
                                SubLObject two = NIL;
                                SubLObject three = NIL;
                                SubLObject rest = NIL;
                                destructuring_bind_must_consp(current, datum, $list_alt183);
                                one = current.first();
                                current = current.rest();
                                destructuring_bind_must_consp(current, datum, $list_alt183);
                                two = current.first();
                                current = current.rest();
                                destructuring_bind_must_consp(current, datum, $list_alt183);
                                three = current.first();
                                current = current.rest();
                                rest = current;
                                {
                                    SubLObject cdolist_list_var = trigram_rules;
                                    SubLObject trigram = NIL;
                                    for (trigram = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , trigram = cdolist_list_var.first()) {
                                        if (trigram.isFunctionSpec()) {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject changeP = funcall(trigram, one, two, three);
                                                SubLObject new_one = thread.secondMultipleValue();
                                                SubLObject new_two = thread.thirdMultipleValue();
                                                SubLObject new_three = thread.fourthMultipleValue();
                                                thread.resetMultipleValues();
                                                if (NIL != changeP) {
                                                    if (one != new_one) {
                                                        set_nth(ZERO_INTEGER, expanded_object_list, new_one);
                                                    }
                                                    if (two != new_two) {
                                                        set_nth(ONE_INTEGER, expanded_object_list, new_two);
                                                    }
                                                    if (three != new_three) {
                                                        set_nth(TWO_INTEGER, expanded_object_list, new_three);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            expanded_object_list = expanded_object_list.rest();
                        } 
                    } finally {
                        {
                            SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
                            try {
                                $is_thread_performing_cleanupP$.bind(T, thread);
                                rplacd(last(expanded_object_list, TWO_INTEGER), NIL);
                            } finally {
                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
            }
            return object_list;
        }
    }

    @LispMethod(comment = "Performs trigram transformation using TRIGRAM-RULES on OBJECT-LIST.\r\nSTART-TOKEN and END-TOKEN are the tokens the rules expect around the object list\nPerforms trigram transformation using TRIGRAM-RULES on OBJECT-LIST.\nSTART-TOKEN and END-TOKEN are the tokens the rules expect around the object list")
    public static SubLObject trigram_transform(final SubLObject object_list, final SubLObject trigram_rules, SubLObject start_token, SubLObject end_token) {
        if (start_token == UNPROVIDED) {
            start_token = NIL;
        }
        if (end_token == UNPROVIDED) {
            end_token = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != listp(object_list) : "! listp(object_list) " + ("Types.listp(object_list) " + "CommonSymbols.NIL != Types.listp(object_list) ") + object_list;
        if (NIL != object_list) {
            SubLObject expanded_object_list = cons(start_token, object_list);
            try {
                rplacd(last(expanded_object_list, UNPROVIDED), cons(end_token, NIL));
                while (NIL != cddr(expanded_object_list)) {
                    SubLObject current;
                    final SubLObject datum = current = expanded_object_list;
                    SubLObject one = NIL;
                    SubLObject two = NIL;
                    SubLObject three = NIL;
                    SubLObject rest = NIL;
                    destructuring_bind_must_consp(current, datum, $list191);
                    one = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list191);
                    two = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list191);
                    three = current.first();
                    current = rest = current.rest();
                    SubLObject cdolist_list_var = trigram_rules;
                    SubLObject trigram = NIL;
                    trigram = cdolist_list_var.first();
                    while (NIL != cdolist_list_var) {
                        if (trigram.isFunctionSpec()) {
                            thread.resetMultipleValues();
                            final SubLObject changeP = funcall(trigram, one, two, three);
                            final SubLObject new_one = thread.secondMultipleValue();
                            final SubLObject new_two = thread.thirdMultipleValue();
                            final SubLObject new_three = thread.fourthMultipleValue();
                            thread.resetMultipleValues();
                            if (NIL != changeP) {
                                if (!one.eql(new_one)) {
                                    set_nth(ZERO_INTEGER, expanded_object_list, new_one);
                                }
                                if (!two.eql(new_two)) {
                                    set_nth(ONE_INTEGER, expanded_object_list, new_two);
                                }
                                if (!three.eql(new_three)) {
                                    set_nth(TWO_INTEGER, expanded_object_list, new_three);
                                }
                            }
                        }
                        cdolist_list_var = cdolist_list_var.rest();
                        trigram = cdolist_list_var.first();
                    } 
                    expanded_object_list = expanded_object_list.rest();
                } 
            } finally {
                final SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
                try {
                    $is_thread_performing_cleanupP$.bind(T, thread);
                    final SubLObject _values = getValuesAsVector();
                    rplacd(last(expanded_object_list, TWO_INTEGER), NIL);
                    restoreValuesFromVector(_values);
                } finally {
                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
                }
            }
        }
        return object_list;
    }/**
     * Performs trigram transformation using TRIGRAM-RULES on OBJECT-LIST.
     * START-TOKEN and END-TOKEN are the tokens the rules expect around the object list
     */


    /**
     * Returns a list of sublists of the list LST. Each sublist will be of size N,
     * except possibly for the last. The last sublist will have size < N just in case
     * N does not divide (LENGTH LST).  Nondestructive, but will not recursively
     * copy tree structure.
     */
    @LispMethod(comment = "Returns a list of sublists of the list LST. Each sublist will be of size N,\r\nexcept possibly for the last. The last sublist will have size < N just in case\r\nN does not divide (LENGTH LST).  Nondestructive, but will not recursively\r\ncopy tree structure.\nReturns a list of sublists of the list LST. Each sublist will be of size N,\nexcept possibly for the last. The last sublist will have size < N just in case\nN does not divide (LENGTH LST).  Nondestructive, but will not recursively\ncopy tree structure.")
    public static final SubLObject chunk_alt(SubLObject lst, SubLObject n) {
        SubLTrampolineFile.checkType(n, INTEGERP);
        if (n.numLE(ZERO_INTEGER)) {
            return NIL;
        }
        if (NIL == lst) {
            return NIL;
        }
        {
            SubLObject cur_list = NIL;
            SubLObject cur_item = NIL;
            SubLObject output = NIL;
            SubLObject i = NIL;
            for (cur_list = lst, cur_item = cur_list.first(), output = list(NIL), i = ZERO_INTEGER; NIL != cur_list; cur_list = cur_list.rest() , cur_item = cur_list.first() , output = output , i = add(i, ONE_INTEGER)) {
                if (i.numL(n)) {
                    rplaca(output, cons(cur_item, output.first()));
                } else {
                    rplaca(output, nreverse(output.first()));
                    output = cons(list(cur_item), output);
                    i = ZERO_INTEGER;
                }
            }
            rplaca(output, nreverse(output.first()));
            return nreverse(output);
        }
    }

    @LispMethod(comment = "Returns a list of sublists of the list LST. Each sublist will be of size N,\r\nexcept possibly for the last. The last sublist will have size < N just in case\r\nN does not divide (LENGTH LST).  Nondestructive, but will not recursively\r\ncopy tree structure.\nReturns a list of sublists of the list LST. Each sublist will be of size N,\nexcept possibly for the last. The last sublist will have size < N just in case\nN does not divide (LENGTH LST).  Nondestructive, but will not recursively\ncopy tree structure.")
    public static SubLObject chunk(final SubLObject lst, final SubLObject n) {
        assert NIL != integerp(n) : "! integerp(n) " + ("Types.integerp(n) " + "CommonSymbols.NIL != Types.integerp(n) ") + n;
        if (n.numLE(ZERO_INTEGER)) {
            return NIL;
        }
        if (NIL == lst) {
            return NIL;
        }
        SubLObject cur_list = NIL;
        SubLObject cur_item = NIL;
        SubLObject output = NIL;
        SubLObject i = NIL;
        cur_list = lst;
        cur_item = cur_list.first();
        output = list(NIL);
        // output = output,
        for (i = ZERO_INTEGER; NIL != cur_list; cur_list = cur_list.rest() , cur_item = cur_list.first() , i = add(i, ONE_INTEGER)) {
            if (i.numL(n)) {
                rplaca(output, cons(cur_item, output.first()));
            } else {
                rplaca(output, nreverse(output.first()));
                output = cons(list(cur_item), output);
                i = ZERO_INTEGER;
            }
        }
        rplaca(output, nreverse(output.first()));
        return nreverse(output);
    }/**
     * Returns a list of sublists of the list LST. Each sublist will be of size N,
     * except possibly for the last. The last sublist will have size < N just in case
     * N does not divide (LENGTH LST).  Nondestructive, but will not recursively
     * copy tree structure.
     */


    public static final SubLObject get_arglist_alt(SubLObject symbol) {
        return subl_promotions.function_symbol_arglist(symbol);
    }

    public static SubLObject get_arglist(final SubLObject symbol) {
        return subl_promotions.function_symbol_arglist(symbol);
    }

    public static final SubLObject get_documentation_alt(SubLObject symbol) {
        {
            SubLObject v_answer = NIL;
            if (symbol.isSymbol()) {
                if (NIL == v_answer) {
                    v_answer = second(get(symbol, $DOCUMENTATION, NIL));
                }
            }
            return v_answer;
        }
    }

    public static SubLObject get_documentation(final SubLObject symbol) {
        SubLObject v_answer = NIL;
        if (symbol.isSymbol() && (NIL == v_answer)) {
            v_answer = second(get(symbol, $DOCUMENTATION, NIL));
        }
        return v_answer;
    }

    /**
     * Push OBJECT onto the first list in LIST.  The first element of LIST must be a list (or nil).  Used in conjunction with @xref pop-and-reverse-car-and-push-on-cadr.
     *
     * @return list
     * @param LIST
    list
     * 		
     * @param OBJECT
    object
     * 		
     * @see listify-string for example usage.
     */
    @LispMethod(comment = "Push OBJECT onto the first list in LIST.  The first element of LIST must be a list (or nil).  Used in conjunction with @xref pop-and-reverse-car-and-push-on-cadr.\r\n\r\n@return list\r\n@param LIST\nlist\r\n\t\t\r\n@param OBJECT\nobject\r\n\t\t\r\n@see listify-string for example usage.")
    public static final SubLObject push_on_car_alt(SubLObject list, SubLObject v_object) {
        {
            SubLObject car_list = list.first();
            SubLObject cdr_list = list.rest();
            if (NIL == car_list) {
                return cons(list(v_object), cdr_list);
            } else {
                return cons(append(list(v_object), car_list), cdr_list);
            }
        }
    }

    @LispMethod(comment = "Push OBJECT onto the first list in LIST.  The first element of LIST must be a list (or nil).  Used in conjunction with @xref pop-and-reverse-car-and-push-on-cadr.\r\n\r\n@return list\r\n@param LIST\n\t\tlist\r\n\t\t\r\n@param OBJECT\n\t\tobject\r\n\t\t\r\n@see listify-string for example usage.")
    public static SubLObject push_on_car(final SubLObject list, final SubLObject v_object) {
        final SubLObject car_list = list.first();
        final SubLObject cdr_list = list.rest();
        if (NIL == car_list) {
            return cons(list(v_object), cdr_list);
        }
        return cons(append(list(v_object), car_list), cdr_list);
    }/**
     * Push OBJECT onto the first list in LIST.  The first element of LIST must be a list (or nil).  Used in conjunction with @xref pop-and-reverse-car-and-push-on-cadr.
     *
     * @return list
     * @param LIST
    		list
     * 		
     * @param OBJECT
    		object
     * 		
     * @see listify-string for example usage.
     */


    /**
     * Pop the car off LIST and push it onto the cadr of LIST (which must be a list).  And reverse the car since @xref push-on-car doesn't add to the end of the first list.
     *
     * @return list
     * @param LIST
    list
     * 		
     * @see listify-string for example usage.
     */
    @LispMethod(comment = "Pop the car off LIST and push it onto the cadr of LIST (which must be a list).  And reverse the car since @xref push-on-car doesn\'t add to the end of the first list.\r\n\r\n@return list\r\n@param LIST\nlist\r\n\t\t\r\n@see listify-string for example usage.")
    public static final SubLObject pop_and_reverse_car_and_push_on_cadr_alt(SubLObject list) {
        {
            SubLObject car_list = nreverse(list.first());
            SubLObject cdr_list = list.rest();
            if (NIL == car_list) {
                return com.cyc.cycjava.cycl.list_utilities.push_on_car(cdr_list, NIL);
            } else {
                return com.cyc.cycjava.cycl.list_utilities.push_on_car(cdr_list, car_list);
            }
        }
    }

    @LispMethod(comment = "Pop the car off LIST and push it onto the cadr of LIST (which must be a list).  And reverse the car since @xref push-on-car doesn\'t add to the end of the first list.\r\n\r\n@return list\r\n@param LIST\n\t\tlist\r\n\t\t\r\n@see listify-string for example usage.")
    public static SubLObject pop_and_reverse_car_and_push_on_cadr(final SubLObject list) {
        final SubLObject car_list = nreverse(list.first());
        final SubLObject cdr_list = list.rest();
        if (NIL == car_list) {
            return push_on_car(cdr_list, NIL);
        }
        return push_on_car(cdr_list, car_list);
    }/**
     * Pop the car off LIST and push it onto the cadr of LIST (which must be a list).  And reverse the car since @xref push-on-car doesn't add to the end of the first list.
     *
     * @return list
     * @param LIST
    		list
     * 		
     * @see listify-string for example usage.
     */


    /**
     *
     *
     * @param l;
     * 		listp: a list of lists
     * @param fun;
     * 		fboundp: an optional function to build the product
     * @param start;
     * 		listp: an optional seed for building the product
     * @param test;
     * 		fboundp (binary function) or nil
     * @unknown list: the cartesian product of the elements of l
     */
    @LispMethod(comment = "@param l;\r\n\t\tlistp: a list of lists\r\n@param fun;\r\n\t\tfboundp: an optional function to build the product\r\n@param start;\r\n\t\tlistp: an optional seed for building the product\r\n@param test;\r\n\t\tfboundp (binary function) or nil\r\n@unknown list: the cartesian product of the elements of l")
    public static final SubLObject cartesian_product_alt(SubLObject l, SubLObject fun, SubLObject start, SubLObject test) {
        if (fun == UNPROVIDED) {
            fun = symbol_function(CONS);
        }
        if (start == UNPROVIDED) {
            start = NIL;
        }
        if (test == UNPROVIDED) {
            test = NIL;
        }
        {
            SubLObject accum = list(start);
            if (NIL != fboundp(test)) {
                {
                    SubLObject cdolist_list_var = l;
                    SubLObject this_one = NIL;
                    for (this_one = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , this_one = cdolist_list_var.first()) {
                        accum = com.cyc.cycjava.cycl.list_utilities.cartesian_helper_with_test(this_one, accum, fun, test);
                    }
                }
            } else {
                {
                    SubLObject cdolist_list_var = l;
                    SubLObject this_one = NIL;
                    for (this_one = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , this_one = cdolist_list_var.first()) {
                        accum = com.cyc.cycjava.cycl.list_utilities.cartesian_helper(this_one, accum, fun);
                    }
                }
            }
            return com.cyc.cycjava.cycl.list_utilities.nmapcar(symbol_function(REVERSE), accum);
        }
    }

    /**
     *
     *
     * @param l;
     * 		listp: a list of lists
     * @param fun;
     * 		fboundp: an optional function to build the product
     * @param start;
     * 		listp: an optional seed for building the product
     * @param test;
     * 		fboundp (binary function) or nil
     * @unknown list: the cartesian product of the elements of l
     */
    @LispMethod(comment = "@param l;\r\n\t\tlistp: a list of lists\r\n@param fun;\r\n\t\tfboundp: an optional function to build the product\r\n@param start;\r\n\t\tlistp: an optional seed for building the product\r\n@param test;\r\n\t\tfboundp (binary function) or nil\r\n@unknown list: the cartesian product of the elements of l")
    public static SubLObject cartesian_product(final SubLObject l, SubLObject fun, SubLObject start, SubLObject test) {
        if (fun == UNPROVIDED) {
            fun = symbol_function(CONS);
        }
        if (start == UNPROVIDED) {
            start = NIL;
        }
        if (test == UNPROVIDED) {
            test = NIL;
        }
        SubLObject accum = list(start);
        if (NIL != fboundp(test)) {
            SubLObject cdolist_list_var = l;
            SubLObject this_one = NIL;
            this_one = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                accum = cartesian_helper_with_test(this_one, accum, fun, test);
                cdolist_list_var = cdolist_list_var.rest();
                this_one = cdolist_list_var.first();
            } 
        } else {
            SubLObject cdolist_list_var = l;
            SubLObject this_one = NIL;
            this_one = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                accum = cartesian_helper(this_one, accum, fun);
                cdolist_list_var = cdolist_list_var.rest();
                this_one = cdolist_list_var.first();
            } 
        }
        return nmapcar(symbol_function(REVERSE), accum);
    }

    public static SubLObject cartesian_product_cardinality(final SubLObject l) {
        return apply($sym195$_, Mapping.mapcar(LENGTH, l));
    }

    /**
     * takes two lists and returns the cartesian product.  fun generally should be #'cons
     */
    @LispMethod(comment = "takes two lists and returns the cartesian product.  fun generally should be #\'cons")
    public static final SubLObject cartesian_helper_alt(SubLObject a, SubLObject b, SubLObject fun) {
        {
            SubLObject accum = NIL;
            SubLObject cdolist_list_var = b;
            SubLObject b_er = NIL;
            for (b_er = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , b_er = cdolist_list_var.first()) {
                {
                    SubLObject cdolist_list_var_35 = a;
                    SubLObject a_er = NIL;
                    for (a_er = cdolist_list_var_35.first(); NIL != cdolist_list_var_35; cdolist_list_var_35 = cdolist_list_var_35.rest() , a_er = cdolist_list_var_35.first()) {
                        accum = cons(funcall(fun, a_er, b_er), accum);
                    }
                }
            }
            return nreverse(accum);
        }
    }

    @LispMethod(comment = "takes two lists and returns the cartesian product.  fun generally should be #\'cons")
    public static SubLObject cartesian_helper(final SubLObject a, final SubLObject b, final SubLObject fun) {
        SubLObject accum = NIL;
        SubLObject cdolist_list_var = b;
        SubLObject b_er = NIL;
        b_er = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$39 = a;
            SubLObject a_er = NIL;
            a_er = cdolist_list_var_$39.first();
            while (NIL != cdolist_list_var_$39) {
                accum = cons(funcall(fun, a_er, b_er), accum);
                cdolist_list_var_$39 = cdolist_list_var_$39.rest();
                a_er = cdolist_list_var_$39.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            b_er = cdolist_list_var.first();
        } 
        return nreverse(accum);
    }/**
     * takes two lists and returns the cartesian product.  fun generally should be #'cons
     */


    /**
     * takes two lists and returns the cartesian product.  FUN generally should be #'cons.
     * TEST must be a binary function and is used in eliminating some elements of the resulting cartesian product at construction time
     */
    @LispMethod(comment = "takes two lists and returns the cartesian product.  FUN generally should be #\'cons.\r\nTEST must be a binary function and is used in eliminating some elements of the resulting cartesian product at construction time\ntakes two lists and returns the cartesian product.  FUN generally should be #\'cons.\nTEST must be a binary function and is used in eliminating some elements of the resulting cartesian product at construction time")
    public static final SubLObject cartesian_helper_with_test_alt(SubLObject a, SubLObject b, SubLObject fun, SubLObject test) {
        {
            SubLObject accum = NIL;
            SubLObject cdolist_list_var = b;
            SubLObject b_er = NIL;
            for (b_er = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , b_er = cdolist_list_var.first()) {
                {
                    SubLObject cdolist_list_var_36 = a;
                    SubLObject a_er = NIL;
                    for (a_er = cdolist_list_var_36.first(); NIL != cdolist_list_var_36; cdolist_list_var_36 = cdolist_list_var_36.rest() , a_er = cdolist_list_var_36.first()) {
                        if (NIL != funcall(test, a_er, b_er)) {
                            accum = cons(funcall(fun, a_er, b_er), accum);
                        }
                    }
                }
            }
            return nreverse(accum);
        }
    }

    @LispMethod(comment = "takes two lists and returns the cartesian product.  FUN generally should be #\'cons.\r\nTEST must be a binary function and is used in eliminating some elements of the resulting cartesian product at construction time\ntakes two lists and returns the cartesian product.  FUN generally should be #\'cons.\nTEST must be a binary function and is used in eliminating some elements of the resulting cartesian product at construction time")
    public static SubLObject cartesian_helper_with_test(final SubLObject a, final SubLObject b, final SubLObject fun, final SubLObject test) {
        SubLObject accum = NIL;
        SubLObject cdolist_list_var = b;
        SubLObject b_er = NIL;
        b_er = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$40 = a;
            SubLObject a_er = NIL;
            a_er = cdolist_list_var_$40.first();
            while (NIL != cdolist_list_var_$40) {
                if (NIL != funcall(test, a_er, b_er)) {
                    accum = cons(funcall(fun, a_er, b_er), accum);
                }
                cdolist_list_var_$40 = cdolist_list_var_$40.rest();
                a_er = cdolist_list_var_$40.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            b_er = cdolist_list_var.first();
        } 
        return nreverse(accum);
    }/**
     * takes two lists and returns the cartesian product.  FUN generally should be #'cons.
     * TEST must be a binary function and is used in eliminating some elements of the resulting cartesian product at construction time
     */


    /**
     * given a list, produce all sets that contain exactly two members of LIST.
     * The order of the items in the sets is arbitrary, even though they are represented
     * as lists.  This function treats each member of the LIST as a distinct element, even if
     * it's a duplicate of something else in the list
     *
     * @unknown (pick-two '(1 2 3)) ((1 2) (1 3) (2 3))
     * @unknown (pick-two '(1 1 2)) ((1 1) (1 2) (1 2))
     * @unknown (pick-two '(1)) ()
     * @unknown daves
     */
    @LispMethod(comment = "given a list, produce all sets that contain exactly two members of LIST.\r\nThe order of the items in the sets is arbitrary, even though they are represented\r\nas lists.  This function treats each member of the LIST as a distinct element, even if\r\nit\'s a duplicate of something else in the list\r\n\r\n@unknown (pick-two \'(1 2 3)) ((1 2) (1 3) (2 3))\r\n@unknown (pick-two \'(1 1 2)) ((1 1) (1 2) (1 2))\r\n@unknown (pick-two \'(1)) ()\r\n@unknown daves\ngiven a list, produce all sets that contain exactly two members of LIST.\nThe order of the items in the sets is arbitrary, even though they are represented\nas lists.  This function treats each member of the LIST as a distinct element, even if\nit\'s a duplicate of something else in the list")
    public static final SubLObject pick_two_alt(SubLObject lyst) {
        {
            SubLObject result = NIL;
            SubLObject list1 = NIL;
            for (list1 = lyst; NIL == com.cyc.cycjava.cycl.list_utilities.lengthL(list1, TWO_INTEGER, UNPROVIDED); list1 = list1.rest()) {
                {
                    SubLObject cdolist_list_var = list1.rest();
                    SubLObject item2 = NIL;
                    for (item2 = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item2 = cdolist_list_var.first()) {
                        result = cons(list(list1.first(), item2), result);
                    }
                }
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "given a list, produce all sets that contain exactly two members of LIST.\r\nThe order of the items in the sets is arbitrary, even though they are represented\r\nas lists.  This function treats each member of the LIST as a distinct element, even if\r\nit\'s a duplicate of something else in the list\r\n\r\n@unknown (pick-two \'(1 2 3)) ((1 2) (1 3) (2 3))\r\n@unknown (pick-two \'(1 1 2)) ((1 1) (1 2) (1 2))\r\n@unknown (pick-two \'(1)) ()\r\n@unknown daves\ngiven a list, produce all sets that contain exactly two members of LIST.\nThe order of the items in the sets is arbitrary, even though they are represented\nas lists.  This function treats each member of the LIST as a distinct element, even if\nit\'s a duplicate of something else in the list")
    public static SubLObject pick_two(final SubLObject lyst) {
        SubLObject result = NIL;
        SubLObject list1;
        SubLObject cdolist_list_var;
        SubLObject item2;
        for (list1 = NIL, list1 = lyst; NIL == lengthL(list1, TWO_INTEGER, UNPROVIDED); list1 = list1.rest()) {
            cdolist_list_var = list1.rest();
            item2 = NIL;
            item2 = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                result = cons(list(list1.first(), item2), result);
                cdolist_list_var = cdolist_list_var.rest();
                item2 = cdolist_list_var.first();
            } 
        }
        return nreverse(result);
    }/**
     * given a list, produce all sets that contain exactly two members of LIST.
     * The order of the items in the sets is arbitrary, even though they are represented
     * as lists.  This function treats each member of the LIST as a distinct element, even if
     * it's a duplicate of something else in the list
     *
     * @unknown (pick-two '(1 2 3)) ((1 2) (1 3) (2 3))
     * @unknown (pick-two '(1 1 2)) ((1 1) (1 2) (1 2))
     * @unknown (pick-two '(1)) ()
     * @unknown daves
     */


    /**
     *
     *
     * @unknown mahler
     */
    @LispMethod(comment = "@unknown mahler")
    public static final SubLObject mapexp_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt187);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject result = NIL;
                    SubLObject var = NIL;
                    SubLObject list = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt187);
                    result = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt187);
                    var = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list_alt187);
                    list = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        current = temp;
                        {
                            SubLObject exp = NIL;
                            destructuring_bind_must_consp(current, datum, $list_alt187);
                            exp = current.first();
                            current = current.rest();
                            {
                                SubLObject body = current;
                                return listS(CLET, list(bq_cons(result, $list_alt72)), list(CDOLIST, list(var, list(REVERSE, list)), list(CPUSH, exp, result)), append(body, NIL));
                            }
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list_alt187);
                    }
                }
            }
        }
        return NIL;
    }

    /**
     *
     *
     * @unknown mahler
     */
    @LispMethod(comment = "@unknown mahler")
    public static SubLObject mapexp(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list196);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject result = NIL;
        SubLObject var = NIL;
        SubLObject list = NIL;
        destructuring_bind_must_consp(current, datum, $list196);
        result = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list196);
        var = current.first();
        current = current.rest();
        destructuring_bind_must_consp(current, datum, $list196);
        list = current.first();
        current = current.rest();
        if (NIL == current) {
            current = temp;
            SubLObject exp = NIL;
            destructuring_bind_must_consp(current, datum, $list196);
            exp = current.first();
            final SubLObject body;
            current = body = current.rest();
            return listS(CLET, list(bq_cons(result, $list72)), list(CDOLIST, list(var, list(REVERSE, list)), list(CPUSH, exp, result)), append(body, NIL));
        }
        cdestructuring_bind_error(datum, $list196);
        return NIL;
    }

    /**
     * A recursive form of member
     */
    @LispMethod(comment = "A recursive form of member")
    public static final SubLObject recursive_member_alt(SubLObject elem, SubLObject form, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != funcall(test, elem, form)) {
            return T;
        } else {
            if (form.isList()) {
                {
                    SubLObject cdolist_list_var = form;
                    SubLObject rec = NIL;
                    for (rec = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , rec = cdolist_list_var.first()) {
                        if (NIL != com.cyc.cycjava.cycl.list_utilities.recursive_member(elem, rec, test)) {
                            return T;
                        }
                    }
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "A recursive form of member")
    public static SubLObject recursive_member(final SubLObject elem, final SubLObject form, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (NIL != funcall(test, elem, form)) {
            return T;
        }
        if (form.isList()) {
            SubLObject cdolist_list_var = form;
            SubLObject rec = NIL;
            rec = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != recursive_member(elem, rec, test)) {
                    return T;
                }
                cdolist_list_var = cdolist_list_var.rest();
                rec = cdolist_list_var.first();
            } 
        }
        return NIL;
    }/**
     * A recursive form of member
     */


    /**
     *
     *
     * @param PRED;
     * 		unary function
     * 		Returns T if: - OBJECT is a non-dotted list, and
     * 		- PRED returns non-nil when applied to any item in OBJECT
     * 		Otherwise, returns NIL.
     */
    @LispMethod(comment = "@param PRED;\r\n\t\tunary function\r\n\t\tReturns T if: - OBJECT is a non-dotted list, and\r\n\t\t- PRED returns non-nil when applied to any item in OBJECT\r\n\t\tOtherwise, returns NIL.")
    public static final SubLObject list_of_type_p_alt(SubLObject pred, SubLObject v_object) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.non_dotted_list_p(v_object)) {
            {
                SubLObject cdolist_list_var = v_object;
                SubLObject subobject = NIL;
                for (subobject = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , subobject = cdolist_list_var.first()) {
                    if (NIL == funcall(pred, subobject)) {
                        return NIL;
                    }
                }
                return T;
            }
        } else {
            return NIL;
        }
    }

    /**
     *
     *
     * @param PRED;
     * 		unary function
     * 		Returns T if: - OBJECT is a non-dotted list, and
     * 		- PRED returns non-nil when applied to any item in OBJECT
     * 		Otherwise, returns NIL.
     */
    @LispMethod(comment = "@param PRED;\r\n\t\tunary function\r\n\t\tReturns T if: - OBJECT is a non-dotted list, and\r\n\t\t- PRED returns non-nil when applied to any item in OBJECT\r\n\t\tOtherwise, returns NIL.")
    public static SubLObject list_of_type_p(final SubLObject pred, final SubLObject v_object) {
        if (NIL != non_dotted_list_p(v_object)) {
            SubLObject cdolist_list_var = v_object;
            SubLObject subobject = NIL;
            subobject = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL == funcall(pred, subobject)) {
                    return NIL;
                }
                cdolist_list_var = cdolist_list_var.rest();
                subobject = cdolist_list_var.first();
            } 
            return T;
        }
        return NIL;
    }

    public static final SubLObject non_empty_list_of_type_p_alt(SubLObject pred, SubLObject v_object) {
        return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.non_empty_list_p(v_object)) && (NIL != com.cyc.cycjava.cycl.list_utilities.list_of_type_p(pred, v_object)));
    }

    public static SubLObject non_empty_list_of_type_p(final SubLObject pred, final SubLObject v_object) {
        return makeBoolean((NIL != non_empty_list_p(v_object)) && (NIL != list_of_type_p(pred, v_object)));
    }

    public static final SubLObject list_of_list_p_alt(SubLObject v_object) {
        return com.cyc.cycjava.cycl.list_utilities.list_of_type_p(symbol_function(LISTP), v_object);
    }

    public static SubLObject list_of_list_p(final SubLObject v_object) {
        return list_of_type_p(symbol_function(LISTP), v_object);
    }

    public static final SubLObject list_of_keyword_p_alt(SubLObject v_object) {
        return com.cyc.cycjava.cycl.list_utilities.list_of_type_p(symbol_function(KEYWORDP), v_object);
    }

    public static SubLObject list_of_keyword_p(final SubLObject v_object) {
        return list_of_type_p(symbol_function(KEYWORDP), v_object);
    }

    /**
     * Returns T if object is a non-dotted list of strings, otherwise it returns NIL.
     */
    @LispMethod(comment = "Returns T if object is a non-dotted list of strings, otherwise it returns NIL.")
    public static final SubLObject string_list_p_alt(SubLObject v_object) {
        return string_utilities.list_of_string_p(v_object);
    }

    @LispMethod(comment = "Returns T if object is a non-dotted list of strings, otherwise it returns NIL.")
    public static SubLObject string_list_p(final SubLObject v_object) {
        return string_utilities.list_of_string_p(v_object);
    }/**
     * Returns T if object is a non-dotted list of strings, otherwise it returns NIL.
     */


    /**
     * Returns T iff OBJECT is a non-dotted list of symbols.
     */
    @LispMethod(comment = "Returns T iff OBJECT is a non-dotted list of symbols.")
    public static final SubLObject symbol_list_p_alt(SubLObject v_object) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.non_dotted_list_p(v_object)) {
            return com.cyc.cycjava.cycl.list_utilities.every_in_list(symbol_function(SYMBOLP), v_object, UNPROVIDED);
        }
        return NIL;
    }

    @LispMethod(comment = "Returns T iff OBJECT is a non-dotted list of symbols.")
    public static SubLObject symbol_list_p(final SubLObject v_object) {
        if (NIL != non_dotted_list_p(v_object)) {
            return every_in_list(symbol_function(SYMBOLP), v_object, UNPROVIDED);
        }
        return NIL;
    }/**
     * Returns T iff OBJECT is a non-dotted list of symbols.
     */


    /**
     * Returns T iff OBJECT is a non-dotted list of function-symbol-p.
     */
    @LispMethod(comment = "Returns T iff OBJECT is a non-dotted list of function-symbol-p.")
    public static final SubLObject function_symbol_list_p_alt(SubLObject v_object) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.non_dotted_list_p(v_object)) {
            return com.cyc.cycjava.cycl.list_utilities.every_in_list(symbol_function(FUNCTION_SYMBOL_P), v_object, UNPROVIDED);
        }
        return NIL;
    }

    @LispMethod(comment = "Returns T iff OBJECT is a non-dotted list of function-symbol-p.")
    public static SubLObject function_symbol_list_p(final SubLObject v_object) {
        if (NIL != non_dotted_list_p(v_object)) {
            return every_in_list(symbol_function(FUNCTION_SYMBOL_P), v_object, UNPROVIDED);
        }
        return NIL;
    }/**
     * Returns T iff OBJECT is a non-dotted list of function-symbol-p.
     */


    /**
     * Return T iff FORM is a form with OPERATOR as its operator.
     */
    @LispMethod(comment = "Return T iff FORM is a form with OPERATOR as its operator.")
    public static final SubLObject form_with_operator_p_alt(SubLObject form, SubLObject operator) {
        return makeBoolean(form.isCons() && (operator == form.first()));
    }

    @LispMethod(comment = "Return T iff FORM is a form with OPERATOR as its operator.")
    public static SubLObject form_with_operator_p(final SubLObject form, final SubLObject operator) {
        return makeBoolean(form.isCons() && operator.eql(form.first()));
    }/**
     * Return T iff FORM is a form with OPERATOR as its operator.
     */


    /**
     * Generate an error if OPERATOR does not match EXPECTED-OPERATOR
     */
    @LispMethod(comment = "Generate an error if OPERATOR does not match EXPECTED-OPERATOR")
    public static final SubLObject verify_operator_alt(SubLObject operator, SubLObject expected_operator) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
                if (operator != expected_operator) {
                    Errors.error($str_alt190$Expected__S__got__S, expected_operator, operator);
                }
            }
            return NIL;
        }
    }

    @LispMethod(comment = "Generate an error if OPERATOR does not match EXPECTED-OPERATOR")
    public static SubLObject verify_operator(final SubLObject operator, final SubLObject expected_operator) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (!operator.eql(expected_operator))) {
            Errors.error($str199$Expected__S__got__S, expected_operator, operator);
        }
        return NIL;
    }/**
     * Generate an error if OPERATOR does not match EXPECTED-OPERATOR
     */


    /**
     * Generate an error if FORM is not a form with OPERATOR as its operator.
     */
    @LispMethod(comment = "Generate an error if FORM is not a form with OPERATOR as its operator.")
    public static final SubLObject verify_form_with_operator_alt(SubLObject form, SubLObject expected_operator) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
                if (NIL == com.cyc.cycjava.cycl.list_utilities.form_with_operator_p(form, expected_operator)) {
                    Errors.error($str_alt191$_S_was_not_a_form_with_operator__, form, expected_operator);
                }
            }
            return NIL;
        }
    }

    @LispMethod(comment = "Generate an error if FORM is not a form with OPERATOR as its operator.")
    public static SubLObject verify_form_with_operator(final SubLObject form, final SubLObject expected_operator) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL == form_with_operator_p(form, expected_operator))) {
            Errors.error($str200$_S_was_not_a_form_with_operator__, form, expected_operator);
        }
        return NIL;
    }/**
     * Generate an error if FORM is not a form with OPERATOR as its operator.
     */


    public static final SubLObject functor_in_expression_p_alt(SubLObject functor, SubLObject expression) {
        if (expression.isAtom()) {
            return NIL;
        } else {
            {
                SubLObject expression_functor = expression.first();
                SubLObject expression_args = expression.rest();
                if (functor.equal(expression_functor)) {
                    return T;
                } else {
                    {
                        SubLObject cdolist_list_var = expression_args;
                        SubLObject arg = NIL;
                        for (arg = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , arg = cdolist_list_var.first()) {
                            if (NIL != com.cyc.cycjava.cycl.list_utilities.functor_in_expression_p(functor, arg)) {
                                return T;
                            }
                        }
                        return NIL;
                    }
                }
            }
        }
    }

    public static SubLObject functor_in_expression_p(final SubLObject functor, final SubLObject expression) {
        if (expression.isAtom()) {
            return NIL;
        }
        final SubLObject expression_functor = expression.first();
        final SubLObject expression_args = expression.rest();
        if (functor.equal(expression_functor)) {
            return T;
        }
        SubLObject cdolist_list_var = expression_args;
        SubLObject arg = NIL;
        arg = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != functor_in_expression_p(functor, arg)) {
                return T;
            }
            cdolist_list_var = cdolist_list_var.rest();
            arg = cdolist_list_var.first();
        } 
        return NIL;
    }

    public static final SubLObject functor_in_body_p_alt(SubLObject symbol, SubLObject body) {
        if (NIL == body) {
            return NIL;
        } else {
            if (body.isCons()) {
                {
                    SubLObject sublist = body;
                    SubLObject expression = NIL;
                    SubLObject functor = NIL;
                    while (sublist.isCons()) {
                        expression = sublist.first();
                        if (expression.isCons()) {
                            functor = expression.first();
                            if (functor == symbol) {
                                return T;
                            }
                            if (NIL != com.cyc.cycjava.cycl.list_utilities.functor_in_body_p(symbol, expression.rest())) {
                                return T;
                            }
                        }
                    } 
                }
            } else {
                return NIL;
            }
        }
        return NIL;
    }

    public static SubLObject functor_in_body_p(final SubLObject symbol, final SubLObject body) {
        if (NIL == body) {
            return NIL;
        }
        if (body.isCons()) {
            SubLObject expression = NIL;
            SubLObject functor = NIL;
            while (body.isCons()) {
                expression = body.first();
                if (expression.isCons()) {
                    functor = expression.first();
                    if (functor.eql(symbol)) {
                        return T;
                    }
                    if (NIL != functor_in_body_p(symbol, expression.rest())) {
                        return T;
                    }
                    continue;
                }
            } 
            return NIL;
        }
        return NIL;
    }

    public static final SubLObject variable_value_used_in_body_p_alt(SubLObject symbol, SubLObject body) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.proper_list_p(body)) {
            {
                SubLObject cdolist_list_var = body;
                SubLObject expression = NIL;
                for (expression = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , expression = cdolist_list_var.first()) {
                    if (NIL != com.cyc.cycjava.cycl.list_utilities.variable_value_used_in_expression_p(symbol, expression)) {
                        return T;
                    }
                }
                return NIL;
            }
        } else {
            return NIL;
        }
    }

    public static SubLObject variable_value_used_in_body_p(final SubLObject symbol, final SubLObject body) {
        if (NIL != proper_list_p(body)) {
            SubLObject cdolist_list_var = body;
            SubLObject expression = NIL;
            expression = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != variable_value_used_in_expression_p(symbol, expression)) {
                    return T;
                }
                cdolist_list_var = cdolist_list_var.rest();
                expression = cdolist_list_var.first();
            } 
            return NIL;
        }
        return NIL;
    }

    public static final SubLObject variable_value_used_in_expression_p_alt(SubLObject symbol, SubLObject expression) {
        if (expression.isCons()) {
            {
                SubLObject args = expression.rest();
                if (expression.first() == QUOTE) {
                    return NIL;
                } else {
                    return com.cyc.cycjava.cycl.list_utilities.variable_value_used_in_body_p(symbol, args);
                }
            }
        } else {
            return eq(symbol, expression);
        }
    }

    public static SubLObject variable_value_used_in_expression_p(final SubLObject symbol, final SubLObject expression) {
        if (!expression.isCons()) {
            return eq(symbol, expression);
        }
        final SubLObject args = expression.rest();
        if (expression.first() == QUOTE) {
            return NIL;
        }
        return variable_value_used_in_body_p(symbol, args);
    }

    public static final SubLObject object_in_expression_p_alt(SubLObject v_object, SubLObject expression) {
        if (expression.isAtom()) {
            return equal(v_object, expression);
        } else {
            return makeBoolean((NIL != com.cyc.cycjava.cycl.list_utilities.object_in_expression_p(v_object, expression.first())) || (NIL != com.cyc.cycjava.cycl.list_utilities.object_in_expression_p(v_object, expression.rest())));
        }
    }

    public static SubLObject object_in_expression_p(final SubLObject v_object, final SubLObject expression) {
        if (expression.isAtom()) {
            return equal(v_object, expression);
        }
        return makeBoolean((NIL != object_in_expression_p(v_object, expression.first())) || (NIL != object_in_expression_p(v_object, expression.rest())));
    }

    /**
     *
     *
     * @return list; Converts string to list of strings and symbols.  Each subpart of the string beginning with
    symbol-start-char upto but not including symbol-end-char is converted to a symbol.  All other parts remain
    strings.
     * @param string;
     * 		The string to be converted.
     * @param symbol-start-char;
     * 		the char beginning each symbol.
     * @param symbol-end-char;
     * 		the char ending each symbol.
     */
    @LispMethod(comment = "@return list; Converts string to list of strings and symbols.  Each subpart of the string beginning with\r\nsymbol-start-char upto but not including symbol-end-char is converted to a symbol.  All other parts remain\r\nstrings.\r\n@param string;\r\n\t\tThe string to be converted.\r\n@param symbol-start-char;\r\n\t\tthe char beginning each symbol.\r\n@param symbol-end-char;\r\n\t\tthe char ending each symbol.")
    public static final SubLObject parse_to_list_of_strings_alt(SubLObject string, SubLObject symbol_start_char, SubLObject symbol_end_char) {
        if (symbol_start_char == UNPROVIDED) {
            symbol_start_char = CHAR_question;
        }
        if (symbol_end_char == UNPROVIDED) {
            symbol_end_char = CHAR_space;
        }
        if (NIL == string) {
            return NIL;
        } else {
            if (!string.isString()) {
                return NIL;
            } else {
                if (NIL != Strings.string_equal(string, $str_alt64$, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED)) {
                    return NIL;
                } else {
                    {
                        SubLObject list_of_strings = NIL;
                        SubLObject current_index = ZERO_INTEGER;
                        SubLObject start_of_string_index = ZERO_INTEGER;
                        SubLObject start_of_symbol_index = ZERO_INTEGER;
                        SubLObject string_length = length(string);
                        SubLObject current_char = NIL;
                        SubLObject new_string_length = NIL;
                        SubLObject new_string = NIL;
                        SubLObject symbol_length = NIL;
                        SubLObject symbol_string = NIL;
                        while (current_index.numL(string_length)) {
                            current_char = aref(string, current_index);
                            if (NIL != charE(current_char, symbol_start_char)) {
                                if (!start_of_string_index.numE(current_index)) {
                                    new_string_length = subtract(current_index, start_of_string_index);
                                    new_string = Strings.make_string(new_string_length, UNPROVIDED);
                                    {
                                        SubLObject new_string_index = NIL;
                                        for (new_string_index = ZERO_INTEGER; new_string_index.numL(new_string_length); new_string_index = add(new_string_index, ONE_INTEGER)) {
                                            set_aref(new_string, new_string_index, aref(string, add(start_of_string_index, new_string_index)));
                                        }
                                    }
                                    list_of_strings = cons(new_string, list_of_strings);
                                }
                                start_of_symbol_index = current_index;
                                current_index = add(current_index, ONE_INTEGER);
                                while (current_index.numL(string_length) && (NIL == charE(aref(string, current_index), symbol_end_char))) {
                                    current_index = add(current_index, ONE_INTEGER);
                                } 
                                start_of_string_index = current_index;
                                symbol_length = subtract(current_index, start_of_symbol_index);
                                symbol_string = Strings.make_string(symbol_length, UNPROVIDED);
                                {
                                    SubLObject new_symbol_index = NIL;
                                    for (new_symbol_index = ZERO_INTEGER; new_symbol_index.numL(symbol_length); new_symbol_index = add(new_symbol_index, ONE_INTEGER)) {
                                        set_aref(symbol_string, new_symbol_index, aref(string, add(start_of_symbol_index, new_symbol_index)));
                                    }
                                }
                                list_of_strings = cons(intern(symbol_string, UNPROVIDED), list_of_strings);
                            } else {
                                current_index = add(current_index, ONE_INTEGER);
                            }
                        } 
                        if (!start_of_string_index.numE(current_index)) {
                            new_string_length = subtract(current_index, start_of_string_index);
                            new_string = Strings.make_string(new_string_length, UNPROVIDED);
                            {
                                SubLObject new_string_index = NIL;
                                for (new_string_index = ZERO_INTEGER; new_string_index.numL(new_string_length); new_string_index = add(new_string_index, ONE_INTEGER)) {
                                    set_aref(new_string, new_string_index, aref(string, add(start_of_string_index, new_string_index)));
                                }
                            }
                            list_of_strings = cons(new_string, list_of_strings);
                        }
                        return nreverse(list_of_strings);
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return list; Converts string to list of strings and symbols.  Each subpart of the string beginning with
    symbol-start-char upto but not including symbol-end-char is converted to a symbol.  All other parts remain
    strings.
     * @param string;
     * 		The string to be converted.
     * @param symbol-start-char;
     * 		the char beginning each symbol.
     * @param symbol-end-char;
     * 		the char ending each symbol.
     */
    @LispMethod(comment = "@return list; Converts string to list of strings and symbols.  Each subpart of the string beginning with\r\nsymbol-start-char upto but not including symbol-end-char is converted to a symbol.  All other parts remain\r\nstrings.\r\n@param string;\r\n\t\tThe string to be converted.\r\n@param symbol-start-char;\r\n\t\tthe char beginning each symbol.\r\n@param symbol-end-char;\r\n\t\tthe char ending each symbol.")
    public static SubLObject parse_to_list_of_strings(final SubLObject string, SubLObject symbol_start_char, SubLObject symbol_end_char) {
        if (symbol_start_char == UNPROVIDED) {
            symbol_start_char = CHAR_question;
        }
        if (symbol_end_char == UNPROVIDED) {
            symbol_end_char = CHAR_space;
        }
        if (NIL == string) {
            return NIL;
        }
        if (!string.isString()) {
            return NIL;
        }
        if (NIL != Strings.string_equal(string, $str64$, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED)) {
            return NIL;
        }
        SubLObject list_of_strings = NIL;
        SubLObject current_index = ZERO_INTEGER;
        SubLObject start_of_string_index = ZERO_INTEGER;
        SubLObject start_of_symbol_index = ZERO_INTEGER;
        final SubLObject string_length = length(string);
        SubLObject current_char = NIL;
        SubLObject new_string_length = NIL;
        SubLObject new_string = NIL;
        SubLObject symbol_length = NIL;
        SubLObject symbol_string = NIL;
        while (current_index.numL(string_length)) {
            current_char = aref(string, current_index);
            if (NIL != charE(current_char, symbol_start_char)) {
                if (!start_of_string_index.numE(current_index)) {
                    new_string_length = subtract(current_index, start_of_string_index);
                    new_string = Strings.make_string(new_string_length, UNPROVIDED);
                    SubLObject new_string_index;
                    for (new_string_index = NIL, new_string_index = ZERO_INTEGER; new_string_index.numL(new_string_length); new_string_index = add(new_string_index, ONE_INTEGER)) {
                        set_aref(new_string, new_string_index, aref(string, add(start_of_string_index, new_string_index)));
                    }
                    list_of_strings = cons(new_string, list_of_strings);
                }
                start_of_symbol_index = current_index;
                for (current_index = add(current_index, ONE_INTEGER); current_index.numL(string_length) && (NIL == charE(aref(string, current_index), symbol_end_char)); current_index = add(current_index, ONE_INTEGER)) {
                }
                start_of_string_index = current_index;
                symbol_length = subtract(current_index, start_of_symbol_index);
                symbol_string = Strings.make_string(symbol_length, UNPROVIDED);
                SubLObject new_symbol_index;
                for (new_symbol_index = NIL, new_symbol_index = ZERO_INTEGER; new_symbol_index.numL(symbol_length); new_symbol_index = add(new_symbol_index, ONE_INTEGER)) {
                    set_aref(symbol_string, new_symbol_index, aref(string, add(start_of_symbol_index, new_symbol_index)));
                }
                list_of_strings = cons(intern(symbol_string, UNPROVIDED), list_of_strings);
            } else {
                current_index = add(current_index, ONE_INTEGER);
            }
        } 
        if (!start_of_string_index.numE(current_index)) {
            new_string_length = subtract(current_index, start_of_string_index);
            new_string = Strings.make_string(new_string_length, UNPROVIDED);
            SubLObject new_string_index;
            for (new_string_index = NIL, new_string_index = ZERO_INTEGER; new_string_index.numL(new_string_length); new_string_index = add(new_string_index, ONE_INTEGER)) {
                set_aref(new_string, new_string_index, aref(string, add(start_of_string_index, new_string_index)));
            }
            list_of_strings = cons(new_string, list_of_strings);
        }
        return nreverse(list_of_strings);
    }

    public static final SubLObject tree_substitute_by_association_alt(SubLObject tree, SubLObject assoc_struct, SubLObject candidate_pred, SubLObject assoc_getter, SubLObject value_accessor) {
        if (candidate_pred == UNPROVIDED) {
            candidate_pred = ATOM;
        }
        if (assoc_getter == UNPROVIDED) {
            assoc_getter = ASSOC;
        }
        if (value_accessor == UNPROVIDED) {
            value_accessor = CDR;
        }
        {
            SubLObject isa_candidate = NIL;
            SubLObject association = NIL;
            SubLObject value = NIL;
            {
                SubLObject pcase_var = candidate_pred;
                if (pcase_var.eql(ATOM)) {
                    isa_candidate = atom(tree);
                } else {
                    if (pcase_var.eql(SYMBOLP)) {
                        isa_candidate = symbolp(tree);
                    } else {
                        if (pcase_var.eql(KEYWORDP)) {
                            isa_candidate = keywordp(tree);
                        } else {
                            if (pcase_var.eql(STRINGP)) {
                                isa_candidate = stringp(tree);
                            } else {
                                isa_candidate = funcall(candidate_pred, tree);
                            }
                        }
                    }
                }
            }
            if (NIL != isa_candidate) {
                {
                    SubLObject pcase_var = assoc_getter;
                    if (pcase_var.eql(ASSOC)) {
                        association = assoc(tree, assoc_struct, UNPROVIDED, UNPROVIDED);
                    } else {
                        association = funcall(assoc_getter, tree, assoc_struct);
                    }
                }
                if (NIL != association) {
                    {
                        SubLObject pcase_var = value_accessor;
                        if (pcase_var.eql(CDR)) {
                            value = association.rest();
                        } else {
                            value = funcall(value_accessor, association);
                        }
                        return value;
                    }
                } else {
                    return tree;
                }
            } else {
                if (tree.isCons()) {
                    return cons(com.cyc.cycjava.cycl.list_utilities.tree_substitute_by_association(tree.first(), assoc_struct, candidate_pred, assoc_getter, value_accessor), com.cyc.cycjava.cycl.list_utilities.tree_substitute_by_association(tree.rest(), assoc_struct, candidate_pred, assoc_getter, value_accessor));
                } else {
                    return tree;
                }
            }
        }
    }

    public static SubLObject tree_substitute_by_association(final SubLObject tree, final SubLObject assoc_struct, SubLObject candidate_pred, SubLObject assoc_getter, SubLObject value_accessor) {
        if (candidate_pred == UNPROVIDED) {
            candidate_pred = ATOM;
        }
        if (assoc_getter == UNPROVIDED) {
            assoc_getter = ASSOC;
        }
        if (value_accessor == UNPROVIDED) {
            value_accessor = CDR;
        }
        SubLObject isa_candidate = NIL;
        SubLObject association = NIL;
        SubLObject value = NIL;
        SubLObject pcase_var = candidate_pred;
        if (pcase_var.eql(ATOM)) {
            isa_candidate = atom(tree);
        } else
            if (pcase_var.eql(SYMBOLP)) {
                isa_candidate = symbolp(tree);
            } else
                if (pcase_var.eql(KEYWORDP)) {
                    isa_candidate = keywordp(tree);
                } else
                    if (pcase_var.eql(STRINGP)) {
                        isa_candidate = stringp(tree);
                    } else {
                        isa_candidate = funcall(candidate_pred, tree);
                    }



        if (NIL != isa_candidate) {
            pcase_var = assoc_getter;
            if (pcase_var.eql(ASSOC)) {
                association = assoc(tree, assoc_struct, UNPROVIDED, UNPROVIDED);
            } else {
                association = funcall(assoc_getter, tree, assoc_struct);
            }
            if (NIL != association) {
                pcase_var = value_accessor;
                if (pcase_var.eql(CDR)) {
                    value = association.rest();
                } else {
                    value = funcall(value_accessor, association);
                }
                return value;
            }
            return tree;
        } else {
            if (tree.isCons()) {
                return cons(tree_substitute_by_association(tree.first(), assoc_struct, candidate_pred, assoc_getter, value_accessor), tree_substitute_by_association(tree.rest(), assoc_struct, candidate_pred, assoc_getter, value_accessor));
            }
            return tree;
        }
    }

    /**
     * a version of read-delimited-list which returns a string when an error occurs instead of bombing out
     */
    @LispMethod(comment = "a version of read-delimited-list which returns a string when an error occurs instead of bombing out")
    public static final SubLObject safe_read_delimited_list_alt(SubLObject v_char, SubLObject input_stream, SubLObject recursive_p) {
        if (input_stream == UNPROVIDED) {
            input_stream = StreamsLow.$standard_input$.getDynamicValue();
        }
        if (recursive_p == UNPROVIDED) {
            recursive_p = NIL;
        }
        {
            SubLObject msg = NIL;
            SubLObject l = NIL;
            try {
                {
                    SubLObject _prev_bind_0 = currentBinding(Errors.$error_handler$);
                    try {
                        bind(Errors.$error_handler$, CATCH_ERROR_MESSAGE_HANDLER);
                        try {
                            l = read_delimited_list(v_char, input_stream, recursive_p);
                        } catch (Throwable catch_var) {
                            Errors.handleThrowable(catch_var, NIL);
                        }
                    } finally {
                        rebind(Errors.$error_handler$, _prev_bind_0);
                    }
                }
            } catch (Throwable ccatch_env_var) {
                msg = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
            }
            if (NIL != msg) {
                return msg;
            } else {
                return l;
            }
        }
    }

    @LispMethod(comment = "a version of read-delimited-list which returns a string when an error occurs instead of bombing out")
    public static SubLObject safe_read_delimited_list(final SubLObject v_char, SubLObject input_stream, SubLObject recursive_p) {
        if (input_stream == UNPROVIDED) {
            input_stream = StreamsLow.$standard_input$.getDynamicValue();
        }
        if (recursive_p == UNPROVIDED) {
            recursive_p = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject msg = NIL;
        SubLObject l = NIL;
        try {
            thread.throwStack.push($catch_error_message_target$.getGlobalValue());
            final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
            try {
                Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
                try {
                    l = read_delimited_list(v_char, input_stream, recursive_p);
                } catch (final Throwable catch_var) {
                    Errors.handleThrowable(catch_var, NIL);
                }
            } finally {
                Errors.$error_handler$.rebind(_prev_bind_0, thread);
            }
        } catch (final Throwable ccatch_env_var) {
            msg = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
        } finally {
            thread.throwStack.pop();
        }
        if (NIL != msg) {
            return msg;
        }
        return l;
    }/**
     * a version of read-delimited-list which returns a string when an error occurs instead of bombing out
     */


    /**
     * This is a version of sublis for multi-association lists.  The form of multi-association lists
     * is: ((key1 value11 value12 ...)
     * (key2 value21 value22 ...)
     * ...)
     * A multi-association list is equivalent to a set of association lists each with the same set
     * of keys.  The return value for this function is a list of trees, each of which is equivalent
     * to applying sublis to TREE with one of the association lists in the set corresponding to
     * MULTI-ALIST.
     */
    @LispMethod(comment = "This is a version of sublis for multi-association lists.  The form of multi-association lists\r\nis: ((key1 value11 value12 ...)\r\n(key2 value21 value22 ...)\r\n...)\r\nA multi-association list is equivalent to a set of association lists each with the same set\r\nof keys.  The return value for this function is a list of trees, each of which is equivalent\r\nto applying sublis to TREE with one of the association lists in the set corresponding to\r\nMULTI-ALIST.\nThis is a version of sublis for multi-association lists.  The form of multi-association lists\nis: ((key1 value11 value12 ...)\n(key2 value21 value22 ...)\n...)\nA multi-association list is equivalent to a set of association lists each with the same set\nof keys.  The return value for this function is a list of trees, each of which is equivalent\nto applying sublis to TREE with one of the association lists in the set corresponding to\nMULTI-ALIST.")
    public static final SubLObject multi_sublis_alt(SubLObject multi_alist, SubLObject tree, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL == tree) {
            return cons(NIL, NIL);
        } else {
            {
                SubLObject trees = com.cyc.cycjava.cycl.list_utilities.multi_assoc(tree, multi_alist, test, key);
                if (NIL == trees) {
                    if (tree.isCons()) {
                        {
                            SubLObject car_trees = com.cyc.cycjava.cycl.list_utilities.multi_sublis(multi_alist, tree.first(), test, key);
                            SubLObject cdr_trees = com.cyc.cycjava.cycl.list_utilities.multi_sublis(multi_alist, tree.rest(), test, key);
                            SubLObject cdolist_list_var = car_trees;
                            SubLObject car_tree = NIL;
                            for (car_tree = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , car_tree = cdolist_list_var.first()) {
                                {
                                    SubLObject cdolist_list_var_37 = cdr_trees;
                                    SubLObject cdr_tree = NIL;
                                    for (cdr_tree = cdolist_list_var_37.first(); NIL != cdolist_list_var_37; cdolist_list_var_37 = cdolist_list_var_37.rest() , cdr_tree = cdolist_list_var_37.first()) {
                                        trees = cons(cons(car_tree, cdr_tree), trees);
                                    }
                                }
                            }
                        }
                    } else {
                        trees = cons(tree, NIL);
                    }
                }
                return trees;
            }
        }
    }

    @LispMethod(comment = "This is a version of sublis for multi-association lists.  The form of multi-association lists\r\nis: ((key1 value11 value12 ...)\r\n(key2 value21 value22 ...)\r\n...)\r\nA multi-association list is equivalent to a set of association lists each with the same set\r\nof keys.  The return value for this function is a list of trees, each of which is equivalent\r\nto applying sublis to TREE with one of the association lists in the set corresponding to\r\nMULTI-ALIST.\nThis is a version of sublis for multi-association lists.  The form of multi-association lists\nis: ((key1 value11 value12 ...)\n(key2 value21 value22 ...)\n...)\nA multi-association list is equivalent to a set of association lists each with the same set\nof keys.  The return value for this function is a list of trees, each of which is equivalent\nto applying sublis to TREE with one of the association lists in the set corresponding to\nMULTI-ALIST.")
    public static SubLObject multi_sublis(final SubLObject multi_alist, final SubLObject tree, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (NIL == tree) {
            return cons(NIL, NIL);
        }
        SubLObject trees = multi_assoc(tree, multi_alist, test, key);
        if (NIL == trees) {
            if (tree.isCons()) {
                final SubLObject car_trees = multi_sublis(multi_alist, tree.first(), test, key);
                final SubLObject cdr_trees = multi_sublis(multi_alist, tree.rest(), test, key);
                SubLObject cdolist_list_var = car_trees;
                SubLObject car_tree = NIL;
                car_tree = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    SubLObject cdolist_list_var_$41 = cdr_trees;
                    SubLObject cdr_tree = NIL;
                    cdr_tree = cdolist_list_var_$41.first();
                    while (NIL != cdolist_list_var_$41) {
                        trees = cons(cons(car_tree, cdr_tree), trees);
                        cdolist_list_var_$41 = cdolist_list_var_$41.rest();
                        cdr_tree = cdolist_list_var_$41.first();
                    } 
                    cdolist_list_var = cdolist_list_var.rest();
                    car_tree = cdolist_list_var.first();
                } 
            } else {
                trees = cons(tree, NIL);
            }
        }
        return trees;
    }/**
     * This is a version of sublis for multi-association lists.  The form of multi-association lists
     * is: ((key1 value11 value12 ...)
     * (key2 value21 value22 ...)
     * ...)
     * A multi-association list is equivalent to a set of association lists each with the same set
     * of keys.  The return value for this function is a list of trees, each of which is equivalent
     * to applying sublis to TREE with one of the association lists in the set corresponding to
     * MULTI-ALIST.
     */


    /**
     * This returns the associations of ITEM in MULTI-ALIST.  A multi-association list
     * is a list of the following form:
     * ((key1 value11 value12 ...)
     * (key2 value21 value22 ...)
     * ...)
     * Note that a key need not be associated with multiple (or, indeed, any) values.
     * Note also that if a key appears twice in a multi-association list, its association
     * will be taken to be the concatenation of the several lists of associations.
     * If ITEM is a key for MULTI-ALIST, then the list of associated values is returned.
     * Otherwise, NIL is returned.
     */
    @LispMethod(comment = "This returns the associations of ITEM in MULTI-ALIST.  A multi-association list\r\nis a list of the following form:\r\n((key1 value11 value12 ...)\r\n(key2 value21 value22 ...)\r\n...)\r\nNote that a key need not be associated with multiple (or, indeed, any) values.\r\nNote also that if a key appears twice in a multi-association list, its association\r\nwill be taken to be the concatenation of the several lists of associations.\r\nIf ITEM is a key for MULTI-ALIST, then the list of associated values is returned.\r\nOtherwise, NIL is returned.\nThis returns the associations of ITEM in MULTI-ALIST.  A multi-association list\nis a list of the following form:\n((key1 value11 value12 ...)\n(key2 value21 value22 ...)\n...)\nNote that a key need not be associated with multiple (or, indeed, any) values.\nNote also that if a key appears twice in a multi-association list, its association\nwill be taken to be the concatenation of the several lists of associations.\nIf ITEM is a key for MULTI-ALIST, then the list of associated values is returned.\nOtherwise, NIL is returned.")
    public static final SubLObject multi_assoc_alt(SubLObject item, SubLObject multi_alist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject associations = NIL;
            SubLObject cdolist_list_var = multi_alist;
            SubLObject key_values = NIL;
            for (key_values = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , key_values = cdolist_list_var.first()) {
                if (NIL != funcall(test, item, funcall(key, key_values.first()))) {
                    associations = append(key_values.rest(), associations);
                }
            }
            return associations;
        }
    }

    @LispMethod(comment = "This returns the associations of ITEM in MULTI-ALIST.  A multi-association list\r\nis a list of the following form:\r\n((key1 value11 value12 ...)\r\n(key2 value21 value22 ...)\r\n...)\r\nNote that a key need not be associated with multiple (or, indeed, any) values.\r\nNote also that if a key appears twice in a multi-association list, its association\r\nwill be taken to be the concatenation of the several lists of associations.\r\nIf ITEM is a key for MULTI-ALIST, then the list of associated values is returned.\r\nOtherwise, NIL is returned.\nThis returns the associations of ITEM in MULTI-ALIST.  A multi-association list\nis a list of the following form:\n((key1 value11 value12 ...)\n(key2 value21 value22 ...)\n...)\nNote that a key need not be associated with multiple (or, indeed, any) values.\nNote also that if a key appears twice in a multi-association list, its association\nwill be taken to be the concatenation of the several lists of associations.\nIf ITEM is a key for MULTI-ALIST, then the list of associated values is returned.\nOtherwise, NIL is returned.")
    public static SubLObject multi_assoc(final SubLObject item, final SubLObject multi_alist, SubLObject test, SubLObject key) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject associations = NIL;
        SubLObject cdolist_list_var = multi_alist;
        SubLObject key_values = NIL;
        key_values = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != funcall(test, item, funcall(key, key_values.first()))) {
                associations = append(key_values.rest(), associations);
            }
            cdolist_list_var = cdolist_list_var.rest();
            key_values = cdolist_list_var.first();
        } 
        return associations;
    }/**
     * This returns the associations of ITEM in MULTI-ALIST.  A multi-association list
     * is a list of the following form:
     * ((key1 value11 value12 ...)
     * (key2 value21 value22 ...)
     * ...)
     * Note that a key need not be associated with multiple (or, indeed, any) values.
     * Note also that if a key appears twice in a multi-association list, its association
     * will be taken to be the concatenation of the several lists of associations.
     * If ITEM is a key for MULTI-ALIST, then the list of associated values is returned.
     * Otherwise, NIL is returned.
     */


    /**
     * Verifies that an object is, in fact, an association list.  If valid-keys is not NIL,
     * it checks, as well, that each key in the alist is a member of valid-keys.  The default
     * predicate for testing equality is EQL.  However, an optional third argument permits
     * the caller to specify another predicate.
     *
     * @unknown sdevoy
     */
    @LispMethod(comment = "Verifies that an object is, in fact, an association list.  If valid-keys is not NIL,\r\nit checks, as well, that each key in the alist is a member of valid-keys.  The default\r\npredicate for testing equality is EQL.  However, an optional third argument permits\r\nthe caller to specify another predicate.\r\n\r\n@unknown sdevoy\nVerifies that an object is, in fact, an association list.  If valid-keys is not NIL,\nit checks, as well, that each key in the alist is a member of valid-keys.  The default\npredicate for testing equality is EQL.  However, an optional third argument permits\nthe caller to specify another predicate.")
    public static final SubLObject valid_and_conformant_alist_p_alt(SubLObject v_object, SubLObject valid_keys, SubLObject test) {
        if (valid_keys == UNPROVIDED) {
            valid_keys = NIL;
        }
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (!v_object.isList()) {
            return NIL;
        } else {
            if (NIL != valid_keys) {
                {
                    SubLObject sublist = NIL;
                    SubLObject element = NIL;
                    for (sublist = v_object, element = (sublist.isCons()) ? ((SubLObject) (sublist.first())) : NIL; sublist.isCons(); sublist = sublist.rest() , element = (sublist.isCons()) ? ((SubLObject) (sublist.first())) : NIL) {
                        if (!element.isCons()) {
                            return NIL;
                        }
                        if (NIL == subl_promotions.memberP(element.first(), valid_keys, test, UNPROVIDED)) {
                            return NIL;
                        }
                    }
                    return NIL == sublist ? ((SubLObject) (T)) : NIL;
                }
            } else {
                {
                    SubLObject sublist = NIL;
                    SubLObject element = NIL;
                    for (sublist = v_object, element = (sublist.isCons()) ? ((SubLObject) (sublist.first())) : NIL; sublist.isCons(); sublist = sublist.rest() , element = (sublist.isCons()) ? ((SubLObject) (sublist.first())) : NIL) {
                        if (!element.isCons()) {
                            return NIL;
                        }
                    }
                    return NIL == sublist ? ((SubLObject) (T)) : NIL;
                }
            }
        }
    }

    @LispMethod(comment = "Verifies that an object is, in fact, an association list.  If valid-keys is not NIL,\r\nit checks, as well, that each key in the alist is a member of valid-keys.  The default\r\npredicate for testing equality is EQL.  However, an optional third argument permits\r\nthe caller to specify another predicate.\r\n\r\n@unknown sdevoy\nVerifies that an object is, in fact, an association list.  If valid-keys is not NIL,\nit checks, as well, that each key in the alist is a member of valid-keys.  The default\npredicate for testing equality is EQL.  However, an optional third argument permits\nthe caller to specify another predicate.")
    public static SubLObject valid_and_conformant_alist_p(final SubLObject v_object, SubLObject valid_keys, SubLObject test) {
        if (valid_keys == UNPROVIDED) {
            valid_keys = NIL;
        }
        if (test == UNPROVIDED) {
            test = symbol_function(EQL);
        }
        if (!v_object.isList()) {
            return NIL;
        }
        if (NIL != valid_keys) {
            SubLObject sublist = NIL;
            SubLObject element = NIL;
            sublist = v_object;
            element = (sublist.isCons()) ? sublist.first() : NIL;
            while (sublist.isCons()) {
                if (!element.isCons()) {
                    return NIL;
                }
                if (NIL == subl_promotions.memberP(element.first(), valid_keys, test, UNPROVIDED)) {
                    return NIL;
                }
                sublist = sublist.rest();
                element = (sublist.isCons()) ? sublist.first() : NIL;
            } 
            return NIL == sublist ? T : NIL;
        }
        SubLObject sublist = NIL;
        SubLObject element = NIL;
        sublist = v_object;
        element = (sublist.isCons()) ? sublist.first() : NIL;
        while (sublist.isCons()) {
            if (!element.isCons()) {
                return NIL;
            }
            sublist = sublist.rest();
            element = (sublist.isCons()) ? sublist.first() : NIL;
        } 
        return NIL == sublist ? T : NIL;
    }/**
     * Verifies that an object is, in fact, an association list.  If valid-keys is not NIL,
     * it checks, as well, that each key in the alist is a member of valid-keys.  The default
     * predicate for testing equality is EQL.  However, an optional third argument permits
     * the caller to specify another predicate.
     *
     * @unknown sdevoy
     */


    /**
     * If specified, KEY-SORT-PRED takes precedence over SORT-PRED.
     */
    @LispMethod(comment = "If specified, KEY-SORT-PRED takes precedence over SORT-PRED.")
    public static final SubLObject histogram_alt(SubLObject list, SubLObject sort_pred, SubLObject key, SubLObject key_sort_pred) {
        if (sort_pred == UNPROVIDED) {
            sort_pred = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(EQL);
        }
        if (key_sort_pred == UNPROVIDED) {
            key_sort_pred = NIL;
        }
        {
            SubLObject dict = dictionary.new_dictionary(key, length(list));
            SubLObject cdolist_list_var = list;
            SubLObject elem = NIL;
            for (elem = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , elem = cdolist_list_var.first()) {
                dictionary_utilities.dictionary_increment(dict, elem, UNPROVIDED);
            }
            {
                SubLObject alist = dictionary_utilities.sort_dictionary_by_values(dict, sort_pred);
                if (NIL != key_sort_pred) {
                    alist = Sort.stable_sort(alist, key_sort_pred, symbol_function(CAR));
                }
                return alist;
            }
        }
    }

    @LispMethod(comment = "If specified, KEY-SORT-PRED takes precedence over SORT-PRED.")
    public static SubLObject histogram(final SubLObject list, SubLObject sort_pred, SubLObject key, SubLObject key_sort_pred) {
        if (sort_pred == UNPROVIDED) {
            sort_pred = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(EQL);
        }
        if (key_sort_pred == UNPROVIDED) {
            key_sort_pred = NIL;
        }
        final SubLObject dict = dictionary.new_dictionary(key, length(list));
        SubLObject cdolist_list_var = list;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            dictionary_utilities.dictionary_increment(dict, elem, UNPROVIDED);
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        SubLObject alist = dictionary_utilities.sort_dictionary_by_values(dict, sort_pred);
        if (NIL != key_sort_pred) {
            alist = Sort.stable_sort(alist, key_sort_pred, symbol_function(CAR));
        }
        return alist;
    }/**
     * If specified, KEY-SORT-PRED takes precedence over SORT-PRED.
     */


    public static final SubLObject histogram_as_plist_alt(SubLObject list, SubLObject sort_pred, SubLObject key, SubLObject key_sort_pred) {
        if (sort_pred == UNPROVIDED) {
            sort_pred = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(EQL);
        }
        if (key_sort_pred == UNPROVIDED) {
            key_sort_pred = NIL;
        }
        return com.cyc.cycjava.cycl.list_utilities.alist_to_plist(com.cyc.cycjava.cycl.list_utilities.histogram(list, sort_pred, key, key_sort_pred));
    }

    public static SubLObject histogram_as_plist(final SubLObject list, SubLObject sort_pred, SubLObject key, SubLObject key_sort_pred) {
        if (sort_pred == UNPROVIDED) {
            sort_pred = symbol_function($sym97$_);
        }
        if (key == UNPROVIDED) {
            key = symbol_function(EQL);
        }
        if (key_sort_pred == UNPROVIDED) {
            key_sort_pred = NIL;
        }
        return alist_to_plist(histogram(list, sort_pred, key, key_sort_pred));
    }

    public static final SubLObject pretty_print_histogram_alt(SubLObject histogram) {
        return com.cyc.cycjava.cycl.list_utilities.pretty_print_plist(com.cyc.cycjava.cycl.list_utilities.alist_to_plist(histogram), UNPROVIDED);
    }

    public static SubLObject pretty_print_histogram(final SubLObject histogram) {
        return pretty_print_plist(alist_to_plist(histogram), UNPROVIDED);
    }

    /**
     * Returns a sublist of LIST.  The middle element of the returned list will be the Ith element
     * of LIST, and there will be WIDTH elements on either side of the middle element.
     */
    @LispMethod(comment = "Returns a sublist of LIST.  The middle element of the returned list will be the Ith element\r\nof LIST, and there will be WIDTH elements on either side of the middle element.\nReturns a sublist of LIST.  The middle element of the returned list will be the Ith element\nof LIST, and there will be WIDTH elements on either side of the middle element.")
    public static final SubLObject n_within_alt(SubLObject list, SubLObject i, SubLObject width) {
        {
            SubLObject result = NIL;
            SubLObject end_var = add(i, width, ONE_INTEGER);
            SubLObject num = NIL;
            for (num = subtract(i, width); !num.numGE(end_var); num = number_utilities.f_1X(num)) {
                result = cons(nth(num, list), result);
            }
            return nreverse(result);
        }
    }

    @LispMethod(comment = "Returns a sublist of LIST.  The middle element of the returned list will be the Ith element\r\nof LIST, and there will be WIDTH elements on either side of the middle element.\nReturns a sublist of LIST.  The middle element of the returned list will be the Ith element\nof LIST, and there will be WIDTH elements on either side of the middle element.")
    public static SubLObject n_within(final SubLObject list, final SubLObject i, final SubLObject width) {
        SubLObject result = NIL;
        SubLObject end_var;
        SubLObject num;
        for (end_var = add(i, width, ONE_INTEGER), num = NIL, num = subtract(i, width); !num.numGE(end_var); num = number_utilities.f_1X(num)) {
            result = cons(nth(num, list), result);
        }
        return nreverse(result);
    }/**
     * Returns a sublist of LIST.  The middle element of the returned list will be the Ith element
     * of LIST, and there will be WIDTH elements on either side of the middle element.
     */


    /**
     * Returns a sublist of LIST.  The middle element of the returned list will be the middle element
     * of LIST, and there will be WIDTH elements on either side of the middle element.
     * Chooses an arbitrary middle for even-length lists.
     */
    @LispMethod(comment = "Returns a sublist of LIST.  The middle element of the returned list will be the middle element\r\nof LIST, and there will be WIDTH elements on either side of the middle element.\r\nChooses an arbitrary middle for even-length lists.\nReturns a sublist of LIST.  The middle element of the returned list will be the middle element\nof LIST, and there will be WIDTH elements on either side of the middle element.\nChooses an arbitrary middle for even-length lists.")
    public static final SubLObject middle_sublist_alt(SubLObject list, SubLObject width) {
        return com.cyc.cycjava.cycl.list_utilities.n_within(list, integerDivide(length(list), TWO_INTEGER), width);
    }

    @LispMethod(comment = "Returns a sublist of LIST.  The middle element of the returned list will be the middle element\r\nof LIST, and there will be WIDTH elements on either side of the middle element.\r\nChooses an arbitrary middle for even-length lists.\nReturns a sublist of LIST.  The middle element of the returned list will be the middle element\nof LIST, and there will be WIDTH elements on either side of the middle element.\nChooses an arbitrary middle for even-length lists.")
    public static SubLObject middle_sublist(final SubLObject list, final SubLObject width) {
        return n_within(list, integerDivide(length(list), TWO_INTEGER), width);
    }/**
     * Returns a sublist of LIST.  The middle element of the returned list will be the middle element
     * of LIST, and there will be WIDTH elements on either side of the middle element.
     * Chooses an arbitrary middle for even-length lists.
     */


    /**
     * Categories the elements of LIST according to CATEGORY-METHODS.
     * CATEGORY-METHODS is a list of function-spec-p to be tested, in order.
     * Return a list of lists of items for each category.
     * If there are any uncategorized elements, they are returned in an extra category at the end.
     */
    @LispMethod(comment = "Categories the elements of LIST according to CATEGORY-METHODS.\r\nCATEGORY-METHODS is a list of function-spec-p to be tested, in order.\r\nReturn a list of lists of items for each category.\r\nIf there are any uncategorized elements, they are returned in an extra category at the end.\nCategories the elements of LIST according to CATEGORY-METHODS.\nCATEGORY-METHODS is a list of function-spec-p to be tested, in order.\nReturn a list of lists of items for each category.\nIf there are any uncategorized elements, they are returned in an extra category at the end.")
    public static final SubLObject categorize_list_elements_alt(SubLObject list, SubLObject category_methods, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        {
            SubLObject categories = make_list(length(category_methods), UNPROVIDED);
            SubLObject remainders = NIL;
            SubLObject cdolist_list_var = list;
            SubLObject item = NIL;
            for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                {
                    SubLObject item_key = funcall(key, item);
                    SubLObject categorizedP = NIL;
                    SubLObject list_var = NIL;
                    SubLObject category_method = NIL;
                    SubLObject index = NIL;
                    for (list_var = category_methods, category_method = list_var.first(), index = ZERO_INTEGER; !((NIL != categorizedP) || (NIL == list_var)); list_var = list_var.rest() , category_method = list_var.first() , index = number_utilities.f_1X(index)) {
                        if (NIL != funcall(category_method, item_key)) {
                            categorizedP = T;
                            set_nth(index, categories, cons(item, nth(index, categories)));
                        }
                    }
                    if (NIL == categorizedP) {
                        remainders = cons(item, remainders);
                    }
                }
            }
            categories = com.cyc.cycjava.cycl.list_utilities.nmapcar(symbol_function(NREVERSE), categories);
            if (NIL != remainders) {
                categories = nconc(categories, list(nreverse(remainders)));
            }
            return categories;
        }
    }

    @LispMethod(comment = "Categories the elements of LIST according to CATEGORY-METHODS.\r\nCATEGORY-METHODS is a list of function-spec-p to be tested, in order.\r\nReturn a list of lists of items for each category.\r\nIf there are any uncategorized elements, they are returned in an extra category at the end.\nCategories the elements of LIST according to CATEGORY-METHODS.\nCATEGORY-METHODS is a list of function-spec-p to be tested, in order.\nReturn a list of lists of items for each category.\nIf there are any uncategorized elements, they are returned in an extra category at the end.")
    public static SubLObject categorize_list_elements(final SubLObject list, final SubLObject category_methods, SubLObject key) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        SubLObject categories = make_list(length(category_methods), UNPROVIDED);
        SubLObject remainders = NIL;
        SubLObject cdolist_list_var = list;
        SubLObject item = NIL;
        item = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject item_key = funcall(key, item);
            SubLObject categorizedP = NIL;
            SubLObject list_var = NIL;
            SubLObject category_method = NIL;
            SubLObject index = NIL;
            list_var = category_methods;
            category_method = list_var.first();
            for (index = ZERO_INTEGER; (NIL == categorizedP) && (NIL != list_var); list_var = list_var.rest() , category_method = list_var.first() , index = number_utilities.f_1X(index)) {
                if (NIL != funcall(category_method, item_key)) {
                    categorizedP = T;
                    set_nth(index, categories, cons(item, nth(index, categories)));
                }
            }
            if (NIL == categorizedP) {
                remainders = cons(item, remainders);
            }
            cdolist_list_var = cdolist_list_var.rest();
            item = cdolist_list_var.first();
        } 
        categories = nmapcar(symbol_function(NREVERSE), categories);
        if (NIL != remainders) {
            categories = nconc(categories, list(nreverse(remainders)));
        }
        return categories;
    }/**
     * Categories the elements of LIST according to CATEGORY-METHODS.
     * CATEGORY-METHODS is a list of function-spec-p to be tested, in order.
     * Return a list of lists of items for each category.
     * If there are any uncategorized elements, they are returned in an extra category at the end.
     */


    /**
     *
     *
     * @param TUPLES;
     * 		a list of tuples, each of the form
     * 		(VALUE-1 VALUE-2 ...)
     * @return listp; a list of tuples, each of the form
    (RANK-1 VALUE-1 RANK-2 VALUE-2 ...)
     */
    @LispMethod(comment = "@param TUPLES;\r\n\t\ta list of tuples, each of the form\r\n\t\t(VALUE-1 VALUE-2 ...)\r\n@return listp; a list of tuples, each of the form\r\n(RANK-1 VALUE-1 RANK-2 VALUE-2 ...)")
    public static final SubLObject rank_tuples_alt(SubLObject tuples) {
        {
            SubLObject length = length(tuples.first());
            SubLObject rank_dictionaries = Mapping.mapcar(symbol_function(NEW_DICTIONARY), make_list(length, symbol_function(EQ)));
            {
                SubLObject index = NIL;
                for (index = ZERO_INTEGER; index.numL(length); index = add(index, ONE_INTEGER)) {
                    {
                        SubLObject key_func = nth(index, $list_alt197);
                        SubLTrampolineFile.checkType(key_func, FUNCTION_SPEC_P);
                        {
                            SubLObject sorted_tuples = Sort.stable_sort(copy_list(tuples), symbol_function($sym97$_), key_func);
                            SubLObject rank_dictionary = nth(index, rank_dictionaries);
                            SubLObject list_var = NIL;
                            SubLObject tuple = NIL;
                            SubLObject rank = NIL;
                            for (list_var = sorted_tuples, tuple = list_var.first(), rank = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , tuple = list_var.first() , rank = add(ONE_INTEGER, rank)) {
                                dictionary.dictionary_enter(rank_dictionary, tuple, rank);
                            }
                        }
                    }
                }
            }
            {
                SubLObject ranked_tuples = NIL;
                SubLObject cdolist_list_var = tuples;
                SubLObject tuple = NIL;
                for (tuple = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , tuple = cdolist_list_var.first()) {
                    {
                        SubLObject ranked_tuple = NIL;
                        SubLObject list_var = NIL;
                        SubLObject value = NIL;
                        SubLObject index = NIL;
                        for (list_var = tuple, value = list_var.first(), index = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , value = list_var.first() , index = add(ONE_INTEGER, index)) {
                            {
                                SubLObject rank = dictionary.dictionary_lookup(nth(index, rank_dictionaries), tuple, UNPROVIDED);
                                ranked_tuple = cons(rank, ranked_tuple);
                                ranked_tuple = cons(value, ranked_tuple);
                            }
                        }
                        ranked_tuples = cons(nreverse(ranked_tuple), ranked_tuples);
                    }
                }
                return nreverse(ranked_tuples);
            }
        }
    }

    /**
     *
     *
     * @param TUPLES;
     * 		a list of tuples, each of the form
     * 		(VALUE-1 VALUE-2 ...)
     * @return listp; a list of tuples, each of the form
    (RANK-1 VALUE-1 RANK-2 VALUE-2 ...)
     */
    @LispMethod(comment = "@param TUPLES;\r\n\t\ta list of tuples, each of the form\r\n\t\t(VALUE-1 VALUE-2 ...)\r\n@return listp; a list of tuples, each of the form\r\n(RANK-1 VALUE-1 RANK-2 VALUE-2 ...)")
    public static SubLObject rank_tuples(final SubLObject tuples) {
        final SubLObject length = length(tuples.first());
        final SubLObject rank_dictionaries = Mapping.mapcar(symbol_function(NEW_DICTIONARY), make_list(length, symbol_function(EQ)));
        SubLObject index;
        SubLObject key_func;
        SubLObject sorted_tuples;
        SubLObject rank_dictionary;
        SubLObject list_var;
        SubLObject tuple;
        SubLObject rank;
        for (index = NIL, index = ZERO_INTEGER; index.numL(length); index = add(index, ONE_INTEGER)) {
            key_func = nth(index, $list206);
            assert NIL != function_spec_p(key_func) : "! function_spec_p(key_func) " + ("Types.function_spec_p(key_func) " + "CommonSymbols.NIL != Types.function_spec_p(key_func) ") + key_func;
            sorted_tuples = Sort.stable_sort(copy_list(tuples), symbol_function($sym97$_), key_func);
            rank_dictionary = nth(index, rank_dictionaries);
            list_var = NIL;
            tuple = NIL;
            rank = NIL;
            list_var = sorted_tuples;
            tuple = list_var.first();
            for (rank = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , tuple = list_var.first() , rank = add(ONE_INTEGER, rank)) {
                dictionary.dictionary_enter(rank_dictionary, tuple, rank);
            }
        }
        SubLObject ranked_tuples = NIL;
        SubLObject cdolist_list_var = tuples;
        SubLObject tuple2 = NIL;
        tuple2 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject ranked_tuple = NIL;
            list_var = NIL;
            SubLObject value = NIL;
            SubLObject index2 = NIL;
            list_var = tuple2;
            value = list_var.first();
            for (index2 = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , value = list_var.first() , index2 = add(ONE_INTEGER, index2)) {
                final SubLObject rank2 = dictionary.dictionary_lookup(nth(index2, rank_dictionaries), tuple2, UNPROVIDED);
                ranked_tuple = cons(rank2, ranked_tuple);
                ranked_tuple = cons(value, ranked_tuple);
            }
            ranked_tuples = cons(nreverse(ranked_tuple), ranked_tuples);
            cdolist_list_var = cdolist_list_var.rest();
            tuple2 = cdolist_list_var.first();
        } 
        return nreverse(ranked_tuples);
    }

    /**
     * Flattens a list of lists of tuples into a list of tuples via concatenation of each ith element.
     * Example: (collate '(((1 A) (2 B)) ((3 C) (4 D)))) -> ((1 A 3 C) (2 B 4 D))
     * This could be made much more efficient if needed.
     */
    @LispMethod(comment = "Flattens a list of lists of tuples into a list of tuples via concatenation of each ith element.\r\nExample: (collate \'(((1 A) (2 B)) ((3 C) (4 D)))) -> ((1 A 3 C) (2 B 4 D))\r\nThis could be made much more efficient if needed.\nFlattens a list of lists of tuples into a list of tuples via concatenation of each ith element.\nExample: (collate \'(((1 A) (2 B)) ((3 C) (4 D)))) -> ((1 A 3 C) (2 B 4 D))\nThis could be made much more efficient if needed.")
    public static final SubLObject collate_alt(SubLObject tuples_list) {
        if (NIL != com.cyc.cycjava.cycl.list_utilities.singletonP(tuples_list)) {
            return tuples_list.first();
        }
        {
            SubLObject result_tuples = NIL;
            SubLObject i = ZERO_INTEGER;
            SubLObject doneP = NIL;
            while (NIL == doneP) {
                {
                    SubLObject result_tuple = NIL;
                    if (NIL == doneP) {
                        {
                            SubLObject csome_list_var = tuples_list;
                            SubLObject tuples = NIL;
                            for (tuples = csome_list_var.first(); !((NIL != doneP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , tuples = csome_list_var.first()) {
                                {
                                    SubLObject tuple = nth(i, tuples);
                                    if (NIL != tuple) {
                                        result_tuple = append(result_tuple, tuple);
                                    } else {
                                        doneP = T;
                                    }
                                }
                            }
                        }
                    }
                    if (NIL == doneP) {
                        i = add(i, ONE_INTEGER);
                        result_tuples = cons(result_tuple, result_tuples);
                    }
                }
            } 
            return nreverse(result_tuples);
        }
    }

    @LispMethod(comment = "Flattens a list of lists of tuples into a list of tuples via concatenation of each ith element.\r\nExample: (collate \'(((1 A) (2 B)) ((3 C) (4 D)))) -> ((1 A 3 C) (2 B 4 D))\r\nThis could be made much more efficient if needed.\nFlattens a list of lists of tuples into a list of tuples via concatenation of each ith element.\nExample: (collate \'(((1 A) (2 B)) ((3 C) (4 D)))) -> ((1 A 3 C) (2 B 4 D))\nThis could be made much more efficient if needed.")
    public static SubLObject collate(final SubLObject tuples_list) {
        if (NIL != singletonP(tuples_list)) {
            return tuples_list.first();
        }
        SubLObject result_tuples = NIL;
        SubLObject i = ZERO_INTEGER;
        SubLObject doneP = NIL;
        while (NIL == doneP) {
            SubLObject result_tuple = NIL;
            if (NIL == doneP) {
                SubLObject csome_list_var = tuples_list;
                SubLObject tuples = NIL;
                tuples = csome_list_var.first();
                while ((NIL == doneP) && (NIL != csome_list_var)) {
                    final SubLObject tuple = nth(i, tuples);
                    if (NIL != tuple) {
                        result_tuple = append(result_tuple, tuple);
                    } else {
                        doneP = T;
                    }
                    csome_list_var = csome_list_var.rest();
                    tuples = csome_list_var.first();
                } 
            }
            if (NIL == doneP) {
                i = add(i, ONE_INTEGER);
                result_tuples = cons(result_tuple, result_tuples);
            }
        } 
        return nreverse(result_tuples);
    }/**
     * Flattens a list of lists of tuples into a list of tuples via concatenation of each ith element.
     * Example: (collate '(((1 A) (2 B)) ((3 C) (4 D)))) -> ((1 A 3 C) (2 B 4 D))
     * This could be made much more efficient if needed.
     */


    /**
     *
     *
     * @return booleanp; whether OBJECT is a non-empty list with FIRST as its first element.
     */
    @LispMethod(comment = "@return booleanp; whether OBJECT is a non-empty list with FIRST as its first element.")
    public static final SubLObject list_with_first_p_alt(SubLObject v_object, SubLObject first) {
        return makeBoolean(v_object.isCons() && first.equal(v_object.first()));
    }

    /**
     *
     *
     * @return booleanp; whether OBJECT is a non-empty list with FIRST as its first element.
     */
    @LispMethod(comment = "@return booleanp; whether OBJECT is a non-empty list with FIRST as its first element.")
    public static SubLObject list_with_first_p(final SubLObject v_object, final SubLObject first) {
        return makeBoolean(v_object.isCons() && first.equal(v_object.first()));
    }

    public static SubLObject elements_incompatibleP(final SubLObject elem1, final SubLObject elem2, final SubLObject incompatible_pairs) {
        if (elem1.equal(elem2)) {
            return NIL;
        }
        if (elem1.equal(elem2)) {
            return NIL;
        }
        SubLObject cdolist_list_var = incompatible_pairs;
        SubLObject incompatible_pair = NIL;
        incompatible_pair = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if ((NIL != member_equalP(elem1, incompatible_pair)) && (NIL != member_equalP(elem2, incompatible_pair))) {
                return T;
            }
            cdolist_list_var = cdolist_list_var.rest();
            incompatible_pair = cdolist_list_var.first();
        } 
        return NIL;
    }

    public static SubLObject element_incompatible_with_any_of(final SubLObject elem, final SubLObject elems, final SubLObject incompatible_pairs) {
        SubLObject other_incompatible_elems = NIL;
        SubLObject cdolist_list_var = elems;
        SubLObject other_elem = NIL;
        other_elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL != elements_incompatibleP(elem, other_elem, incompatible_pairs)) {
                other_incompatible_elems = cons(other_elem, other_incompatible_elems);
            }
            cdolist_list_var = cdolist_list_var.rest();
            other_elem = cdolist_list_var.first();
        } 
        return other_incompatible_elems;
    }

    public static SubLObject compute_all_compatible_sublists(final SubLObject list, final SubLObject incompatible_pairs, SubLObject prefix_list, SubLObject skip_list) {
        if (prefix_list == UNPROVIDED) {
            prefix_list = NIL;
        }
        if (skip_list == UNPROVIDED) {
            skip_list = NIL;
        }
        final SubLObject debugP = NIL;
        if (NIL == list) {
            if (NIL != prefix_list) {
                return list(NIL);
            }
            return NIL;
        } else {
            final SubLObject first_elem = list.first();
            SubLObject relevant_incompatibility_sets = NIL;
            SubLObject results = NIL;
            SubLObject cdolist_list_var = incompatible_pairs;
            SubLObject incompatible_pair = NIL;
            incompatible_pair = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != member_equalP(first_elem, incompatible_pair)) {
                    relevant_incompatibility_sets = cons(incompatible_pair, relevant_incompatibility_sets);
                }
                cdolist_list_var = cdolist_list_var.rest();
                incompatible_pair = cdolist_list_var.first();
            } 
            if (NIL == relevant_incompatibility_sets) {
                if (NIL != debugP) {
                    format(T, $str207$choose__S__default___, first_elem);
                }
                cdolist_list_var = compute_all_compatible_sublists(list.rest(), incompatible_pairs, snoc(first_elem, prefix_list), skip_list);
                SubLObject future_result = NIL;
                future_result = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    results = cons(cons(first_elem, future_result), results);
                    cdolist_list_var = cdolist_list_var.rest();
                    future_result = cdolist_list_var.first();
                } 
                return remove_subsumed_items(results, $sym208$FAST_SUPERSET_, UNPROVIDED);
            }
            if (NIL != relevant_incompatibility_sets) {
                SubLObject past_incompatibleP = NIL;
                SubLObject future_incompatible_choosable_list = NIL;
                SubLObject choice_incompatible_with_previous_skipsP = NIL;
                if (NIL != element_incompatible_with_any_of(first_elem, prefix_list, incompatible_pairs)) {
                    past_incompatibleP = T;
                }
                SubLObject cdolist_list_var2;
                final SubLObject future_incompatible_choosable_elems = cdolist_list_var2 = element_incompatible_with_any_of(first_elem, list.rest(), incompatible_pairs);
                SubLObject future_incompatible_choosable_elem = NIL;
                future_incompatible_choosable_elem = cdolist_list_var2.first();
                while (NIL != cdolist_list_var2) {
                    if (NIL == element_incompatible_with_any_of(future_incompatible_choosable_elem, prefix_list, incompatible_pairs)) {
                        future_incompatible_choosable_list = cons(future_incompatible_choosable_elem, future_incompatible_choosable_list);
                    }
                    cdolist_list_var2 = cdolist_list_var2.rest();
                    future_incompatible_choosable_elem = cdolist_list_var2.first();
                } 
                SubLObject incompatible_with_all_skipsP = sublisp_boolean(skip_list);
                cdolist_list_var2 = skip_list;
                SubLObject skip = NIL;
                skip = cdolist_list_var2.first();
                while (NIL != cdolist_list_var2) {
                    if ((NIL != member_equalP(first_elem, skip)) || (NIL == element_incompatible_with_any_of(first_elem, skip.rest(), incompatible_pairs))) {
                        incompatible_with_all_skipsP = NIL;
                    }
                    cdolist_list_var2 = cdolist_list_var2.rest();
                    skip = cdolist_list_var2.first();
                } 
                if (NIL != incompatible_with_all_skipsP) {
                    if (NIL != debugP) {
                        format(T, $str209$can_t_choose__S_since_incompatibl, first_elem, Mapping.mapcar(CDR, skip_list));
                    }
                    choice_incompatible_with_previous_skipsP = T;
                }
                if (NIL != debugP) {
                    format(T, $str210$past_incompatible___S__, past_incompatibleP);
                    format(T, $str211$future_incompatible_choosable___S, future_incompatible_choosable_list);
                }
                if ((NIL == past_incompatibleP) && (NIL == choice_incompatible_with_previous_skipsP)) {
                    if (NIL != debugP) {
                        format(T, $str212$choose__S__not_past_incompatible_, first_elem);
                    }
                    SubLObject cdolist_list_var3 = compute_all_compatible_sublists(list.rest(), incompatible_pairs, snoc(first_elem, prefix_list), skip_list);
                    SubLObject future_result2 = NIL;
                    future_result2 = cdolist_list_var3.first();
                    while (NIL != cdolist_list_var3) {
                        results = cons(cons(first_elem, future_result2), results);
                        cdolist_list_var3 = cdolist_list_var3.rest();
                        future_result2 = cdolist_list_var3.first();
                    } 
                }
                if ((NIL != future_incompatible_choosable_list) || (NIL != past_incompatibleP)) {
                    if (NIL != debugP) {
                        format(T, $str213$skip__S__past_incompatible_or_fut, first_elem);
                    }
                    SubLObject cdolist_list_var3 = compute_all_compatible_sublists(list.rest(), incompatible_pairs, prefix_list, snoc(cons(first_elem, future_incompatible_choosable_list), skip_list));
                    SubLObject future_result2 = NIL;
                    future_result2 = cdolist_list_var3.first();
                    while (NIL != cdolist_list_var3) {
                        results = cons(future_result2, results);
                        cdolist_list_var3 = cdolist_list_var3.rest();
                        future_result2 = cdolist_list_var3.first();
                    } 
                }
            }
            if (NIL != results) {
                return remove_subsumed_items(results, $sym208$FAST_SUPERSET_, UNPROVIDED);
            }
            if (NIL != prefix_list) {
                return list(NIL);
            }
            return NIL;
        }
    }

    public static SubLObject test_compute_all_compatible_sublists(final SubLObject list, final SubLObject incompatible_pairs, final SubLObject v_answer) {
        return sets_equalP(compute_all_compatible_sublists(list, incompatible_pairs, UNPROVIDED, UNPROVIDED), v_answer, $sym214$SETS_EQUAL_);
    }

    public static SubLObject gather_nodes_and_incompatible_pairs_from_graph_txt(final SubLObject graph_string) {
        final SubLObject lines = string_utilities.string_tokenize(string_utilities.trim_whitespace(graph_string), $list218, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        final SubLObject node_count = length(lines);
        SubLObject node_numbers = NIL;
        SubLObject incompatible_pairs = NIL;
        SubLObject list_var = NIL;
        SubLObject line = NIL;
        SubLObject x = NIL;
        list_var = lines;
        line = list_var.first();
        for (x = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest() , line = list_var.first() , x = add(ONE_INTEGER, x)) {
            final SubLObject elems = string_utilities.string_tokenize(string_utilities.trim_whitespace(line), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            if (!node_count.eql(length(elems))) {
                Errors.error($str219$Invalid_graph_txt_specification_r, line, node_count);
            }
            node_numbers = cons(add(x, ONE_INTEGER), node_numbers);
            SubLObject list_var_$42 = NIL;
            SubLObject elem = NIL;
            SubLObject y = NIL;
            list_var_$42 = elems;
            elem = list_var_$42.first();
            for (y = ZERO_INTEGER; NIL != list_var_$42; list_var_$42 = list_var_$42.rest() , elem = list_var_$42.first() , y = add(ONE_INTEGER, y)) {
                if (elem.equal($$$1)) {
                    incompatible_pairs = cons(list(add(x, ONE_INTEGER), add(y, ONE_INTEGER)), incompatible_pairs);
                }
            }
        }
        return values(nreverse(node_numbers), incompatible_pairs);
    }

    public static SubLObject test_find_maximum_independent_set(final SubLObject graph_txt, final SubLObject answer_max_length, final SubLObject answers) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        thread.resetMultipleValues();
        final SubLObject node_numbers = gather_nodes_and_incompatible_pairs_from_graph_txt(graph_txt);
        final SubLObject incompatible_pairs = thread.secondMultipleValue();
        thread.resetMultipleValues();
        final SubLObject sets = compute_all_compatible_sublists(node_numbers, incompatible_pairs, UNPROVIDED, UNPROVIDED);
        SubLObject max_length = ZERO_INTEGER;
        SubLObject cdolist_list_var = sets;
        SubLObject v_set = NIL;
        v_set = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            max_length = max(max_length, length(v_set));
            cdolist_list_var = cdolist_list_var.rest();
            v_set = cdolist_list_var.first();
        } 
        if (max_length.eql(answer_max_length) && (NIL != subsetp(answers, sets, symbol_function(EQUAL), UNPROVIDED))) {
            return T;
        }
        format(T, $str221$Expected___S__, answers);
        format(T, $str222$Got___);
        cdolist_list_var = sets;
        v_set = NIL;
        v_set = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            format(T, $str223$___S__, v_set);
            cdolist_list_var = cdolist_list_var.rest();
            v_set = cdolist_list_var.first();
        } 
        return NIL;
    }

    public static SubLObject comparator_compare_internal(final SubLObject predicate, final SubLObject val1, final SubLObject val2) {
        final SubLObject predicate_1_2 = funcall(predicate, val1, val2);
        final SubLObject predicate_2_1 = funcall(predicate, val2, val1);
        return NIL != predicate_1_2 ? NIL != predicate_2_1 ? ZERO_INTEGER : ONE_INTEGER : NIL != predicate_2_1 ? MINUS_ONE_INTEGER : ZERO_INTEGER;
    }

    public static SubLObject comparator_compare(final SubLObject predicate, final SubLObject val1, final SubLObject val2) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return comparator_compare_internal(predicate, val1, val2);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, COMPARATOR_COMPARE, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), COMPARATOR_COMPARE, THREE_INTEGER, NIL, EQUAL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, COMPARATOR_COMPARE, caching_state);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_3(predicate, val1, val2);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (predicate.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (val1.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && val2.equal(cached_args.first())) {
                            return memoization_state.caching_results(results2);
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(thread.resetMultipleValues(), multiple_value_list(comparator_compare_internal(predicate, val1, val2)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(predicate, val1, val2));
        return memoization_state.caching_results(results3);
    }

    public static SubLObject sort_preferred_list_to_front(final SubLObject l, final SubLObject preferred_list, SubLObject key) {
        if (key == UNPROVIDED) {
            key = IDENTITY;
        }
        return sort_preferred_to_front(l, set_utilities.construct_set_from_list(preferred_list, UNPROVIDED, UNPROVIDED), key);
    }

    public static SubLObject sort_preferred_to_front(final SubLObject l, final SubLObject preferred, SubLObject key) {
        if (key == UNPROVIDED) {
            key = IDENTITY;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject _prev_bind_0 = $preferred_term_set$.currentBinding(thread);
        try {
            $preferred_term_set$.bind(preferred, thread);
            return Sort.stable_sort(l, A_PREFERRED_OVER_B, key);
        } finally {
            $preferred_term_set$.rebind(_prev_bind_0, thread);
        }
    }

    public static SubLObject a_preferred_over_b(final SubLObject a, final SubLObject b) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        return makeBoolean((NIL != set.set_memberP(a, $preferred_term_set$.getDynamicValue(thread))) && (NIL == set.set_memberP(b, $preferred_term_set$.getDynamicValue(thread))));
    }

    public static SubLObject debug_comparison_method_violates_its_general_contract(final SubLObject seq, final SubLObject predicate, SubLObject key, SubLObject print_all_violationsP) {
        if (key == UNPROVIDED) {
            key = symbol_function(IDENTITY);
        }
        if (print_all_violationsP == UNPROVIDED) {
            print_all_violationsP = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject local_state;
        final SubLObject state = local_state = memoization_state.new_memoization_state(UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        final SubLObject _prev_bind_0 = memoization_state.$memoization_state$.currentBinding(thread);
        try {
            memoization_state.$memoization_state$.bind(local_state, thread);
            final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
            try {
                SubLObject cdolist_list_var = seq;
                SubLObject elem1 = NIL;
                elem1 = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    SubLObject cdolist_list_var_$43 = seq;
                    SubLObject elem2 = NIL;
                    elem2 = cdolist_list_var_$43.first();
                    while (NIL != cdolist_list_var_$43) {
                        final SubLObject elem1_key = funcall(key, elem1);
                        final SubLObject elem2_key = funcall(key, elem2);
                        final SubLObject compare_1_2 = comparator_compare(predicate, elem1_key, elem2_key);
                        final SubLObject compare_2_1 = comparator_compare(predicate, elem2_key, elem1_key);
                        if (!compare_1_2.numE(minus(compare_2_1))) {
                            format(T, $str229$__The_implementer_must_ensure_tha, new SubLObject[]{ elem1, elem2, compare_1_2, predicate, quotify(elem1), quotify(elem2), compare_2_1, predicate, quotify(elem2), quotify(elem1) });
                            if (NIL == print_all_violationsP) {
                                return NIL;
                            }
                        }
                        if (compare_1_2.numG(ZERO_INTEGER)) {
                            SubLObject cdolist_list_var_$44 = seq;
                            SubLObject elem3 = NIL;
                            elem3 = cdolist_list_var_$44.first();
                            while (NIL != cdolist_list_var_$44) {
                                final SubLObject elem3_key = funcall(key, elem3);
                                final SubLObject compare_2_2 = comparator_compare(predicate, elem2_key, elem3_key);
                                if (compare_2_2.numG(ZERO_INTEGER)) {
                                    final SubLObject compare_1_3 = comparator_compare(predicate, elem1_key, elem3_key);
                                    if (!compare_1_3.numG(ZERO_INTEGER)) {
                                        format(T, $str230$__The_implementer_must_ensure_tha, new SubLObject[]{ elem1, elem2, elem3, compare_1_2, predicate, quotify(elem1), quotify(elem2), compare_2_2, predicate, quotify(elem2), quotify(elem3), compare_1_3, predicate, quotify(elem1), quotify(elem3) });
                                        if (NIL == print_all_violationsP) {
                                            return NIL;
                                        }
                                    }
                                }
                                cdolist_list_var_$44 = cdolist_list_var_$44.rest();
                                elem3 = cdolist_list_var_$44.first();
                            } 
                        }
                        if (ZERO_INTEGER.numE(compare_1_2)) {
                            SubLObject cdolist_list_var_$45 = seq;
                            SubLObject elem3 = NIL;
                            elem3 = cdolist_list_var_$45.first();
                            while (NIL != cdolist_list_var_$45) {
                                final SubLObject elem3_key = funcall(key, elem3);
                                final SubLObject compare_1_4 = comparator_compare(predicate, elem1_key, elem3_key);
                                final SubLObject compare_2_3 = comparator_compare(predicate, elem2_key, elem3_key);
                                if (!compare_1_4.numE(compare_2_3)) {
                                    format(T, $str231$__The_implementer_must_ensure_tha, new SubLObject[]{ elem1, elem2, elem3, compare_1_2, predicate, quotify(elem1), quotify(elem2), compare_1_4, predicate, quotify(elem1), quotify(elem3), compare_2_3, predicate, quotify(elem2), quotify(elem3) });
                                    if (NIL == print_all_violationsP) {
                                        return NIL;
                                    }
                                }
                                cdolist_list_var_$45 = cdolist_list_var_$45.rest();
                                elem3 = cdolist_list_var_$45.first();
                            } 
                        }
                        cdolist_list_var_$43 = cdolist_list_var_$43.rest();
                        elem2 = cdolist_list_var_$43.first();
                    } 
                    cdolist_list_var = cdolist_list_var.rest();
                    elem1 = cdolist_list_var.first();
                } 
            } finally {
                final SubLObject _prev_bind_0_$46 = $is_thread_performing_cleanupP$.currentBinding(thread);
                try {
                    $is_thread_performing_cleanupP$.bind(T, thread);
                    final SubLObject _values = getValuesAsVector();
                    memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                    restoreValuesFromVector(_values);
                } finally {
                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$46, thread);
                }
            }
        } finally {
            memoization_state.$memoization_state$.rebind(_prev_bind_0, thread);
        }
        return NIL;
    }

    public static SubLObject find_first_and_nreplace_test(final SubLObject old, final SubLObject v_new, final SubLObject list, SubLObject test) {
        if (test == UNPROVIDED) {
            test = symbol_function(EQ);
        }
        return find_first_and_nreplace(old, v_new, copy_list(list), test);
    }

    public static final SubLObject declare_list_utilities_file_alt() {
        declareFunction("sublisp_boolean", "BOOLEAN", 1, 0, false);
        declareFunction("not_boolean", "NOT-BOOLEAN", 1, 0, false);
        declareFunction("not_eq", "NOT-EQ", 2, 0, false);
        declareFunction("not_eql", "NOT-EQL", 2, 0, false);
        declareFunction("not_equal", "NOT-EQUAL", 2, 0, false);
        declareFunction("not_equalp", "NOT-EQUALP", 2, 0, false);
        declareFunction("not_assoc", "NOT-ASSOC", 2, 2, false);
        declareFunction("not_consp", "NOT-CONSP", 1, 0, false);
        declareFunction("eq_and_not_eq", "EQ-AND-NOT-EQ", 2, 0, false);
        declareFunction("bull", "BULL", 2, 0, false);
        declareFunction("caadr", "CAADR", 1, 0, false);
        declareFunction("caddr", "CADDR", 1, 0, false);
        declareFunction("cdddr", "CDDDR", 1, 0, false);
        declareFunction("cadddr", "CADDDR", 1, 0, false);
        declareFunction("cadadr", "CADADR", 1, 0, false);
        declareFunction("cadar", "CADAR", 1, 0, false);
        new com.cyc.cycjava.cycl.list_utilities.$cadar$UnaryFunction();
        declareFunction("cdadr", "CDADR", 1, 0, false);
        declareFunction("snoc", "SNOC", 2, 0, false);
        declareFunction("list_rotate_left", "LIST-ROTATE-LEFT", 1, 0, false);
        declareFunction("list_rotate_right", "LIST-ROTATE-RIGHT", 1, 0, false);
        declareFunction("proper_subsetp", "PROPER-SUBSETP", 2, 2, false);
        declareFunction("proper_subsetp_pre_sorted", "PROPER-SUBSETP-PRE-SORTED", 2, 2, false);
        declareFunction("nth_cycling", "NTH-CYCLING", 2, 2, false);
        declareMacro("pop_setq", "POP-SETQ");
        declareMacro("pop_bind", "POP-BIND");
        declareMacro("push_max_length", "PUSH-MAX-LENGTH");
        declareMacro("cdolist_multiple", "CDOLIST-MULTIPLE");
        declareMacro("cdolist_multiple_numbered", "CDOLIST-MULTIPLE-NUMBERED");
        declareMacro("csome_multiple", "CSOME-MULTIPLE");
        declareMacro("cdolist_numbered", "CDOLIST-NUMBERED");
        declareMacro("cdolist_backward", "CDOLIST-BACKWARD");
        declareMacro("cdolist_backward_numbered", "CDOLIST-BACKWARD-NUMBERED");
        declareMacro("csome_numbered", "CSOME-NUMBERED");
        declareMacro("cdolist_cycling", "CDOLIST-CYCLING");
        declareMacro("cdolist_cycling_complex", "CDOLIST-CYCLING-COMPLEX");
        declareMacro("do_tree_leaves", "DO-TREE-LEAVES");
        declareFunction("args_from_arg_list", "ARGS-FROM-ARG-LIST", 1, 0, false);
        declareFunction("lengthL", "LENGTH<", 2, 1, false);
        declareFunction("lengthLE", "LENGTH<=", 2, 1, false);
        declareFunction("lengthE", "LENGTH=", 2, 1, false);
        declareFunction("lengthsE", "LENGTHS=", 2, 1, false);
        declareFunction("lengthG", "LENGTH>", 2, 1, false);
        declareFunction("lengthGE", "LENGTH>=", 2, 1, false);
        declareFunction("zero_length_p", "ZERO-LENGTH-P", 1, 0, false);
        declareFunction("same_length_p", "SAME-LENGTH-P", 2, 0, false);
        declareFunction("same_lengths_p", "SAME-LENGTHS-P", 1, 0, false);
        declareFunction("longer_p", "LONGER-P", 2, 0, false);
        declareFunction("greater_length_p", "GREATER-LENGTH-P", 2, 0, false);
        declareFunction("greater_or_same_length_p", "GREATER-OR-SAME-LENGTH-P", 2, 0, false);
        declareFunction("shorter_p", "SHORTER-P", 2, 0, false);
        declareFunction("lesser_length_p", "LESSER-LENGTH-P", 2, 0, false);
        declareFunction("lesser_or_same_length_p", "LESSER-OR-SAME-LENGTH-P", 2, 0, false);
        declareFunction("empty_list_p", "EMPTY-LIST-P", 1, 0, false);
        declareFunction("non_empty_list_p", "NON-EMPTY-LIST-P", 1, 0, false);
        declareFunction("proper_list_p", "PROPER-LIST-P", 1, 0, false);
        declareFunction("dotted_list_p", "DOTTED-LIST-P", 1, 0, false);
        new com.cyc.cycjava.cycl.list_utilities.$dotted_list_p$UnaryFunction();
        declareFunction("non_dotted_list_p", "NON-DOTTED-LIST-P", 1, 0, false);
        declareFunction("dotted_length", "DOTTED-LENGTH", 1, 0, false);
        declareFunction("dotted_last", "DOTTED-LAST", 1, 0, false);
        declareFunction("dotted_butlast", "DOTTED-BUTLAST", 1, 0, false);
        declareFunction("undot", "UNDOT", 1, 0, false);
        declareFunction("add_to_dotted_end", "ADD-TO-DOTTED-END", 2, 0, false);
        declareFunction("nadd_to_dotted_end", "NADD-TO-DOTTED-END", 2, 0, false);
        declareFunction("ndot_last", "NDOT-LAST", 1, 0, false);
        declareFunction("dot_last", "DOT-LAST", 1, 0, false);
        declareFunction("possible_dotted_list_to_dotted_list", "POSSIBLE-DOTTED-LIST-TO-DOTTED-LIST", 1, 1, false);
        declareFunction("list_non_dotted_through_n_p", "LIST-NON-DOTTED-THROUGH-N-P", 2, 0, false);
        declareFunction("negated_test_func", "NEGATED-TEST-FUNC", 1, 0, false);
        new com.cyc.cycjava.cycl.list_utilities.$negated_test_func$UnaryFunction();
        declareFunction("remove_if_not", "REMOVE-IF-NOT", 2, 4, false);
        declareFunction("delete_if_not", "DELETE-IF-NOT", 2, 4, false);
        declareFunction("substitute_if_not", "SUBSTITUTE-IF-NOT", 3, 4, false);
        declareFunction("nsubstitute_if_not", "NSUBSTITUTE-IF-NOT", 3, 4, false);
        declareFunction("find_if_not", "FIND-IF-NOT", 2, 3, false);
        declareFunction("position_if_not", "POSITION-IF-NOT", 2, 3, false);
        declareFunction("position_if_binary_lambda", "POSITION-IF-BINARY-LAMBDA", 1, 0, false);
        declareFunction("position_if_binary", "POSITION-IF-BINARY", 3, 3, false);
        declareFunction("position_from_end", "POSITION-FROM-END", 2, 4, false);
        declareFunction("tree_positions", "TREE-POSITIONS", 2, 2, false);
        declareFunction("tree_position_bfs", "TREE-POSITION-BFS", 2, 1, false);
        declareFunction("tree_position_dfs", "TREE-POSITION-DFS", 2, 1, false);
        declareFunction("list_position", "LIST-POSITION", 2, 2, false);
        declareFunction("tree_position_p", "TREE-POSITION-P", 1, 0, false);
        declareFunction("tree_nested_nths", "TREE-NESTED-NTHS", 2, 0, false);
        declareFunction("tree_nths", "TREE-NTHS", 2, 0, false);
        declareFunction("has_nested_nth_p", "HAS-NESTED-NTH-P", 2, 0, false);
        declareFunction("get_nested_nth", "GET-NESTED-NTH", 2, 1, false);
        declareFunction("replace_nested_nth", "REPLACE-NESTED-NTH", 3, 0, false);
        declareFunction("nreplace_nested_nth", "NREPLACE-NESTED-NTH", 3, 0, false);
        declareFunction("remove_nested_nth", "REMOVE-NESTED-NTH", 2, 0, false);
        declareFunction("delete_nested_nth", "DELETE-NESTED-NTH", 2, 0, false);
        declareFunction("delete_nested_nth_internal", "DELETE-NESTED-NTH-INTERNAL", 2, 0, false);
        declareFunction("tree_positions_int", "TREE-POSITIONS-INT", 3, 1, false);
        declareFunction("tree_positions_dfs", "TREE-POSITIONS-DFS", 2, 1, false);
        declareFunction("tree_positions_bfs", "TREE-POSITIONS-BFS", 2, 1, false);
        declareFunction("containing_subtrees", "CONTAINING-SUBTREES", 2, 0, false);
        declareFunction("tree_positions_if_dfs", "TREE-POSITIONS-IF-DFS", 2, 1, false);
        declareFunction("tree_positions_if_bfs", "TREE-POSITIONS-IF-BFS", 2, 1, false);
        declareFunction("tree_positions_if_dfs_int", "TREE-POSITIONS-IF-DFS-INT", 2, 1, false);
        declareFunction("tree_position_if_bfs", "TREE-POSITION-IF-BFS", 2, 1, false);
        declareFunction("tree_position_if_dfs", "TREE-POSITION-IF-DFS", 2, 1, false);
        declareFunction("count_if_not", "COUNT-IF-NOT", 2, 3, false);
        declareFunction("subst_if_not", "SUBST-IF-NOT", 3, 1, false);
        declareFunction("nsubst_if_not", "NSUBST-IF-NOT", 3, 1, false);
        declareFunction("member_if_not", "MEMBER-IF-NOT", 2, 1, false);
        declareFunction("assoc_if_not", "ASSOC-IF-NOT", 2, 0, false);
        declareFunction("rassoc_if_not", "RASSOC-IF-NOT", 2, 0, false);
        declareFunction("assoc_all", "ASSOC-ALL", 2, 1, false);
        declareFunction("assoc_push", "ASSOC-PUSH", 3, 1, false);
        declareFunction("assoc_pushnew", "ASSOC-PUSHNEW", 3, 1, false);
        declareFunction("dotted_assoc_push", "DOTTED-ASSOC-PUSH", 3, 1, false);
        declareFunction("assoc_equal", "ASSOC-EQUAL", 2, 0, false);
        declareFunction("assoc_subsumedP", "ASSOC-SUBSUMED?", 3, 0, false);
        declareFunction("alist_extend", "ALIST-EXTEND", 2, 0, false);
        declareFunction("make_alist", "MAKE-ALIST", 1, 1, false);
        declareFunction("make_alist_from_keys_and_values", "MAKE-ALIST-FROM-KEYS-AND-VALUES", 2, 0, false);
        declareFunction("make_pair_list", "MAKE-PAIR-LIST", 2, 0, false);
        declareFunction("make_paired_lists", "MAKE-PAIRED-LISTS", 1, 0, false);
        declareFunction("first_safe_for_atoms", "FIRST-SAFE-FOR-ATOMS", 1, 0, false);
        declareMacro("first_of", "FIRST-OF");
        declareFunction("recons", "RECONS", 3, 0, false);
        declareFunction("ncons", "NCONS", 3, 0, false);
        declareFunction("delete_first", "DELETE-FIRST", 2, 1, false);
        declareFunction("remove_first", "REMOVE-FIRST", 2, 1, false);
        declareFunction("nmapcar", "NMAPCAR", 2, 0, false);
        declareFunction("mapappend", "MAPAPPEND", 2, 0, false);
        declareFunction("mapunion", "MAPUNION", 2, 1, false);
        declareFunction("mapnunion", "MAPNUNION", 2, 1, false);
        declareFunction("mapcar_product", "MAPCAR-PRODUCT", 3, 0, false);
        declareFunction("mapcar_unique", "MAPCAR-UNIQUE", 2, 1, false);
        declareFunction("last1", "LAST1", 1, 0, false);
        declareFunction("add_to_end", "ADD-TO-END", 2, 0, false);
        declareFunction("nadd_to_end", "NADD-TO-END", 2, 0, false);
        declareFunction("adjoin_to_end", "ADJOIN-TO-END", 2, 1, false);
        declareFunction("nadjoin_to_end", "NADJOIN-TO-END", 2, 1, false);
        declareFunction("add_to_end_if", "ADD-TO-END-IF", 2, 0, false);
        declareFunction("nadd_to_end_if", "NADD-TO-END-IF", 2, 0, false);
        declareFunction("nth_from_end", "NTH-FROM-END", 2, 0, false);
        declareFunction("remove_from_end", "REMOVE-FROM-END", 2, 1, false);
        declareFunction("remove_objects_from_list", "REMOVE-OBJECTS-FROM-LIST", 2, 1, false);
        declareFunction("partition_list", "PARTITION-LIST", 2, 0, false);
        declareFunction("npartition_list", "NPARTITION-LIST", 2, 0, false);
        declareFunction("partition_list_by_equality", "PARTITION-LIST-BY-EQUALITY", 2, 2, false);
        declareFunction("partition_list_n_ways", "PARTITION-LIST-N-WAYS", 2, 0, false);
        declareFunction("randomly_partition_list_n_ways", "RANDOMLY-PARTITION-LIST-N-WAYS", 2, 0, false);
        declareFunction("split_list", "SPLIT-LIST", 2, 0, false);
        declareFunction("random_element", "RANDOM-ELEMENT", 1, 0, false);
        declareFunction("random_aref", "RANDOM-AREF", 1, 0, false);
        declareFunction("random_n", "RANDOM-N", 2, 0, false);
        declareFunction("random_remove_n", "RANDOM-REMOVE-N", 2, 0, false);
        declareFunction("random_delete", "RANDOM-DELETE", 1, 0, false);
        declareFunction("randomize_list", "RANDOMIZE-LIST", 1, 0, false);
        declareFunction("randomize_vector", "RANDOMIZE-VECTOR", 1, 0, false);
        declareFunction("randomize_vector_int", "RANDOMIZE-VECTOR-INT", 3, 0, false);
        declareFunction("random_compare", "RANDOM-COMPARE", 2, 0, false);
        declareFunction("thirdL", "THIRD<", 2, 0, false);
        declareFunction("find_all", "FIND-ALL", 2, 2, false);
        declareFunction("find_all_if", "FIND-ALL-IF", 2, 1, false);
        declareFunction("find_all_if_not", "FIND-ALL-IF-NOT", 2, 1, false);
        declareFunction("all_positions", "ALL-POSITIONS", 2, 3, false);
        declareFunction("only_one", "ONLY-ONE", 1, 0, false);
        declareFunction("last_one", "LAST-ONE", 1, 0, false);
        declareFunction("penultimate_one", "PENULTIMATE-ONE", 1, 0, false);
        declareFunction("cons_if", "CONS-IF", 2, 0, false);
        declareFunction("list_if", "LIST-IF", 1, 0, false);
        declareFunction("adjoin_if", "ADJOIN-IF", 2, 1, false);
        declareFunction("flatten", "FLATTEN", 1, 0, false);
        declareFunction("insert_between_each", "INSERT-BETWEEN-EACH", 2, 0, false);
        declareFunction("safe_nth", "SAFE-NTH", 2, 0, false);
        declareFunction("nths", "NTHS", 2, 0, false);
        declareFunction("every_nth", "EVERY-NTH", 2, 0, false);
        declareFunction("first_n", "FIRST-N", 2, 0, false);
        declareFunction("first_n_percent", "FIRST-N-PERCENT", 2, 0, false);
        declareFunction("first_n_if", "FIRST-N-IF", 3, 1, false);
        declareFunction("first_2", "FIRST-2", 1, 0, false);
        declareFunction("first_10", "FIRST-10", 1, 0, false);
        declareFunction("last_n", "LAST-N", 2, 0, false);
        declareFunction("nth_chunk_of_k", "NTH-CHUNK-OF-K", 3, 0, false);
        declareFunction("delete_nth", "DELETE-NTH", 2, 0, false);
        declareFunction("remove_nth", "REMOVE-NTH", 2, 0, false);
        declareFunction("remove_last", "REMOVE-LAST", 1, 0, false);
        declareFunction("remove_nths", "REMOVE-NTHS", 2, 0, false);
        declareFunction("nreplace_last", "NREPLACE-LAST", 2, 0, false);
        declareFunction("nreplace_nth", "NREPLACE-NTH", 3, 0, false);
        declareFunction("find_and_replace", "FIND-AND-REPLACE", 3, 1, false);
        declareFunction("find_and_nreplace", "FIND-AND-NREPLACE", 3, 1, false);
        declareFunction("find_first_and_nreplace", "FIND-FIRST-AND-NREPLACE", 3, 1, false);
        declareFunction("ncollapse_n_from_pos", "NCOLLAPSE-N-FROM-POS", 4, 0, false);
        declareFunction("ninsert_by_position", "NINSERT-BY-POSITION", 3, 0, false);
        declareFunction("ninsert_randomly", "NINSERT-RANDOMLY", 2, 0, false);
        declareFunction("ninsert_somewhere_before_and_after", "NINSERT-SOMEWHERE-BEFORE-AND-AFTER", 3, 1, false);
        declareFunction("ninsert_somewhere_before", "NINSERT-SOMEWHERE-BEFORE", 3, 0, false);
        declareFunction("ninsert_somewhere_before_or_at", "NINSERT-SOMEWHERE-BEFORE-OR-AT", 3, 0, false);
        declareFunction("ninsert_somewhere_after", "NINSERT-SOMEWHERE-AFTER", 3, 0, false);
        declareFunction("move_nth_to_front", "MOVE-NTH-TO-FRONT", 2, 0, false);
        declareFunction("move_nth_to_position", "MOVE-NTH-TO-POSITION", 3, 0, false);
        declareFunction("nmove_to_front", "NMOVE-TO-FRONT", 2, 1, false);
        declareFunction("move_to_front", "MOVE-TO-FRONT", 2, 1, false);
        declareFunction("nmove_to_end", "NMOVE-TO-END", 2, 0, false);
        declareFunction("move_to_end", "MOVE-TO-END", 2, 0, false);
        declareFunction("replace_nth", "REPLACE-NTH", 3, 0, false);
        declareFunction("replace_last", "REPLACE-LAST", 2, 0, false);
        declareFunction("remove_duplicates_from_end", "REMOVE-DUPLICATES-FROM-END", 1, 4, false);
        declareFunction("remove_duplicates_from_start", "REMOVE-DUPLICATES-FROM-START", 1, 4, false);
        declareFunction("delete_duplicates_from_end", "DELETE-DUPLICATES-FROM-END", 1, 4, false);
        declareFunction("delete_duplicates_from_start", "DELETE-DUPLICATES-FROM-START", 1, 4, false);
        declareFunction("remove_null", "REMOVE-NULL", 1, 4, false);
        declareFunction("remove_from_end_duplicates_and_those_wXkey", "REMOVE-FROM-END-DUPLICATES-AND-THOSE-W/KEY", 2, 4, false);
        declareFunction("skipping_positions", "SKIPPING-POSITIONS", 2, 0, false);
        declareFunction("num_list", "NUM-LIST", 1, 1, false);
        declareFunction("new_num_list", "NEW-NUM-LIST", 1, 1, false);
        declareFunction("verify_num_list", "VERIFY-NUM-LIST", 3, 0, false);
        declareFunction("clear_num_list_cached", "CLEAR-NUM-LIST-CACHED", 0, 0, false);
        declareFunction("remove_num_list_cached", "REMOVE-NUM-LIST-CACHED", 2, 0, false);
        declareFunction("num_list_cached_internal", "NUM-LIST-CACHED-INTERNAL", 2, 0, false);
        declareFunction("num_list_cached", "NUM-LIST-CACHED", 2, 0, false);
        declareFunction("numlist", "NUMLIST", 1, 1, false);
        declareFunction("tree_ancestor", "TREE-ANCESTOR", 2, 1, false);
        declareFunction("member_eqP", "MEMBER-EQ?", 2, 0, false);
        declareFunction("member_equalP", "MEMBER-EQUAL?", 2, 0, false);
        declareFunction("member_equalpP", "MEMBER-EQUALP?", 2, 0, false);
        declareFunction("nmemberP", "NMEMBER?", 2, 1, false);
        declareFunction("nmember_eqP", "NMEMBER-EQ?", 2, 0, false);
        declareFunction("nmember_eqlP", "NMEMBER-EQL?", 2, 0, false);
        declareFunction("nmember_equalP", "NMEMBER-EQUAL?", 2, 0, false);
        declareFunction("nmember_equalpP", "NMEMBER-EQUALP?", 2, 0, false);
        declareFunction("nmember_funcallP", "NMEMBER-FUNCALL?", 3, 0, false);
        declareFunction("nmember_success", "NMEMBER-SUCCESS", 3, 0, false);
        declareFunction("intersectP", "INTERSECT?", 2, 2, false);
        declareFunction("intersect_sortedP", "INTERSECT-SORTED?", 2, 2, false);
        declareFunction("which_intersect_element_sorted", "WHICH-INTERSECT-ELEMENT-SORTED", 2, 2, false);
        declareFunction("sorted_subsetp", "SORTED-SUBSETP", 2, 3, false);
        declareFunction("sortedP", "SORTED?", 1, 1, false);
        declareFunction("occurs_onceP", "OCCURS-ONCE?", 2, 1, false);
        declareFunction("not_only_elementP", "NOT-ONLY-ELEMENT?", 2, 1, false);
        declareFunction("occurs_at_least_n_timesP", "OCCURS-AT-LEAST-N-TIMES?", 3, 1, false);
        declareFunction("occurs_exactly_n_timesP", "OCCURS-EXACTLY-N-TIMES?", 3, 1, false);
        declareFunction("occurs_at_most_n_timesP", "OCCURS-AT-MOST-N-TIMES?", 3, 1, false);
        declareFunction("singletonP", "SINGLETON?", 1, 0, false);
        declareFunction("doubletonP", "DOUBLETON?", 1, 0, false);
        declareFunction("tripleP", "TRIPLE?", 1, 0, false);
        declareFunction("list_of_length_p", "LIST-OF-LENGTH-P", 2, 1, false);
        declareFunction("list_of_doubletonP", "LIST-OF-DOUBLETON?", 1, 0, false);
        declareFunction("exactly_one_distinct_memberP", "EXACTLY-ONE-DISTINCT-MEMBER?", 1, 1, false);
        declareFunction("duplicatesP", "DUPLICATES?", 1, 2, false);
        declareFunction("equal_duplicatesP", "EQUAL-DUPLICATES?", 1, 1, false);
        declareFunction("duplicates", "DUPLICATES", 1, 2, false);
        declareFunction("duplicate_memberP", "DUPLICATE-MEMBER?", 2, 1, false);
        declareFunction("list_starts_with_repeating_sequenceP", "LIST-STARTS-WITH-REPEATING-SEQUENCE?", 1, 3, false);
        declareFunction("update_repeating_sequence", "UPDATE-REPEATING-SEQUENCE", 8, 0, false);
        declareFunction("multisets_equalP", "MULTISETS-EQUAL?", 2, 1, false);
        declareFunction("sets_equalP", "SETS-EQUAL?", 2, 1, false);
        declareFunction("fast_sets_equalP", "FAST-SETS-EQUAL?", 2, 1, false);
        declareFunction("fast_subsetP", "FAST-SUBSET?", 2, 1, false);
        declareFunction("fast_subset_equalP", "FAST-SUBSET-EQUAL?", 2, 0, false);
        declareFunction("fast_supersetP", "FAST-SUPERSET?", 2, 1, false);
        declareFunction("fast_superset_equalP", "FAST-SUPERSET-EQUAL?", 2, 0, false);
        declareFunction("sets_equal_equalP", "SETS-EQUAL-EQUAL?", 2, 0, false);
        declareFunction("subsetp_equalP", "SUBSETP-EQUAL?", 2, 1, false);
        declareFunction("supersetp", "SUPERSETP", 2, 2, false);
        declareFunction("set_differenceP", "SET-DIFFERENCE?", 2, 2, false);
        declareFunction("tree_set_equalP", "TREE-SET-EQUAL?", 2, 0, false);
        declareFunction("ordered_merge", "ORDERED-MERGE", 2, 2, false);
        declareFunction("ordered_union", "ORDERED-UNION", 2, 2, false);
        declareFunction("union_all", "UNION-ALL", 1, 2, false);
        declareFunction("ordered_set_difference", "ORDERED-SET-DIFFERENCE", 2, 2, false);
        declareFunction("hash_set_difference", "HASH-SET-DIFFERENCE", 2, 1, false);
        declareFunction("fast_set_difference", "FAST-SET-DIFFERENCE", 2, 1, false);
        declareFunction("partial_order_sort", "PARTIAL-ORDER-SORT", 2, 1, false);
        declareFunction("list2vector", "LIST2VECTOR", 1, 0, false);
        declareFunction("vector2list", "VECTOR2LIST", 1, 0, false);
        declareFunction("list_without_repetition_p", "LIST-WITHOUT-REPETITION-P", 1, 2, false);
        declareFunction("sequence_elements", "SEQUENCE-ELEMENTS", 2, 0, false);
        declareFunction("set_difference_forts", "SET-DIFFERENCE-FORTS", 2, 0, false);
        declareFunction("ordered_intersection", "ORDERED-INTERSECTION", 2, 2, false);
        declareFunction("intersect_all", "INTERSECT-ALL", 1, 2, false);
        declareFunction("fast_intersect_all", "FAST-INTERSECT-ALL", 1, 2, false);
        declareFunction("safe_pairlis", "SAFE-PAIRLIS", 2, 0, false);
        declareFunction("flip_alist", "FLIP-ALIST", 1, 0, false);
        declareFunction("flip_cons", "FLIP-CONS", 1, 0, false);
        new com.cyc.cycjava.cycl.list_utilities.$flip_cons$UnaryFunction();
        declareFunction("flip_doubleton", "FLIP-DOUBLETON", 1, 0, false);
        declareFunction("substitute_sequence", "SUBSTITUTE-SEQUENCE", 3, 0, false);
        declareFunction("substitute_sequence_1", "SUBSTITUTE-SEQUENCE-1", 4, 0, false);
        declareFunction("compare_lists", "COMPARE-LISTS", 2, 2, false);
        declareFunction("unique_difference_among_lists", "UNIQUE-DIFFERENCE-AMONG-LISTS", 1, 0, false);
        declareFunction("unique_difference_between_lists", "UNIQUE-DIFFERENCE-BETWEEN-LISTS", 2, 0, false);
        declareFunction("list_subst", "LIST-SUBST", 3, 1, false);
        declareFunction("self_evaluating_form_p", "SELF-EVALUATING-FORM-P", 1, 0, false);
        declareFunction("quote_form_p", "QUOTE-FORM-P", 1, 0, false);
        declareFunction("non_side_effecting_form_p", "NON-SIDE-EFFECTING-FORM-P", 1, 0, false);
        declareFunction("quotify", "QUOTIFY", 1, 0, false);
        new com.cyc.cycjava.cycl.list_utilities.$quotify$UnaryFunction();
        declareFunction("unquotify", "UNQUOTIFY", 1, 0, false);
        declareFunction("sort_adjoin", "SORT-ADJOIN", 2, 3, false);
        declareFunction("sorted_add_to_list", "SORTED-ADD-TO-LIST", 3, 1, false);
        declareFunction("splice_into_sorted_list", "SPLICE-INTO-SORTED-LIST", 3, 1, false);
        declareFunction("safe_splice_into_sorted_list", "SAFE-SPLICE-INTO-SORTED-LIST", 3, 1, false);
        declareFunction("element_precedes_specified_othersP", "ELEMENT-PRECEDES-SPECIFIED-OTHERS?", 3, 2, false);
        declareFunction("function_arglist_max_args", "FUNCTION-ARGLIST-MAX-ARGS", 1, 0, false);
        declareFunction("function_arglist_min_args", "FUNCTION-ARGLIST-MIN-ARGS", 1, 0, false);
        declareFunction("remove_self_binds", "REMOVE-SELF-BINDS", 1, 1, false);
        declareFunction("self_bindP", "SELF-BIND?", 1, 1, false);
        declareFunction("bind_for_var", "BIND-FOR-VAR", 2, 2, false);
        declareFunction("remove_bind", "REMOVE-BIND", 2, 2, false);
        declareFunction("extract_bindings", "EXTRACT-BINDINGS", 2, 0, false);
        declareFunction("car_is_el_varP", "CAR-IS-EL-VAR?", 1, 0, false);
        declareFunction("extract_binding_strings", "EXTRACT-BINDING-STRINGS", 2, 0, false);
        declareFunction("tree_funcall_if", "TREE-FUNCALL-IF", 3, 1, false);
        declareFunction("tree_find_all_if", "TREE-FIND-ALL-IF", 2, 1, false);
        declareFunction("tree_remove_all_if", "TREE-REMOVE-ALL-IF", 2, 1, false);
        declareFunction("nswap_tree", "NSWAP-TREE", 3, 2, false);
        declareFunction("swap_tree", "SWAP-TREE", 3, 2, false);
        declareFunction("tree_find_all_nested_if", "TREE-FIND-ALL-NESTED-IF", 2, 1, false);
        declareFunction("tree_find_all_nested_if_int", "TREE-FIND-ALL-NESTED-IF-INT", 3, 0, false);
        declareFunction("hash_delete_duplicates", "HASH-DELETE-DUPLICATES", 1, 4, false);
        declareFunction("hash_delete_duplicates_int", "HASH-DELETE-DUPLICATES-INT", 5, 0, false);
        declareFunction("hash_remove_duplicates", "HASH-REMOVE-DUPLICATES", 1, 4, false);
        declareFunction("fast_delete_duplicates_hashtable", "FAST-DELETE-DUPLICATES-HASHTABLE", 1, 0, false);
        declareFunction("fast_delete_duplicates", "FAST-DELETE-DUPLICATES", 1, 5, false);
        declareFunction("fast_remove_duplicates", "FAST-REMOVE-DUPLICATES", 1, 5, false);
        declareFunction("remove_duplicate_forts", "REMOVE-DUPLICATE-FORTS", 1, 0, false);
        declareFunction("delete_duplicate_forts", "DELETE-DUPLICATE-FORTS", 1, 0, false);
        declareFunction("hash_unique_elements", "HASH-UNIQUE-ELEMENTS", 2, 0, false);
        declareFunction("unique_elements", "UNIQUE-ELEMENTS", 1, 1, false);
        declareFunction("remove_all_n_icates", "REMOVE-ALL-N-ICATES", 2, 1, false);
        declareFunction("nsort_intersection", "NSORT-INTERSECTION", 2, 2, false);
        declareFunction("intersect_sorted", "INTERSECT-SORTED", 2, 2, false);
        declareFunction("nintersect_sorted", "NINTERSECT-SORTED", 2, 2, false);
        declareFunction("nintersect_sorted_destroy_first_only", "NINTERSECT-SORTED-DESTROY-FIRST-ONLY", 2, 2, false);
        declareFunction("nintersect_sorted_int", "NINTERSECT-SORTED-INT", 4, 0, false);
        declareFunction("sort_intersection", "SORT-INTERSECTION", 2, 2, false);
        declareFunction("union_sorted", "UNION-SORTED", 2, 2, false);
        declareFunction("nunion_sorted", "NUNION-SORTED", 2, 2, false);
        declareFunction("union_sorted_int", "UNION-SORTED-INT", 5, 0, false);
        declareFunction("union_of_intersecting_sorted_lists", "UNION-OF-INTERSECTING-SORTED-LISTS", 1, 2, false);
        declareFunction("union_of_intersecting_sorted_lists_recursive", "UNION-OF-INTERSECTING-SORTED-LISTS-RECURSIVE", 4, 0, false);
        declareFunction("delete_duplicates_sorted", "DELETE-DUPLICATES-SORTED", 1, 1, false);
        declareFunction("remove_duplicates_sorted", "REMOVE-DUPLICATES-SORTED", 1, 1, false);
        declareFunction("position_wrt", "POSITION-WRT", 3, 3, false);
        declareFunction("difference_sorted", "DIFFERENCE-SORTED", 2, 2, false);
        declareFunction("alist_p", "ALIST-P", 1, 0, false);
        declareFunction("alist_lookup", "ALIST-LOOKUP", 2, 2, false);
        declareFunction("alist_lookup_without_values", "ALIST-LOOKUP-WITHOUT-VALUES", 2, 2, false);
        declareFunction("alist_nlookup_without_values", "ALIST-NLOOKUP-WITHOUT-VALUES", 2, 2, false);
        declareFunction("alist_nlookup_eq", "ALIST-NLOOKUP-EQ", 2, 1, false);
        declareFunction("alist_nlookup_eql", "ALIST-NLOOKUP-EQL", 2, 1, false);
        declareFunction("alist_nlookup_equal", "ALIST-NLOOKUP-EQUAL", 2, 1, false);
        declareFunction("alist_nlookup_equalp", "ALIST-NLOOKUP-EQUALP", 2, 1, false);
        declareFunction("alist_nlookup_funcall", "ALIST-NLOOKUP-FUNCALL", 3, 1, false);
        declareFunction("alist_nlookup_success", "ALIST-NLOOKUP-SUCCESS", 4, 0, false);
        declareFunction("alist_has_keyP", "ALIST-HAS-KEY?", 2, 1, false);
        declareFunction("alist_has_valueP", "ALIST-HAS-VALUE?", 2, 1, false);
        declareFunction("alist_reverse_lookup", "ALIST-REVERSE-LOOKUP", 2, 2, false);
        declareFunction("alist_reverse_lookup_without_values", "ALIST-REVERSE-LOOKUP-WITHOUT-VALUES", 2, 2, false);
        declareFunction("alist_enter", "ALIST-ENTER", 3, 1, false);
        declareFunction("alist_enter_without_values", "ALIST-ENTER-WITHOUT-VALUES", 3, 1, false);
        declareFunction("alist_capacity_enter_without_values", "ALIST-CAPACITY-ENTER-WITHOUT-VALUES", 4, 1, false);
        declareFunction("alist_promote", "ALIST-PROMOTE", 2, 1, false);
        declareFunction("alist_delete", "ALIST-DELETE", 2, 1, false);
        declareFunction("alist_delete_without_values", "ALIST-DELETE-WITHOUT-VALUES", 2, 1, false);
        declareFunction("alist_remove", "ALIST-REMOVE", 2, 1, false);
        declareFunction("alist_remove_without_values", "ALIST-REMOVE-WITHOUT-VALUES", 2, 1, false);
        declareFunction("alist_push", "ALIST-PUSH", 3, 1, false);
        declareFunction("alist_pushnew", "ALIST-PUSHNEW", 3, 2, false);
        declareFunction("alist_remove_from_value", "ALIST-REMOVE-FROM-VALUE", 3, 2, false);
        declareMacro("pushnew_onto_alist", "PUSHNEW-ONTO-ALIST");
        declareMacro("push_onto_alist", "PUSH-ONTO-ALIST");
        declareMacro("enter_into_alist", "ENTER-INTO-ALIST");
        declareFunction("alist_keys", "ALIST-KEYS", 1, 0, false);
        declareFunction("alist_values", "ALIST-VALUES", 1, 0, false);
        declareFunction("alist_optimize", "ALIST-OPTIMIZE", 2, 0, false);
        declareFunction("alist_E", "ALIST-=", 2, 2, false);
        declareFunction("alist_subsumesP", "ALIST-SUBSUMES?", 2, 2, false);
        declareFunction("alist_to_hash_table", "ALIST-TO-HASH-TABLE", 1, 1, false);
        declareFunction("alist_to_reverse_hash_table", "ALIST-TO-REVERSE-HASH-TABLE", 1, 1, false);
        declareFunction("sort_alist_by_keys", "SORT-ALIST-BY-KEYS", 2, 0, false);
        declareFunction("sort_alist_by_values", "SORT-ALIST-BY-VALUES", 2, 0, false);
        declareFunction("property_list_p", "PROPERTY-LIST-P", 1, 0, false);
        declareFunction("non_empty_property_list_p", "NON-EMPTY-PROPERTY-LIST-P", 1, 0, false);
        declareFunction("filter_plist", "FILTER-PLIST", 2, 0, false);
        declareFunction("prune_plist", "PRUNE-PLIST", 1, 1, false);
        declareFunction("plist_of_type_p", "PLIST-OF-TYPE-P", 2, 0, false);
        declareFunction("plist_of_value_type_p", "PLIST-OF-VALUE-TYPE-P", 2, 0, false);
        declareFunction("make_plist", "MAKE-PLIST", 2, 0, false);
        declareMacro("plist_enter", "PLIST-ENTER");
        declareFunction("plist_lookup", "PLIST-LOOKUP", 2, 1, false);
        declareMacro("plist_increment", "PLIST-INCREMENT");
        declareMacro("plist_push", "PLIST-PUSH");
        declareFunction("alist_to_plist", "ALIST-TO-PLIST", 1, 0, false);
        declareFunction("plist_to_alist", "PLIST-TO-ALIST", 1, 0, false);
        declareFunction("nmerge_plist", "NMERGE-PLIST", 2, 0, false);
        declareFunction("merge_plist", "MERGE-PLIST", 2, 0, false);
        declareFunction("sort_plist_by_properties", "SORT-PLIST-BY-PROPERTIES", 2, 0, false);
        declareFunction("sort_plist_via_position", "SORT-PLIST-VIA-POSITION", 2, 1, false);
        declareFunction("indicator_presentP", "INDICATOR-PRESENT?", 2, 0, false);
        declareFunction("plist_has_keyP", "PLIST-HAS-KEY?", 2, 0, false);
        declareFunction("member_plist_key_p", "MEMBER-PLIST-KEY-P", 2, 0, false);
        declareFunction("non_nil_plist_valueP", "NON-NIL-PLIST-VALUE?", 2, 0, false);
        declareFunction("get_property_with_defaults", "GET-PROPERTY-WITH-DEFAULTS", 3, 1, false);
        declareFunction("augment_plist_with_defaults", "AUGMENT-PLIST-WITH-DEFAULTS", 2, 0, false);
        declareFunction("plist_restricted_to_indicatorsP", "PLIST-RESTRICTED-TO-INDICATORS?", 2, 0, false);
        declareFunction("maybe_putf", "MAYBE-PUTF", 3, 0, false);
        declareFunction("plist_properties", "PLIST-PROPERTIES", 1, 0, false);
        declareFunction("plist_keys", "PLIST-KEYS", 1, 0, false);
        declareFunction("plist_values", "PLIST-VALUES", 1, 0, false);
        declareFunction("plist_restricted_to_indicators", "PLIST-RESTRICTED-TO-INDICATORS", 2, 0, false);
        declareFunction("plist_except", "PLIST-EXCEPT", 2, 0, false);
        declareFunction("plistlist_if_getf", "PLISTLIST-IF-GETF", 3, 1, false);
        declareFunction("plistlist_sort", "PLISTLIST-SORT", 3, 0, false);
        declareFunction("plistlist_sort_key", "PLISTLIST-SORT-KEY", 1, 0, false);
        declareFunction("sub_plistP", "SUB-PLIST?", 2, 1, false);
        declareFunction("slow_plists_equalP", "SLOW-PLISTS-EQUAL?", 2, 1, false);
        declareFunction("format_item_list", "FORMAT-ITEM-LIST", 1, 0, false);
        declareFunction("print_plist_readably", "PRINT-PLIST-READABLY", 1, 1, false);
        declareFunction("pretty_print_plist", "PRETTY-PRINT-PLIST", 1, 1, false);
        declareFunction("pretty_print_alist", "PRETTY-PRINT-ALIST", 1, 1, false);
        declareFunction("print_list_of_lists_as_table", "PRINT-LIST-OF-LISTS-AS-TABLE", 1, 1, false);
        declareFunction("print_list_as_delimited_line", "PRINT-LIST-AS-DELIMITED-LINE", 1, 2, false);
        declareFunction("any_in_list", "ANY-IN-LIST", 2, 1, false);
        declareFunction("every_in_list", "EVERY-IN-LIST", 2, 1, false);
        declareFunction("not_any_in_list", "NOT-ANY-IN-LIST", 2, 1, false);
        declareFunction("not_every_in_list", "NOT-EVERY-IN-LIST", 2, 1, false);
        declareFunction("plist_difference", "PLIST-DIFFERENCE", 2, 1, false);
        declareFunction("list_subseq_subst_combos", "LIST-SUBSEQ-SUBST-COMBOS", 2, 0, false);
        declareFunction("list_subseq_subst_combos_internal", "LIST-SUBSEQ-SUBST-COMBOS-INTERNAL", 3, 0, false);
        declareFunction("greedy_list_subseq_subst", "GREEDY-LIST-SUBSEQ-SUBST", 2, 0, false);
        declareFunction("greedy_list_subseq_subst_internal", "GREEDY-LIST-SUBSEQ-SUBST-INTERNAL", 3, 0, false);
        declareFunction("extremal", "EXTREMAL", 2, 1, false);
        declareFunction("extremals", "EXTREMALS", 2, 1, false);
        declareFunction("nth_rank_items", "NTH-RANK-ITEMS", 2, 2, false);
        declareFunction("rerank", "RERANK", 2, 3, false);
        declareFunction("powerset", "POWERSET", 1, 0, false);
        declareFunction("subsets_of_size", "SUBSETS-OF-SIZE", 2, 0, false);
        declareFunction("subsets_of_size_int", "SUBSETS-OF-SIZE-INT", 2, 0, false);
        declareFunction("position_L", "POSITION-<", 3, 2, false);
        declareFunction("sort_via_position", "SORT-VIA-POSITION", 2, 2, false);
        declareFunction("stable_sort_via_position", "STABLE-SORT-VIA-POSITION", 2, 2, false);
        declareFunction("sort_via_position_earlier", "SORT-VIA-POSITION-EARLIER", 2, 0, false);
        new com.cyc.cycjava.cycl.list_utilities.$sort_via_position_earlier$BinaryFunction();
        declareFunction("sort_via_test", "SORT-VIA-TEST", 2, 1, false);
        declareFunction("stable_sort_via_test", "STABLE-SORT-VIA-TEST", 2, 1, false);
        declareFunction("sort_via_test_earlier", "SORT-VIA-TEST-EARLIER", 2, 0, false);
        declareFunction("sort_L", "SORT-<", 1, 1, false);
        declareFunction("sort_G", "SORT->", 1, 1, false);
        declareFunction("safe_sort_L", "SAFE-SORT-<", 1, 1, false);
        declareFunction("safe_sort_G", "SAFE-SORT->", 1, 1, false);
        declareFunction("sets_of_sets_L", "SETS-OF-SETS-<", 2, 1, false);
        declareFunction("sets_L", "SETS-<", 2, 1, false);
        declareFunction("set_L", "SET-<", 2, 1, false);
        declareFunction("list_structure", "LIST-STRUCTURE", 1, 1, false);
        declareFunction("list_structure_min", "LIST-STRUCTURE-MIN", 1, 0, false);
        declareFunction("list_structure_L", "LIST-STRUCTURE-<", 2, 0, false);
        declareFunction("tree_min", "TREE-MIN", 1, 0, false);
        declareFunction("safe_tree_L", "SAFE-TREE-<", 2, 0, false);
        declareFunction("safe_L", "SAFE-<", 2, 0, false);
        declareFunction("safe_G", "SAFE->", 2, 0, false);
        declareFunction("safe_GE", "SAFE->=", 2, 0, false);
        declareFunction("safe_LE", "SAFE-<=", 2, 0, false);
        declareFunction("safe_max", "SAFE-MAX", 1, 1, false);
        declareFunction("safe_difference", "SAFE-DIFFERENCE", 2, 0, false);
        declareFunction("safe_quotient", "SAFE-QUOTIENT", 2, 0, false);
        declareFunction("safe_product", "SAFE-PRODUCT", 2, 0, false);
        declareFunction("safe_sum", "SAFE-SUM", 2, 0, false);
        declareFunction("safe_E", "SAFE-=", 2, 0, false);
        declareFunction("equalE", "EQUAL=", 2, 0, false);
        declareFunction("tree_L", "TREE-<", 2, 2, false);
        declareFunction("tree_lt_intP", "TREE-LT-INT?", 4, 0, false);
        declareFunction("parametrized_median", "PARAMETRIZED-MEDIAN", 2, 0, false);
        declareFunction("shortest", "SHORTEST", 1, 0, false);
        declareFunction("longest", "LONGEST", 1, 0, false);
        declareFunction("cons_count", "CONS-COUNT", 1, 0, false);
        declareFunction("tree_delete", "TREE-DELETE", 2, 2, false);
        declareFunction("tree_map", "TREE-MAP", 2, 1, false);
        declareFunction("tree_ntransform_if", "TREE-NTRANSFORM-IF", 3, 1, false);
        declareFunction("tree_transform_if", "TREE-TRANSFORM-IF", 3, 1, false);
        declareFunction("cons_tree_find", "CONS-TREE-FIND", 2, 2, false);
        declareFunction("tree_find", "TREE-FIND", 2, 2, false);
        declareFunction("simple_tree_findP", "SIMPLE-TREE-FIND?", 2, 0, false);
        declareFunction("simple_tree_find_via_equalP", "SIMPLE-TREE-FIND-VIA-EQUAL?", 2, 0, false);
        declareFunction("tree_find_any", "TREE-FIND-ANY", 2, 2, false);
        declareFunction("cons_tree_find_if", "CONS-TREE-FIND-IF", 2, 1, false);
        declareFunction("tree_find_if", "TREE-FIND-IF", 2, 1, false);
        declareFunction("cons_tree_count", "CONS-TREE-COUNT", 2, 2, false);
        declareFunction("tree_count", "TREE-COUNT", 2, 2, false);
        declareFunction("tree_countG", "TREE-COUNT>", 3, 2, false);
        declareFunction("tree_countGE", "TREE-COUNT>=", 3, 2, false);
        declareFunction("tree_countL", "TREE-COUNT<", 3, 2, false);
        declareFunction("tree_countLE", "TREE-COUNT<=", 3, 2, false);
        declareFunction("tree_countE", "TREE-COUNT=", 3, 2, false);
        declareFunction("tree_count_internal", "TREE-COUNT-INTERNAL", 5, 1, false);
        declareFunction("simple_tree_count", "SIMPLE-TREE-COUNT", 2, 0, false);
        declareFunction("simple_tree_count_recursive", "SIMPLE-TREE-COUNT-RECURSIVE", 3, 0, false);
        declareFunction("cons_tree_count_if", "CONS-TREE-COUNT-IF", 2, 1, false);
        declareFunction("tree_count_if", "TREE-COUNT-IF", 2, 1, false);
        declareFunction("tree_count_if_unique", "TREE-COUNT-IF-UNIQUE", 2, 1, false);
        declareFunction("cons_tree_gather", "CONS-TREE-GATHER", 2, 3, false);
        declareFunction("tree_gather", "TREE-GATHER", 2, 3, false);
        declareFunction("tree_gather_internal", "TREE-GATHER-INTERNAL", 6, 0, false);
        declareFunction("tree_gather_ordered", "TREE-GATHER-ORDERED", 2, 2, false);
        declareFunction("tree_gather_ordered_subs", "TREE-GATHER-ORDERED-SUBS", 3, 0, false);
        declareFunction("tree_gather_ordered_no_subs", "TREE-GATHER-ORDERED-NO-SUBS", 3, 0, false);
        declareFunction("tree_substitute", "TREE-SUBSTITUTE", 3, 0, false);
        declareFunction("tree_substitute_using_dictionary", "TREE-SUBSTITUTE-USING-DICTIONARY", 2, 0, false);
        declareFunction("tree_splice", "TREE-SPLICE", 3, 0, false);
        declareFunction("tree_gather_transformations", "TREE-GATHER-TRANSFORMATIONS", 3, 2, false);
        declareFunction("remove_if_doesnt_include", "REMOVE-IF-DOESNT-INCLUDE", 2, 0, false);
        declareFunction("delete_subsumed_items", "DELETE-SUBSUMED-ITEMS", 2, 1, false);
        declareFunction("delete_subsumed_items_internal", "DELETE-SUBSUMED-ITEMS-INTERNAL", 3, 0, false);
        declareFunction("subsumedP", "SUBSUMED?", 4, 0, false);
        declareFunction("subsumesP", "SUBSUMES?", 4, 0, false);
        declareFunction("subsumesP_internal", "SUBSUMES?-INTERNAL", 4, 0, false);
        declareFunction("remove_subsumed_items", "REMOVE-SUBSUMED-ITEMS", 2, 1, false);
        declareFunction("cross_products", "CROSS-PRODUCTS", 1, 0, false);
        declareFunction("map_pairs", "MAP-PAIRS", 3, 0, false);
        declareFunction("fn_with_each", "FN-WITH-EACH", 3, 0, false);
        declareFunction("indexed_products", "INDEXED-PRODUCTS", 1, 0, false);
        declareFunction("explicate_permutations", "EXPLICATE-PERMUTATIONS", 1, 1, false);
        declareFunction("untranslate_elements_from_tagged_sets", "UNTRANSLATE-ELEMENTS-FROM-TAGGED-SETS", 2, 1, false);
        declareFunction("translate_elements_to_tagged_sets", "TRANSLATE-ELEMENTS-TO-TAGGED-SETS", 2, 0, false);
        declareFunction("permute_list", "PERMUTE-LIST", 1, 1, false);
        declareFunction("permute_list_int", "PERMUTE-LIST-INT", 1, 1, false);
        declareFunction("all_permutations", "ALL-PERMUTATIONS", 1, 0, false);
        declareFunction("nsublis_permute", "NSUBLIS-PERMUTE", 3, 0, false);
        declareFunction("sublis_permute", "SUBLIS-PERMUTE", 3, 0, false);
        declareFunction("permute", "PERMUTE", 2, 0, false);
        declareFunction("random_permutation", "RANDOM-PERMUTATION", 1, 0, false);
        declareFunction("choose_n_between", "CHOOSE-N-BETWEEN", 2, 0, false);
        declareFunction("trigram_transform", "TRIGRAM-TRANSFORM", 2, 2, false);
        declareFunction("chunk", "CHUNK", 2, 0, false);
        declareFunction("get_arglist", "GET-ARGLIST", 1, 0, false);
        declareFunction("get_documentation", "GET-DOCUMENTATION", 1, 0, false);
        declareFunction("push_on_car", "PUSH-ON-CAR", 2, 0, false);
        declareFunction("pop_and_reverse_car_and_push_on_cadr", "POP-AND-REVERSE-CAR-AND-PUSH-ON-CADR", 1, 0, false);
        declareFunction("cartesian_product", "CARTESIAN-PRODUCT", 1, 3, false);
        declareFunction("cartesian_helper", "CARTESIAN-HELPER", 3, 0, false);
        declareFunction("cartesian_helper_with_test", "CARTESIAN-HELPER-WITH-TEST", 4, 0, false);
        declareFunction("pick_two", "PICK-TWO", 1, 0, false);
        declareMacro("mapexp", "MAPEXP");
        declareFunction("recursive_member", "RECURSIVE-MEMBER", 2, 1, false);
        declareFunction("list_of_type_p", "LIST-OF-TYPE-P", 2, 0, false);
        declareFunction("non_empty_list_of_type_p", "NON-EMPTY-LIST-OF-TYPE-P", 2, 0, false);
        declareFunction("list_of_list_p", "LIST-OF-LIST-P", 1, 0, false);
        declareFunction("list_of_keyword_p", "LIST-OF-KEYWORD-P", 1, 0, false);
        declareFunction("string_list_p", "STRING-LIST-P", 1, 0, false);
        declareFunction("symbol_list_p", "SYMBOL-LIST-P", 1, 0, false);
        declareFunction("function_symbol_list_p", "FUNCTION-SYMBOL-LIST-P", 1, 0, false);
        declareFunction("form_with_operator_p", "FORM-WITH-OPERATOR-P", 2, 0, false);
        declareFunction("verify_operator", "VERIFY-OPERATOR", 2, 0, false);
        declareFunction("verify_form_with_operator", "VERIFY-FORM-WITH-OPERATOR", 2, 0, false);
        declareFunction("functor_in_expression_p", "FUNCTOR-IN-EXPRESSION-P", 2, 0, false);
        declareFunction("functor_in_body_p", "FUNCTOR-IN-BODY-P", 2, 0, false);
        declareFunction("variable_value_used_in_body_p", "VARIABLE-VALUE-USED-IN-BODY-P", 2, 0, false);
        declareFunction("variable_value_used_in_expression_p", "VARIABLE-VALUE-USED-IN-EXPRESSION-P", 2, 0, false);
        declareFunction("object_in_expression_p", "OBJECT-IN-EXPRESSION-P", 2, 0, false);
        declareFunction("parse_to_list_of_strings", "PARSE-TO-LIST-OF-STRINGS", 1, 2, false);
        declareFunction("tree_substitute_by_association", "TREE-SUBSTITUTE-BY-ASSOCIATION", 2, 3, false);
        declareFunction("safe_read_delimited_list", "SAFE-READ-DELIMITED-LIST", 1, 2, false);
        declareFunction("multi_sublis", "MULTI-SUBLIS", 2, 2, false);
        declareFunction("multi_assoc", "MULTI-ASSOC", 2, 2, false);
        declareFunction("valid_and_conformant_alist_p", "VALID-AND-CONFORMANT-ALIST-P", 1, 2, false);
        declareFunction("histogram", "HISTOGRAM", 1, 3, false);
        declareFunction("histogram_as_plist", "HISTOGRAM-AS-PLIST", 1, 3, false);
        declareFunction("pretty_print_histogram", "PRETTY-PRINT-HISTOGRAM", 1, 0, false);
        declareFunction("n_within", "N-WITHIN", 3, 0, false);
        declareFunction("middle_sublist", "MIDDLE-SUBLIST", 2, 0, false);
        declareFunction("categorize_list_elements", "CATEGORIZE-LIST-ELEMENTS", 2, 1, false);
        declareFunction("rank_tuples", "RANK-TUPLES", 1, 0, false);
        declareFunction("collate", "COLLATE", 1, 0, false);
        declareFunction("list_with_first_p", "LIST-WITH-FIRST-P", 2, 0, false);
        declareFunction("get_nadd_to_end_test_case_p_queue", "GET-NADD-TO-END-TEST-CASE-P-QUEUE", 1, 0, false);
        declareFunction("set_nadd_to_end_test_case_p_queue", "SET-NADD-TO-END-TEST-CASE-P-QUEUE", 2, 0, false);
        declareFunction("subloop_reserved_initialize_nadd_to_end_test_case_class", "SUBLOOP-RESERVED-INITIALIZE-NADD-TO-END-TEST-CASE-CLASS", 1, 0, false);
        declareFunction("subloop_reserved_initialize_nadd_to_end_test_case_instance", "SUBLOOP-RESERVED-INITIALIZE-NADD-TO-END-TEST-CASE-INSTANCE", 1, 0, false);
        declareFunction("nadd_to_end_test_case_p", "NADD-TO-END-TEST-CASE-P", 1, 0, false);
        declareFunction("get_last1_test_case_p_queue", "GET-LAST1-TEST-CASE-P-QUEUE", 1, 0, false);
        declareFunction("set_last1_test_case_p_queue", "SET-LAST1-TEST-CASE-P-QUEUE", 2, 0, false);
        declareFunction("subloop_reserved_initialize_last1_test_case_class", "SUBLOOP-RESERVED-INITIALIZE-LAST1-TEST-CASE-CLASS", 1, 0, false);
        declareFunction("subloop_reserved_initialize_last1_test_case_instance", "SUBLOOP-RESERVED-INITIALIZE-LAST1-TEST-CASE-INSTANCE", 1, 0, false);
        declareFunction("last1_test_case_p", "LAST1-TEST-CASE-P", 1, 0, false);
        declareFunction("get_list_macros_test_case_p_queue", "GET-LIST-MACROS-TEST-CASE-P-QUEUE", 1, 0, false);
        declareFunction("set_list_macros_test_case_p_queue", "SET-LIST-MACROS-TEST-CASE-P-QUEUE", 2, 0, false);
        declareFunction("subloop_reserved_initialize_list_macros_test_case_class", "SUBLOOP-RESERVED-INITIALIZE-LIST-MACROS-TEST-CASE-CLASS", 1, 0, false);
        declareFunction("subloop_reserved_initialize_list_macros_test_case_instance", "SUBLOOP-RESERVED-INITIALIZE-LIST-MACROS-TEST-CASE-INSTANCE", 1, 0, false);
        declareFunction("list_macros_test_case_p", "LIST-MACROS-TEST-CASE-P", 1, 0, false);
        return NIL;
    }

    public static SubLObject declare_list_utilities_file() {
        if (SubLFiles.USE_V1) {
            declareFunction("sublisp_boolean", "BOOLEAN", 1, 0, false);
            declareFunction("not_boolean", "NOT-BOOLEAN", 1, 0, false);
            declareFunction("not_eq", "NOT-EQ", 2, 0, false);
            declareFunction("not_eql", "NOT-EQL", 2, 0, false);
            declareFunction("not_equal", "NOT-EQUAL", 2, 0, false);
            declareFunction("not_equalp", "NOT-EQUALP", 2, 0, false);
            declareFunction("not_assoc", "NOT-ASSOC", 2, 2, false);
            declareFunction("not_consp", "NOT-CONSP", 1, 0, false);
            declareFunction("eq_and_not_eq", "EQ-AND-NOT-EQ", 2, 0, false);
            declareFunction("bull", "BULL", 2, 0, false);
            declareFunction("no_op", "NO-OP", 0, 0, false);
            declareFunction("caadr", "CAADR", 1, 0, false);
            declareFunction("caddr", "CADDR", 1, 0, false);
            declareFunction("cdddr", "CDDDR", 1, 0, false);
            declareFunction("cadddr", "CADDDR", 1, 0, false);
            declareFunction("cadadr", "CADADR", 1, 0, false);
            declareFunction("cadar", "CADAR", 1, 0, false);
            new list_utilities.$cadar$UnaryFunction();
            declareFunction("cdadr", "CDADR", 1, 0, false);
            declareFunction("snoc", "SNOC", 2, 0, false);
            declareFunction("list_rotate_left", "LIST-ROTATE-LEFT", 1, 0, false);
            declareFunction("list_rotate_right", "LIST-ROTATE-RIGHT", 1, 0, false);
            declareFunction("proper_subsetp", "PROPER-SUBSETP", 2, 2, false);
            declareFunction("proper_subsetp_pre_sorted", "PROPER-SUBSETP-PRE-SORTED", 2, 2, false);
            declareFunction("nth_cycling", "NTH-CYCLING", 2, 2, false);
            declareMacro("pop_setq", "POP-SETQ");
            declareMacro("pop_bind", "POP-BIND");
            declareMacro("push_max_length", "PUSH-MAX-LENGTH");
            declareMacro("cdolist_multiple", "CDOLIST-MULTIPLE");
            declareMacro("cdolist_multiple_numbered", "CDOLIST-MULTIPLE-NUMBERED");
            declareMacro("csome_multiple", "CSOME-MULTIPLE");
            declareMacro("cdolist_numbered", "CDOLIST-NUMBERED");
            declareMacro("cdolist_backward", "CDOLIST-BACKWARD");
            declareMacro("cdolist_backward_numbered", "CDOLIST-BACKWARD-NUMBERED");
            declareMacro("csome_numbered", "CSOME-NUMBERED");
            declareMacro("cdolist_cycling", "CDOLIST-CYCLING");
            declareMacro("cdolist_cycling_complex", "CDOLIST-CYCLING-COMPLEX");
            declareMacro("do_tree_leaves", "DO-TREE-LEAVES");
            declareFunction("args_from_arg_list", "ARGS-FROM-ARG-LIST", 1, 0, false);
            declareFunction("lengthL", "LENGTH<", 2, 1, false);
            declareFunction("lengthLE", "LENGTH<=", 2, 1, false);
            declareFunction("lengthE", "LENGTH=", 2, 1, false);
            declareFunction("lengthsE", "LENGTHS=", 2, 1, false);
            declareFunction("lengthG", "LENGTH>", 2, 1, false);
            declareFunction("lengthGE", "LENGTH>=", 2, 1, false);
            declareFunction("zero_length_p", "ZERO-LENGTH-P", 1, 0, false);
            declareFunction("same_length_p", "SAME-LENGTH-P", 2, 0, false);
            declareFunction("same_lengths_p", "SAME-LENGTHS-P", 1, 0, false);
            declareFunction("longer_p", "LONGER-P", 2, 0, false);
            declareFunction("greater_length_p", "GREATER-LENGTH-P", 2, 0, false);
            declareFunction("greater_or_same_length_p", "GREATER-OR-SAME-LENGTH-P", 2, 0, false);
            declareFunction("shorter_p", "SHORTER-P", 2, 0, false);
            declareFunction("lesser_length_p", "LESSER-LENGTH-P", 2, 0, false);
            declareFunction("lesser_or_same_length_p", "LESSER-OR-SAME-LENGTH-P", 2, 0, false);
            declareFunction("empty_list_p", "EMPTY-LIST-P", 1, 0, false);
            declareFunction("non_empty_list_p", "NON-EMPTY-LIST-P", 1, 0, false);
            declareFunction("proper_list_p", "PROPER-LIST-P", 1, 0, false);
            declareFunction("dotted_list_p", "DOTTED-LIST-P", 1, 0, false);
            new list_utilities.$dotted_list_p$UnaryFunction();
            declareFunction("non_dotted_list_p", "NON-DOTTED-LIST-P", 1, 0, false);
            declareFunction("dotted_length", "DOTTED-LENGTH", 1, 0, false);
            declareFunction("dotted_last", "DOTTED-LAST", 1, 0, false);
            declareFunction("dotted_butlast", "DOTTED-BUTLAST", 1, 0, false);
            declareFunction("undot", "UNDOT", 1, 0, false);
            declareFunction("add_to_dotted_end", "ADD-TO-DOTTED-END", 2, 0, false);
            declareFunction("nadd_to_dotted_end", "NADD-TO-DOTTED-END", 2, 0, false);
            declareFunction("ndot_last", "NDOT-LAST", 1, 0, false);
            declareFunction("dot_last", "DOT-LAST", 1, 0, false);
            declareFunction("possible_dotted_list_to_dotted_list", "POSSIBLE-DOTTED-LIST-TO-DOTTED-LIST", 1, 1, false);
            declareFunction("list_non_dotted_through_n_p", "LIST-NON-DOTTED-THROUGH-N-P", 2, 0, false);
            declareFunction("negated_test_func", "NEGATED-TEST-FUNC", 1, 0, false);
            new list_utilities.$negated_test_func$UnaryFunction();
            declareFunction("remove_if_not", "REMOVE-IF-NOT", 2, 4, false);
            declareFunction("delete_if_not", "DELETE-IF-NOT", 2, 4, false);
            declareFunction("substitute_if_not", "SUBSTITUTE-IF-NOT", 3, 4, false);
            declareFunction("nsubstitute_if_not", "NSUBSTITUTE-IF-NOT", 3, 4, false);
            declareFunction("find_if_not", "FIND-IF-NOT", 2, 3, false);
            declareFunction("position_if_not", "POSITION-IF-NOT", 2, 3, false);
            declareFunction("position_if_binary_lambda", "POSITION-IF-BINARY-LAMBDA", 1, 0, false);
            declareFunction("position_if_binary", "POSITION-IF-BINARY", 3, 3, false);
            declareFunction("position_from_end", "POSITION-FROM-END", 2, 4, false);
            declareFunction("tree_positions", "TREE-POSITIONS", 2, 2, false);
            declareFunction("tree_positions_w_parents", "TREE-POSITIONS-W-PARENTS", 2, 1, false);
            declareFunction("difference_from_head", "DIFFERENCE-FROM-HEAD", 2, 0, false);
            declareFunction("tree_position_bfs", "TREE-POSITION-BFS", 2, 1, false);
            declareFunction("tree_position_dfs", "TREE-POSITION-DFS", 2, 1, false);
            declareFunction("list_position", "LIST-POSITION", 2, 2, false);
            declareFunction("tree_position_p", "TREE-POSITION-P", 1, 0, false);
            declareFunction("tree_nested_nths", "TREE-NESTED-NTHS", 2, 0, false);
            declareFunction("tree_nths", "TREE-NTHS", 2, 0, false);
            declareFunction("has_nested_nth_p", "HAS-NESTED-NTH-P", 2, 0, false);
            declareFunction("get_nested_nth", "GET-NESTED-NTH", 2, 1, false);
            declareFunction("replace_nested_nth", "REPLACE-NESTED-NTH", 3, 0, false);
            declareFunction("nreplace_nested_nth", "NREPLACE-NESTED-NTH", 3, 0, false);
            declareFunction("remove_nested_nth", "REMOVE-NESTED-NTH", 2, 0, false);
            declareFunction("delete_nested_nth", "DELETE-NESTED-NTH", 2, 0, false);
            declareFunction("delete_nested_nth_internal", "DELETE-NESTED-NTH-INTERNAL", 2, 0, false);
            declareFunction("tree_positions_int", "TREE-POSITIONS-INT", 3, 1, false);
            declareFunction("tree_positions_dfs", "TREE-POSITIONS-DFS", 2, 1, false);
            declareFunction("tree_positions_bfs", "TREE-POSITIONS-BFS", 2, 1, false);
            declareFunction("containing_subtrees", "CONTAINING-SUBTREES", 2, 0, false);
            declareFunction("tree_positions_if_dfs", "TREE-POSITIONS-IF-DFS", 2, 1, false);
            declareFunction("tree_positions_if_bfs", "TREE-POSITIONS-IF-BFS", 2, 1, false);
            declareFunction("tree_positions_if_dfs_int", "TREE-POSITIONS-IF-DFS-INT", 2, 1, false);
            declareFunction("tree_position_if_bfs", "TREE-POSITION-IF-BFS", 2, 1, false);
            declareFunction("tree_position_if_dfs", "TREE-POSITION-IF-DFS", 2, 1, false);
            declareFunction("count_if_not", "COUNT-IF-NOT", 2, 3, false);
            declareFunction("subst_if_not", "SUBST-IF-NOT", 3, 1, false);
            declareFunction("nsubst_if_not", "NSUBST-IF-NOT", 3, 1, false);
            declareFunction("member_if_not", "MEMBER-IF-NOT", 2, 1, false);
            declareFunction("assoc_if_not", "ASSOC-IF-NOT", 2, 0, false);
            declareFunction("rassoc_if_not", "RASSOC-IF-NOT", 2, 0, false);
            declareFunction("assoc_all", "ASSOC-ALL", 2, 1, false);
            declareFunction("assoc_push", "ASSOC-PUSH", 3, 1, false);
            declareFunction("assoc_pushnew", "ASSOC-PUSHNEW", 3, 1, false);
            declareFunction("dotted_assoc_push", "DOTTED-ASSOC-PUSH", 3, 1, false);
            declareFunction("assoc_equal", "ASSOC-EQUAL", 2, 0, false);
            declareFunction("assoc_subsumedP", "ASSOC-SUBSUMED?", 3, 0, false);
            declareFunction("alist_extend", "ALIST-EXTEND", 2, 0, false);
            declareFunction("make_alist", "MAKE-ALIST", 1, 1, false);
            declareFunction("make_alist_from_keys_and_values", "MAKE-ALIST-FROM-KEYS-AND-VALUES", 2, 0, false);
            declareFunction("make_pair_list", "MAKE-PAIR-LIST", 2, 0, false);
            declareFunction("make_paired_lists", "MAKE-PAIRED-LISTS", 1, 0, false);
            declareFunction("first_safe_for_atoms", "FIRST-SAFE-FOR-ATOMS", 1, 0, false);
            declareMacro("first_of", "FIRST-OF");
            declareFunction("recons", "RECONS", 3, 0, false);
            declareFunction("ncons", "NCONS", 3, 0, false);
            declareFunction("delete_first", "DELETE-FIRST", 2, 1, false);
            declareFunction("remove_first", "REMOVE-FIRST", 2, 1, false);
            declareFunction("remove_duplicates_equal", "REMOVE-DUPLICATES-EQUAL", 1, 3, false);
            declareFunction("nmapcar", "NMAPCAR", 2, 0, false);
            declareFunction("mapcar_multiple", "MAPCAR-MULTIPLE", 2, 0, false);
            declareFunction("mapappend", "MAPAPPEND", 2, 0, false);
            declareFunction("mapunion", "MAPUNION", 2, 1, false);
            declareFunction("mapnunion", "MAPNUNION", 2, 1, false);
            declareFunction("mapcar_product", "MAPCAR-PRODUCT", 3, 0, false);
            declareFunction("mapcar_unique", "MAPCAR-UNIQUE", 2, 1, false);
            declareFunction("last1", "LAST1", 1, 0, false);
            declareFunction("add_to_end", "ADD-TO-END", 2, 0, false);
            declareFunction("nadd_to_end", "NADD-TO-END", 2, 0, false);
            declareFunction("adjoin_to_end", "ADJOIN-TO-END", 2, 1, false);
            declareFunction("nadjoin_to_end", "NADJOIN-TO-END", 2, 1, false);
            declareFunction("add_to_end_if", "ADD-TO-END-IF", 2, 0, false);
            declareFunction("nadd_to_end_if", "NADD-TO-END-IF", 2, 0, false);
            declareFunction("nth_from_end", "NTH-FROM-END", 2, 0, false);
            declareFunction("remove_from_end", "REMOVE-FROM-END", 2, 1, false);
            declareFunction("remove_objects_from_list", "REMOVE-OBJECTS-FROM-LIST", 2, 1, false);
            declareFunction("partition_list", "PARTITION-LIST", 2, 0, false);
            declareFunction("npartition_list", "NPARTITION-LIST", 2, 0, false);
            declareFunction("partition_list_by_equality", "PARTITION-LIST-BY-EQUALITY", 2, 2, false);
            declareFunction("partition_list_n_ways", "PARTITION-LIST-N-WAYS", 2, 0, false);
            declareFunction("randomly_partition_list_n_ways", "RANDOMLY-PARTITION-LIST-N-WAYS", 2, 0, false);
            declareFunction("split_list", "SPLIT-LIST", 2, 0, false);
            declareFunction("random_element", "RANDOM-ELEMENT", 1, 0, false);
            declareFunction("random_aref", "RANDOM-AREF", 1, 0, false);
            declareFunction("random_n", "RANDOM-N", 2, 0, false);
            declareFunction("random_remove_n", "RANDOM-REMOVE-N", 2, 0, false);
            declareFunction("random_delete", "RANDOM-DELETE", 1, 0, false);
            declareFunction("randomize_list", "RANDOMIZE-LIST", 1, 0, false);
            declareFunction("randomize_vector", "RANDOMIZE-VECTOR", 1, 0, false);
            declareFunction("randomize_vector_int", "RANDOMIZE-VECTOR-INT", 3, 0, false);
            declareFunction("random_compare", "RANDOM-COMPARE", 2, 0, false);
            declareFunction("thirdL", "THIRD<", 2, 0, false);
            declareFunction("gather_all", "GATHER-ALL", 2, 2, false);
            declareFunction("find_all", "FIND-ALL", 2, 2, false);
            declareFunction("find_all_if", "FIND-ALL-IF", 2, 1, false);
            declareFunction("find_all_if_not", "FIND-ALL-IF-NOT", 2, 1, false);
            declareFunction("all_positions", "ALL-POSITIONS", 2, 3, false);
            declareFunction("only_one", "ONLY-ONE", 1, 0, false);
            declareFunction("last_one", "LAST-ONE", 1, 0, false);
            declareFunction("penultimate_one", "PENULTIMATE-ONE", 1, 0, false);
            declareFunction("cons_if", "CONS-IF", 2, 0, false);
            declareFunction("list_if", "LIST-IF", 1, 0, false);
            declareFunction("adjoin_if", "ADJOIN-IF", 2, 1, false);
            declareFunction("flatten", "FLATTEN", 1, 0, false);
            declareFunction("insert_between_each", "INSERT-BETWEEN-EACH", 2, 0, false);
            declareFunction("safe_nth", "SAFE-NTH", 2, 0, false);
            declareFunction("nths", "NTHS", 2, 0, false);
            declareFunction("every_nth", "EVERY-NTH", 2, 0, false);
            declareFunction("first_n", "FIRST-N", 2, 0, false);
            declareFunction("first_n_percent", "FIRST-N-PERCENT", 2, 0, false);
            declareFunction("first_n_if", "FIRST-N-IF", 3, 1, false);
            declareFunction("first_2", "FIRST-2", 1, 0, false);
            declareFunction("first_10", "FIRST-10", 1, 0, false);
            declareFunction("last_n", "LAST-N", 2, 0, false);
            declareFunction("nth_chunk_of_k", "NTH-CHUNK-OF-K", 3, 0, false);
            declareFunction("delete_nth", "DELETE-NTH", 2, 0, false);
            declareFunction("remove_nth", "REMOVE-NTH", 2, 0, false);
            declareFunction("remove_last", "REMOVE-LAST", 1, 0, false);
            declareFunction("remove_nths", "REMOVE-NTHS", 2, 0, false);
            declareFunction("nreplace_last", "NREPLACE-LAST", 2, 0, false);
            declareFunction("nreplace_nth", "NREPLACE-NTH", 3, 0, false);
            declareFunction("find_and_replace", "FIND-AND-REPLACE", 3, 1, false);
            declareFunction("find_and_nreplace", "FIND-AND-NREPLACE", 3, 1, false);
            declareFunction("find_first_and_nreplace", "FIND-FIRST-AND-NREPLACE", 3, 1, false);
            declareFunction("ncollapse_n_from_pos", "NCOLLAPSE-N-FROM-POS", 4, 0, false);
            declareFunction("ninsert_by_position", "NINSERT-BY-POSITION", 3, 0, false);
            declareFunction("ninsert_randomly", "NINSERT-RANDOMLY", 2, 0, false);
            declareFunction("ninsert_somewhere_before_and_after", "NINSERT-SOMEWHERE-BEFORE-AND-AFTER", 3, 1, false);
            declareFunction("ninsert_somewhere_before", "NINSERT-SOMEWHERE-BEFORE", 3, 0, false);
            declareFunction("ninsert_somewhere_before_or_at", "NINSERT-SOMEWHERE-BEFORE-OR-AT", 3, 0, false);
            declareFunction("ninsert_somewhere_after", "NINSERT-SOMEWHERE-AFTER", 3, 0, false);
            declareFunction("move_nth_to_front", "MOVE-NTH-TO-FRONT", 2, 0, false);
            declareFunction("move_nth_to_position", "MOVE-NTH-TO-POSITION", 3, 0, false);
            declareFunction("nmove_to_front", "NMOVE-TO-FRONT", 2, 1, false);
            declareFunction("move_to_front", "MOVE-TO-FRONT", 2, 1, false);
            declareFunction("nmove_to_end", "NMOVE-TO-END", 2, 0, false);
            declareFunction("move_to_end", "MOVE-TO-END", 2, 0, false);
            declareFunction("replace_nth", "REPLACE-NTH", 3, 0, false);
            declareFunction("replace_last", "REPLACE-LAST", 2, 0, false);
            declareFunction("remove_duplicates_from_end", "REMOVE-DUPLICATES-FROM-END", 1, 4, false);
            declareFunction("remove_duplicates_from_start", "REMOVE-DUPLICATES-FROM-START", 1, 4, false);
            declareFunction("delete_duplicates_from_end", "DELETE-DUPLICATES-FROM-END", 1, 4, false);
            declareFunction("delete_duplicates_from_start", "DELETE-DUPLICATES-FROM-START", 1, 4, false);
            declareFunction("remove_null", "REMOVE-NULL", 1, 4, false);
            declareFunction("remove_from_end_duplicates_and_those_wXkey", "REMOVE-FROM-END-DUPLICATES-AND-THOSE-W/KEY", 2, 4, false);
            declareFunction("skipping_positions", "SKIPPING-POSITIONS", 2, 0, false);
            declareFunction("num_list", "NUM-LIST", 1, 1, false);
            declareFunction("new_num_list", "NEW-NUM-LIST", 1, 1, false);
            declareFunction("verify_num_list", "VERIFY-NUM-LIST", 3, 0, false);
            declareFunction("clear_num_list_cached", "CLEAR-NUM-LIST-CACHED", 0, 0, false);
            declareFunction("remove_num_list_cached", "REMOVE-NUM-LIST-CACHED", 2, 0, false);
            declareFunction("num_list_cached_internal", "NUM-LIST-CACHED-INTERNAL", 2, 0, false);
            declareFunction("num_list_cached", "NUM-LIST-CACHED", 2, 0, false);
            declareFunction("numlist", "NUMLIST", 1, 1, false);
            declareFunction("tree_ancestor", "TREE-ANCESTOR", 2, 1, false);
            declareFunction("member_eqP", "MEMBER-EQ?", 2, 0, false);
            declareFunction("member_kbeqP", "MEMBER-KBEQ?", 2, 0, false);
            declareFunction("member_equalP", "MEMBER-EQUAL?", 2, 0, false);
            declareFunction("has_member_equalP", "HAS-MEMBER-EQUAL?", 2, 0, false);
            declareFunction("not_has_member_equalP", "NOT-HAS-MEMBER-EQUAL?", 2, 0, false);
            declareFunction("member_equalpP", "MEMBER-EQUALP?", 2, 0, false);
            declareFunction("nmemberP", "NMEMBER?", 2, 1, false);
            declareFunction("nmember_eqP", "NMEMBER-EQ?", 2, 0, false);
            declareFunction("nmember_eqlP", "NMEMBER-EQL?", 2, 0, false);
            declareFunction("nmember_equalP", "NMEMBER-EQUAL?", 2, 0, false);
            declareFunction("nmember_equalpP", "NMEMBER-EQUALP?", 2, 0, false);
            declareFunction("nmember_funcallP", "NMEMBER-FUNCALL?", 3, 0, false);
            declareFunction("nmember_success", "NMEMBER-SUCCESS", 3, 0, false);
            declareFunction("intersectP", "INTERSECT?", 2, 2, false);
            declareFunction("intersect_sortedP", "INTERSECT-SORTED?", 2, 2, false);
            declareFunction("which_intersect_element_sorted", "WHICH-INTERSECT-ELEMENT-SORTED", 2, 2, false);
            declareFunction("sorted_subsetp", "SORTED-SUBSETP", 2, 3, false);
            declareFunction("sortedP", "SORTED?", 1, 1, false);
            declareFunction("occurs_onceP", "OCCURS-ONCE?", 2, 1, false);
            declareFunction("not_only_elementP", "NOT-ONLY-ELEMENT?", 2, 1, false);
            declareFunction("occurs_at_least_n_timesP", "OCCURS-AT-LEAST-N-TIMES?", 3, 1, false);
            declareFunction("occurs_exactly_n_timesP", "OCCURS-EXACTLY-N-TIMES?", 3, 1, false);
            declareFunction("occurs_at_most_n_timesP", "OCCURS-AT-MOST-N-TIMES?", 3, 1, false);
            declareFunction("singletonP", "SINGLETON?", 1, 0, false);
            declareFunction("doubletonP", "DOUBLETON?", 1, 0, false);
            declareFunction("tripleP", "TRIPLE?", 1, 0, false);
            declareFunction("list_of_length_p", "LIST-OF-LENGTH-P", 2, 1, false);
            declareFunction("list_of_doubletonP", "LIST-OF-DOUBLETON?", 1, 0, false);
            declareFunction("exactly_one_distinct_memberP", "EXACTLY-ONE-DISTINCT-MEMBER?", 1, 1, false);
            declareFunction("duplicatesP", "DUPLICATES?", 1, 2, false);
            declareFunction("equal_duplicatesP", "EQUAL-DUPLICATES?", 1, 1, false);
            declareFunction("duplicates", "DUPLICATES", 1, 2, false);
            declareFunction("duplicate_memberP", "DUPLICATE-MEMBER?", 2, 1, false);
            declareFunction("list_starts_with_repeating_sequenceP", "LIST-STARTS-WITH-REPEATING-SEQUENCE?", 1, 3, false);
            declareFunction("update_repeating_sequence", "UPDATE-REPEATING-SEQUENCE", 8, 0, false);
            declareFunction("multisets_equalP", "MULTISETS-EQUAL?", 2, 1, false);
            declareFunction("sets_equalP", "SETS-EQUAL?", 2, 1, false);
            declareFunction("member_via_sets_equalP", "MEMBER-VIA-SETS-EQUAL?", 2, 1, false);
            declareFunction("list_has_member_via_sets_equalP", "LIST-HAS-MEMBER-VIA-SETS-EQUAL?", 2, 1, false);
            declareFunction("sets_equalp", "SETS-EQUALP", 2, 0, false);
            declareFunction("fast_sets_equalP", "FAST-SETS-EQUAL?", 2, 1, false);
            declareFunction("fast_subsetP", "FAST-SUBSET?", 2, 1, false);
            declareFunction("fast_subset_equalP", "FAST-SUBSET-EQUAL?", 2, 0, false);
            declareFunction("fast_supersetP", "FAST-SUPERSET?", 2, 1, false);
            declareFunction("fast_superset_equalP", "FAST-SUPERSET-EQUAL?", 2, 0, false);
            declareFunction("sets_equal_equalP", "SETS-EQUAL-EQUAL?", 2, 0, false);
            declareFunction("subsetp_equalP", "SUBSETP-EQUAL?", 2, 1, false);
            declareFunction("supersetp", "SUPERSETP", 2, 2, false);
            declareFunction("set_differenceP", "SET-DIFFERENCE?", 2, 2, false);
            declareFunction("tree_set_equalP", "TREE-SET-EQUAL?", 2, 0, false);
            declareFunction("ordered_merge", "ORDERED-MERGE", 2, 2, false);
            declareFunction("ordered_union", "ORDERED-UNION", 2, 2, false);
            declareFunction("union_all", "UNION-ALL", 1, 2, false);
            declareFunction("ordered_set_difference", "ORDERED-SET-DIFFERENCE", 2, 2, false);
            declareFunction("hash_set_difference", "HASH-SET-DIFFERENCE", 2, 1, false);
            declareFunction("fast_set_difference", "FAST-SET-DIFFERENCE", 2, 1, false);
            declareFunction("partial_order_sort", "PARTIAL-ORDER-SORT", 2, 1, false);
            declareFunction("list2vector", "LIST2VECTOR", 1, 0, false);
            declareFunction("vector2list", "VECTOR2LIST", 1, 0, false);
            declareFunction("vector2list_reversible", "VECTOR2LIST-REVERSIBLE", 1, 1, false);
            declareFunction("listified_vector2vector", "LISTIFIED-VECTOR2VECTOR", 1, 1, false);
            declareFunction("list_without_repetition_p", "LIST-WITHOUT-REPETITION-P", 1, 2, false);
            declareFunction("sequence_elements", "SEQUENCE-ELEMENTS", 2, 0, false);
            declareFunction("set_difference_forts", "SET-DIFFERENCE-FORTS", 2, 0, false);
            declareFunction("ordered_intersection", "ORDERED-INTERSECTION", 2, 2, false);
            declareFunction("intersect_all", "INTERSECT-ALL", 1, 2, false);
            declareFunction("fast_intersect_all", "FAST-INTERSECT-ALL", 1, 2, false);
            declareFunction("safe_pairlis", "SAFE-PAIRLIS", 2, 0, false);
            declareFunction("flip_alist", "FLIP-ALIST", 1, 0, false);
            declareFunction("flip_cons", "FLIP-CONS", 1, 0, false);
            new list_utilities.$flip_cons$UnaryFunction();
            declareFunction("flip_doubleton", "FLIP-DOUBLETON", 1, 0, false);
            declareFunction("substitute_sequence", "SUBSTITUTE-SEQUENCE", 3, 0, false);
            declareFunction("substitute_sequence_1", "SUBSTITUTE-SEQUENCE-1", 4, 0, false);
            declareFunction("compare_lists", "COMPARE-LISTS", 2, 2, false);
            declareFunction("unique_difference_among_lists", "UNIQUE-DIFFERENCE-AMONG-LISTS", 1, 0, false);
            declareFunction("unique_difference_between_lists", "UNIQUE-DIFFERENCE-BETWEEN-LISTS", 2, 0, false);
            declareFunction("list_subst", "LIST-SUBST", 3, 1, false);
            declareFunction("list_subst_all_in_tree", "LIST-SUBST-ALL-IN-TREE", 3, 1, false);
            declareFunction("subseq_subst", "SUBSEQ-SUBST", 3, 1, false);
            declareFunction("self_evaluating_form_p", "SELF-EVALUATING-FORM-P", 1, 0, false);
            declareFunction("quote_form_p", "QUOTE-FORM-P", 1, 0, false);
            declareFunction("non_side_effecting_form_p", "NON-SIDE-EFFECTING-FORM-P", 1, 0, false);
            declareFunction("quotify", "QUOTIFY", 1, 0, false);
            new list_utilities.$quotify$UnaryFunction();
            declareFunction("unquotify", "UNQUOTIFY", 1, 0, false);
            declareFunction("sort_adjoin", "SORT-ADJOIN", 2, 3, false);
            declareFunction("sorted_add_to_list", "SORTED-ADD-TO-LIST", 3, 1, false);
            declareFunction("splice_into_sorted_list", "SPLICE-INTO-SORTED-LIST", 3, 1, false);
            declareFunction("safe_splice_into_sorted_list", "SAFE-SPLICE-INTO-SORTED-LIST", 3, 1, false);
            declareFunction("element_precedes_specified_othersP", "ELEMENT-PRECEDES-SPECIFIED-OTHERS?", 3, 2, false);
            declareFunction("function_arglist_max_args", "FUNCTION-ARGLIST-MAX-ARGS", 1, 0, false);
            declareFunction("function_arglist_min_args", "FUNCTION-ARGLIST-MIN-ARGS", 1, 0, false);
            declareFunction("remove_self_binds", "REMOVE-SELF-BINDS", 1, 1, false);
            declareFunction("self_bindP", "SELF-BIND?", 1, 1, false);
            declareFunction("bind_for_var", "BIND-FOR-VAR", 2, 2, false);
            declareFunction("remove_bind", "REMOVE-BIND", 2, 2, false);
            declareFunction("extract_bindings", "EXTRACT-BINDINGS", 2, 0, false);
            declareFunction("car_is_el_varP", "CAR-IS-EL-VAR?", 1, 0, false);
            declareFunction("extract_binding_strings", "EXTRACT-BINDING-STRINGS", 2, 0, false);
            declareFunction("tree_funcall_if", "TREE-FUNCALL-IF", 3, 1, false);
            declareFunction("tree_find_all_if", "TREE-FIND-ALL-IF", 2, 1, false);
            declareFunction("tree_remove_all_if", "TREE-REMOVE-ALL-IF", 2, 1, false);
            declareFunction("nswap_tree", "NSWAP-TREE", 3, 2, false);
            declareFunction("swap_tree", "SWAP-TREE", 3, 2, false);
            declareFunction("tree_find_all_nested_if", "TREE-FIND-ALL-NESTED-IF", 2, 1, false);
            declareFunction("tree_find_all_nested_if_int", "TREE-FIND-ALL-NESTED-IF-INT", 3, 0, false);
            declareFunction("hash_delete_duplicates", "HASH-DELETE-DUPLICATES", 1, 4, false);
            declareFunction("hash_delete_duplicates_int", "HASH-DELETE-DUPLICATES-INT", 5, 0, false);
            declareFunction("hash_remove_duplicates", "HASH-REMOVE-DUPLICATES", 1, 4, false);
            declareFunction("fast_delete_duplicates_hashtable", "FAST-DELETE-DUPLICATES-HASHTABLE", 1, 0, false);
            declareFunction("fast_delete_duplicates", "FAST-DELETE-DUPLICATES", 1, 5, false);
            declareFunction("fast_remove_duplicates", "FAST-REMOVE-DUPLICATES", 1, 5, false);
            declareFunction("fast_remove_duplicates_preserving_first", "FAST-REMOVE-DUPLICATES-PRESERVING-FIRST", 1, 2, false);
            declareFunction("remove_duplicates_preserving_order", "REMOVE-DUPLICATES-PRESERVING-ORDER", 1, 2, false);
            declareFunction("remove_duplicate_forts", "REMOVE-DUPLICATE-FORTS", 1, 0, false);
            declareFunction("delete_duplicate_forts", "DELETE-DUPLICATE-FORTS", 1, 0, false);
            declareFunction("hash_unique_elements", "HASH-UNIQUE-ELEMENTS", 2, 0, false);
            declareFunction("unique_elements", "UNIQUE-ELEMENTS", 1, 1, false);
            declareFunction("remove_all_n_icates", "REMOVE-ALL-N-ICATES", 2, 1, false);
            declareFunction("nsort_intersection", "NSORT-INTERSECTION", 2, 2, false);
            declareFunction("intersect_sorted_all", "INTERSECT-SORTED-ALL", 1, 2, false);
            declareFunction("intersect_sorted", "INTERSECT-SORTED", 2, 2, false);
            declareFunction("nintersect_sorted", "NINTERSECT-SORTED", 2, 2, false);
            declareFunction("nintersect_sorted_destroy_first_only", "NINTERSECT-SORTED-DESTROY-FIRST-ONLY", 2, 2, false);
            declareFunction("nintersect_sorted_int", "NINTERSECT-SORTED-INT", 4, 0, false);
            declareFunction("sort_intersection", "SORT-INTERSECTION", 2, 2, false);
            declareFunction("union_sorted", "UNION-SORTED", 2, 2, false);
            declareFunction("nunion_sorted", "NUNION-SORTED", 2, 2, false);
            declareFunction("union_sorted_int", "UNION-SORTED-INT", 5, 0, false);
            declareFunction("union_of_intersecting_sorted_lists", "UNION-OF-INTERSECTING-SORTED-LISTS", 1, 2, false);
            declareFunction("union_of_intersecting_sorted_lists_recursive", "UNION-OF-INTERSECTING-SORTED-LISTS-RECURSIVE", 4, 0, false);
            declareFunction("delete_duplicates_sorted", "DELETE-DUPLICATES-SORTED", 1, 1, false);
            declareFunction("remove_duplicates_sorted", "REMOVE-DUPLICATES-SORTED", 1, 1, false);
            declareFunction("position_wrt", "POSITION-WRT", 3, 3, false);
            declareFunction("difference_sorted", "DIFFERENCE-SORTED", 2, 2, false);
            declareFunction("alist_p", "ALIST-P", 1, 0, false);
            declareFunction("alist_lookup", "ALIST-LOOKUP", 2, 2, false);
            declareFunction("alist_lookup_without_values", "ALIST-LOOKUP-WITHOUT-VALUES", 2, 2, false);
            declareFunction("alist_nlookup_without_values", "ALIST-NLOOKUP-WITHOUT-VALUES", 2, 2, false);
            declareFunction("alist_nlookup_eq", "ALIST-NLOOKUP-EQ", 2, 1, false);
            declareFunction("alist_nlookup_eql", "ALIST-NLOOKUP-EQL", 2, 1, false);
            declareFunction("alist_nlookup_equal", "ALIST-NLOOKUP-EQUAL", 2, 1, false);
            declareFunction("alist_nlookup_equalp", "ALIST-NLOOKUP-EQUALP", 2, 1, false);
            declareFunction("alist_nlookup_funcall", "ALIST-NLOOKUP-FUNCALL", 3, 1, false);
            declareFunction("alist_nlookup_success", "ALIST-NLOOKUP-SUCCESS", 4, 0, false);
            declareFunction("alist_has_keyP", "ALIST-HAS-KEY?", 2, 1, false);
            declareFunction("alist_has_valueP", "ALIST-HAS-VALUE?", 2, 1, false);
            declareFunction("alist_reverse_lookup", "ALIST-REVERSE-LOOKUP", 2, 2, false);
            declareFunction("alist_reverse_lookup_without_values", "ALIST-REVERSE-LOOKUP-WITHOUT-VALUES", 2, 2, false);
            declareFunction("alist_enter", "ALIST-ENTER", 3, 1, false);
            declareFunction("alist_enter_without_values", "ALIST-ENTER-WITHOUT-VALUES", 3, 1, false);
            declareFunction("alist_capacity_enter_without_values", "ALIST-CAPACITY-ENTER-WITHOUT-VALUES", 4, 1, false);
            declareFunction("alist_promote", "ALIST-PROMOTE", 2, 1, false);
            declareFunction("alist_delete", "ALIST-DELETE", 2, 1, false);
            declareFunction("alist_delete_without_values", "ALIST-DELETE-WITHOUT-VALUES", 2, 1, false);
            declareFunction("alist_remove", "ALIST-REMOVE", 2, 1, false);
            declareFunction("alist_remove_without_values", "ALIST-REMOVE-WITHOUT-VALUES", 2, 1, false);
            declareFunction("alist_push", "ALIST-PUSH", 3, 1, false);
            declareFunction("alist_pushnew", "ALIST-PUSHNEW", 3, 2, false);
            declareFunction("alist_remove_from_value", "ALIST-REMOVE-FROM-VALUE", 3, 2, false);
            declareMacro("pushnew_onto_alist", "PUSHNEW-ONTO-ALIST");
            declareMacro("push_onto_alist", "PUSH-ONTO-ALIST");
            declareMacro("enter_into_alist", "ENTER-INTO-ALIST");
            declareFunction("alist_keys", "ALIST-KEYS", 1, 0, false);
            declareFunction("alist_values", "ALIST-VALUES", 1, 0, false);
            declareFunction("alist_optimize", "ALIST-OPTIMIZE", 2, 0, false);
            declareFunction("alist_E", "ALIST-=", 2, 2, false);
            declareFunction("alist_subsumesP", "ALIST-SUBSUMES?", 2, 2, false);
            declareFunction("alist_to_hash_table", "ALIST-TO-HASH-TABLE", 1, 1, false);
            declareFunction("alist_to_reverse_hash_table", "ALIST-TO-REVERSE-HASH-TABLE", 1, 1, false);
            declareFunction("sort_alist_by_keys", "SORT-ALIST-BY-KEYS", 2, 0, false);
            declareFunction("sort_alist_by_values", "SORT-ALIST-BY-VALUES", 2, 0, false);
            declareFunction("cons_to_tuple", "CONS-TO-TUPLE", 1, 0, false);
            declareFunction("tuple_to_cons", "TUPLE-TO-CONS", 1, 0, false);
            declareFunction("alist_to_tuples", "ALIST-TO-TUPLES", 1, 0, false);
            declareFunction("property_list_p", "PROPERTY-LIST-P", 1, 0, false);
            declareFunction("non_empty_property_list_p", "NON-EMPTY-PROPERTY-LIST-P", 1, 0, false);
            declareFunction("filter_plist", "FILTER-PLIST", 2, 0, false);
            declareFunction("prune_plist", "PRUNE-PLIST", 1, 1, false);
            declareFunction("plist_of_type_p", "PLIST-OF-TYPE-P", 2, 0, false);
            declareFunction("plist_of_value_type_p", "PLIST-OF-VALUE-TYPE-P", 2, 0, false);
            declareFunction("make_plist", "MAKE-PLIST", 2, 0, false);
            declareMacro("plist_enter", "PLIST-ENTER");
            declareFunction("plist_lookup", "PLIST-LOOKUP", 2, 1, false);
            declareMacro("plist_increment", "PLIST-INCREMENT");
            declareMacro("plist_push", "PLIST-PUSH");
            declareMacro("plist_remove", "PLIST-REMOVE");
            declareFunction("alist_to_plist", "ALIST-TO-PLIST", 1, 0, false);
            declareFunction("plist_to_alist", "PLIST-TO-ALIST", 1, 0, false);
            declareFunction("nmerge_plist", "NMERGE-PLIST", 2, 0, false);
            declareFunction("merge_plist", "MERGE-PLIST", 2, 0, false);
            declareFunction("sort_plist_by_properties", "SORT-PLIST-BY-PROPERTIES", 2, 0, false);
            declareFunction("sort_plist_by_values", "SORT-PLIST-BY-VALUES", 2, 0, false);
            declareFunction("sort_plist_via_position", "SORT-PLIST-VIA-POSITION", 2, 1, false);
            declareFunction("indicator_presentP", "INDICATOR-PRESENT?", 2, 0, false);
            declareFunction("plist_has_keyP", "PLIST-HAS-KEY?", 2, 0, false);
            declareFunction("plist_has_keysP", "PLIST-HAS-KEYS?", 2, 0, false);
            declareFunction("member_plist_key_p", "MEMBER-PLIST-KEY-P", 2, 0, false);
            declareFunction("non_nil_plist_valueP", "NON-NIL-PLIST-VALUE?", 2, 0, false);
            declareFunction("get_property_with_defaults", "GET-PROPERTY-WITH-DEFAULTS", 3, 1, false);
            declareFunction("augment_plist_with_defaults", "AUGMENT-PLIST-WITH-DEFAULTS", 2, 0, false);
            declareFunction("plist_restricted_to_indicatorsP", "PLIST-RESTRICTED-TO-INDICATORS?", 2, 0, false);
            declareFunction("maybe_putf", "MAYBE-PUTF", 3, 0, false);
            declareFunction("plist_properties", "PLIST-PROPERTIES", 1, 0, false);
            declareFunction("plist_keys", "PLIST-KEYS", 1, 0, false);
            declareFunction("plist_values", "PLIST-VALUES", 1, 0, false);
            declareFunction("plist_restricted_to_indicators", "PLIST-RESTRICTED-TO-INDICATORS", 2, 0, false);
            declareFunction("plist_except", "PLIST-EXCEPT", 2, 0, false);
            declareFunction("plistlist_if_getf", "PLISTLIST-IF-GETF", 3, 1, false);
            declareFunction("plistlist_sort", "PLISTLIST-SORT", 3, 0, false);
            declareFunction("plistlist_sort_key", "PLISTLIST-SORT-KEY", 1, 0, false);
            declareFunction("sub_plistP", "SUB-PLIST?", 2, 1, false);
            declareFunction("slow_plists_equalP", "SLOW-PLISTS-EQUAL?", 2, 1, false);
            declareFunction("format_item_list", "FORMAT-ITEM-LIST", 1, 0, false);
            declareFunction("print_plist_readably", "PRINT-PLIST-READABLY", 1, 1, false);
            declareFunction("pretty_print_plist", "PRETTY-PRINT-PLIST", 1, 1, false);
            declareFunction("pretty_prin1_plist", "PRETTY-PRIN1-PLIST", 1, 1, false);
            declareFunction("pretty_print_alist", "PRETTY-PRINT-ALIST", 1, 1, false);
            declareFunction("print_list_of_lists_as_table", "PRINT-LIST-OF-LISTS-AS-TABLE", 1, 1, false);
            declareFunction("print_list_as_delimited_line", "PRINT-LIST-AS-DELIMITED-LINE", 1, 2, false);
            declareFunction("any_in_list", "ANY-IN-LIST", 2, 1, false);
            declareFunction("every_in_list", "EVERY-IN-LIST", 2, 1, false);
            declareFunction("not_any_in_list", "NOT-ANY-IN-LIST", 2, 1, false);
            declareFunction("not_every_in_list", "NOT-EVERY-IN-LIST", 2, 1, false);
            declareFunction("plist_difference", "PLIST-DIFFERENCE", 2, 1, false);
            declareFunction("list_subseq_subst_combos", "LIST-SUBSEQ-SUBST-COMBOS", 2, 0, false);
            declareFunction("list_subseq_subst_combos_internal", "LIST-SUBSEQ-SUBST-COMBOS-INTERNAL", 3, 0, false);
            declareFunction("greedy_list_subseq_subst", "GREEDY-LIST-SUBSEQ-SUBST", 2, 0, false);
            declareFunction("greedy_list_subseq_subst_internal", "GREEDY-LIST-SUBSEQ-SUBST-INTERNAL", 3, 0, false);
            declareFunction("extremal", "EXTREMAL", 2, 1, false);
            declareFunction("extremals", "EXTREMALS", 2, 1, false);
            declareFunction("nth_rank_items", "NTH-RANK-ITEMS", 2, 2, false);
            declareFunction("rerank", "RERANK", 2, 3, false);
            declareFunction("powerset", "POWERSET", 1, 0, false);
            declareFunction("subsets_of_size", "SUBSETS-OF-SIZE", 2, 0, false);
            declareFunction("subsets_of_size_int", "SUBSETS-OF-SIZE-INT", 2, 0, false);
            declareFunction("position_L", "POSITION-<", 3, 2, false);
            declareFunction("sort_via_position", "SORT-VIA-POSITION", 2, 2, false);
            declareFunction("stable_sort_via_position", "STABLE-SORT-VIA-POSITION", 2, 2, false);
            declareFunction("sort_via_position_earlier", "SORT-VIA-POSITION-EARLIER", 2, 0, false);
            new list_utilities.$sort_via_position_earlier$BinaryFunction();
            declareFunction("sort_via_test", "SORT-VIA-TEST", 2, 1, false);
            declareFunction("stable_sort_via_test", "STABLE-SORT-VIA-TEST", 2, 1, false);
            declareFunction("sort_via_test_earlier", "SORT-VIA-TEST-EARLIER", 2, 0, false);
            declareFunction("sort_L", "SORT-<", 1, 1, false);
            declareFunction("sort_G", "SORT->", 1, 1, false);
            declareFunction("safe_sort_L", "SAFE-SORT-<", 1, 1, false);
            declareFunction("safe_sort_G", "SAFE-SORT->", 1, 1, false);
            declareFunction("sets_of_sets_L", "SETS-OF-SETS-<", 2, 1, false);
            declareFunction("sets_L", "SETS-<", 2, 1, false);
            declareFunction("set_L", "SET-<", 2, 1, false);
            declareFunction("list_structure", "LIST-STRUCTURE", 1, 1, false);
            declareFunction("list_structure_min", "LIST-STRUCTURE-MIN", 1, 0, false);
            declareFunction("list_structure_L", "LIST-STRUCTURE-<", 2, 0, false);
            declareFunction("tree_min", "TREE-MIN", 1, 0, false);
            declareFunction("safe_tree_L", "SAFE-TREE-<", 2, 0, false);
            declareFunction("safe_L", "SAFE-<", 2, 0, false);
            declareFunction("safe_G", "SAFE->", 2, 0, false);
            declareFunction("safe_GE", "SAFE->=", 2, 0, false);
            declareFunction("safe_LE", "SAFE-<=", 2, 0, false);
            declareFunction("safe_max", "SAFE-MAX", 1, 1, false);
            declareFunction("safe_difference", "SAFE-DIFFERENCE", 2, 0, false);
            declareFunction("safe_quotient", "SAFE-QUOTIENT", 2, 0, false);
            declareFunction("safe_product", "SAFE-PRODUCT", 2, 0, false);
            declareFunction("safe_sum", "SAFE-SUM", 2, 0, false);
            declareFunction("safe_E", "SAFE-=", 2, 0, false);
            declareFunction("absL", "ABS<", 2, 0, false);
            declareFunction("absG", "ABS>", 2, 0, false);
            declareFunction("equalE", "EQUAL=", 2, 0, false);
            declareFunction("tree_L", "TREE-<", 2, 2, false);
            declareFunction("tree_lt_intP", "TREE-LT-INT?", 4, 0, false);
            declareFunction("parametrized_median", "PARAMETRIZED-MEDIAN", 2, 0, false);
            declareFunction("shortest", "SHORTEST", 1, 0, false);
            declareFunction("longest", "LONGEST", 1, 0, false);
            declareFunction("cons_count", "CONS-COUNT", 1, 0, false);
            declareFunction("tree_delete", "TREE-DELETE", 2, 2, false);
            declareFunction("tree_map", "TREE-MAP", 2, 1, false);
            declareFunction("tree_ntransform_if", "TREE-NTRANSFORM-IF", 3, 1, false);
            declareFunction("tree_transform_if", "TREE-TRANSFORM-IF", 3, 1, false);
            declareFunction("cons_tree_find", "CONS-TREE-FIND", 2, 2, false);
            declareFunction("tree_find", "TREE-FIND", 2, 2, false);
            declareFunction("tree_find_int", "TREE-FIND-INT", 4, 0, false);
            declareFunction("tree_find_without_values_int", "TREE-FIND-WITHOUT-VALUES-INT", 4, 0, false);
            declareFunction("simple_tree_findP", "SIMPLE-TREE-FIND?", 2, 0, false);
            declareFunction("simple_tree_find", "SIMPLE-TREE-FIND", 2, 0, false);
            declareFunction("simple_tree_find_via_eqlP", "SIMPLE-TREE-FIND-VIA-EQL?", 2, 0, false);
            declareFunction("simple_tree_find_via_eql", "SIMPLE-TREE-FIND-VIA-EQL", 2, 0, false);
            declareFunction("simple_tree_find_via_equalP", "SIMPLE-TREE-FIND-VIA-EQUAL?", 2, 0, false);
            declareFunction("simple_tree_find_via_equal", "SIMPLE-TREE-FIND-VIA-EQUAL", 2, 0, false);
            declareFunction("tree_find_any", "TREE-FIND-ANY", 2, 2, false);
            declareFunction("cons_tree_find_if", "CONS-TREE-FIND-IF", 2, 1, false);
            declareFunction("tree_find_if", "TREE-FIND-IF", 2, 1, false);
            declareFunction("cons_tree_count", "CONS-TREE-COUNT", 2, 2, false);
            declareFunction("tree_count", "TREE-COUNT", 2, 2, false);
            declareFunction("tree_countG", "TREE-COUNT>", 3, 2, false);
            declareFunction("tree_countGE", "TREE-COUNT>=", 3, 2, false);
            declareFunction("tree_countL", "TREE-COUNT<", 3, 2, false);
            declareFunction("tree_countLE", "TREE-COUNT<=", 3, 2, false);
            declareFunction("tree_countE", "TREE-COUNT=", 3, 2, false);
            declareFunction("tree_count_internal", "TREE-COUNT-INTERNAL", 5, 1, false);
            declareFunction("simple_tree_count", "SIMPLE-TREE-COUNT", 2, 0, false);
            declareFunction("simple_tree_count_recursive", "SIMPLE-TREE-COUNT-RECURSIVE", 3, 0, false);
            declareFunction("cons_tree_count_if", "CONS-TREE-COUNT-IF", 2, 1, false);
            declareFunction("tree_count_if", "TREE-COUNT-IF", 2, 1, false);
            declareFunction("tree_count_if_unique", "TREE-COUNT-IF-UNIQUE", 2, 1, false);
            declareFunction("cons_tree_gather", "CONS-TREE-GATHER", 2, 3, false);
            declareFunction("tree_gather", "TREE-GATHER", 2, 3, false);
            declareFunction("tree_gather_internal", "TREE-GATHER-INTERNAL", 6, 0, false);
            declareFunction("tree_gather_ordered", "TREE-GATHER-ORDERED", 2, 2, false);
            declareFunction("tree_gather_ordered_subs", "TREE-GATHER-ORDERED-SUBS", 3, 0, false);
            declareFunction("tree_gather_ordered_no_subs", "TREE-GATHER-ORDERED-NO-SUBS", 3, 0, false);
            declareFunction("tree_substitute", "TREE-SUBSTITUTE", 3, 0, false);
            declareFunction("tree_substitute_using_dictionary", "TREE-SUBSTITUTE-USING-DICTIONARY", 2, 0, false);
            declareFunction("tree_splice", "TREE-SPLICE", 3, 0, false);
            declareFunction("tree_gather_transformations", "TREE-GATHER-TRANSFORMATIONS", 3, 2, false);
            declareFunction("remove_if_doesnt_include", "REMOVE-IF-DOESNT-INCLUDE", 2, 0, false);
            declareFunction("delete_subsumed_items", "DELETE-SUBSUMED-ITEMS", 2, 1, false);
            declareFunction("delete_subsumed_items_internal", "DELETE-SUBSUMED-ITEMS-INTERNAL", 3, 0, false);
            declareFunction("subsumedP", "SUBSUMED?", 4, 0, false);
            declareFunction("subsumesP", "SUBSUMES?", 4, 0, false);
            declareFunction("subsumesP_internal", "SUBSUMES?-INTERNAL", 4, 0, false);
            declareFunction("remove_subsumed_items", "REMOVE-SUBSUMED-ITEMS", 2, 1, false);
            declareFunction("cross_products", "CROSS-PRODUCTS", 1, 0, false);
            declareFunction("map_pairs", "MAP-PAIRS", 3, 0, false);
            declareFunction("fn_with_each", "FN-WITH-EACH", 3, 0, false);
            declareFunction("indexed_products", "INDEXED-PRODUCTS", 1, 0, false);
            declareFunction("explicate_permutations", "EXPLICATE-PERMUTATIONS", 1, 1, false);
            declareFunction("untranslate_elements_from_tagged_sets", "UNTRANSLATE-ELEMENTS-FROM-TAGGED-SETS", 2, 1, false);
            declareFunction("translate_elements_to_tagged_sets", "TRANSLATE-ELEMENTS-TO-TAGGED-SETS", 2, 0, false);
            declareFunction("permute_list", "PERMUTE-LIST", 1, 1, false);
            declareFunction("permute_list_int", "PERMUTE-LIST-INT", 1, 1, false);
            declareFunction("all_permutations", "ALL-PERMUTATIONS", 1, 0, false);
            declareFunction("nsublis_permute", "NSUBLIS-PERMUTE", 3, 0, false);
            declareFunction("sublis_permute", "SUBLIS-PERMUTE", 3, 0, false);
            declareFunction("permute", "PERMUTE", 2, 0, false);
            declareFunction("random_permutation", "RANDOM-PERMUTATION", 1, 0, false);
            declareFunction("choose_n_between", "CHOOSE-N-BETWEEN", 2, 0, false);
            declareFunction("trigram_transform", "TRIGRAM-TRANSFORM", 2, 2, false);
            declareFunction("chunk", "CHUNK", 2, 0, false);
            declareFunction("get_arglist", "GET-ARGLIST", 1, 0, false);
            declareFunction("get_documentation", "GET-DOCUMENTATION", 1, 0, false);
            declareFunction("push_on_car", "PUSH-ON-CAR", 2, 0, false);
            declareFunction("pop_and_reverse_car_and_push_on_cadr", "POP-AND-REVERSE-CAR-AND-PUSH-ON-CADR", 1, 0, false);
            declareFunction("cartesian_product", "CARTESIAN-PRODUCT", 1, 3, false);
            declareFunction("cartesian_product_cardinality", "CARTESIAN-PRODUCT-CARDINALITY", 1, 0, false);
            declareFunction("cartesian_helper", "CARTESIAN-HELPER", 3, 0, false);
            declareFunction("cartesian_helper_with_test", "CARTESIAN-HELPER-WITH-TEST", 4, 0, false);
            declareFunction("pick_two", "PICK-TWO", 1, 0, false);
            declareMacro("mapexp", "MAPEXP");
            declareFunction("recursive_member", "RECURSIVE-MEMBER", 2, 1, false);
            declareFunction("list_of_type_p", "LIST-OF-TYPE-P", 2, 0, false);
            declareFunction("non_empty_list_of_type_p", "NON-EMPTY-LIST-OF-TYPE-P", 2, 0, false);
            declareFunction("list_of_list_p", "LIST-OF-LIST-P", 1, 0, false);
            declareFunction("list_of_keyword_p", "LIST-OF-KEYWORD-P", 1, 0, false);
            declareFunction("string_list_p", "STRING-LIST-P", 1, 0, false);
            declareFunction("symbol_list_p", "SYMBOL-LIST-P", 1, 0, false);
            declareFunction("function_symbol_list_p", "FUNCTION-SYMBOL-LIST-P", 1, 0, false);
            declareFunction("form_with_operator_p", "FORM-WITH-OPERATOR-P", 2, 0, false);
            declareFunction("verify_operator", "VERIFY-OPERATOR", 2, 0, false);
            declareFunction("verify_form_with_operator", "VERIFY-FORM-WITH-OPERATOR", 2, 0, false);
            declareFunction("functor_in_expression_p", "FUNCTOR-IN-EXPRESSION-P", 2, 0, false);
            declareFunction("functor_in_body_p", "FUNCTOR-IN-BODY-P", 2, 0, false);
            declareFunction("variable_value_used_in_body_p", "VARIABLE-VALUE-USED-IN-BODY-P", 2, 0, false);
            declareFunction("variable_value_used_in_expression_p", "VARIABLE-VALUE-USED-IN-EXPRESSION-P", 2, 0, false);
            declareFunction("object_in_expression_p", "OBJECT-IN-EXPRESSION-P", 2, 0, false);
            declareFunction("parse_to_list_of_strings", "PARSE-TO-LIST-OF-STRINGS", 1, 2, false);
            declareFunction("tree_substitute_by_association", "TREE-SUBSTITUTE-BY-ASSOCIATION", 2, 3, false);
            declareFunction("safe_read_delimited_list", "SAFE-READ-DELIMITED-LIST", 1, 2, false);
            declareFunction("multi_sublis", "MULTI-SUBLIS", 2, 2, false);
            declareFunction("multi_assoc", "MULTI-ASSOC", 2, 2, false);
            declareFunction("valid_and_conformant_alist_p", "VALID-AND-CONFORMANT-ALIST-P", 1, 2, false);
            declareFunction("histogram", "HISTOGRAM", 1, 3, false);
            declareFunction("histogram_as_plist", "HISTOGRAM-AS-PLIST", 1, 3, false);
            declareFunction("pretty_print_histogram", "PRETTY-PRINT-HISTOGRAM", 1, 0, false);
            declareFunction("n_within", "N-WITHIN", 3, 0, false);
            declareFunction("middle_sublist", "MIDDLE-SUBLIST", 2, 0, false);
            declareFunction("categorize_list_elements", "CATEGORIZE-LIST-ELEMENTS", 2, 1, false);
            declareFunction("rank_tuples", "RANK-TUPLES", 1, 0, false);
            declareFunction("collate", "COLLATE", 1, 0, false);
            declareFunction("list_with_first_p", "LIST-WITH-FIRST-P", 2, 0, false);
            declareFunction("elements_incompatibleP", "ELEMENTS-INCOMPATIBLE?", 3, 0, false);
            declareFunction("element_incompatible_with_any_of", "ELEMENT-INCOMPATIBLE-WITH-ANY-OF", 3, 0, false);
            declareFunction("compute_all_compatible_sublists", "COMPUTE-ALL-COMPATIBLE-SUBLISTS", 2, 2, false);
            declareFunction("test_compute_all_compatible_sublists", "TEST-COMPUTE-ALL-COMPATIBLE-SUBLISTS", 3, 0, false);
            declareFunction("gather_nodes_and_incompatible_pairs_from_graph_txt", "GATHER-NODES-AND-INCOMPATIBLE-PAIRS-FROM-GRAPH-TXT", 1, 0, false);
            declareFunction("test_find_maximum_independent_set", "TEST-FIND-MAXIMUM-INDEPENDENT-SET", 3, 0, false);
            declareFunction("comparator_compare_internal", "COMPARATOR-COMPARE-INTERNAL", 3, 0, false);
            declareFunction("comparator_compare", "COMPARATOR-COMPARE", 3, 0, false);
            declareFunction("sort_preferred_list_to_front", "SORT-PREFERRED-LIST-TO-FRONT", 2, 1, false);
            declareFunction("sort_preferred_to_front", "SORT-PREFERRED-TO-FRONT", 2, 1, false);
            declareFunction("a_preferred_over_b", "A-PREFERRED-OVER-B", 2, 0, false);
            declareFunction("debug_comparison_method_violates_its_general_contract", "DEBUG-COMPARISON-METHOD-VIOLATES-ITS-GENERAL-CONTRACT", 2, 2, false);
            declareFunction("find_first_and_nreplace_test", "FIND-FIRST-AND-NREPLACE-TEST", 3, 1, false);
        }
        if (SubLFiles.USE_V2) {
            declareFunction("get_nadd_to_end_test_case_p_queue", "GET-NADD-TO-END-TEST-CASE-P-QUEUE", 1, 0, false);
            declareFunction("set_nadd_to_end_test_case_p_queue", "SET-NADD-TO-END-TEST-CASE-P-QUEUE", 2, 0, false);
            declareFunction("subloop_reserved_initialize_nadd_to_end_test_case_class", "SUBLOOP-RESERVED-INITIALIZE-NADD-TO-END-TEST-CASE-CLASS", 1, 0, false);
            declareFunction("subloop_reserved_initialize_nadd_to_end_test_case_instance", "SUBLOOP-RESERVED-INITIALIZE-NADD-TO-END-TEST-CASE-INSTANCE", 1, 0, false);
            declareFunction("nadd_to_end_test_case_p", "NADD-TO-END-TEST-CASE-P", 1, 0, false);
            declareFunction("get_last1_test_case_p_queue", "GET-LAST1-TEST-CASE-P-QUEUE", 1, 0, false);
            declareFunction("set_last1_test_case_p_queue", "SET-LAST1-TEST-CASE-P-QUEUE", 2, 0, false);
            declareFunction("subloop_reserved_initialize_last1_test_case_class", "SUBLOOP-RESERVED-INITIALIZE-LAST1-TEST-CASE-CLASS", 1, 0, false);
            declareFunction("subloop_reserved_initialize_last1_test_case_instance", "SUBLOOP-RESERVED-INITIALIZE-LAST1-TEST-CASE-INSTANCE", 1, 0, false);
            declareFunction("last1_test_case_p", "LAST1-TEST-CASE-P", 1, 0, false);
            declareFunction("get_list_macros_test_case_p_queue", "GET-LIST-MACROS-TEST-CASE-P-QUEUE", 1, 0, false);
            declareFunction("set_list_macros_test_case_p_queue", "SET-LIST-MACROS-TEST-CASE-P-QUEUE", 2, 0, false);
            declareFunction("subloop_reserved_initialize_list_macros_test_case_class", "SUBLOOP-RESERVED-INITIALIZE-LIST-MACROS-TEST-CASE-CLASS", 1, 0, false);
            declareFunction("subloop_reserved_initialize_list_macros_test_case_instance", "SUBLOOP-RESERVED-INITIALIZE-LIST-MACROS-TEST-CASE-INSTANCE", 1, 0, false);
            declareFunction("list_macros_test_case_p", "LIST-MACROS-TEST-CASE-P", 1, 0, false);
        }
        return NIL;
    }

    public static SubLObject declare_list_utilities_file_Previous() {
        declareFunction("sublisp_boolean", "BOOLEAN", 1, 0, false);
        declareFunction("not_boolean", "NOT-BOOLEAN", 1, 0, false);
        declareFunction("not_eq", "NOT-EQ", 2, 0, false);
        declareFunction("not_eql", "NOT-EQL", 2, 0, false);
        declareFunction("not_equal", "NOT-EQUAL", 2, 0, false);
        declareFunction("not_equalp", "NOT-EQUALP", 2, 0, false);
        declareFunction("not_assoc", "NOT-ASSOC", 2, 2, false);
        declareFunction("not_consp", "NOT-CONSP", 1, 0, false);
        declareFunction("eq_and_not_eq", "EQ-AND-NOT-EQ", 2, 0, false);
        declareFunction("bull", "BULL", 2, 0, false);
        declareFunction("no_op", "NO-OP", 0, 0, false);
        declareFunction("caadr", "CAADR", 1, 0, false);
        declareFunction("caddr", "CADDR", 1, 0, false);
        declareFunction("cdddr", "CDDDR", 1, 0, false);
        declareFunction("cadddr", "CADDDR", 1, 0, false);
        declareFunction("cadadr", "CADADR", 1, 0, false);
        declareFunction("cadar", "CADAR", 1, 0, false);
        new list_utilities.$cadar$UnaryFunction();
        declareFunction("cdadr", "CDADR", 1, 0, false);
        declareFunction("snoc", "SNOC", 2, 0, false);
        declareFunction("list_rotate_left", "LIST-ROTATE-LEFT", 1, 0, false);
        declareFunction("list_rotate_right", "LIST-ROTATE-RIGHT", 1, 0, false);
        declareFunction("proper_subsetp", "PROPER-SUBSETP", 2, 2, false);
        declareFunction("proper_subsetp_pre_sorted", "PROPER-SUBSETP-PRE-SORTED", 2, 2, false);
        declareFunction("nth_cycling", "NTH-CYCLING", 2, 2, false);
        declareMacro("pop_setq", "POP-SETQ");
        declareMacro("pop_bind", "POP-BIND");
        declareMacro("push_max_length", "PUSH-MAX-LENGTH");
        declareMacro("cdolist_multiple", "CDOLIST-MULTIPLE");
        declareMacro("cdolist_multiple_numbered", "CDOLIST-MULTIPLE-NUMBERED");
        declareMacro("csome_multiple", "CSOME-MULTIPLE");
        declareMacro("cdolist_numbered", "CDOLIST-NUMBERED");
        declareMacro("cdolist_backward", "CDOLIST-BACKWARD");
        declareMacro("cdolist_backward_numbered", "CDOLIST-BACKWARD-NUMBERED");
        declareMacro("csome_numbered", "CSOME-NUMBERED");
        declareMacro("cdolist_cycling", "CDOLIST-CYCLING");
        declareMacro("cdolist_cycling_complex", "CDOLIST-CYCLING-COMPLEX");
        declareMacro("do_tree_leaves", "DO-TREE-LEAVES");
        declareFunction("args_from_arg_list", "ARGS-FROM-ARG-LIST", 1, 0, false);
        declareFunction("lengthL", "LENGTH<", 2, 1, false);
        declareFunction("lengthLE", "LENGTH<=", 2, 1, false);
        declareFunction("lengthE", "LENGTH=", 2, 1, false);
        declareFunction("lengthsE", "LENGTHS=", 2, 1, false);
        declareFunction("lengthG", "LENGTH>", 2, 1, false);
        declareFunction("lengthGE", "LENGTH>=", 2, 1, false);
        declareFunction("zero_length_p", "ZERO-LENGTH-P", 1, 0, false);
        declareFunction("same_length_p", "SAME-LENGTH-P", 2, 0, false);
        declareFunction("same_lengths_p", "SAME-LENGTHS-P", 1, 0, false);
        declareFunction("longer_p", "LONGER-P", 2, 0, false);
        declareFunction("greater_length_p", "GREATER-LENGTH-P", 2, 0, false);
        declareFunction("greater_or_same_length_p", "GREATER-OR-SAME-LENGTH-P", 2, 0, false);
        declareFunction("shorter_p", "SHORTER-P", 2, 0, false);
        declareFunction("lesser_length_p", "LESSER-LENGTH-P", 2, 0, false);
        declareFunction("lesser_or_same_length_p", "LESSER-OR-SAME-LENGTH-P", 2, 0, false);
        declareFunction("empty_list_p", "EMPTY-LIST-P", 1, 0, false);
        declareFunction("non_empty_list_p", "NON-EMPTY-LIST-P", 1, 0, false);
        declareFunction("proper_list_p", "PROPER-LIST-P", 1, 0, false);
        declareFunction("dotted_list_p", "DOTTED-LIST-P", 1, 0, false);
        new list_utilities.$dotted_list_p$UnaryFunction();
        declareFunction("non_dotted_list_p", "NON-DOTTED-LIST-P", 1, 0, false);
        declareFunction("dotted_length", "DOTTED-LENGTH", 1, 0, false);
        declareFunction("dotted_last", "DOTTED-LAST", 1, 0, false);
        declareFunction("dotted_butlast", "DOTTED-BUTLAST", 1, 0, false);
        declareFunction("undot", "UNDOT", 1, 0, false);
        declareFunction("add_to_dotted_end", "ADD-TO-DOTTED-END", 2, 0, false);
        declareFunction("nadd_to_dotted_end", "NADD-TO-DOTTED-END", 2, 0, false);
        declareFunction("ndot_last", "NDOT-LAST", 1, 0, false);
        declareFunction("dot_last", "DOT-LAST", 1, 0, false);
        declareFunction("possible_dotted_list_to_dotted_list", "POSSIBLE-DOTTED-LIST-TO-DOTTED-LIST", 1, 1, false);
        declareFunction("list_non_dotted_through_n_p", "LIST-NON-DOTTED-THROUGH-N-P", 2, 0, false);
        declareFunction("negated_test_func", "NEGATED-TEST-FUNC", 1, 0, false);
        new list_utilities.$negated_test_func$UnaryFunction();
        declareFunction("remove_if_not", "REMOVE-IF-NOT", 2, 4, false);
        declareFunction("delete_if_not", "DELETE-IF-NOT", 2, 4, false);
        declareFunction("substitute_if_not", "SUBSTITUTE-IF-NOT", 3, 4, false);
        declareFunction("nsubstitute_if_not", "NSUBSTITUTE-IF-NOT", 3, 4, false);
        declareFunction("find_if_not", "FIND-IF-NOT", 2, 3, false);
        declareFunction("position_if_not", "POSITION-IF-NOT", 2, 3, false);
        declareFunction("position_if_binary_lambda", "POSITION-IF-BINARY-LAMBDA", 1, 0, false);
        declareFunction("position_if_binary", "POSITION-IF-BINARY", 3, 3, false);
        declareFunction("position_from_end", "POSITION-FROM-END", 2, 4, false);
        declareFunction("tree_positions", "TREE-POSITIONS", 2, 2, false);
        declareFunction("tree_positions_w_parents", "TREE-POSITIONS-W-PARENTS", 2, 1, false);
        declareFunction("difference_from_head", "DIFFERENCE-FROM-HEAD", 2, 0, false);
        declareFunction("tree_position_bfs", "TREE-POSITION-BFS", 2, 1, false);
        declareFunction("tree_position_dfs", "TREE-POSITION-DFS", 2, 1, false);
        declareFunction("list_position", "LIST-POSITION", 2, 2, false);
        declareFunction("tree_position_p", "TREE-POSITION-P", 1, 0, false);
        declareFunction("tree_nested_nths", "TREE-NESTED-NTHS", 2, 0, false);
        declareFunction("tree_nths", "TREE-NTHS", 2, 0, false);
        declareFunction("has_nested_nth_p", "HAS-NESTED-NTH-P", 2, 0, false);
        declareFunction("get_nested_nth", "GET-NESTED-NTH", 2, 1, false);
        declareFunction("replace_nested_nth", "REPLACE-NESTED-NTH", 3, 0, false);
        declareFunction("nreplace_nested_nth", "NREPLACE-NESTED-NTH", 3, 0, false);
        declareFunction("remove_nested_nth", "REMOVE-NESTED-NTH", 2, 0, false);
        declareFunction("delete_nested_nth", "DELETE-NESTED-NTH", 2, 0, false);
        declareFunction("delete_nested_nth_internal", "DELETE-NESTED-NTH-INTERNAL", 2, 0, false);
        declareFunction("tree_positions_int", "TREE-POSITIONS-INT", 3, 1, false);
        declareFunction("tree_positions_dfs", "TREE-POSITIONS-DFS", 2, 1, false);
        declareFunction("tree_positions_bfs", "TREE-POSITIONS-BFS", 2, 1, false);
        declareFunction("containing_subtrees", "CONTAINING-SUBTREES", 2, 0, false);
        declareFunction("tree_positions_if_dfs", "TREE-POSITIONS-IF-DFS", 2, 1, false);
        declareFunction("tree_positions_if_bfs", "TREE-POSITIONS-IF-BFS", 2, 1, false);
        declareFunction("tree_positions_if_dfs_int", "TREE-POSITIONS-IF-DFS-INT", 2, 1, false);
        declareFunction("tree_position_if_bfs", "TREE-POSITION-IF-BFS", 2, 1, false);
        declareFunction("tree_position_if_dfs", "TREE-POSITION-IF-DFS", 2, 1, false);
        declareFunction("count_if_not", "COUNT-IF-NOT", 2, 3, false);
        declareFunction("subst_if_not", "SUBST-IF-NOT", 3, 1, false);
        declareFunction("nsubst_if_not", "NSUBST-IF-NOT", 3, 1, false);
        declareFunction("member_if_not", "MEMBER-IF-NOT", 2, 1, false);
        declareFunction("assoc_if_not", "ASSOC-IF-NOT", 2, 0, false);
        declareFunction("rassoc_if_not", "RASSOC-IF-NOT", 2, 0, false);
        declareFunction("assoc_all", "ASSOC-ALL", 2, 1, false);
        declareFunction("assoc_push", "ASSOC-PUSH", 3, 1, false);
        declareFunction("assoc_pushnew", "ASSOC-PUSHNEW", 3, 1, false);
        declareFunction("dotted_assoc_push", "DOTTED-ASSOC-PUSH", 3, 1, false);
        declareFunction("assoc_equal", "ASSOC-EQUAL", 2, 0, false);
        declareFunction("assoc_subsumedP", "ASSOC-SUBSUMED?", 3, 0, false);
        declareFunction("alist_extend", "ALIST-EXTEND", 2, 0, false);
        declareFunction("make_alist", "MAKE-ALIST", 1, 1, false);
        declareFunction("make_alist_from_keys_and_values", "MAKE-ALIST-FROM-KEYS-AND-VALUES", 2, 0, false);
        declareFunction("make_pair_list", "MAKE-PAIR-LIST", 2, 0, false);
        declareFunction("make_paired_lists", "MAKE-PAIRED-LISTS", 1, 0, false);
        declareFunction("first_safe_for_atoms", "FIRST-SAFE-FOR-ATOMS", 1, 0, false);
        declareMacro("first_of", "FIRST-OF");
        declareFunction("recons", "RECONS", 3, 0, false);
        declareFunction("ncons", "NCONS", 3, 0, false);
        declareFunction("delete_first", "DELETE-FIRST", 2, 1, false);
        declareFunction("remove_first", "REMOVE-FIRST", 2, 1, false);
        declareFunction("remove_duplicates_equal", "REMOVE-DUPLICATES-EQUAL", 1, 3, false);
        declareFunction("nmapcar", "NMAPCAR", 2, 0, false);
        declareFunction("mapcar_multiple", "MAPCAR-MULTIPLE", 2, 0, false);
        declareFunction("mapappend", "MAPAPPEND", 2, 0, false);
        declareFunction("mapunion", "MAPUNION", 2, 1, false);
        declareFunction("mapnunion", "MAPNUNION", 2, 1, false);
        declareFunction("mapcar_product", "MAPCAR-PRODUCT", 3, 0, false);
        declareFunction("mapcar_unique", "MAPCAR-UNIQUE", 2, 1, false);
        declareFunction("last1", "LAST1", 1, 0, false);
        declareFunction("add_to_end", "ADD-TO-END", 2, 0, false);
        declareFunction("nadd_to_end", "NADD-TO-END", 2, 0, false);
        declareFunction("adjoin_to_end", "ADJOIN-TO-END", 2, 1, false);
        declareFunction("nadjoin_to_end", "NADJOIN-TO-END", 2, 1, false);
        declareFunction("add_to_end_if", "ADD-TO-END-IF", 2, 0, false);
        declareFunction("nadd_to_end_if", "NADD-TO-END-IF", 2, 0, false);
        declareFunction("nth_from_end", "NTH-FROM-END", 2, 0, false);
        declareFunction("remove_from_end", "REMOVE-FROM-END", 2, 1, false);
        declareFunction("remove_objects_from_list", "REMOVE-OBJECTS-FROM-LIST", 2, 1, false);
        declareFunction("partition_list", "PARTITION-LIST", 2, 0, false);
        declareFunction("npartition_list", "NPARTITION-LIST", 2, 0, false);
        declareFunction("partition_list_by_equality", "PARTITION-LIST-BY-EQUALITY", 2, 2, false);
        declareFunction("partition_list_n_ways", "PARTITION-LIST-N-WAYS", 2, 0, false);
        declareFunction("randomly_partition_list_n_ways", "RANDOMLY-PARTITION-LIST-N-WAYS", 2, 0, false);
        declareFunction("split_list", "SPLIT-LIST", 2, 0, false);
        declareFunction("random_element", "RANDOM-ELEMENT", 1, 0, false);
        declareFunction("random_aref", "RANDOM-AREF", 1, 0, false);
        declareFunction("random_n", "RANDOM-N", 2, 0, false);
        declareFunction("random_remove_n", "RANDOM-REMOVE-N", 2, 0, false);
        declareFunction("random_delete", "RANDOM-DELETE", 1, 0, false);
        declareFunction("randomize_list", "RANDOMIZE-LIST", 1, 0, false);
        declareFunction("randomize_vector", "RANDOMIZE-VECTOR", 1, 0, false);
        declareFunction("randomize_vector_int", "RANDOMIZE-VECTOR-INT", 3, 0, false);
        declareFunction("random_compare", "RANDOM-COMPARE", 2, 0, false);
        declareFunction("thirdL", "THIRD<", 2, 0, false);
        declareFunction("gather_all", "GATHER-ALL", 2, 2, false);
        declareFunction("find_all", "FIND-ALL", 2, 2, false);
        declareFunction("find_all_if", "FIND-ALL-IF", 2, 1, false);
        declareFunction("find_all_if_not", "FIND-ALL-IF-NOT", 2, 1, false);
        declareFunction("all_positions", "ALL-POSITIONS", 2, 3, false);
        declareFunction("only_one", "ONLY-ONE", 1, 0, false);
        declareFunction("last_one", "LAST-ONE", 1, 0, false);
        declareFunction("penultimate_one", "PENULTIMATE-ONE", 1, 0, false);
        declareFunction("cons_if", "CONS-IF", 2, 0, false);
        declareFunction("list_if", "LIST-IF", 1, 0, false);
        declareFunction("adjoin_if", "ADJOIN-IF", 2, 1, false);
        declareFunction("flatten", "FLATTEN", 1, 0, false);
        declareFunction("insert_between_each", "INSERT-BETWEEN-EACH", 2, 0, false);
        declareFunction("safe_nth", "SAFE-NTH", 2, 0, false);
        declareFunction("nths", "NTHS", 2, 0, false);
        declareFunction("every_nth", "EVERY-NTH", 2, 0, false);
        declareFunction("first_n", "FIRST-N", 2, 0, false);
        declareFunction("first_n_percent", "FIRST-N-PERCENT", 2, 0, false);
        declareFunction("first_n_if", "FIRST-N-IF", 3, 1, false);
        declareFunction("first_2", "FIRST-2", 1, 0, false);
        declareFunction("first_10", "FIRST-10", 1, 0, false);
        declareFunction("last_n", "LAST-N", 2, 0, false);
        declareFunction("nth_chunk_of_k", "NTH-CHUNK-OF-K", 3, 0, false);
        declareFunction("delete_nth", "DELETE-NTH", 2, 0, false);
        declareFunction("remove_nth", "REMOVE-NTH", 2, 0, false);
        declareFunction("remove_last", "REMOVE-LAST", 1, 0, false);
        declareFunction("remove_nths", "REMOVE-NTHS", 2, 0, false);
        declareFunction("nreplace_last", "NREPLACE-LAST", 2, 0, false);
        declareFunction("nreplace_nth", "NREPLACE-NTH", 3, 0, false);
        declareFunction("find_and_replace", "FIND-AND-REPLACE", 3, 1, false);
        declareFunction("find_and_nreplace", "FIND-AND-NREPLACE", 3, 1, false);
        declareFunction("find_first_and_nreplace", "FIND-FIRST-AND-NREPLACE", 3, 1, false);
        declareFunction("ncollapse_n_from_pos", "NCOLLAPSE-N-FROM-POS", 4, 0, false);
        declareFunction("ninsert_by_position", "NINSERT-BY-POSITION", 3, 0, false);
        declareFunction("ninsert_randomly", "NINSERT-RANDOMLY", 2, 0, false);
        declareFunction("ninsert_somewhere_before_and_after", "NINSERT-SOMEWHERE-BEFORE-AND-AFTER", 3, 1, false);
        declareFunction("ninsert_somewhere_before", "NINSERT-SOMEWHERE-BEFORE", 3, 0, false);
        declareFunction("ninsert_somewhere_before_or_at", "NINSERT-SOMEWHERE-BEFORE-OR-AT", 3, 0, false);
        declareFunction("ninsert_somewhere_after", "NINSERT-SOMEWHERE-AFTER", 3, 0, false);
        declareFunction("move_nth_to_front", "MOVE-NTH-TO-FRONT", 2, 0, false);
        declareFunction("move_nth_to_position", "MOVE-NTH-TO-POSITION", 3, 0, false);
        declareFunction("nmove_to_front", "NMOVE-TO-FRONT", 2, 1, false);
        declareFunction("move_to_front", "MOVE-TO-FRONT", 2, 1, false);
        declareFunction("nmove_to_end", "NMOVE-TO-END", 2, 0, false);
        declareFunction("move_to_end", "MOVE-TO-END", 2, 0, false);
        declareFunction("replace_nth", "REPLACE-NTH", 3, 0, false);
        declareFunction("replace_last", "REPLACE-LAST", 2, 0, false);
        declareFunction("remove_duplicates_from_end", "REMOVE-DUPLICATES-FROM-END", 1, 4, false);
        declareFunction("remove_duplicates_from_start", "REMOVE-DUPLICATES-FROM-START", 1, 4, false);
        declareFunction("delete_duplicates_from_end", "DELETE-DUPLICATES-FROM-END", 1, 4, false);
        declareFunction("delete_duplicates_from_start", "DELETE-DUPLICATES-FROM-START", 1, 4, false);
        declareFunction("remove_null", "REMOVE-NULL", 1, 4, false);
        declareFunction("remove_from_end_duplicates_and_those_wXkey", "REMOVE-FROM-END-DUPLICATES-AND-THOSE-W/KEY", 2, 4, false);
        declareFunction("skipping_positions", "SKIPPING-POSITIONS", 2, 0, false);
        declareFunction("num_list", "NUM-LIST", 1, 1, false);
        declareFunction("new_num_list", "NEW-NUM-LIST", 1, 1, false);
        declareFunction("verify_num_list", "VERIFY-NUM-LIST", 3, 0, false);
        declareFunction("clear_num_list_cached", "CLEAR-NUM-LIST-CACHED", 0, 0, false);
        declareFunction("remove_num_list_cached", "REMOVE-NUM-LIST-CACHED", 2, 0, false);
        declareFunction("num_list_cached_internal", "NUM-LIST-CACHED-INTERNAL", 2, 0, false);
        declareFunction("num_list_cached", "NUM-LIST-CACHED", 2, 0, false);
        declareFunction("numlist", "NUMLIST", 1, 1, false);
        declareFunction("tree_ancestor", "TREE-ANCESTOR", 2, 1, false);
        declareFunction("member_eqP", "MEMBER-EQ?", 2, 0, false);
        declareFunction("member_kbeqP", "MEMBER-KBEQ?", 2, 0, false);
        declareFunction("member_equalP", "MEMBER-EQUAL?", 2, 0, false);
        declareFunction("has_member_equalP", "HAS-MEMBER-EQUAL?", 2, 0, false);
        declareFunction("not_has_member_equalP", "NOT-HAS-MEMBER-EQUAL?", 2, 0, false);
        declareFunction("member_equalpP", "MEMBER-EQUALP?", 2, 0, false);
        declareFunction("nmemberP", "NMEMBER?", 2, 1, false);
        declareFunction("nmember_eqP", "NMEMBER-EQ?", 2, 0, false);
        declareFunction("nmember_eqlP", "NMEMBER-EQL?", 2, 0, false);
        declareFunction("nmember_equalP", "NMEMBER-EQUAL?", 2, 0, false);
        declareFunction("nmember_equalpP", "NMEMBER-EQUALP?", 2, 0, false);
        declareFunction("nmember_funcallP", "NMEMBER-FUNCALL?", 3, 0, false);
        declareFunction("nmember_success", "NMEMBER-SUCCESS", 3, 0, false);
        declareFunction("intersectP", "INTERSECT?", 2, 2, false);
        declareFunction("intersect_sortedP", "INTERSECT-SORTED?", 2, 2, false);
        declareFunction("which_intersect_element_sorted", "WHICH-INTERSECT-ELEMENT-SORTED", 2, 2, false);
        declareFunction("sorted_subsetp", "SORTED-SUBSETP", 2, 3, false);
        declareFunction("sortedP", "SORTED?", 1, 1, false);
        declareFunction("occurs_onceP", "OCCURS-ONCE?", 2, 1, false);
        declareFunction("not_only_elementP", "NOT-ONLY-ELEMENT?", 2, 1, false);
        declareFunction("occurs_at_least_n_timesP", "OCCURS-AT-LEAST-N-TIMES?", 3, 1, false);
        declareFunction("occurs_exactly_n_timesP", "OCCURS-EXACTLY-N-TIMES?", 3, 1, false);
        declareFunction("occurs_at_most_n_timesP", "OCCURS-AT-MOST-N-TIMES?", 3, 1, false);
        declareFunction("singletonP", "SINGLETON?", 1, 0, false);
        declareFunction("doubletonP", "DOUBLETON?", 1, 0, false);
        declareFunction("tripleP", "TRIPLE?", 1, 0, false);
        declareFunction("list_of_length_p", "LIST-OF-LENGTH-P", 2, 1, false);
        declareFunction("list_of_doubletonP", "LIST-OF-DOUBLETON?", 1, 0, false);
        declareFunction("exactly_one_distinct_memberP", "EXACTLY-ONE-DISTINCT-MEMBER?", 1, 1, false);
        declareFunction("duplicatesP", "DUPLICATES?", 1, 2, false);
        declareFunction("equal_duplicatesP", "EQUAL-DUPLICATES?", 1, 1, false);
        declareFunction("duplicates", "DUPLICATES", 1, 2, false);
        declareFunction("duplicate_memberP", "DUPLICATE-MEMBER?", 2, 1, false);
        declareFunction("list_starts_with_repeating_sequenceP", "LIST-STARTS-WITH-REPEATING-SEQUENCE?", 1, 3, false);
        declareFunction("update_repeating_sequence", "UPDATE-REPEATING-SEQUENCE", 8, 0, false);
        declareFunction("multisets_equalP", "MULTISETS-EQUAL?", 2, 1, false);
        declareFunction("sets_equalP", "SETS-EQUAL?", 2, 1, false);
        declareFunction("member_via_sets_equalP", "MEMBER-VIA-SETS-EQUAL?", 2, 1, false);
        declareFunction("list_has_member_via_sets_equalP", "LIST-HAS-MEMBER-VIA-SETS-EQUAL?", 2, 1, false);
        declareFunction("sets_equalp", "SETS-EQUALP", 2, 0, false);
        declareFunction("fast_sets_equalP", "FAST-SETS-EQUAL?", 2, 1, false);
        declareFunction("fast_subsetP", "FAST-SUBSET?", 2, 1, false);
        declareFunction("fast_subset_equalP", "FAST-SUBSET-EQUAL?", 2, 0, false);
        declareFunction("fast_supersetP", "FAST-SUPERSET?", 2, 1, false);
        declareFunction("fast_superset_equalP", "FAST-SUPERSET-EQUAL?", 2, 0, false);
        declareFunction("sets_equal_equalP", "SETS-EQUAL-EQUAL?", 2, 0, false);
        declareFunction("subsetp_equalP", "SUBSETP-EQUAL?", 2, 1, false);
        declareFunction("supersetp", "SUPERSETP", 2, 2, false);
        declareFunction("set_differenceP", "SET-DIFFERENCE?", 2, 2, false);
        declareFunction("tree_set_equalP", "TREE-SET-EQUAL?", 2, 0, false);
        declareFunction("ordered_merge", "ORDERED-MERGE", 2, 2, false);
        declareFunction("ordered_union", "ORDERED-UNION", 2, 2, false);
        declareFunction("union_all", "UNION-ALL", 1, 2, false);
        declareFunction("ordered_set_difference", "ORDERED-SET-DIFFERENCE", 2, 2, false);
        declareFunction("hash_set_difference", "HASH-SET-DIFFERENCE", 2, 1, false);
        declareFunction("fast_set_difference", "FAST-SET-DIFFERENCE", 2, 1, false);
        declareFunction("partial_order_sort", "PARTIAL-ORDER-SORT", 2, 1, false);
        declareFunction("list2vector", "LIST2VECTOR", 1, 0, false);
        declareFunction("vector2list", "VECTOR2LIST", 1, 0, false);
        declareFunction("vector2list_reversible", "VECTOR2LIST-REVERSIBLE", 1, 1, false);
        declareFunction("listified_vector2vector", "LISTIFIED-VECTOR2VECTOR", 1, 1, false);
        declareFunction("list_without_repetition_p", "LIST-WITHOUT-REPETITION-P", 1, 2, false);
        declareFunction("sequence_elements", "SEQUENCE-ELEMENTS", 2, 0, false);
        declareFunction("set_difference_forts", "SET-DIFFERENCE-FORTS", 2, 0, false);
        declareFunction("ordered_intersection", "ORDERED-INTERSECTION", 2, 2, false);
        declareFunction("intersect_all", "INTERSECT-ALL", 1, 2, false);
        declareFunction("fast_intersect_all", "FAST-INTERSECT-ALL", 1, 2, false);
        declareFunction("safe_pairlis", "SAFE-PAIRLIS", 2, 0, false);
        declareFunction("flip_alist", "FLIP-ALIST", 1, 0, false);
        declareFunction("flip_cons", "FLIP-CONS", 1, 0, false);
        new list_utilities.$flip_cons$UnaryFunction();
        declareFunction("flip_doubleton", "FLIP-DOUBLETON", 1, 0, false);
        declareFunction("substitute_sequence", "SUBSTITUTE-SEQUENCE", 3, 0, false);
        declareFunction("substitute_sequence_1", "SUBSTITUTE-SEQUENCE-1", 4, 0, false);
        declareFunction("compare_lists", "COMPARE-LISTS", 2, 2, false);
        declareFunction("unique_difference_among_lists", "UNIQUE-DIFFERENCE-AMONG-LISTS", 1, 0, false);
        declareFunction("unique_difference_between_lists", "UNIQUE-DIFFERENCE-BETWEEN-LISTS", 2, 0, false);
        declareFunction("list_subst", "LIST-SUBST", 3, 1, false);
        declareFunction("list_subst_all_in_tree", "LIST-SUBST-ALL-IN-TREE", 3, 1, false);
        declareFunction("subseq_subst", "SUBSEQ-SUBST", 3, 1, false);
        declareFunction("self_evaluating_form_p", "SELF-EVALUATING-FORM-P", 1, 0, false);
        declareFunction("quote_form_p", "QUOTE-FORM-P", 1, 0, false);
        declareFunction("non_side_effecting_form_p", "NON-SIDE-EFFECTING-FORM-P", 1, 0, false);
        declareFunction("quotify", "QUOTIFY", 1, 0, false);
        new list_utilities.$quotify$UnaryFunction();
        declareFunction("unquotify", "UNQUOTIFY", 1, 0, false);
        declareFunction("sort_adjoin", "SORT-ADJOIN", 2, 3, false);
        declareFunction("sorted_add_to_list", "SORTED-ADD-TO-LIST", 3, 1, false);
        declareFunction("splice_into_sorted_list", "SPLICE-INTO-SORTED-LIST", 3, 1, false);
        declareFunction("safe_splice_into_sorted_list", "SAFE-SPLICE-INTO-SORTED-LIST", 3, 1, false);
        declareFunction("element_precedes_specified_othersP", "ELEMENT-PRECEDES-SPECIFIED-OTHERS?", 3, 2, false);
        declareFunction("function_arglist_max_args", "FUNCTION-ARGLIST-MAX-ARGS", 1, 0, false);
        declareFunction("function_arglist_min_args", "FUNCTION-ARGLIST-MIN-ARGS", 1, 0, false);
        declareFunction("remove_self_binds", "REMOVE-SELF-BINDS", 1, 1, false);
        declareFunction("self_bindP", "SELF-BIND?", 1, 1, false);
        declareFunction("bind_for_var", "BIND-FOR-VAR", 2, 2, false);
        declareFunction("remove_bind", "REMOVE-BIND", 2, 2, false);
        declareFunction("extract_bindings", "EXTRACT-BINDINGS", 2, 0, false);
        declareFunction("car_is_el_varP", "CAR-IS-EL-VAR?", 1, 0, false);
        declareFunction("extract_binding_strings", "EXTRACT-BINDING-STRINGS", 2, 0, false);
        declareFunction("tree_funcall_if", "TREE-FUNCALL-IF", 3, 1, false);
        declareFunction("tree_find_all_if", "TREE-FIND-ALL-IF", 2, 1, false);
        declareFunction("tree_remove_all_if", "TREE-REMOVE-ALL-IF", 2, 1, false);
        declareFunction("nswap_tree", "NSWAP-TREE", 3, 2, false);
        declareFunction("swap_tree", "SWAP-TREE", 3, 2, false);
        declareFunction("tree_find_all_nested_if", "TREE-FIND-ALL-NESTED-IF", 2, 1, false);
        declareFunction("tree_find_all_nested_if_int", "TREE-FIND-ALL-NESTED-IF-INT", 3, 0, false);
        declareFunction("hash_delete_duplicates", "HASH-DELETE-DUPLICATES", 1, 4, false);
        declareFunction("hash_delete_duplicates_int", "HASH-DELETE-DUPLICATES-INT", 5, 0, false);
        declareFunction("hash_remove_duplicates", "HASH-REMOVE-DUPLICATES", 1, 4, false);
        declareFunction("fast_delete_duplicates_hashtable", "FAST-DELETE-DUPLICATES-HASHTABLE", 1, 0, false);
        declareFunction("fast_delete_duplicates", "FAST-DELETE-DUPLICATES", 1, 5, false);
        declareFunction("fast_remove_duplicates", "FAST-REMOVE-DUPLICATES", 1, 5, false);
        declareFunction("fast_remove_duplicates_preserving_first", "FAST-REMOVE-DUPLICATES-PRESERVING-FIRST", 1, 2, false);
        declareFunction("remove_duplicates_preserving_order", "REMOVE-DUPLICATES-PRESERVING-ORDER", 1, 2, false);
        declareFunction("remove_duplicate_forts", "REMOVE-DUPLICATE-FORTS", 1, 0, false);
        declareFunction("delete_duplicate_forts", "DELETE-DUPLICATE-FORTS", 1, 0, false);
        declareFunction("hash_unique_elements", "HASH-UNIQUE-ELEMENTS", 2, 0, false);
        declareFunction("unique_elements", "UNIQUE-ELEMENTS", 1, 1, false);
        declareFunction("remove_all_n_icates", "REMOVE-ALL-N-ICATES", 2, 1, false);
        declareFunction("nsort_intersection", "NSORT-INTERSECTION", 2, 2, false);
        declareFunction("intersect_sorted_all", "INTERSECT-SORTED-ALL", 1, 2, false);
        declareFunction("intersect_sorted", "INTERSECT-SORTED", 2, 2, false);
        declareFunction("nintersect_sorted", "NINTERSECT-SORTED", 2, 2, false);
        declareFunction("nintersect_sorted_destroy_first_only", "NINTERSECT-SORTED-DESTROY-FIRST-ONLY", 2, 2, false);
        declareFunction("nintersect_sorted_int", "NINTERSECT-SORTED-INT", 4, 0, false);
        declareFunction("sort_intersection", "SORT-INTERSECTION", 2, 2, false);
        declareFunction("union_sorted", "UNION-SORTED", 2, 2, false);
        declareFunction("nunion_sorted", "NUNION-SORTED", 2, 2, false);
        declareFunction("union_sorted_int", "UNION-SORTED-INT", 5, 0, false);
        declareFunction("union_of_intersecting_sorted_lists", "UNION-OF-INTERSECTING-SORTED-LISTS", 1, 2, false);
        declareFunction("union_of_intersecting_sorted_lists_recursive", "UNION-OF-INTERSECTING-SORTED-LISTS-RECURSIVE", 4, 0, false);
        declareFunction("delete_duplicates_sorted", "DELETE-DUPLICATES-SORTED", 1, 1, false);
        declareFunction("remove_duplicates_sorted", "REMOVE-DUPLICATES-SORTED", 1, 1, false);
        declareFunction("position_wrt", "POSITION-WRT", 3, 3, false);
        declareFunction("difference_sorted", "DIFFERENCE-SORTED", 2, 2, false);
        declareFunction("alist_p", "ALIST-P", 1, 0, false);
        declareFunction("alist_lookup", "ALIST-LOOKUP", 2, 2, false);
        declareFunction("alist_lookup_without_values", "ALIST-LOOKUP-WITHOUT-VALUES", 2, 2, false);
        declareFunction("alist_nlookup_without_values", "ALIST-NLOOKUP-WITHOUT-VALUES", 2, 2, false);
        declareFunction("alist_nlookup_eq", "ALIST-NLOOKUP-EQ", 2, 1, false);
        declareFunction("alist_nlookup_eql", "ALIST-NLOOKUP-EQL", 2, 1, false);
        declareFunction("alist_nlookup_equal", "ALIST-NLOOKUP-EQUAL", 2, 1, false);
        declareFunction("alist_nlookup_equalp", "ALIST-NLOOKUP-EQUALP", 2, 1, false);
        declareFunction("alist_nlookup_funcall", "ALIST-NLOOKUP-FUNCALL", 3, 1, false);
        declareFunction("alist_nlookup_success", "ALIST-NLOOKUP-SUCCESS", 4, 0, false);
        declareFunction("alist_has_keyP", "ALIST-HAS-KEY?", 2, 1, false);
        declareFunction("alist_has_valueP", "ALIST-HAS-VALUE?", 2, 1, false);
        declareFunction("alist_reverse_lookup", "ALIST-REVERSE-LOOKUP", 2, 2, false);
        declareFunction("alist_reverse_lookup_without_values", "ALIST-REVERSE-LOOKUP-WITHOUT-VALUES", 2, 2, false);
        declareFunction("alist_enter", "ALIST-ENTER", 3, 1, false);
        declareFunction("alist_enter_without_values", "ALIST-ENTER-WITHOUT-VALUES", 3, 1, false);
        declareFunction("alist_capacity_enter_without_values", "ALIST-CAPACITY-ENTER-WITHOUT-VALUES", 4, 1, false);
        declareFunction("alist_promote", "ALIST-PROMOTE", 2, 1, false);
        declareFunction("alist_delete", "ALIST-DELETE", 2, 1, false);
        declareFunction("alist_delete_without_values", "ALIST-DELETE-WITHOUT-VALUES", 2, 1, false);
        declareFunction("alist_remove", "ALIST-REMOVE", 2, 1, false);
        declareFunction("alist_remove_without_values", "ALIST-REMOVE-WITHOUT-VALUES", 2, 1, false);
        declareFunction("alist_push", "ALIST-PUSH", 3, 1, false);
        declareFunction("alist_pushnew", "ALIST-PUSHNEW", 3, 2, false);
        declareFunction("alist_remove_from_value", "ALIST-REMOVE-FROM-VALUE", 3, 2, false);
        declareMacro("pushnew_onto_alist", "PUSHNEW-ONTO-ALIST");
        declareMacro("push_onto_alist", "PUSH-ONTO-ALIST");
        declareMacro("enter_into_alist", "ENTER-INTO-ALIST");
        declareFunction("alist_keys", "ALIST-KEYS", 1, 0, false);
        declareFunction("alist_values", "ALIST-VALUES", 1, 0, false);
        declareFunction("alist_optimize", "ALIST-OPTIMIZE", 2, 0, false);
        declareFunction("alist_E", "ALIST-=", 2, 2, false);
        declareFunction("alist_subsumesP", "ALIST-SUBSUMES?", 2, 2, false);
        declareFunction("alist_to_hash_table", "ALIST-TO-HASH-TABLE", 1, 1, false);
        declareFunction("alist_to_reverse_hash_table", "ALIST-TO-REVERSE-HASH-TABLE", 1, 1, false);
        declareFunction("sort_alist_by_keys", "SORT-ALIST-BY-KEYS", 2, 0, false);
        declareFunction("sort_alist_by_values", "SORT-ALIST-BY-VALUES", 2, 0, false);
        declareFunction("cons_to_tuple", "CONS-TO-TUPLE", 1, 0, false);
        declareFunction("tuple_to_cons", "TUPLE-TO-CONS", 1, 0, false);
        declareFunction("alist_to_tuples", "ALIST-TO-TUPLES", 1, 0, false);
        declareFunction("property_list_p", "PROPERTY-LIST-P", 1, 0, false);
        declareFunction("non_empty_property_list_p", "NON-EMPTY-PROPERTY-LIST-P", 1, 0, false);
        declareFunction("filter_plist", "FILTER-PLIST", 2, 0, false);
        declareFunction("prune_plist", "PRUNE-PLIST", 1, 1, false);
        declareFunction("plist_of_type_p", "PLIST-OF-TYPE-P", 2, 0, false);
        declareFunction("plist_of_value_type_p", "PLIST-OF-VALUE-TYPE-P", 2, 0, false);
        declareFunction("make_plist", "MAKE-PLIST", 2, 0, false);
        declareMacro("plist_enter", "PLIST-ENTER");
        declareFunction("plist_lookup", "PLIST-LOOKUP", 2, 1, false);
        declareMacro("plist_increment", "PLIST-INCREMENT");
        declareMacro("plist_push", "PLIST-PUSH");
        declareMacro("plist_remove", "PLIST-REMOVE");
        declareFunction("alist_to_plist", "ALIST-TO-PLIST", 1, 0, false);
        declareFunction("plist_to_alist", "PLIST-TO-ALIST", 1, 0, false);
        declareFunction("nmerge_plist", "NMERGE-PLIST", 2, 0, false);
        declareFunction("merge_plist", "MERGE-PLIST", 2, 0, false);
        declareFunction("sort_plist_by_properties", "SORT-PLIST-BY-PROPERTIES", 2, 0, false);
        declareFunction("sort_plist_by_values", "SORT-PLIST-BY-VALUES", 2, 0, false);
        declareFunction("sort_plist_via_position", "SORT-PLIST-VIA-POSITION", 2, 1, false);
        declareFunction("indicator_presentP", "INDICATOR-PRESENT?", 2, 0, false);
        declareFunction("plist_has_keyP", "PLIST-HAS-KEY?", 2, 0, false);
        declareFunction("plist_has_keysP", "PLIST-HAS-KEYS?", 2, 0, false);
        declareFunction("member_plist_key_p", "MEMBER-PLIST-KEY-P", 2, 0, false);
        declareFunction("non_nil_plist_valueP", "NON-NIL-PLIST-VALUE?", 2, 0, false);
        declareFunction("get_property_with_defaults", "GET-PROPERTY-WITH-DEFAULTS", 3, 1, false);
        declareFunction("augment_plist_with_defaults", "AUGMENT-PLIST-WITH-DEFAULTS", 2, 0, false);
        declareFunction("plist_restricted_to_indicatorsP", "PLIST-RESTRICTED-TO-INDICATORS?", 2, 0, false);
        declareFunction("maybe_putf", "MAYBE-PUTF", 3, 0, false);
        declareFunction("plist_properties", "PLIST-PROPERTIES", 1, 0, false);
        declareFunction("plist_keys", "PLIST-KEYS", 1, 0, false);
        declareFunction("plist_values", "PLIST-VALUES", 1, 0, false);
        declareFunction("plist_restricted_to_indicators", "PLIST-RESTRICTED-TO-INDICATORS", 2, 0, false);
        declareFunction("plist_except", "PLIST-EXCEPT", 2, 0, false);
        declareFunction("plistlist_if_getf", "PLISTLIST-IF-GETF", 3, 1, false);
        declareFunction("plistlist_sort", "PLISTLIST-SORT", 3, 0, false);
        declareFunction("plistlist_sort_key", "PLISTLIST-SORT-KEY", 1, 0, false);
        declareFunction("sub_plistP", "SUB-PLIST?", 2, 1, false);
        declareFunction("slow_plists_equalP", "SLOW-PLISTS-EQUAL?", 2, 1, false);
        declareFunction("format_item_list", "FORMAT-ITEM-LIST", 1, 0, false);
        declareFunction("print_plist_readably", "PRINT-PLIST-READABLY", 1, 1, false);
        declareFunction("pretty_print_plist", "PRETTY-PRINT-PLIST", 1, 1, false);
        declareFunction("pretty_prin1_plist", "PRETTY-PRIN1-PLIST", 1, 1, false);
        declareFunction("pretty_print_alist", "PRETTY-PRINT-ALIST", 1, 1, false);
        declareFunction("print_list_of_lists_as_table", "PRINT-LIST-OF-LISTS-AS-TABLE", 1, 1, false);
        declareFunction("print_list_as_delimited_line", "PRINT-LIST-AS-DELIMITED-LINE", 1, 2, false);
        declareFunction("any_in_list", "ANY-IN-LIST", 2, 1, false);
        declareFunction("every_in_list", "EVERY-IN-LIST", 2, 1, false);
        declareFunction("not_any_in_list", "NOT-ANY-IN-LIST", 2, 1, false);
        declareFunction("not_every_in_list", "NOT-EVERY-IN-LIST", 2, 1, false);
        declareFunction("plist_difference", "PLIST-DIFFERENCE", 2, 1, false);
        declareFunction("list_subseq_subst_combos", "LIST-SUBSEQ-SUBST-COMBOS", 2, 0, false);
        declareFunction("list_subseq_subst_combos_internal", "LIST-SUBSEQ-SUBST-COMBOS-INTERNAL", 3, 0, false);
        declareFunction("greedy_list_subseq_subst", "GREEDY-LIST-SUBSEQ-SUBST", 2, 0, false);
        declareFunction("greedy_list_subseq_subst_internal", "GREEDY-LIST-SUBSEQ-SUBST-INTERNAL", 3, 0, false);
        declareFunction("extremal", "EXTREMAL", 2, 1, false);
        declareFunction("extremals", "EXTREMALS", 2, 1, false);
        declareFunction("nth_rank_items", "NTH-RANK-ITEMS", 2, 2, false);
        declareFunction("rerank", "RERANK", 2, 3, false);
        declareFunction("powerset", "POWERSET", 1, 0, false);
        declareFunction("subsets_of_size", "SUBSETS-OF-SIZE", 2, 0, false);
        declareFunction("subsets_of_size_int", "SUBSETS-OF-SIZE-INT", 2, 0, false);
        declareFunction("position_L", "POSITION-<", 3, 2, false);
        declareFunction("sort_via_position", "SORT-VIA-POSITION", 2, 2, false);
        declareFunction("stable_sort_via_position", "STABLE-SORT-VIA-POSITION", 2, 2, false);
        declareFunction("sort_via_position_earlier", "SORT-VIA-POSITION-EARLIER", 2, 0, false);
        new list_utilities.$sort_via_position_earlier$BinaryFunction();
        declareFunction("sort_via_test", "SORT-VIA-TEST", 2, 1, false);
        declareFunction("stable_sort_via_test", "STABLE-SORT-VIA-TEST", 2, 1, false);
        declareFunction("sort_via_test_earlier", "SORT-VIA-TEST-EARLIER", 2, 0, false);
        declareFunction("sort_L", "SORT-<", 1, 1, false);
        declareFunction("sort_G", "SORT->", 1, 1, false);
        declareFunction("safe_sort_L", "SAFE-SORT-<", 1, 1, false);
        declareFunction("safe_sort_G", "SAFE-SORT->", 1, 1, false);
        declareFunction("sets_of_sets_L", "SETS-OF-SETS-<", 2, 1, false);
        declareFunction("sets_L", "SETS-<", 2, 1, false);
        declareFunction("set_L", "SET-<", 2, 1, false);
        declareFunction("list_structure", "LIST-STRUCTURE", 1, 1, false);
        declareFunction("list_structure_min", "LIST-STRUCTURE-MIN", 1, 0, false);
        declareFunction("list_structure_L", "LIST-STRUCTURE-<", 2, 0, false);
        declareFunction("tree_min", "TREE-MIN", 1, 0, false);
        declareFunction("safe_tree_L", "SAFE-TREE-<", 2, 0, false);
        declareFunction("safe_L", "SAFE-<", 2, 0, false);
        declareFunction("safe_G", "SAFE->", 2, 0, false);
        declareFunction("safe_GE", "SAFE->=", 2, 0, false);
        declareFunction("safe_LE", "SAFE-<=", 2, 0, false);
        declareFunction("safe_max", "SAFE-MAX", 1, 1, false);
        declareFunction("safe_difference", "SAFE-DIFFERENCE", 2, 0, false);
        declareFunction("safe_quotient", "SAFE-QUOTIENT", 2, 0, false);
        declareFunction("safe_product", "SAFE-PRODUCT", 2, 0, false);
        declareFunction("safe_sum", "SAFE-SUM", 2, 0, false);
        declareFunction("safe_E", "SAFE-=", 2, 0, false);
        declareFunction("absL", "ABS<", 2, 0, false);
        declareFunction("absG", "ABS>", 2, 0, false);
        declareFunction("equalE", "EQUAL=", 2, 0, false);
        declareFunction("tree_L", "TREE-<", 2, 2, false);
        declareFunction("tree_lt_intP", "TREE-LT-INT?", 4, 0, false);
        declareFunction("parametrized_median", "PARAMETRIZED-MEDIAN", 2, 0, false);
        declareFunction("shortest", "SHORTEST", 1, 0, false);
        declareFunction("longest", "LONGEST", 1, 0, false);
        declareFunction("cons_count", "CONS-COUNT", 1, 0, false);
        declareFunction("tree_delete", "TREE-DELETE", 2, 2, false);
        declareFunction("tree_map", "TREE-MAP", 2, 1, false);
        declareFunction("tree_ntransform_if", "TREE-NTRANSFORM-IF", 3, 1, false);
        declareFunction("tree_transform_if", "TREE-TRANSFORM-IF", 3, 1, false);
        declareFunction("cons_tree_find", "CONS-TREE-FIND", 2, 2, false);
        declareFunction("tree_find", "TREE-FIND", 2, 2, false);
        declareFunction("tree_find_int", "TREE-FIND-INT", 4, 0, false);
        declareFunction("tree_find_without_values_int", "TREE-FIND-WITHOUT-VALUES-INT", 4, 0, false);
        declareFunction("simple_tree_findP", "SIMPLE-TREE-FIND?", 2, 0, false);
        declareFunction("simple_tree_find", "SIMPLE-TREE-FIND", 2, 0, false);
        declareFunction("simple_tree_find_via_eqlP", "SIMPLE-TREE-FIND-VIA-EQL?", 2, 0, false);
        declareFunction("simple_tree_find_via_eql", "SIMPLE-TREE-FIND-VIA-EQL", 2, 0, false);
        declareFunction("simple_tree_find_via_equalP", "SIMPLE-TREE-FIND-VIA-EQUAL?", 2, 0, false);
        declareFunction("simple_tree_find_via_equal", "SIMPLE-TREE-FIND-VIA-EQUAL", 2, 0, false);
        declareFunction("tree_find_any", "TREE-FIND-ANY", 2, 2, false);
        declareFunction("cons_tree_find_if", "CONS-TREE-FIND-IF", 2, 1, false);
        declareFunction("tree_find_if", "TREE-FIND-IF", 2, 1, false);
        declareFunction("cons_tree_count", "CONS-TREE-COUNT", 2, 2, false);
        declareFunction("tree_count", "TREE-COUNT", 2, 2, false);
        declareFunction("tree_countG", "TREE-COUNT>", 3, 2, false);
        declareFunction("tree_countGE", "TREE-COUNT>=", 3, 2, false);
        declareFunction("tree_countL", "TREE-COUNT<", 3, 2, false);
        declareFunction("tree_countLE", "TREE-COUNT<=", 3, 2, false);
        declareFunction("tree_countE", "TREE-COUNT=", 3, 2, false);
        declareFunction("tree_count_internal", "TREE-COUNT-INTERNAL", 5, 1, false);
        declareFunction("simple_tree_count", "SIMPLE-TREE-COUNT", 2, 0, false);
        declareFunction("simple_tree_count_recursive", "SIMPLE-TREE-COUNT-RECURSIVE", 3, 0, false);
        declareFunction("cons_tree_count_if", "CONS-TREE-COUNT-IF", 2, 1, false);
        declareFunction("tree_count_if", "TREE-COUNT-IF", 2, 1, false);
        declareFunction("tree_count_if_unique", "TREE-COUNT-IF-UNIQUE", 2, 1, false);
        declareFunction("cons_tree_gather", "CONS-TREE-GATHER", 2, 3, false);
        declareFunction("tree_gather", "TREE-GATHER", 2, 3, false);
        declareFunction("tree_gather_internal", "TREE-GATHER-INTERNAL", 6, 0, false);
        declareFunction("tree_gather_ordered", "TREE-GATHER-ORDERED", 2, 2, false);
        declareFunction("tree_gather_ordered_subs", "TREE-GATHER-ORDERED-SUBS", 3, 0, false);
        declareFunction("tree_gather_ordered_no_subs", "TREE-GATHER-ORDERED-NO-SUBS", 3, 0, false);
        declareFunction("tree_substitute", "TREE-SUBSTITUTE", 3, 0, false);
        declareFunction("tree_substitute_using_dictionary", "TREE-SUBSTITUTE-USING-DICTIONARY", 2, 0, false);
        declareFunction("tree_splice", "TREE-SPLICE", 3, 0, false);
        declareFunction("tree_gather_transformations", "TREE-GATHER-TRANSFORMATIONS", 3, 2, false);
        declareFunction("remove_if_doesnt_include", "REMOVE-IF-DOESNT-INCLUDE", 2, 0, false);
        declareFunction("delete_subsumed_items", "DELETE-SUBSUMED-ITEMS", 2, 1, false);
        declareFunction("delete_subsumed_items_internal", "DELETE-SUBSUMED-ITEMS-INTERNAL", 3, 0, false);
        declareFunction("subsumedP", "SUBSUMED?", 4, 0, false);
        declareFunction("subsumesP", "SUBSUMES?", 4, 0, false);
        declareFunction("subsumesP_internal", "SUBSUMES?-INTERNAL", 4, 0, false);
        declareFunction("remove_subsumed_items", "REMOVE-SUBSUMED-ITEMS", 2, 1, false);
        declareFunction("cross_products", "CROSS-PRODUCTS", 1, 0, false);
        declareFunction("map_pairs", "MAP-PAIRS", 3, 0, false);
        declareFunction("fn_with_each", "FN-WITH-EACH", 3, 0, false);
        declareFunction("indexed_products", "INDEXED-PRODUCTS", 1, 0, false);
        declareFunction("explicate_permutations", "EXPLICATE-PERMUTATIONS", 1, 1, false);
        declareFunction("untranslate_elements_from_tagged_sets", "UNTRANSLATE-ELEMENTS-FROM-TAGGED-SETS", 2, 1, false);
        declareFunction("translate_elements_to_tagged_sets", "TRANSLATE-ELEMENTS-TO-TAGGED-SETS", 2, 0, false);
        declareFunction("permute_list", "PERMUTE-LIST", 1, 1, false);
        declareFunction("permute_list_int", "PERMUTE-LIST-INT", 1, 1, false);
        declareFunction("all_permutations", "ALL-PERMUTATIONS", 1, 0, false);
        declareFunction("nsublis_permute", "NSUBLIS-PERMUTE", 3, 0, false);
        declareFunction("sublis_permute", "SUBLIS-PERMUTE", 3, 0, false);
        declareFunction("permute", "PERMUTE", 2, 0, false);
        declareFunction("random_permutation", "RANDOM-PERMUTATION", 1, 0, false);
        declareFunction("choose_n_between", "CHOOSE-N-BETWEEN", 2, 0, false);
        declareFunction("trigram_transform", "TRIGRAM-TRANSFORM", 2, 2, false);
        declareFunction("chunk", "CHUNK", 2, 0, false);
        declareFunction("get_arglist", "GET-ARGLIST", 1, 0, false);
        declareFunction("get_documentation", "GET-DOCUMENTATION", 1, 0, false);
        declareFunction("push_on_car", "PUSH-ON-CAR", 2, 0, false);
        declareFunction("pop_and_reverse_car_and_push_on_cadr", "POP-AND-REVERSE-CAR-AND-PUSH-ON-CADR", 1, 0, false);
        declareFunction("cartesian_product", "CARTESIAN-PRODUCT", 1, 3, false);
        declareFunction("cartesian_product_cardinality", "CARTESIAN-PRODUCT-CARDINALITY", 1, 0, false);
        declareFunction("cartesian_helper", "CARTESIAN-HELPER", 3, 0, false);
        declareFunction("cartesian_helper_with_test", "CARTESIAN-HELPER-WITH-TEST", 4, 0, false);
        declareFunction("pick_two", "PICK-TWO", 1, 0, false);
        declareMacro("mapexp", "MAPEXP");
        declareFunction("recursive_member", "RECURSIVE-MEMBER", 2, 1, false);
        declareFunction("list_of_type_p", "LIST-OF-TYPE-P", 2, 0, false);
        declareFunction("non_empty_list_of_type_p", "NON-EMPTY-LIST-OF-TYPE-P", 2, 0, false);
        declareFunction("list_of_list_p", "LIST-OF-LIST-P", 1, 0, false);
        declareFunction("list_of_keyword_p", "LIST-OF-KEYWORD-P", 1, 0, false);
        declareFunction("string_list_p", "STRING-LIST-P", 1, 0, false);
        declareFunction("symbol_list_p", "SYMBOL-LIST-P", 1, 0, false);
        declareFunction("function_symbol_list_p", "FUNCTION-SYMBOL-LIST-P", 1, 0, false);
        declareFunction("form_with_operator_p", "FORM-WITH-OPERATOR-P", 2, 0, false);
        declareFunction("verify_operator", "VERIFY-OPERATOR", 2, 0, false);
        declareFunction("verify_form_with_operator", "VERIFY-FORM-WITH-OPERATOR", 2, 0, false);
        declareFunction("functor_in_expression_p", "FUNCTOR-IN-EXPRESSION-P", 2, 0, false);
        declareFunction("functor_in_body_p", "FUNCTOR-IN-BODY-P", 2, 0, false);
        declareFunction("variable_value_used_in_body_p", "VARIABLE-VALUE-USED-IN-BODY-P", 2, 0, false);
        declareFunction("variable_value_used_in_expression_p", "VARIABLE-VALUE-USED-IN-EXPRESSION-P", 2, 0, false);
        declareFunction("object_in_expression_p", "OBJECT-IN-EXPRESSION-P", 2, 0, false);
        declareFunction("parse_to_list_of_strings", "PARSE-TO-LIST-OF-STRINGS", 1, 2, false);
        declareFunction("tree_substitute_by_association", "TREE-SUBSTITUTE-BY-ASSOCIATION", 2, 3, false);
        declareFunction("safe_read_delimited_list", "SAFE-READ-DELIMITED-LIST", 1, 2, false);
        declareFunction("multi_sublis", "MULTI-SUBLIS", 2, 2, false);
        declareFunction("multi_assoc", "MULTI-ASSOC", 2, 2, false);
        declareFunction("valid_and_conformant_alist_p", "VALID-AND-CONFORMANT-ALIST-P", 1, 2, false);
        declareFunction("histogram", "HISTOGRAM", 1, 3, false);
        declareFunction("histogram_as_plist", "HISTOGRAM-AS-PLIST", 1, 3, false);
        declareFunction("pretty_print_histogram", "PRETTY-PRINT-HISTOGRAM", 1, 0, false);
        declareFunction("n_within", "N-WITHIN", 3, 0, false);
        declareFunction("middle_sublist", "MIDDLE-SUBLIST", 2, 0, false);
        declareFunction("categorize_list_elements", "CATEGORIZE-LIST-ELEMENTS", 2, 1, false);
        declareFunction("rank_tuples", "RANK-TUPLES", 1, 0, false);
        declareFunction("collate", "COLLATE", 1, 0, false);
        declareFunction("list_with_first_p", "LIST-WITH-FIRST-P", 2, 0, false);
        declareFunction("elements_incompatibleP", "ELEMENTS-INCOMPATIBLE?", 3, 0, false);
        declareFunction("element_incompatible_with_any_of", "ELEMENT-INCOMPATIBLE-WITH-ANY-OF", 3, 0, false);
        declareFunction("compute_all_compatible_sublists", "COMPUTE-ALL-COMPATIBLE-SUBLISTS", 2, 2, false);
        declareFunction("test_compute_all_compatible_sublists", "TEST-COMPUTE-ALL-COMPATIBLE-SUBLISTS", 3, 0, false);
        declareFunction("gather_nodes_and_incompatible_pairs_from_graph_txt", "GATHER-NODES-AND-INCOMPATIBLE-PAIRS-FROM-GRAPH-TXT", 1, 0, false);
        declareFunction("test_find_maximum_independent_set", "TEST-FIND-MAXIMUM-INDEPENDENT-SET", 3, 0, false);
        declareFunction("comparator_compare_internal", "COMPARATOR-COMPARE-INTERNAL", 3, 0, false);
        declareFunction("comparator_compare", "COMPARATOR-COMPARE", 3, 0, false);
        declareFunction("sort_preferred_list_to_front", "SORT-PREFERRED-LIST-TO-FRONT", 2, 1, false);
        declareFunction("sort_preferred_to_front", "SORT-PREFERRED-TO-FRONT", 2, 1, false);
        declareFunction("a_preferred_over_b", "A-PREFERRED-OVER-B", 2, 0, false);
        declareFunction("debug_comparison_method_violates_its_general_contract", "DEBUG-COMPARISON-METHOD-VIOLATES-ITS-GENERAL-CONTRACT", 2, 2, false);
        declareFunction("find_first_and_nreplace_test", "FIND-FIRST-AND-NREPLACE-TEST", 3, 1, false);
        return NIL;
    }

    public static final SubLObject init_list_utilities_file_alt() {
        defparameter("*MAGIC-HASHING-CUTOFF*", $int$80);
        defparameter("*NEGATED-TEST-FUNC*", NIL);
        defparameter("*POSITION-IF-BINARY-LAMBDA-FUNC*", NIL);
        defparameter("*POSITION-IF-BINARY-LAMBDA-ARG2*", NIL);
        deflexical("*NUM-LIST-CACHED-CACHING-STATE*", NIL);
        deflexical("*REMOVE-DUPLICATES-EQ-TABLE*", make_hash_table($int$500, symbol_function(EQ), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQL-TABLE*", make_hash_table($int$500, symbol_function(EQL), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE*", make_hash_table($int$500, symbol_function(EQUAL), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE*", make_hash_table($int$500, symbol_function(EQUALP), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQ-TABLE-LOCK*", make_lock($str_alt126$remove_duplicates_eq_table_lock));
        deflexical("*REMOVE-DUPLICATES-EQL-TABLE-LOCK*", make_lock($str_alt127$remove_duplicates_eql_table_lock));
        deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE-LOCK*", make_lock($str_alt128$remove_duplicates_equal_table_loc));
        deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE-LOCK*", make_lock($str_alt129$remove_duplicates_equalp_table_lo));
        defparameter("*PLISTLIST-SORT-INDICATOR*", NIL);
        defparameter("*SUBSEQ-SUBST-RECURSIVE-ANSWERS*", NIL);
        defparameter("*SORT-VIA-POSITION-GUIDE*", NIL);
        defparameter("*SORT-VIA-POSITION-TEST*", NIL);
        defparameter("*SORT-VIA-TEST-FUNCTION*", NIL);
        return NIL;
    }

    public static SubLObject init_list_utilities_file() {
        if (SubLFiles.USE_V1) {
            defparameter("*MAGIC-HASHING-CUTOFF*", $int$80);
            defparameter("*NEGATED-TEST-FUNC*", NIL);
            defparameter("*POSITION-IF-BINARY-LAMBDA-FUNC*", NIL);
            defparameter("*POSITION-IF-BINARY-LAMBDA-ARG2*", NIL);
            deflexical("*NUM-LIST-CACHED-CACHING-STATE*", NIL);
            defparameter("*LISTIFIED-VECTOR-MARKER*", $LISTIFIED_VECTOR);
            deflexical("*REMOVE-DUPLICATES-EQ-TABLE*", make_hash_table($int$500, symbol_function(EQ), UNPROVIDED));
            deflexical("*REMOVE-DUPLICATES-EQL-TABLE*", make_hash_table($int$500, symbol_function(EQL), UNPROVIDED));
            deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE*", make_hash_table($int$500, symbol_function(EQUAL), UNPROVIDED));
            deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE*", make_hash_table($int$500, symbol_function(EQUALP), UNPROVIDED));
            deflexical("*REMOVE-DUPLICATES-EQ-TABLE-LOCK*", make_lock($str128$remove_duplicates_eq_table_lock));
            deflexical("*REMOVE-DUPLICATES-EQL-TABLE-LOCK*", make_lock($str129$remove_duplicates_eql_table_lock));
            deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE-LOCK*", make_lock($str130$remove_duplicates_equal_table_loc));
            deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE-LOCK*", make_lock($str131$remove_duplicates_equalp_table_lo));
            defparameter("*PLISTLIST-SORT-INDICATOR*", NIL);
            defparameter("*SUBSEQ-SUBST-RECURSIVE-ANSWERS*", NIL);
            defparameter("*SORT-VIA-POSITION-GUIDE*", NIL);
            defparameter("*SORT-VIA-POSITION-TEST*", NIL);
            defparameter("*SORT-VIA-TEST-FUNCTION*", NIL);
            defparameter("*PREFERRED-TERM-SET*", NIL);
        }
        if (SubLFiles.USE_V2) {
            deflexical("*REMOVE-DUPLICATES-EQ-TABLE-LOCK*", make_lock($str_alt126$remove_duplicates_eq_table_lock));
            deflexical("*REMOVE-DUPLICATES-EQL-TABLE-LOCK*", make_lock($str_alt127$remove_duplicates_eql_table_lock));
            deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE-LOCK*", make_lock($str_alt128$remove_duplicates_equal_table_loc));
            deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE-LOCK*", make_lock($str_alt129$remove_duplicates_equalp_table_lo));
        }
        return NIL;
    }

    public static SubLObject init_list_utilities_file_Previous() {
        defparameter("*MAGIC-HASHING-CUTOFF*", $int$80);
        defparameter("*NEGATED-TEST-FUNC*", NIL);
        defparameter("*POSITION-IF-BINARY-LAMBDA-FUNC*", NIL);
        defparameter("*POSITION-IF-BINARY-LAMBDA-ARG2*", NIL);
        deflexical("*NUM-LIST-CACHED-CACHING-STATE*", NIL);
        defparameter("*LISTIFIED-VECTOR-MARKER*", $LISTIFIED_VECTOR);
        deflexical("*REMOVE-DUPLICATES-EQ-TABLE*", make_hash_table($int$500, symbol_function(EQ), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQL-TABLE*", make_hash_table($int$500, symbol_function(EQL), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE*", make_hash_table($int$500, symbol_function(EQUAL), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE*", make_hash_table($int$500, symbol_function(EQUALP), UNPROVIDED));
        deflexical("*REMOVE-DUPLICATES-EQ-TABLE-LOCK*", make_lock($str128$remove_duplicates_eq_table_lock));
        deflexical("*REMOVE-DUPLICATES-EQL-TABLE-LOCK*", make_lock($str129$remove_duplicates_eql_table_lock));
        deflexical("*REMOVE-DUPLICATES-EQUAL-TABLE-LOCK*", make_lock($str130$remove_duplicates_equal_table_loc));
        deflexical("*REMOVE-DUPLICATES-EQUALP-TABLE-LOCK*", make_lock($str131$remove_duplicates_equalp_table_lo));
        defparameter("*PLISTLIST-SORT-INDICATOR*", NIL);
        defparameter("*SUBSEQ-SUBST-RECURSIVE-ANSWERS*", NIL);
        defparameter("*SORT-VIA-POSITION-GUIDE*", NIL);
        defparameter("*SORT-VIA-POSITION-TEST*", NIL);
        defparameter("*SORT-VIA-TEST-FUNCTION*", NIL);
        defparameter("*PREFERRED-TERM-SET*", NIL);
        return NIL;
    }

    public static final SubLObject setup_list_utilities_file_alt() {
        memoization_state.note_globally_cached_function(NUM_LIST_CACHED);
        define_test_case_table_int(SAFE_SPLICE_INTO_SORTED_LIST, list(new SubLObject[]{ $TEST, symbol_function(EQUAL), $OWNER, $$$goolsbey, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt118);
        define_obsolete_register(GET_ARGLIST, $list_alt185);
        define_test_case_table_int(NINTERSECT_SORTED, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt200);
        define_test_case_table_int(REMOVE_SUBSUMED_ITEMS, list(new SubLObject[]{ $TEST, symbol_function($sym202$SETS_EQUAL_), $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt204);
        define_test_case_table_int(REMOVE_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt206);
        define_test_case_table_int(REMOVE_NESTED_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt208);
        define_test_case_table_int(POSITION_FROM_END, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt210);
        define_test_case_table_int(FIND_AND_REPLACE, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt212);
        define_test_case_table_int(FIRST_N_IF, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$bgottesm, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt215);
        define_test_case_table_int(TREE_POSITION_IF_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, $list_alt217, $KB, $TINY, $WORKING_, T }), $list_alt218);
        define_test_case_table_int(TREE_POSITION_IF_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, $list_alt217, $KB, $TINY, $WORKING_, T }), $list_alt220);
        define_test_case_table_int(ARG_POSITIONS_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt222);
        define_test_case_table_int(ARG_POSITIONS_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt222);
        define_test_case_table_int(RANK_TUPLES, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt225);
        define_test_case_table_int($sym226$NMEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt227);
        define_test_case_table_int(ALIST_NLOOKUP_WITHOUT_VALUES, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt229);
        define_test_case_table_int($sym230$EXACTLY_ONE_DISTINCT_MEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$sbrown, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt232);
        sunit_external.define_test_category($str_alt233$List_Utilities_Module_Supercatego, UNPROVIDED);
        sunit_external.define_test_category($$$Utility_Subcategory, list($str_alt233$List_Utilities_Module_Supercatego));
        sunit_external.define_test_suite($str_alt235$nadd_to_end_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
        sunit_macros.$current_module_sunit_tests$.setDynamicValue(cons(NADD_TO_END_TEST_CASE, sunit_macros.$current_module_sunit_tests$.getDynamicValue()));
        sunit_macros.define_test_case_preamble(NADD_TO_END_TEST_CASE);
        classes.subloop_new_class(NADD_TO_END_TEST_CASE, TEST_CASE, NIL, NIL, $list_alt238);
        classes.class_set_implements_slot_listeners(NADD_TO_END_TEST_CASE, NIL);
        classes.subloop_note_class_initialization_function(NADD_TO_END_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_NADD_TO_END_TEST_CASE_CLASS);
        classes.subloop_note_instance_initialization_function(NADD_TO_END_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_NADD_TO_END_TEST_CASE_INSTANCE);
        com.cyc.cycjava.cycl.list_utilities.subloop_reserved_initialize_nadd_to_end_test_case_class(NADD_TO_END_TEST_CASE);
        sunit_macros.define_test_case_postamble(NADD_TO_END_TEST_CASE, $str_alt254$list_utilities, $$$cycl, $list_alt256);
        sunit_macros.def_test_method_register(NADD_TO_END_TEST_CASE, TEST);
        sunit_external.define_test_suite($$$last1_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
        sunit_macros.$current_module_sunit_tests$.setDynamicValue(cons(LAST1_TEST_CASE, sunit_macros.$current_module_sunit_tests$.getDynamicValue()));
        sunit_macros.define_test_case_preamble(LAST1_TEST_CASE);
        classes.subloop_new_class(LAST1_TEST_CASE, TEST_CASE, NIL, NIL, $list_alt238);
        classes.class_set_implements_slot_listeners(LAST1_TEST_CASE, NIL);
        classes.subloop_note_class_initialization_function(LAST1_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LAST1_TEST_CASE_CLASS);
        classes.subloop_note_instance_initialization_function(LAST1_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LAST1_TEST_CASE_INSTANCE);
        com.cyc.cycjava.cycl.list_utilities.subloop_reserved_initialize_last1_test_case_class(LAST1_TEST_CASE);
        sunit_macros.define_test_case_postamble(LAST1_TEST_CASE, $str_alt254$list_utilities, $$$cycl, $list_alt256);
        sunit_macros.def_test_method_register(LAST1_TEST_CASE, TEST);
        sunit_macros.$current_module_sunit_tests$.setDynamicValue(cons(LIST_MACROS_TEST_CASE, sunit_macros.$current_module_sunit_tests$.getDynamicValue()));
        sunit_macros.define_test_case_preamble(LIST_MACROS_TEST_CASE);
        classes.subloop_new_class(LIST_MACROS_TEST_CASE, TEST_CASE, NIL, NIL, $list_alt263);
        classes.class_set_implements_slot_listeners(LIST_MACROS_TEST_CASE, NIL);
        classes.subloop_note_class_initialization_function(LIST_MACROS_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LIST_MACROS_TEST_CASE_CLASS);
        classes.subloop_note_instance_initialization_function(LIST_MACROS_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LIST_MACROS_TEST_CASE_INSTANCE);
        com.cyc.cycjava.cycl.list_utilities.subloop_reserved_initialize_list_macros_test_case_class(LIST_MACROS_TEST_CASE);
        sunit_macros.define_test_case_postamble(LIST_MACROS_TEST_CASE, $str_alt254$list_utilities, $$$cycl, $list_alt256);
        sunit_macros.def_test_method_register(LIST_MACROS_TEST_CASE, POPPERS_TEST);
        sunit_macros.def_test_method_register(LIST_MACROS_TEST_CASE, PUSHERS_TEST);
        return NIL;
    }

    public static SubLObject setup_list_utilities_file() {
        if (SubLFiles.USE_V1) {
            memoization_state.note_globally_cached_function(NUM_LIST_CACHED);
            define_test_case_table_int(SAFE_SPLICE_INTO_SORTED_LIST, list(new SubLObject[]{ $TEST, symbol_function(EQUAL), $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list119);
            define_obsolete_register(GET_ARGLIST, $list193);
            define_test_case_table_int(TEST_COMPUTE_ALL_COMPATIBLE_SUBLISTS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $BOTH, $WORKING_, T }), $list217);
            define_test_case_table_int(TEST_FIND_MAXIMUM_INDEPENDENT_SET, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $BOTH, $WORKING_, T }), $list225);
            memoization_state.note_memoized_function(COMPARATOR_COMPARE);
            define_test_case_table_int(NINTERSECT_SORTED, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list233);
            define_test_case_table_int(REMOVE_SUBSUMED_ITEMS, list(new SubLObject[]{ $TEST, symbol_function($sym214$SETS_EQUAL_), $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list235);
            define_test_case_table_int(REMOVE_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list237);
            define_test_case_table_int(FIND_FIRST_AND_NREPLACE_TEST, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list239);
            define_test_case_table_int(REMOVE_NESTED_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list241);
            define_test_case_table_int(POSITION_FROM_END, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list243);
            define_test_case_table_int(FIND_AND_REPLACE, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list245);
            define_test_case_table_int(FIRST_N_IF, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list247);
            define_test_case_table_int(TREE_POSITION_IF_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, $list249, $KB, $TINY, $WORKING_, T }), $list250);
            define_test_case_table_int(TREE_POSITION_IF_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, $list249, $KB, $TINY, $WORKING_, T }), $list252);
            define_test_case_table_int(ARG_POSITIONS_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list254);
            define_test_case_table_int(ARG_POSITIONS_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list254);
            define_test_case_table_int(RANK_TUPLES, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list257);
            define_test_case_table_int($sym258$NMEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list259);
            define_test_case_table_int(ALIST_NLOOKUP_WITHOUT_VALUES, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list261);
            define_test_case_table_int($sym262$EXACTLY_ONE_DISTINCT_MEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list263);
            define_test_case_table_int(SORT_PREFERRED_LIST_TO_FRONT, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $BOTH, $WORKING_, T }), $list265);
            sunit_external.define_test_category($str266$List_Utilities_Module_Supercatego, UNPROVIDED);
            sunit_external.define_test_category($$$Utility_Subcategory, list($str266$List_Utilities_Module_Supercatego));
            sunit_external.define_test_suite($str268$nadd_to_end_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
            sunit_external.define_test_suite($$$last1_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
        }
        if (SubLFiles.USE_V2) {
            define_test_case_table_int(SAFE_SPLICE_INTO_SORTED_LIST, list(new SubLObject[]{ $TEST, symbol_function(EQUAL), $OWNER, $$$goolsbey, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt118);
            define_obsolete_register(GET_ARGLIST, $list_alt185);
            define_test_case_table_int(NINTERSECT_SORTED, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt200);
            define_test_case_table_int(REMOVE_SUBSUMED_ITEMS, list(new SubLObject[]{ $TEST, symbol_function($sym202$SETS_EQUAL_), $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt204);
            define_test_case_table_int(REMOVE_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt206);
            define_test_case_table_int(REMOVE_NESTED_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt208);
            define_test_case_table_int(POSITION_FROM_END, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt210);
            define_test_case_table_int(FIND_AND_REPLACE, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt212);
            define_test_case_table_int(FIRST_N_IF, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$bgottesm, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt215);
            define_test_case_table_int(TREE_POSITION_IF_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, $list_alt217, $KB, $TINY, $WORKING_, T }), $list_alt218);
            define_test_case_table_int(TREE_POSITION_IF_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$baxter, $CLASSES, $list_alt217, $KB, $TINY, $WORKING_, T }), $list_alt220);
            define_test_case_table_int(ARG_POSITIONS_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt222);
            define_test_case_table_int(ARG_POSITIONS_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt222);
            define_test_case_table_int(RANK_TUPLES, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt225);
            define_test_case_table_int($sym226$NMEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt227);
            define_test_case_table_int(ALIST_NLOOKUP_WITHOUT_VALUES, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$pace, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt229);
            define_test_case_table_int($sym230$EXACTLY_ONE_DISTINCT_MEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, $$$sbrown, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list_alt232);
            sunit_external.define_test_category($str_alt233$List_Utilities_Module_Supercatego, UNPROVIDED);
            sunit_external.define_test_category($$$Utility_Subcategory, list($str_alt233$List_Utilities_Module_Supercatego));
            sunit_external.define_test_suite($str_alt235$nadd_to_end_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
            sunit_macros.$current_module_sunit_tests$.setDynamicValue(cons(NADD_TO_END_TEST_CASE, sunit_macros.$current_module_sunit_tests$.getDynamicValue()));
            sunit_macros.define_test_case_preamble(NADD_TO_END_TEST_CASE);
	    classes.subloop_new_class(NADD_TO_END_TEST_CASE, TEST_CASE, NIL, NIL, $list_alt238);
            classes.class_set_implements_slot_listeners(NADD_TO_END_TEST_CASE, NIL);
            classes.subloop_note_class_initialization_function(NADD_TO_END_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_NADD_TO_END_TEST_CASE_CLASS);
            classes.subloop_note_instance_initialization_function(NADD_TO_END_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_NADD_TO_END_TEST_CASE_INSTANCE);
            com.cyc.cycjava.cycl.list_utilities.subloop_reserved_initialize_nadd_to_end_test_case_class(NADD_TO_END_TEST_CASE);
            sunit_macros.define_test_case_postamble(NADD_TO_END_TEST_CASE, $str_alt254$list_utilities, $$$cycl, $list_alt256);
            sunit_macros.def_test_method_register(NADD_TO_END_TEST_CASE, TEST);
            sunit_macros.$current_module_sunit_tests$.setDynamicValue(cons(LAST1_TEST_CASE, sunit_macros.$current_module_sunit_tests$.getDynamicValue()));
            sunit_macros.define_test_case_preamble(LAST1_TEST_CASE);
            classes.subloop_new_class(LAST1_TEST_CASE, TEST_CASE, NIL, NIL, $list_alt238);
            classes.class_set_implements_slot_listeners(LAST1_TEST_CASE, NIL);
            classes.subloop_note_class_initialization_function(LAST1_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LAST1_TEST_CASE_CLASS);
            classes.subloop_note_instance_initialization_function(LAST1_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LAST1_TEST_CASE_INSTANCE);
            com.cyc.cycjava.cycl.list_utilities.subloop_reserved_initialize_last1_test_case_class(LAST1_TEST_CASE);
            sunit_macros.define_test_case_postamble(LAST1_TEST_CASE, $str_alt254$list_utilities, $$$cycl, $list_alt256);
            sunit_macros.def_test_method_register(LAST1_TEST_CASE, TEST);
            sunit_macros.$current_module_sunit_tests$.setDynamicValue(cons(LIST_MACROS_TEST_CASE, sunit_macros.$current_module_sunit_tests$.getDynamicValue()));
            sunit_macros.define_test_case_preamble(LIST_MACROS_TEST_CASE);
            classes.subloop_new_class(LIST_MACROS_TEST_CASE, TEST_CASE, NIL, NIL, $list_alt263);
            classes.class_set_implements_slot_listeners(LIST_MACROS_TEST_CASE, NIL);
            classes.subloop_note_class_initialization_function(LIST_MACROS_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LIST_MACROS_TEST_CASE_CLASS);
            classes.subloop_note_instance_initialization_function(LIST_MACROS_TEST_CASE, SUBLOOP_RESERVED_INITIALIZE_LIST_MACROS_TEST_CASE_INSTANCE);
            com.cyc.cycjava.cycl.list_utilities.subloop_reserved_initialize_list_macros_test_case_class(LIST_MACROS_TEST_CASE);
            sunit_macros.define_test_case_postamble(LIST_MACROS_TEST_CASE, $str_alt254$list_utilities, $$$cycl, $list_alt256);
            sunit_macros.def_test_method_register(LIST_MACROS_TEST_CASE, POPPERS_TEST);
            sunit_macros.def_test_method_register(LIST_MACROS_TEST_CASE, PUSHERS_TEST);
        }
        return NIL;
    }

    public static SubLObject setup_list_utilities_file_Previous() {
        memoization_state.note_globally_cached_function(NUM_LIST_CACHED);
        define_test_case_table_int(SAFE_SPLICE_INTO_SORTED_LIST, list(new SubLObject[]{ $TEST, symbol_function(EQUAL), $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list119);
        define_obsolete_register(GET_ARGLIST, $list193);
        define_test_case_table_int(TEST_COMPUTE_ALL_COMPATIBLE_SUBLISTS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $BOTH, $WORKING_, T }), $list217);
        define_test_case_table_int(TEST_FIND_MAXIMUM_INDEPENDENT_SET, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $BOTH, $WORKING_, T }), $list225);
        memoization_state.note_memoized_function(COMPARATOR_COMPARE);
        define_test_case_table_int(NINTERSECT_SORTED, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list233);
        define_test_case_table_int(REMOVE_SUBSUMED_ITEMS, list(new SubLObject[]{ $TEST, symbol_function($sym214$SETS_EQUAL_), $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list235);
        define_test_case_table_int(REMOVE_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list237);
        define_test_case_table_int(FIND_FIRST_AND_NREPLACE_TEST, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list239);
        define_test_case_table_int(REMOVE_NESTED_NTH, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list241);
        define_test_case_table_int(POSITION_FROM_END, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list243);
        define_test_case_table_int(FIND_AND_REPLACE, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list245);
        define_test_case_table_int(FIRST_N_IF, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list247);
        define_test_case_table_int(TREE_POSITION_IF_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, $list249, $KB, $TINY, $WORKING_, T }), $list250);
        define_test_case_table_int(TREE_POSITION_IF_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, $list249, $KB, $TINY, $WORKING_, T }), $list252);
        define_test_case_table_int(ARG_POSITIONS_DFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list254);
        define_test_case_table_int(ARG_POSITIONS_BFS, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list254);
        define_test_case_table_int(RANK_TUPLES, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list257);
        define_test_case_table_int($sym258$NMEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list259);
        define_test_case_table_int(ALIST_NLOOKUP_WITHOUT_VALUES, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list261);
        define_test_case_table_int($sym262$EXACTLY_ONE_DISTINCT_MEMBER_, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $TINY, $WORKING_, T }), $list263);
        define_test_case_table_int(SORT_PREFERRED_LIST_TO_FRONT, list(new SubLObject[]{ $TEST, NIL, $OWNER, NIL, $CLASSES, NIL, $KB, $BOTH, $WORKING_, T }), $list265);
        sunit_external.define_test_category($str266$List_Utilities_Module_Supercatego, UNPROVIDED);
        sunit_external.define_test_category($$$Utility_Subcategory, list($str266$List_Utilities_Module_Supercatego));
        sunit_external.define_test_suite($str268$nadd_to_end_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
        sunit_external.define_test_suite($$$last1_Testing_Suite, list($$$Utility_Subcategory), UNPROVIDED, UNPROVIDED);
        return NIL;
    }

    private static SubLObject _constant_217_initializer() {
        return list(list(list(list(ONE_INTEGER, TWO_INTEGER, makeString("II"), THREE_INTEGER, makeString("three"), makeString("III"), FOUR_INTEGER), list(list(TWO_INTEGER, makeString("II")), list(THREE_INTEGER, makeString("III")), list(makeString("three"), makeString("III"))), list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("three"), FOUR_INTEGER), list(ONE_INTEGER, TWO_INTEGER, makeString("III"), FOUR_INTEGER), list(ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("three"), FOUR_INTEGER), list(ONE_INTEGER, makeString("II"), makeString("III"), FOUR_INTEGER))), T), list(list(list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(list(TWO_INTEGER, makeString("II")), list(FOUR_INTEGER, makeString("IV")), list(makeString("four"), makeString("IV")), list(SEVEN_INTEGER, makeString("VII")), list(EIGHT_INTEGER, makeString("VIII")), list(makeString("eight"), makeString("VIII")), list(EIGHT_INTEGER, makeString("Successor(7)")), list(makeString("Successor(9)"), TEN_INTEGER)), list(new SubLObject[]{ list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, makeString("IV"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, makeString("VII"), EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("eight"), makeString("Successor(7)"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, makeString("Successor(7)"), makeString("VIII"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), TEN_INTEGER, makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }), list(new SubLObject[]{ ONE_INTEGER, makeString("II"), THREE_INTEGER, FOUR_INTEGER, makeString("four"), SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, makeString("eight"), NINE_INTEGER, makeString("nine"), makeString("Successor(9)"), makeString("IX"), ELEVEN_INTEGER, makeString("twelve") }) })), T), list(list(list(new SubLObject[]{ ZERO_INTEGER, ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, NINE_INTEGER, TEN_INTEGER, ELEVEN_INTEGER }), list(new SubLObject[]{ list(ZERO_INTEGER, ONE_INTEGER), list(ONE_INTEGER, TWO_INTEGER), list(TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER, FOUR_INTEGER), list(FOUR_INTEGER, FIVE_INTEGER), list(FIVE_INTEGER, SIX_INTEGER), list(SIX_INTEGER, ZERO_INTEGER), list(ZERO_INTEGER, SEVEN_INTEGER), list(ONE_INTEGER, EIGHT_INTEGER), list(TWO_INTEGER, EIGHT_INTEGER), list(THREE_INTEGER, NINE_INTEGER), list(FOUR_INTEGER, NINE_INTEGER), list(FIVE_INTEGER, TEN_INTEGER), list(SIX_INTEGER, TEN_INTEGER), list(SEVEN_INTEGER, EIGHT_INTEGER), list(SEVEN_INTEGER, ELEVEN_INTEGER), list(NINE_INTEGER, ELEVEN_INTEGER), list(TEN_INTEGER, ELEVEN_INTEGER) }), list(new SubLObject[]{ list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER), list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, ELEVEN_INTEGER), list(ONE_INTEGER, THREE_INTEGER, SEVEN_INTEGER, TEN_INTEGER), list(ONE_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER), list(ONE_INTEGER, THREE_INTEGER, SIX_INTEGER, ELEVEN_INTEGER), list(ONE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(ONE_INTEGER, SEVEN_INTEGER, NINE_INTEGER, TEN_INTEGER), list(ONE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(ONE_INTEGER, FOUR_INTEGER, SEVEN_INTEGER, TEN_INTEGER), list(ONE_INTEGER, FOUR_INTEGER, SIX_INTEGER, SEVEN_INTEGER), list(ONE_INTEGER, FOUR_INTEGER, SIX_INTEGER, ELEVEN_INTEGER), list(THREE_INTEGER, SIX_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER), list(SIX_INTEGER, EIGHT_INTEGER, NINE_INTEGER), list(FOUR_INTEGER, SIX_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER), list(TWO_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(TWO_INTEGER, SEVEN_INTEGER, NINE_INTEGER, TEN_INTEGER), list(TWO_INTEGER, SIX_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SEVEN_INTEGER, TEN_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER, SEVEN_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER, ELEVEN_INTEGER), list(ZERO_INTEGER, THREE_INTEGER, FIVE_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER), list(ZERO_INTEGER, THREE_INTEGER, EIGHT_INTEGER, TEN_INTEGER), list(ZERO_INTEGER, FIVE_INTEGER, EIGHT_INTEGER, NINE_INTEGER), list(ZERO_INTEGER, EIGHT_INTEGER, NINE_INTEGER, TEN_INTEGER), list(ZERO_INTEGER, FOUR_INTEGER, EIGHT_INTEGER, ELEVEN_INTEGER), list(ZERO_INTEGER, FOUR_INTEGER, EIGHT_INTEGER, TEN_INTEGER), list(ZERO_INTEGER, TWO_INTEGER, FIVE_INTEGER, NINE_INTEGER), list(ZERO_INTEGER, TWO_INTEGER, FIVE_INTEGER, ELEVEN_INTEGER), list(ZERO_INTEGER, TWO_INTEGER, NINE_INTEGER, TEN_INTEGER), list(ZERO_INTEGER, TWO_INTEGER, FOUR_INTEGER, ELEVEN_INTEGER), list(ZERO_INTEGER, TWO_INTEGER, FOUR_INTEGER, TEN_INTEGER) })), T), list(list(list(ZERO_INTEGER, ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(list(ZERO_INTEGER, ONE_INTEGER), list(ONE_INTEGER, TWO_INTEGER), list(TWO_INTEGER, ZERO_INTEGER), list(ZERO_INTEGER, THREE_INTEGER), list(ONE_INTEGER, THREE_INTEGER), list(TWO_INTEGER, THREE_INTEGER)), list(list(ONE_INTEGER), list(THREE_INTEGER), list(TWO_INTEGER), list(ZERO_INTEGER))), T), list(list(list(ZERO_INTEGER, ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(new SubLObject[]{ list(ZERO_INTEGER, THREE_INTEGER), list(ZERO_INTEGER, FOUR_INTEGER), list(ZERO_INTEGER, FIVE_INTEGER), list(ONE_INTEGER, THREE_INTEGER), list(ONE_INTEGER, FOUR_INTEGER), list(ONE_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, THREE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER), list(TWO_INTEGER, FIVE_INTEGER) }), list(list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(ZERO_INTEGER, ONE_INTEGER, TWO_INTEGER))), T), list(list(list(ZERO_INTEGER, ONE_INTEGER, TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(new SubLObject[]{ list(ZERO_INTEGER, ONE_INTEGER), list(ONE_INTEGER, TWO_INTEGER), list(TWO_INTEGER, ZERO_INTEGER), list(ZERO_INTEGER, THREE_INTEGER), list(ZERO_INTEGER, FIVE_INTEGER), list(ONE_INTEGER, THREE_INTEGER), list(ONE_INTEGER, FOUR_INTEGER), list(TWO_INTEGER, FOUR_INTEGER), list(TWO_INTEGER, FIVE_INTEGER), list(THREE_INTEGER, FOUR_INTEGER), list(FOUR_INTEGER, FIVE_INTEGER), list(FIVE_INTEGER, THREE_INTEGER) }), list(list(ONE_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER, ZERO_INTEGER))), T));
    }

    private static SubLObject _constant_233_initializer() {
        return list(new SubLObject[]{ list(list(list(ONE_INTEGER), list(ONE_INTEGER)), list(ONE_INTEGER)), list(list(NIL, list(ONE_INTEGER)), NIL), list(list(list(ONE_INTEGER), NIL), NIL), list(list(list(ONE_INTEGER), list(TWO_INTEGER)), NIL), list(list(list(ONE_INTEGER, THREE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER)), NIL), list(list(list(TWO_INTEGER, FOUR_INTEGER), list(ONE_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER), list(THREE_INTEGER, FOUR_INTEGER)), NIL), list(list(list(THREE_INTEGER, FOUR_INTEGER), list(ONE_INTEGER, TWO_INTEGER)), NIL), list(list(list(ZERO_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ZERO_INTEGER)), NIL), list(list(list(ONE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ONE_INTEGER)), list(ONE_INTEGER)), list(list(list(TWO_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(TWO_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(TWO_INTEGER)), list(TWO_INTEGER)), list(list(list(THREE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(THREE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER)), list(THREE_INTEGER)), list(list(list(FOUR_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER)), NIL), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER)), NIL), list(list(list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER), list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(ONE_INTEGER)), list(list(list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER)), list(FOUR_INTEGER)), list(list(list(TWO_INTEGER, FOUR_INTEGER, SIX_INTEGER), list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER)), list(FOUR_INTEGER)), list(list(list(FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(NINE_INTEGER)), list(list(list(ONE_INTEGER, EIGHT_INTEGER, NINE_INTEGER), list(FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER)), list(NINE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER)), NIL), list(list(list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER), list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER)), list(FOUR_INTEGER)), list(list(list(FOUR_INTEGER, FIVE_INTEGER, SIX_INTEGER), list(TWO_INTEGER, THREE_INTEGER, FOUR_INTEGER)), list(FOUR_INTEGER)), list(list(list(ZERO_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ZERO_INTEGER, NINE_INTEGER)), NIL), list(list(list(ONE_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(ONE_INTEGER, NINE_INTEGER)), list(ONE_INTEGER)), list(list(list(TWO_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(TWO_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(TWO_INTEGER, NINE_INTEGER)), list(TWO_INTEGER)), list(list(list(THREE_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(THREE_INTEGER)), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER, NINE_INTEGER)), list(THREE_INTEGER)), list(list(list(FOUR_INTEGER, NINE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), NIL), list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(FOUR_INTEGER, NINE_INTEGER)), NIL), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER)), list(THREE_INTEGER, SEVEN_INTEGER)), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, NINE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(THREE_INTEGER, SEVEN_INTEGER, NINE_INTEGER)), list(list(list(ONE_INTEGER, THREE_INTEGER, FIVE_INTEGER, SEVEN_INTEGER, makeInteger(99)), list(TWO_INTEGER, THREE_INTEGER, SIX_INTEGER, SEVEN_INTEGER, EIGHT_INTEGER, NINE_INTEGER)), list(THREE_INTEGER, SEVEN_INTEGER)) });
    }

    @Override
    public void declareFunctions() {
        declare_list_utilities_file();
    }

    @Override
    public void initializeVariables() {
        init_list_utilities_file();
    }

    @Override
    public void runTopLevelForms() {
        setup_list_utilities_file();
    }

    static {
    }

    public static final class $cadar$UnaryFunction extends UnaryFunction {
        public $cadar$UnaryFunction() {
            super(extractFunctionNamed("CADAR"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1) {
            return cadar(arg1);
        }
    }

    public static final class $dotted_list_p$UnaryFunction extends UnaryFunction {
        public $dotted_list_p$UnaryFunction() {
            super(extractFunctionNamed("DOTTED-LIST-P"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1) {
            return dotted_list_p(arg1);
        }
    }

    public static final class $negated_test_func$UnaryFunction extends UnaryFunction {
        public $negated_test_func$UnaryFunction() {
            super(extractFunctionNamed("NEGATED-TEST-FUNC"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1) {
            return negated_test_func(arg1);
        }
    }

    public static final class $flip_cons$UnaryFunction extends UnaryFunction {
        public $flip_cons$UnaryFunction() {
            super(extractFunctionNamed("FLIP-CONS"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1) {
            return flip_cons(arg1);
        }
    }

    public static final class $quotify$UnaryFunction extends UnaryFunction {
        public $quotify$UnaryFunction() {
            super(extractFunctionNamed("QUOTIFY"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1) {
            return quotify(arg1);
        }
    }

    public static final class $sort_via_position_earlier$BinaryFunction extends BinaryFunction {
        public $sort_via_position_earlier$BinaryFunction() {
            super(extractFunctionNamed("SORT-VIA-POSITION-EARLIER"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1, final SubLObject arg2) {
            return sort_via_position_earlier(arg1, arg2);
        }
    }

    static private final SubLString $str_alt1$nth_cycling__width_must_be_greate = makeString("nth-cycling: width must be greater than zero");

    static private final SubLString $str_alt2$nth_cycling__width_must_be_less_t = makeString("nth-cycling: width must be less than or equal to list length");

    static private final SubLString $str_alt3$nth_cycling__width_overruns_offse = makeString("nth-cycling: width overruns offset");

    static private final SubLList $list_alt4 = list(makeSymbol("VAR"), makeSymbol("PLACE"));

    static private final SubLList $list_alt9 = list(list(makeSymbol("VAR"), makeSymbol("PLACE")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt11 = list(makeSymbol("ITEM"), makeSymbol("PLACE"), makeSymbol("MAX-LENGTH"));

    static private final SubLList $list_alt16 = list(ONE_INTEGER);

    static private final SubLList $list_alt17 = list(list(makeSymbol("&REST"), makeSymbol("VAR-LIST-FORMS")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt18 = list(makeSymbol("VAR"), makeSymbol("LISTFORM"));

    static private final SubLList $list_alt24 = list(list(makeSymbol("NUMBER-VAR"), makeSymbol("&REST"), makeSymbol("VAR-LIST-FORMS")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt25 = list(ZERO_INTEGER);

    static private final SubLList $list_alt28 = list(list(makeSymbol("ENDVAR"), makeSymbol("&REST"), makeSymbol("VAR-LIST-FORMS")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLString $str_alt29$Malformed_csome_multiple_____S_wa = makeString("Malformed csome-multiple -- ~S was not a variable");

    static private final SubLList $list_alt32 = list(list(makeSymbol("ELEM-VAR"), makeSymbol("NUMBER-VAR"), makeSymbol("LISTFORM")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt35 = list(list(makeSymbol("VAR"), makeSymbol("LISTFORM")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt41 = list(list(makeSymbol("ELEM-VAR"), makeSymbol("NUMBER-VAR"), makeSymbol("LISTFORM"), makeSymbol("ENDVAR")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt44 = list(list(makeSymbol("VAR-LIST-FORMS"), makeSymbol("&OPTIONAL"), list(makeSymbol("SECONDARY-LISTS"), NIL)), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLString $str_alt46$_orig = makeString("-orig");

    static private final SubLString $str_alt47$_cdr = makeString("-cdr");

    static private final SubLList $list_alt49 = list(list(makeSymbol("LEAF-VAR"), makeSymbol("TREE"), makeSymbol("&KEY"), list(makeSymbol("LIST-TYPE"), list(QUOTE, makeSymbol("LISTP"))), makeSymbol("DONE")), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt50 = list(makeKeyword("LIST-TYPE"), $DONE);

    static private final SubLList $list_alt72 = list(NIL);

    static private final SubLList $list_alt77 = cons(makeSymbol("KEY"), makeSymbol("VALUE1"));

    static private final SubLString $str_alt78$The_lists_of_keys_and_data_are_of = makeString("The lists of keys and data are of unequal length.");

    static private final SubLList $list_alt80 = list(makeSymbol("THING-ONE"), makeSymbol("THING-TWO"));

    static private final SubLString $str_alt81$FIRST_OF_will_multiply_evaluate__ = makeString("FIRST-OF will multiply evaluate ~s");

    static private final SubLString $str_alt87$_s_was_not_a_singleton = makeString("~s was not a singleton");

    static private final SubLString $str_alt92$Position_is_not_valid_for_the_siz = makeString("Position is not valid for the size of list.");

    public static final SubLSymbol $kw96$_MEMOIZED_ITEM_NOT_FOUND_ = makeKeyword("&MEMOIZED-ITEM-NOT-FOUND&");

    static private final SubLString $str_alt99$Number_of_repetitions_must_be_gre = makeString("Number of repetitions must be greater than 1. Got ~S");

    static private final SubLSymbol $sym107$STRING_ = makeSymbol("STRING=");

    static private final SubLSymbol $sym108$STRING_ = makeSymbol("STRING<");

    static private final SubLString $$$goolsbey = makeString("goolsbey");

    static private final SubLList $list_alt118 = list(list(list(ONE_INTEGER, NIL, makeSymbol("<")), list(ONE_INTEGER)), list(list(ONE_INTEGER, list(TWO_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER)), list(list(TWO_INTEGER, list(ONE_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER)), list(list(ONE_INTEGER, list(TWO_INTEGER, THREE_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(TWO_INTEGER, list(ONE_INTEGER, THREE_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(THREE_INTEGER, list(ONE_INTEGER, TWO_INTEGER), makeSymbol("<")), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(makeString("xxx"), list(makeString("x"), makeString("xxxx")), makeSymbol("<"), makeSymbol("LENGTH")), list(makeString("x"), makeString("xxx"), makeString("xxxx"))));

    static private final SubLSymbol $sym119$_REST = makeSymbol("&REST");

    static private final SubLList $list_alt120 = list(makeSymbol("&OPTIONAL"), makeSymbol("&REST"));

    static private final SubLList $list_alt121 = cons(T, T);

    static private final SubLSymbol $sym122$CAR_IS_EL_VAR_ = makeSymbol("CAR-IS-EL-VAR?");

    static private final SubLString $str_alt123$_s____s = makeString("~s = ~s");

    static private final SubLString $str_alt126$remove_duplicates_eq_table_lock = makeString("remove-duplicates eq table lock");

    static private final SubLString $str_alt127$remove_duplicates_eql_table_lock = makeString("remove-duplicates eql table lock");

    static private final SubLString $str_alt128$remove_duplicates_equal_table_loc = makeString("remove-duplicates equal table lock");

    static private final SubLString $str_alt129$remove_duplicates_equalp_table_lo = makeString("remove-duplicates equalp table lock");

    static private final SubLSymbol $sym133$TERM__ = makeSymbol("TERM-<");

    static private final SubLSymbol $sym134$SAFE__ = makeSymbol("SAFE-<");

    static private final SubLList $list_alt136 = list(makeSymbol("ALIST-VAR"), makeSymbol("KEY"), makeSymbol("VALUE"), makeSymbol("&OPTIONAL"), list(makeSymbol("KEY-TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))), list(makeSymbol("VALUE-TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))));

    static private final SubLList $list_alt137 = list(makeSymbol("FUNCTION"), EQL);

    static private final SubLList $list_alt139 = list(makeSymbol("ALIST-VAR"), makeSymbol("KEY"), makeSymbol("VALUE"), makeSymbol("&OPTIONAL"), list(makeSymbol("KEY-TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))));

    static private final SubLList $list_alt141 = list(makeSymbol("ALIST-VAR"), makeSymbol("KEY"), makeSymbol("VALUE"), makeSymbol("&OPTIONAL"), list(makeSymbol("TEST"), list(QUOTE, list(makeSymbol("FUNCTION"), EQL))));

    static private final SubLList $list_alt143 = cons(makeSymbol("KEY"), makeSymbol("VALUE"));

    static private final SubLList $list_alt144 = list(makeSymbol("PLIST"), makeSymbol("INDICATOR"), makeSymbol("VALUE"));

    static private final SubLList $list_alt146 = list(makeSymbol("PLIST"), makeSymbol("KEY"), makeSymbol("&KEY"), list(makeSymbol("INCREMENT"), ONE_INTEGER));

    static private final SubLList $list_alt147 = list(makeKeyword("INCREMENT"));

    static private final SubLList $list_alt151 = list(makeSymbol("PLIST"), makeSymbol("KEY"), makeSymbol("VALUE"));

    static private final SubLString $str_alt155$_A_and__A = makeString("~A and ~A");

    static private final SubLString $str_alt157$__ = makeString(", ");

    static private final SubLString $str_alt158$__and_ = makeString(", and ");

    static private final SubLString $str_alt159$_a_____a__ = makeString("~a -> ~a~%");

    static private final SubLString $str_alt162$_a___4_2f__ = makeString("~a  ~4,2f~%");

    static private final SubLString $str_alt163$_a___a__ = makeString("~a  ~a~%");

    static private final SubLString $str_alt165$___ = makeString(" | ");

    static private final SubLList $list_alt166 = list(makeSymbol("SUBST-INDEX"), makeSymbol("SUBST-LENGTH"), makeSymbol("SUBST-ITEM"));

    static private final SubLSymbol $sym171$_ = makeSymbol(">");

    static private final SubLSymbol $sym172$SAFE__ = makeSymbol("SAFE->");

    static private final SubLSymbol $sym173$SAFE_TREE__ = makeSymbol("SAFE-TREE-<");

    static private final SubLSymbol $sym174$SET__ = makeSymbol("SET-<");

    static private final SubLSymbol $sym176$LIST_STRUCTURE__ = makeSymbol("LIST-STRUCTURE-<");

    static private final SubLSymbol $sym178$_ = makeSymbol("=");

    static private final SubLList $list_alt183 = listS(makeSymbol("ONE"), makeSymbol("TWO"), makeSymbol("THREE"), makeSymbol("REST"));

    static private final SubLList $list_alt185 = list(makeSymbol("FUNCTION-SYMBOL-ARGLIST"));

    static private final SubLList $list_alt187 = list(list(makeSymbol("RESULT"), makeSymbol("VAR"), makeSymbol("LIST")), makeSymbol("EXP"), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLString $str_alt190$Expected__S__got__S = makeString("Expected ~S, got ~S");

    static private final SubLString $str_alt191$_S_was_not_a_form_with_operator__ = makeString("~S was not a form with operator ~S");

    static private final SubLList $list_alt197 = list(new SubLObject[]{ makeSymbol("FIRST"), makeSymbol("SECOND"), makeSymbol("THIRD"), makeSymbol("FOURTH"), makeSymbol("FIFTH"), makeSymbol("SIXTH"), makeSymbol("SEVENTH"), makeSymbol("EIGHTH"), makeSymbol("NINTH"), makeSymbol("TENTH") });

    static private final SubLString $$$pace = makeString("pace");

    public static final SubLObject $list_alt200 = com.cyc.cycjava.cycl.list_utilities._constant_200_initializer();

    static private final SubLSymbol $sym202$SETS_EQUAL_ = makeSymbol("SETS-EQUAL?");

    static private final SubLString $$$baxter = makeString("baxter");

    static private final SubLList $list_alt204 = list(list(list(list(makeString("foo"), makeString("food"), makeString("bar")), makeSymbol("SUBSTRING?")), list(makeString("foo"), makeString("bar"))), list(list(list(makeString("foo"), makeString("food"), makeString("bart"), makeString("bar")), makeSymbol("SUBSTRING?")), list(makeString("foo"), makeString("bar"))), list(list(list(makeString("bar")), makeSymbol("SUBSTRING?")), list(makeString("bar"))), list(list(NIL, makeSymbol("SUBSTRING?")), NIL), list(list(list(ONE_INTEGER, ONE_INTEGER), makeSymbol("<=")), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, ONE_INTEGER), makeSymbol("<=")), list(ONE_INTEGER, ONE_INTEGER)));

    static private final SubLList $list_alt206 = list(list(list(ZERO_INTEGER, list(TWO_INTEGER, ONE_INTEGER)), list(ONE_INTEGER)), list(list(ZERO_INTEGER, list(ONE_INTEGER)), NIL));

    static private final SubLList $list_alt208 = list(list(list(list(ONE_INTEGER), list(ONE_INTEGER)), list(ONE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ZERO_INTEGER)), list(list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ONE_INTEGER, ZERO_INTEGER)), list(ONE_INTEGER, list(ONE_INTEGER), THREE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ONE_INTEGER, ONE_INTEGER)), list(ONE_INTEGER, list(TWO_INTEGER), THREE_INTEGER)), list(list(list(ONE_INTEGER, list(TWO_INTEGER, THREE_INTEGER, ONE_INTEGER), THREE_INTEGER), list(ONE_INTEGER, ONE_INTEGER)), list(ONE_INTEGER, list(TWO_INTEGER, ONE_INTEGER), THREE_INTEGER)));

    static private final SubLList $list_alt210 = list(new SubLObject[]{ list(list(CHAR_a, makeString("abc")), ZERO_INTEGER), list(list(CHAR_a, makeString("bcd")), NIL), list(list(CHAR_a, makeString("aba")), TWO_INTEGER), list(list(makeSymbol("A"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("A"))), TWO_INTEGER), list(list(makeSymbol("A"), vector(new SubLObject[]{ makeSymbol("A"), makeSymbol("B"), makeSymbol("A") })), TWO_INTEGER), list(list(CHAR_a, makeString("abA"), EQL), ZERO_INTEGER), list(list(CHAR_a, makeString("abA"), EQUALP), TWO_INTEGER), list(list(CHAR_a, makeString("abA"), EQUALP, IDENTITY, ONE_INTEGER), ONE_INTEGER), list(list(CHAR_a, makeString("abA"), EQUALP, IDENTITY, ZERO_INTEGER, ONE_INTEGER), ZERO_INTEGER) });

    static private final SubLList $list_alt212 = list(list(list(ONE_INTEGER, TWO_INTEGER, list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(TWO_INTEGER, TWO_INTEGER, THREE_INTEGER)));

    static private final SubLString $$$bgottesm = makeString("bgottesm");

    static private final SubLList $list_alt215 = list(list(list(THREE_INTEGER, makeSymbol("NUMBERP"), list(makeSymbol("A"), ONE_INTEGER, TWO_INTEGER, makeSymbol("B"), THREE_INTEGER, FOUR_INTEGER, makeSymbol("C"))), list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER)), list(list(NINE_INTEGER, makeSymbol("SYMBOLP"), list(makeSymbol("A"), ONE_INTEGER, TWO_INTEGER, makeSymbol("B"), THREE_INTEGER, FOUR_INTEGER, makeSymbol("C"))), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), list(list(TWO_INTEGER, makeSymbol("SYMBOLP"), list(list(ONE_INTEGER, TWO_INTEGER), list(makeSymbol("A"), THREE_INTEGER), list(makeSymbol("B"), makeSymbol("C")), list(makeSymbol("D"), FOUR_INTEGER), list(FIVE_INTEGER, makeSymbol("E"))), makeSymbol("FIRST")), list(list(makeSymbol("A"), THREE_INTEGER), list(makeSymbol("B"), makeSymbol("C")))));

    static private final SubLList $list_alt217 = list(makeSymbol("TREE-POSITION-TEST-CASE-TABLES"));

    static private final SubLList $list_alt218 = list(list(list(makeSymbol("PRIME-NUMBER?"), list(list(ZERO_INTEGER, ZERO_INTEGER, list(ZERO_INTEGER, SEVEN_INTEGER)), list(THREE_INTEGER))), list(ONE_INTEGER, ZERO_INTEGER)));

    static private final SubLList $list_alt220 = list(list(list(makeSymbol("PRIME-NUMBER?"), list(list(ZERO_INTEGER, ZERO_INTEGER, list(ZERO_INTEGER, SEVEN_INTEGER)), list(THREE_INTEGER))), list(ZERO_INTEGER, TWO_INTEGER, ONE_INTEGER)));

    static private final SubLList $list_alt222 = list(list(list(TWO_INTEGER, list(TWO_INTEGER), EQUAL), list(list(ZERO_INTEGER))), list(list(list(TWO_INTEGER), list(TWO_INTEGER), EQUAL), list(NIL)));

    static private final SubLList $list_alt225 = list(list(list(list(list(ONE_INTEGER, TWO_INTEGER, THREE_INTEGER), list(THREE_INTEGER, FOUR_INTEGER, FIVE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, ONE_INTEGER))), list(list(ZERO_INTEGER, ONE_INTEGER, ZERO_INTEGER, TWO_INTEGER, ONE_INTEGER, THREE_INTEGER), list(TWO_INTEGER, THREE_INTEGER, TWO_INTEGER, FOUR_INTEGER, TWO_INTEGER, FIVE_INTEGER), list(ONE_INTEGER, TWO_INTEGER, ONE_INTEGER, THREE_INTEGER, ZERO_INTEGER, ONE_INTEGER))));

    static private final SubLSymbol $sym226$NMEMBER_ = makeSymbol("NMEMBER?");

    static private final SubLList $list_alt227 = list(list(list(makeSymbol("C"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), T), list(list(makeSymbol("B"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), T), list(list(makeSymbol("A"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), T), list(list(makeSymbol("Z"), list(makeSymbol("A"), makeSymbol("B"), makeSymbol("C"))), NIL));

    static private final SubLList $list_alt229 = list(list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), THREE_INTEGER), makeSymbol("C")), list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), TWO_INTEGER), makeSymbol("B")), list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), ONE_INTEGER), makeSymbol("A")), list(list(list(cons(ONE_INTEGER, makeSymbol("A")), cons(TWO_INTEGER, makeSymbol("B")), cons(THREE_INTEGER, makeSymbol("C"))), ZERO_INTEGER), NIL));

    static private final SubLSymbol $sym230$EXACTLY_ONE_DISTINCT_MEMBER_ = makeSymbol("EXACTLY-ONE-DISTINCT-MEMBER?");

    static private final SubLString $$$sbrown = makeString("sbrown");

    static private final SubLList $list_alt232 = list(list(list(NIL), NIL), list(list(list(ONE_INTEGER)), T), list(list(list(ONE_INTEGER, ONE_INTEGER)), T), list(list(list(ONE_INTEGER, ONE_INTEGER, ONE_INTEGER)), T), list(list(list(ONE_INTEGER, ONE_INTEGER, ONE_INTEGER, TWO_INTEGER)), NIL));

    static private final SubLString $str_alt233$List_Utilities_Module_Supercatego = makeString("List Utilities Module Supercategory");

    static private final SubLString $str_alt235$nadd_to_end_Testing_Suite = makeString("nadd-to-end Testing Suite");

    private static final SubLSymbol NADD_TO_END_TEST_CASE = makeSymbol("NADD-TO-END-TEST-CASE");

    static private final SubLList $list_alt238 = list(list(makeSymbol("P-QUEUE"), makeKeyword("INSTANCE"), makeKeyword("PRIVATE")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("SETUP"), NIL, makeKeyword("PROTECTED")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("CLEANUP"), NIL, makeKeyword("PROTECTED")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("TEST"), NIL, makeKeyword("PROTECTED")));

    private static final SubLSymbol SUBLOOP_RESERVED_INITIALIZE_NADD_TO_END_TEST_CASE_CLASS = makeSymbol("SUBLOOP-RESERVED-INITIALIZE-NADD-TO-END-TEST-CASE-CLASS");

    private static final SubLSymbol SUBLOOP_RESERVED_INITIALIZE_NADD_TO_END_TEST_CASE_INSTANCE = makeSymbol("SUBLOOP-RESERVED-INITIALIZE-NADD-TO-END-TEST-CASE-INSTANCE");

    static private final SubLString $str_alt254$list_utilities = makeString("list-utilities");

    static private final SubLString $$$cycl = makeString("cycl");

    static private final SubLList $list_alt256 = list(makeString("Utility Subcategory"));

    private static final SubLSymbol LAST1_TEST_CASE = makeSymbol("LAST1-TEST-CASE");

    private static final SubLSymbol SUBLOOP_RESERVED_INITIALIZE_LAST1_TEST_CASE_CLASS = makeSymbol("SUBLOOP-RESERVED-INITIALIZE-LAST1-TEST-CASE-CLASS");

    private static final SubLSymbol SUBLOOP_RESERVED_INITIALIZE_LAST1_TEST_CASE_INSTANCE = makeSymbol("SUBLOOP-RESERVED-INITIALIZE-LAST1-TEST-CASE-INSTANCE");

    private static final SubLSymbol LIST_MACROS_TEST_CASE = makeSymbol("LIST-MACROS-TEST-CASE");

    static private final SubLList $list_alt263 = list(list(makeSymbol("P-QUEUE"), makeKeyword("INSTANCE"), makeKeyword("PRIVATE")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("SETUP"), NIL, makeKeyword("PROTECTED")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("CLEANUP"), NIL, makeKeyword("PROTECTED")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("POPPERS-TEST"), NIL, makeKeyword("PROTECTED")), list(makeSymbol("DEF-INSTANCE-METHOD"), makeSymbol("PUSHERS-TEST"), NIL, makeKeyword("PROTECTED")));

    private static final SubLSymbol SUBLOOP_RESERVED_INITIALIZE_LIST_MACROS_TEST_CASE_CLASS = makeSymbol("SUBLOOP-RESERVED-INITIALIZE-LIST-MACROS-TEST-CASE-CLASS");

    private static final SubLSymbol SUBLOOP_RESERVED_INITIALIZE_LIST_MACROS_TEST_CASE_INSTANCE = makeSymbol("SUBLOOP-RESERVED-INITIALIZE-LIST-MACROS-TEST-CASE-INSTANCE");

    private static final SubLSymbol POPPERS_TEST = makeSymbol("POPPERS-TEST");

    private static final SubLSymbol PUSHERS_TEST = makeSymbol("PUSHERS-TEST");
}

/**
 * Total time: 4417 ms
 */
