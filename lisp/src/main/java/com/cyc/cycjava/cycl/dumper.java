/**
 * Copyright (c) 1995 - 2019 Cycorp, Inc.  All rights reserved.
 */
package com.cyc.cycjava.cycl;

import static com.cyc.cycjava.cycl.access_macros.register_external_symbol;
import static com.cyc.cycjava.cycl.arguments.asserted_argument_tokens;
import static com.cyc.cycjava.cycl.assertion_manager.initialize_assertion_hl_store_cache;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_bookkeeping_binary_gaf_store;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_clear_bookkeeping_binary_gaf_store;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_dumpable_bookkeeping_index;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_load_bookkeeping_binary_gaf;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_load_bookkeeping_index;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_num_intermediate_index;
import static com.cyc.cycjava.cycl.bookkeeping_store.dumper_num_top_level_index;
import static com.cyc.cycjava.cycl.bookkeeping_store.reindex_all_bookkeeping_assertions;
import static com.cyc.cycjava.cycl.cfasl.$cfasl_common_symbols$;
import static com.cyc.cycjava.cycl.cfasl.$cfasl_input_to_static_area$;
import static com.cyc.cycjava.cycl.cfasl.$cfasl_stream_extensions_enabled$;
import static com.cyc.cycjava.cycl.cfasl.$cfasl_unread_byte$;
import static com.cyc.cycjava.cycl.cfasl.$within_cfasl_externalization$;
import static com.cyc.cycjava.cycl.cfasl.cfasl_current_common_symbols;
import static com.cyc.cycjava.cycl.cfasl.cfasl_input;
import static com.cyc.cycjava.cycl.cfasl.cfasl_opcode_peek;
import static com.cyc.cycjava.cycl.cfasl.cfasl_output;
import static com.cyc.cycjava.cycl.cfasl.cfasl_set_common_symbols;
import static com.cyc.cycjava.cycl.constant_handles.constant_count;
import static com.cyc.cycjava.cycl.constant_handles.constant_p;
import static com.cyc.cycjava.cycl.constant_handles.constant_suid;
import static com.cyc.cycjava.cycl.constant_handles.create_constant_dump_id_table;
import static com.cyc.cycjava.cycl.constant_handles.deleted_constant_id_iterator;
import static com.cyc.cycjava.cycl.constant_handles.do_constants_table;
import static com.cyc.cycjava.cycl.constant_handles.finalize_constants;
import static com.cyc.cycjava.cycl.constant_handles.has_new_constantsP;
import static com.cyc.cycjava.cycl.constant_handles.make_constant_shell;
import static com.cyc.cycjava.cycl.constant_handles.missing_constant_id_set;
import static com.cyc.cycjava.cycl.constant_handles.new_new_constants_iterator;
import static com.cyc.cycjava.cycl.constant_handles.next_constant_suid;
import static com.cyc.cycjava.cycl.constant_handles.reader_make_constant_shell;
import static com.cyc.cycjava.cycl.constant_handles.synchronize_constants_with_hl_store;
import static com.cyc.cycjava.cycl.constant_handles.valid_constantP;
import static com.cyc.cycjava.cycl.constant_index_manager.initialize_constant_index_hl_store_cache;
import static com.cyc.cycjava.cycl.control_vars.$bootstrapping_kbP$;
import static com.cyc.cycjava.cycl.control_vars.$communication_mode$;
import static com.cyc.cycjava.cycl.control_vars.$save_asked_queriesP$;
import static com.cyc.cycjava.cycl.control_vars.build_kb_loaded;
import static com.cyc.cycjava.cycl.control_vars.kb_loaded;
import static com.cyc.cycjava.cycl.control_vars.lexicon_initialized_p;
import static com.cyc.cycjava.cycl.control_vars.non_tiny_kb_loadedP;
import static com.cyc.cycjava.cycl.control_vars.set_build_kb_loaded;
import static com.cyc.cycjava.cycl.control_vars.set_kb_loaded;
import static com.cyc.cycjava.cycl.deduction_manager.initialize_deduction_hl_store_cache;
import static com.cyc.cycjava.cycl.el_utilities.literal_args;
import static com.cyc.cycjava.cycl.file_vector.close_file_vector;
import static com.cyc.cycjava.cycl.file_vector.create_file_vector;
import static com.cyc.cycjava.cycl.file_vector.file_vector_length_from_index;
import static com.cyc.cycjava.cycl.file_vector.file_vector_p;
import static com.cyc.cycjava.cycl.file_vector.get_file_vector_data_stream;
import static com.cyc.cycjava.cycl.file_vector.new_file_vector;
import static com.cyc.cycjava.cycl.file_vector.update_file_vector_index_linear;
import static com.cyc.cycjava.cycl.file_vector_utilities.create_file_vector_backed_map_from_map;
import static com.cyc.cycjava.cycl.hash_table_utilities.valid_hash_test_symbols;
import static com.cyc.cycjava.cycl.id_index.do_id_index_empty_p;
import static com.cyc.cycjava.cycl.id_index.do_id_index_id_and_object_validP;
import static com.cyc.cycjava.cycl.id_index.do_id_index_next_id;
import static com.cyc.cycjava.cycl.id_index.do_id_index_next_state;
import static com.cyc.cycjava.cycl.id_index.do_id_index_state_object;
import static com.cyc.cycjava.cycl.id_index.id_index_count;
import static com.cyc.cycjava.cycl.id_index.id_index_dense_objects;
import static com.cyc.cycjava.cycl.id_index.id_index_dense_objects_empty_p;
import static com.cyc.cycjava.cycl.id_index.id_index_lock;
import static com.cyc.cycjava.cycl.id_index.id_index_lookup;
import static com.cyc.cycjava.cycl.id_index.id_index_next_id;
import static com.cyc.cycjava.cycl.id_index.id_index_objects_empty_p;
import static com.cyc.cycjava.cycl.id_index.id_index_skip_tombstones_p;
import static com.cyc.cycjava.cycl.id_index.id_index_sparse_id_threshold;
import static com.cyc.cycjava.cycl.id_index.id_index_sparse_objects;
import static com.cyc.cycjava.cycl.id_index.id_index_sparse_objects_empty_p;
import static com.cyc.cycjava.cycl.id_index.id_index_tombstone_p;
import static com.cyc.cycjava.cycl.kb_hl_support_manager.initialize_kb_hl_support_hl_store_cache;
import static com.cyc.cycjava.cycl.kb_indexing.perform_indexing_pre_dump_cleanup;
import static com.cyc.cycjava.cycl.kb_indexing.reindex_all_assertions;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.$changed_index_entry_hints$;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.$recent_final_topn_indices$;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.$with_final_topn_index_tracking$;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.clear_term_index;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.complex_index_p;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.indexed_unrepresented_term_p;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.initialize_term_complex_index;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.new_simple_index;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.reserve_final_topn_index_for_term;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.term_index;
import static com.cyc.cycjava.cycl.kb_utilities.clear_kb_state;
import static com.cyc.cycjava.cycl.kb_utilities.clear_kb_state_int;
import static com.cyc.cycjava.cycl.kb_utilities.initialize_kb_state_hashes;
import static com.cyc.cycjava.cycl.kb_utilities.kb_statistics;
import static com.cyc.cycjava.cycl.kb_utilities.setup_kb_tables_int;
import static com.cyc.cycjava.cycl.kb_utilities.swap_out_all_pristine_kb_objects;
import static com.cyc.cycjava.cycl.misc_utilities.copyright_notice;
import static com.cyc.cycjava.cycl.misc_utilities.initialize_hl_store_cache_directory_and_shared_symbols;
import static com.cyc.cycjava.cycl.nart_index_manager.initialize_nart_index_hl_store_cache;
import static com.cyc.cycjava.cycl.operation_communication.kb_op_number;
import static com.cyc.cycjava.cycl.pph_methods.init_pph_name_string_preds;
import static com.cyc.cycjava.cycl.pph_vars.initialize_pph_vars;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$all_mts_genl_inverse_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$all_mts_genl_predicate_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$all_mts_genls_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$all_mts_isa_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$all_mts_quoted_isa_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$genl_inverse_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$genl_predicate_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$genls_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$isa_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.$quoted_isa_cache$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.initialize_all_sbhl_caching;
import static com.cyc.cycjava.cycl.sbhl.sbhl_cache.note_sbhl_caches_initialized;
import static com.cyc.cycjava.cycl.sbhl.sbhl_caching_policies.dump_active_kb_sbhl_caching_policies;
import static com.cyc.cycjava.cycl.sbhl.sbhl_caching_policies.enforce_monolithic_kb_sbhl_caching_policies;
import static com.cyc.cycjava.cycl.sbhl.sbhl_caching_policies.enforce_standard_kb_sbhl_caching_policies;
import static com.cyc.cycjava.cycl.sbhl.sbhl_graphs.initialize_sbhl_graph_caches_during_load_kb;
import static com.cyc.cycjava.cycl.sbhl.sbhl_graphs.swap_in_all_graph_links;
import static com.cyc.cycjava.cycl.sbhl.sbhl_graphs.swap_out_all_pristine_graph_links;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.$isa_arg2_naut_table$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.initialize_non_fort_isa_tables;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.make_all_sbhl_links;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.make_all_sbhl_time_links;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.make_sbhl_links_for_module;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.non_fort_instance_table;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.non_fort_isa_table;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.rebuild_non_fort_isa_tables;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.set_non_fort_instance_table;
import static com.cyc.cycjava.cycl.sbhl.sbhl_link_methods.set_non_fort_isa_table;
import static com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars.$resourced_sbhl_marking_space_limit$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars.$resourced_sbhl_marking_spaces$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars.$resourcing_sbhl_marking_spaces_p$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars.determine_resource_limit;
import static com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars.possibly_new_marking_resource;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_declarations.initialize_sbhl_modules;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_declarations.note_sbhl_modules_initialized;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_utilities.get_sbhl_graph;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.clean_sbhl_modules;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.get_sbhl_module;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.get_sbhl_module_graph;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.get_sbhl_module_link_pred;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.get_sbhl_module_list;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.get_sbhl_modules;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.sbhl_module_p;
import static com.cyc.cycjava.cycl.sbhl.sbhl_module_vars.set_sbhl_module_property;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_dates.$sbhl_time_date_graph$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_dates.$sbhl_time_date_object_inverse_links$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_dates.$sbhl_time_date_object_predicate_links$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_dates.$sbhl_time_object_date_inverse_links$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_dates.$sbhl_time_object_date_predicate_links$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_modules.cleanly_initialize_sbhl_time_modules;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_utilities.initialize_hl_endpoint_tables;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_utilities.initialize_time_kb_feature;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_vars.$sbhl_extended_universal_date_list$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_vars.$sbhl_temporal_link_disjunction_support_table$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_vars.$sbhl_temporal_link_disjunction_term_table$;
import static com.cyc.cycjava.cycl.sbhl.sbhl_time_vars.$sbhl_temporal_link_support_table$;
import static com.cyc.cycjava.cycl.somewhere_cache.dump_somewhere_cache_to_stream;
import static com.cyc.cycjava.cycl.somewhere_cache.load_somewhere_cache_from_stream;
import static com.cyc.cycjava.cycl.somewhere_cache.rebuild_somewhere_cache;
import static com.cyc.cycjava.cycl.subl_macro_promotions.$catch_error_message_target$;
import static com.cyc.cycjava.cycl.subl_macro_promotions.declare_defglobal;
import static com.cyc.cycjava.cycl.unrepresented_term_index_manager.initialize_unrepresented_term_index_hl_store_cache;
import static com.cyc.cycjava.cycl.utilities_macros.$is_noting_progressP$;
import static com.cyc.cycjava.cycl.utilities_macros.$last_percent_progress_index$;
import static com.cyc.cycjava.cycl.utilities_macros.$last_percent_progress_prediction$;
import static com.cyc.cycjava.cycl.utilities_macros.$noting_progress_start_time$;
import static com.cyc.cycjava.cycl.utilities_macros.$percent_progress_start_time$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_count$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_elapsed_seconds_for_notification$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_last_pacification_time$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_note$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_notification_count$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_pacifications_since_last_nl$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_sofar$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_start_time$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_total$;
import static com.cyc.cycjava.cycl.utilities_macros.$silent_progressP$;
import static com.cyc.cycjava.cycl.utilities_macros.$structure_resourcing_make_static$;
import static com.cyc.cycjava.cycl.utilities_macros.$suppress_all_progress_faster_than_seconds$;
import static com.cyc.cycjava.cycl.utilities_macros.$within_noting_percent_progress$;
import static com.cyc.cycjava.cycl.utilities_macros.initialize_kb_variables;
import static com.cyc.cycjava.cycl.utilities_macros.note_funcall_helper_function;
import static com.cyc.cycjava.cycl.utilities_macros.note_percent_progress;
import static com.cyc.cycjava.cycl.utilities_macros.note_progress;
import static com.cyc.cycjava.cycl.utilities_macros.noting_percent_progress_postamble;
import static com.cyc.cycjava.cycl.utilities_macros.noting_percent_progress_preamble;
import static com.cyc.cycjava.cycl.utilities_macros.noting_progress_postamble;
import static com.cyc.cycjava.cycl.utilities_macros.noting_progress_preamble;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_space;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.append;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.cons;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.listS;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.make_list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.nth;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.rplaca;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.rplacd;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.set_nth;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.bind;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.currentBinding;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.rebind;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Dynamic.sublisp_throw;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.eq;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.identity;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Eval.eval;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Functions.funcall;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntryKey;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntrySetIterator;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntryValue;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.gethash_without_values;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.iteratorHasNext;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.iteratorNextEntry;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.releaseEntrySetIterator;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Locks.release_lock;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Locks.seize_lock;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.add;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.ceiling;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.divide;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.floor;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.max;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.min;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.mod;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.multiply;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.subtract;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.PrintLow.format;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.cconcatenate;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.fill;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.length;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.nreverse;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Structures.def_csetf;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Structures.makeStructDeclNative;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Structures.register_method;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.boundp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.symbol_function;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Threads.$is_thread_performing_cleanupP$;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Threads.current_process;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Threads.sleep;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Time.get_internal_real_time;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Time.get_universal_time;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.consp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.integerp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.stringp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.sublisp_null;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.symbolp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.arg2;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.getValuesAsVector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.multiple_value_list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.resetMultipleValues;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.restoreValuesFromVector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.values;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Vectors.aref;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeBoolean;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeInteger;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeKeyword;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeString;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeSymbol;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeUninternedSymbol;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.cdestructuring_bind_error;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.destructuring_bind_must_consp;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.property_list_member;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.cadr;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.cddr;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.copy_tree;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.fourth;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.getf;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.last;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.member;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.second;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.third;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.print_high.$print_object_method_table$;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.print_high.$print_pretty$;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.print_high.prin1;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.$read_suppress$;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.bq_cons;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.read;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.read_from_string;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.close;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.file_length;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.file_position;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.force_output;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.open_stream_p;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.terpri;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.streams_high.write_char;
import static com.cyc.tool.subl.util.SubLFiles.declareFunction;
import static com.cyc.tool.subl.util.SubLFiles.declareMacro;
import static com.cyc.tool.subl.util.SubLFiles.defconstant;
import static com.cyc.tool.subl.util.SubLFiles.deflexical;
import static com.cyc.tool.subl.util.SubLFiles.defparameter;

import java.util.Iterator;
import java.util.Map;

import org.armedbear.lisp.Lisp;

import com.cyc.cycjava.cycl.cyc_testing.kb_content_test.kct_utils;
import com.cyc.cycjava.cycl.inference.open_cyc_inference_api;
import com.cyc.cycjava.cycl.inference.harness.forward;
import com.cyc.cycjava.cycl.inference.harness.inference_analysis;
import com.cyc.cycjava.cycl.rtp.rtp_datastructures;
import com.cyc.cycjava.cycl.rtp.rtp_initialize;
import com.cyc.cycjava.cycl.sbhl.sbhl_cache;
import com.cyc.cycjava.cycl.sbhl.sbhl_caching_policies;
import com.cyc.cycjava.cycl.sbhl.sbhl_graphs;
import com.cyc.cycjava.cycl.sbhl.sbhl_link_methods;
import com.cyc.cycjava.cycl.sbhl.sbhl_link_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_links;
import com.cyc.cycjava.cycl.sbhl.sbhl_macros;
import com.cyc.cycjava.cycl.sbhl.sbhl_marking_utilities;
import com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_module_declarations;
import com.cyc.cycjava.cycl.sbhl.sbhl_module_utilities;
import com.cyc.cycjava.cycl.sbhl.sbhl_module_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_paranoia;
import com.cyc.cycjava.cycl.sbhl.sbhl_search_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_time_dates;
import com.cyc.cycjava.cycl.sbhl.sbhl_time_modules;
import com.cyc.cycjava.cycl.sbhl.sbhl_time_utilities;
import com.cyc.cycjava.cycl.sbhl.sbhl_time_vars;
import com.cyc.cycjava.cycl.sksi.sksi_infrastructure.sksi_infrastructure_utilities;
import com.cyc.cycjava.cycl.thesaurus.tm_control_vars;
import com.cyc.cycjava.cycl.wordnet_import.wordnet_import;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.BinaryFunction;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Environment;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Errors;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Filesys;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Mapper;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Mapping;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sort;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Storage;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.StreamsLow;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Strings;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.SubLSpecialOperatorDeclarations;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.SubLStructDecl;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.SubLStructDeclNative;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.SubLThread;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.UnaryFunction;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLList;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObject;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLProcess;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLString;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLStructNative;
import com.cyc.tool.subl.jrtl.nativeCode.type.number.SubLInteger;
import com.cyc.tool.subl.jrtl.nativeCode.type.symbol.SubLSymbol;
import com.cyc.tool.subl.jrtl.translatedCode.sublisp.compatibility;
import com.cyc.tool.subl.jrtl.translatedCode.sublisp.stream_macros;
import com.cyc.tool.subl.jrtl.translatedCode.sublisp.time_high;
import com.cyc.tool.subl.jrtl.translatedCode.sublisp.visitation;
import com.cyc.tool.subl.util.SubLFile;
import com.cyc.tool.subl.util.SubLFiles;
import com.cyc.tool.subl.util.SubLFiles.LispMethod;
import com.cyc.tool.subl.util.SubLTrampolineFile;
import com.cyc.tool.subl.util.SubLTranslatedFile;

/**
 * Copyright (c) 1995 - 2019 Cycorp, Inc. All rights reserved. module: DUMPER
 * source file: /cyc/top/cycl/dumper.lisp created: 2019/07/03 17:37:54
 */
public class dumper extends SubLTranslatedFile implements V12 {
	public static final SubLObject report_stale_documentation_references_to_stream(SubLObject stream) {
		{
			SubLObject assertions = com.cyc.cycjava.cycl.dumper.invalid_constant_in_string_assertions();
			SubLObject total = length(assertions);
			format(stream, $str_alt289$___System__A_KB__S______A________, new SubLObject[] {
					system_info.cyc_revision_string(), kb_loaded(), numeric_date_utilities.timestring(UNPROVIDED) });
			format(stream, $str_alt290$_____S_stale_assertions_, total);
			{
				SubLObject cdolist_list_var = assertions;
				SubLObject assertion = NIL;
				for (assertion = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
						.rest(), assertion = cdolist_list_var.first()) {
					if (NIL != assertions_high.gaf_assertionP(assertion)) {
						format(stream, $str_alt291$___S_on__S_in__S,
								new SubLObject[] { assertions_high.gaf_arg0(assertion),
										assertions_high.gaf_arg1(assertion), assertions_high.assertion_mt(assertion) });
					} else {
						format(stream, $str_alt292$___S_in__S_, assertions_high.assertion_formula(assertion),
								assertions_high.assertion_mt(assertion));
					}
				}
			}
			return total;
		}
	}

	public static final SubLObject report_recent_renames_to_stream(SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cutoff_date = numeric_date_utilities
						.month_ago(numeric_date_utilities.get_universal_date(UNPROVIDED, UNPROVIDED), TWO_INTEGER);
				SubLObject old_names = NIL;
				SubLObject total = NIL;
				{
					SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
					SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
					try {
						mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
						mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
						{
							SubLObject pred_var = $$oldConstantName;
							if (NIL != kb_mapping_macros.do_predicate_extent_index_key_validator(pred_var)) {
								{
									SubLObject iterator_var = kb_mapping_macros
											.new_predicate_extent_final_index_spec_iterator(pred_var);
									SubLObject done_var = NIL;
									SubLObject token_var = NIL;
									while (NIL == done_var) {
										{
											SubLObject final_index_spec = iteration
													.iteration_next_without_values_macro_helper(iterator_var,
															token_var);
											SubLObject valid = makeBoolean(token_var != final_index_spec);
											if (NIL != valid) {
												{
													SubLObject final_index_iterator = NIL;
													try {
														final_index_iterator = kb_mapping_macros
																.new_final_index_iterator(final_index_spec, $GAF, NIL,
																		NIL);
														{
															SubLObject done_var_142 = NIL;
															SubLObject token_var_143 = NIL;
															while (NIL == done_var_142) {
																{
																	SubLObject ass = iteration
																			.iteration_next_without_values_macro_helper(
																					final_index_iterator,
																					token_var_143);
																	SubLObject valid_144 = makeBoolean(
																			token_var_143 != ass);
																	if (NIL != valid_144) {
																		{
																			SubLObject when = assertions_high
																					.asserted_when(ass);
																			if ((NIL != when)
																					&& when.numGE(cutoff_date)) {
																				old_names = cons(ass, old_names);
																			}
																		}
																	}
																	done_var_142 = makeBoolean(NIL == valid_144);
																}
															}
														}
													} finally {
														{
															SubLObject _prev_bind_0_145 = $is_thread_performing_cleanupP$
																	.currentBinding(thread);
															try {
																$is_thread_performing_cleanupP$.bind(T, thread);
																if (NIL != final_index_iterator) {
																	kb_mapping_macros.destroy_final_index_iterator(
																			final_index_iterator);
																}
															} finally {
																$is_thread_performing_cleanupP$.rebind(_prev_bind_0_145,
																		thread);
															}
														}
													}
												}
											}
											done_var = makeBoolean(NIL == valid);
										}
									}
								}
							}
						}
					} finally {
						mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
						mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
					}
				}
				old_names = Sort.sort(old_names, symbol_function(STRING_LESSP), symbol_function(GAF_ARG2));
				total = length(old_names);
				format(stream, $str_alt296$_____S_recent_renames_, total);
				{
					SubLObject cdolist_list_var = old_names;
					SubLObject old_name = NIL;
					for (old_name = cdolist_list_var
							.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
									.rest(), old_name = cdolist_list_var.first()) {
						{
							SubLObject v_term = assertions_high.gaf_arg1(old_name);
							SubLObject old_string = assertions_high.gaf_arg2(old_name);
							format(stream, $str_alt297$___S____, old_string);
							if (NIL != constant_p(v_term)) {
								format(stream, $str_alt298$_S, constants_high.constant_name(v_term));
							} else {
								format(stream, $str_alt299$NAT__S, narts_high.nart_el_formula(v_term));
							}
							{
								SubLObject whom = assertions_high.asserted_by(old_name);
								SubLObject when = assertions_high.asserted_when(old_name);
								if (NIL != whom) {
									format(stream, $str_alt300$_by__S, whom);
								}
								if (NIL != when) {
									thread.resetMultipleValues();
									{
										SubLObject day = numeric_date_utilities.decode_universal_date(when);
										SubLObject month = thread.secondMultipleValue();
										SubLObject year = thread.thirdMultipleValue();
										thread.resetMultipleValues();
										format(stream, $str_alt301$_on__D__2__0D__2__0D,
												new SubLObject[] { month, day, mod(year, $int$100) });
									}
								}
							}
						}
					}
				}
				return total;
			}
		}
	}

	public static final SubLObject preds_of_strings() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject preds = NIL;
				{
					SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
					SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
					try {
						mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
						mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
						{
							SubLObject cdolist_list_var = $list_alt285;
							SubLObject col = NIL;
							for (col = cdolist_list_var
									.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
											.rest(), col = cdolist_list_var.first()) {
								{
									SubLObject node_var = col;
									SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
									SubLObject recur_deck = deck.create_deck(deck_type);
									{
										SubLObject _prev_bind_0_115 = sbhl_marking_vars.$sbhl_space$
												.currentBinding(thread);
										try {
											sbhl_marking_vars.$sbhl_space$
													.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
											{
												SubLObject tv_var = NIL;
												{
													SubLObject _prev_bind_0_116 = sbhl_search_vars.$sbhl_tv$
															.currentBinding(thread);
													SubLObject _prev_bind_1_117 = sbhl_search_vars.$relevant_sbhl_tv_function$
															.currentBinding(thread);
													try {
														sbhl_search_vars.$sbhl_tv$
																.bind(NIL != tv_var ? ((SubLObject) (tv_var))
																		: sbhl_search_vars.get_sbhl_true_tv(), thread);
														sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var
																? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV))
																: sbhl_search_vars.$relevant_sbhl_tv_function$
																		.getDynamicValue(thread),
																thread);
														if (NIL != tv_var) {
															if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
																if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
																	{
																		SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$
																				.getDynamicValue(thread);
																		if (pcase_var.eql($ERROR)) {
																			sbhl_paranoia.sbhl_error(ONE_INTEGER,
																					$str_alt276$_A_is_not_a__A, tv_var,
																					SBHL_TRUE_TV_P, UNPROVIDED,
																					UNPROVIDED, UNPROVIDED);
																		} else {
																			if (pcase_var.eql($CERROR)) {
																				sbhl_paranoia.sbhl_cerror(ONE_INTEGER,
																						$$$continue_anyway,
																						$str_alt276$_A_is_not_a__A,
																						tv_var, SBHL_TRUE_TV_P,
																						UNPROVIDED, UNPROVIDED,
																						UNPROVIDED);
																			} else {
																				if (pcase_var.eql($WARN)) {
																					Errors.warn(
																							$str_alt276$_A_is_not_a__A,
																							tv_var, SBHL_TRUE_TV_P);
																				} else {
																					Errors.warn(
																							$str_alt281$_A_is_not_a_valid__sbhl_type_erro,
																							sbhl_paranoia.$sbhl_type_error_action$
																									.getDynamicValue(
																											thread));
																					Errors.cerror($$$continue_anyway,
																							$str_alt276$_A_is_not_a__A,
																							tv_var, SBHL_TRUE_TV_P);
																				}
																			}
																		}
																	}
																}
															}
														}
														{
															SubLObject _prev_bind_0_118 = sbhl_search_vars.$sbhl_search_module$
																	.currentBinding(thread);
															SubLObject _prev_bind_1_119 = sbhl_search_vars.$sbhl_search_module_type$
																	.currentBinding(thread);
															SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$
																	.currentBinding(thread);
															SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$
																	.currentBinding(thread);
															SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$
																	.currentBinding(thread);
															try {
																sbhl_search_vars.$sbhl_search_module$.bind(
																		sbhl_module_vars.get_sbhl_module($$genls),
																		thread);
																sbhl_search_vars.$sbhl_search_module_type$.bind(
																		sbhl_module_utilities
																				.get_sbhl_module_type(sbhl_module_vars
																						.get_sbhl_module($$genls)),
																		thread);
																sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(
																		sbhl_module_utilities
																				.get_sbhl_add_node_to_result_test(
																						sbhl_module_vars
																								.get_sbhl_module(
																										$$genls)),
																		thread);
																sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL,
																		thread);
																sbhl_module_vars.$sbhl_module$.bind(
																		sbhl_module_vars.get_sbhl_module($$genls),
																		thread);
																if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP())
																		|| (NIL != sbhl_module_utilities
																				.apply_sbhl_module_type_test(col,
																						sbhl_module_vars
																								.get_sbhl_module(
																										UNPROVIDED)))) {
																	{
																		SubLObject _prev_bind_0_120 = sbhl_search_vars.$sbhl_search_direction$
																				.currentBinding(thread);
																		SubLObject _prev_bind_1_121 = sbhl_link_vars.$sbhl_link_direction$
																				.currentBinding(thread);
																		SubLObject _prev_bind_2_122 = sbhl_search_vars.$genl_inverse_mode_p$
																				.currentBinding(thread);
																		try {
																			sbhl_search_vars.$sbhl_search_direction$
																					.bind(sbhl_search_vars
																							.get_sbhl_backward_search_direction(),
																							thread);
																			sbhl_link_vars.$sbhl_link_direction$.bind(
																					sbhl_module_utilities
																							.sbhl_search_direction_to_link_direction(
																									sbhl_search_vars
																											.get_sbhl_backward_search_direction(),
																									sbhl_module_vars
																											.get_sbhl_module(
																													$$genls)),
																					thread);
																			sbhl_search_vars.$genl_inverse_mode_p$
																					.bind(NIL, thread);
																			sbhl_marking_utilities
																					.sbhl_mark_node_marked(node_var,
																							UNPROVIDED);
																			while (NIL != node_var) {
																				{
																					SubLObject spec = node_var;
																					SubLObject cdolist_list_var_123 = com.cyc.cycjava.cycl.dumper
																							.binary_preds_with_arg_isa(
																									spec);
																					SubLObject pred = NIL;
																					for (pred = cdolist_list_var_123
																							.first(); NIL != cdolist_list_var_123; cdolist_list_var_123 = cdolist_list_var_123
																									.rest(), pred = cdolist_list_var_123
																											.first()) {
																						preds = cons(pred, preds);
																					}
																				}
																				{
																					SubLObject accessible_modules = sbhl_macros
																							.get_sbhl_accessible_modules(
																									sbhl_module_vars
																											.get_sbhl_module(
																													$$genls));
																					SubLObject cdolist_list_var_124 = accessible_modules;
																					SubLObject module_var = NIL;
																					for (module_var = cdolist_list_var_124
																							.first(); NIL != cdolist_list_var_124; cdolist_list_var_124 = cdolist_list_var_124
																									.rest(), module_var = cdolist_list_var_124
																											.first()) {
																						{
																							SubLObject _prev_bind_0_125 = sbhl_module_vars.$sbhl_module$
																									.currentBinding(
																											thread);
																							SubLObject _prev_bind_1_126 = sbhl_search_vars.$genl_inverse_mode_p$
																									.currentBinding(
																											thread);
																							try {
																								sbhl_module_vars.$sbhl_module$
																										.bind(module_var,
																												thread);
																								sbhl_search_vars.$genl_inverse_mode_p$
																										.bind(NIL != sbhl_search_vars
																												.flip_genl_inverse_modeP(
																														UNPROVIDED,
																														UNPROVIDED)
																																? ((SubLObject) (makeBoolean(
																																		NIL == sbhl_search_vars.$genl_inverse_mode_p$
																																				.getDynamicValue(
																																						thread))))
																																: sbhl_search_vars.$genl_inverse_mode_p$
																																		.getDynamicValue(
																																				thread),
																												thread);
																								{
																									SubLObject node = function_terms
																											.naut_to_nart(
																													node_var);
																									if (NIL != sbhl_link_vars
																											.sbhl_node_object_p(
																													node)) {
																										{
																											SubLObject d_link = sbhl_graphs
																													.get_sbhl_graph_link(
																															node,
																															sbhl_module_vars
																																	.get_sbhl_module(
																																			UNPROVIDED));
																											if (NIL != d_link) {
																												{
																													SubLObject mt_links = sbhl_links
																															.get_sbhl_mt_links(
																																	d_link,
																																	sbhl_link_vars
																																			.get_sbhl_link_direction(),
																																	sbhl_module_vars
																																			.get_sbhl_module(
																																					UNPROVIDED));
																													if (NIL != mt_links) {
																														{
																															SubLObject iteration_state = dictionary_contents
																																	.do_dictionary_contents_state(
																																			dictionary
																																					.dictionary_contents(
																																							mt_links));
																															while (NIL == dictionary_contents
																																	.do_dictionary_contents_doneP(
																																			iteration_state)) {
																																thread.resetMultipleValues();
																																{
																																	SubLObject mt = dictionary_contents
																																			.do_dictionary_contents_key_value(
																																					iteration_state);
																																	SubLObject tv_links = thread
																																			.secondMultipleValue();
																																	thread.resetMultipleValues();
																																	if (NIL != mt_relevance_macros
																																			.relevant_mtP(
																																					mt)) {
																																		{
																																			SubLObject _prev_bind_0_127 = sbhl_link_vars.$sbhl_link_mt$
																																					.currentBinding(
																																							thread);
																																			try {
																																				sbhl_link_vars.$sbhl_link_mt$
																																						.bind(mt,
																																								thread);
																																				{
																																					SubLObject iteration_state_128 = dictionary_contents
																																							.do_dictionary_contents_state(
																																									dictionary
																																											.dictionary_contents(
																																													tv_links));
																																					while (NIL == dictionary_contents
																																							.do_dictionary_contents_doneP(
																																									iteration_state_128)) {
																																						thread.resetMultipleValues();
																																						{
																																							SubLObject tv = dictionary_contents
																																									.do_dictionary_contents_key_value(
																																											iteration_state_128);
																																							SubLObject link_nodes = thread
																																									.secondMultipleValue();
																																							thread.resetMultipleValues();
																																							if (NIL != sbhl_search_vars
																																									.relevant_sbhl_tvP(
																																											tv)) {
																																								{
																																									SubLObject _prev_bind_0_129 = sbhl_link_vars.$sbhl_link_tv$
																																											.currentBinding(
																																													thread);
																																									try {
																																										sbhl_link_vars.$sbhl_link_tv$
																																												.bind(tv,
																																														thread);
																																										{
																																											SubLObject new_list = (NIL != sbhl_link_vars
																																													.sbhl_randomize_lists_p())
																																															? ((SubLObject) (list_utilities
																																																	.randomize_list(
																																																			link_nodes)))
																																															: link_nodes;
																																											SubLObject cdolist_list_var_130 = new_list;
																																											SubLObject node_vars_link_node = NIL;
																																											for (node_vars_link_node = cdolist_list_var_130
																																													.first(); NIL != cdolist_list_var_130; cdolist_list_var_130 = cdolist_list_var_130
																																															.rest(), node_vars_link_node = cdolist_list_var_130
																																																	.first()) {
																																												if (NIL == sbhl_marking_utilities
																																														.sbhl_search_path_termination_p(
																																																node_vars_link_node,
																																																UNPROVIDED)) {
																																													sbhl_marking_utilities
																																															.sbhl_mark_node_marked(
																																																	node_vars_link_node,
																																																	UNPROVIDED);
																																													deck.deck_push(
																																															node_vars_link_node,
																																															recur_deck);
																																												}
																																											}
																																										}
																																									} finally {
																																										sbhl_link_vars.$sbhl_link_tv$
																																												.rebind(_prev_bind_0_129,
																																														thread);
																																									}
																																								}
																																							}
																																							iteration_state_128 = dictionary_contents
																																									.do_dictionary_contents_next(
																																											iteration_state_128);
																																						}
																																					}
																																					dictionary_contents
																																							.do_dictionary_contents_finalize(
																																									iteration_state_128);
																																				}
																																			} finally {
																																				sbhl_link_vars.$sbhl_link_mt$
																																						.rebind(_prev_bind_0_127,
																																								thread);
																																			}
																																		}
																																	}
																																	iteration_state = dictionary_contents
																																			.do_dictionary_contents_next(
																																					iteration_state);
																																}
																															}
																															dictionary_contents
																																	.do_dictionary_contents_finalize(
																																			iteration_state);
																														}
																													}
																												}
																											} else {
																												sbhl_paranoia
																														.sbhl_error(
																																FIVE_INTEGER,
																																$str_alt283$attempting_to_bind_direction_link,
																																UNPROVIDED,
																																UNPROVIDED,
																																UNPROVIDED,
																																UNPROVIDED,
																																UNPROVIDED);
																											}
																										}
																									} else {
																										if (NIL != obsolete
																												.cnat_p(node,
																														UNPROVIDED)) {
																											{
																												SubLObject new_list = (NIL != sbhl_link_vars
																														.sbhl_randomize_lists_p())
																																? ((SubLObject) (list_utilities
																																		.randomize_list(
																																				sbhl_module_utilities
																																						.get_sbhl_module_relevant_naut_link_generators(
																																								sbhl_link_vars
																																										.get_sbhl_link_direction(),
																																								sbhl_search_vars.$sbhl_tv$
																																										.getDynamicValue(
																																												thread),
																																								sbhl_module_vars
																																										.get_sbhl_module(
																																												UNPROVIDED)))))
																																: sbhl_module_utilities
																																		.get_sbhl_module_relevant_naut_link_generators(
																																				sbhl_link_vars
																																						.get_sbhl_link_direction(),
																																				sbhl_search_vars.$sbhl_tv$
																																						.getDynamicValue(
																																								thread),
																																				sbhl_module_vars
																																						.get_sbhl_module(
																																								UNPROVIDED));
																												SubLObject cdolist_list_var_131 = new_list;
																												SubLObject generating_fn = NIL;
																												for (generating_fn = cdolist_list_var_131
																														.first(); NIL != cdolist_list_var_131; cdolist_list_var_131 = cdolist_list_var_131
																																.rest(), generating_fn = cdolist_list_var_131
																																		.first()) {
																													{
																														SubLObject _prev_bind_0_132 = sbhl_link_vars.$sbhl_link_generator$
																																.currentBinding(
																																		thread);
																														try {
																															sbhl_link_vars.$sbhl_link_generator$
																																	.bind(generating_fn,
																																			thread);
																															{
																																SubLObject link_nodes = funcall(
																																		generating_fn,
																																		node);
																																SubLObject new_list_133 = (NIL != sbhl_link_vars
																																		.sbhl_randomize_lists_p())
																																				? ((SubLObject) (list_utilities
																																						.randomize_list(
																																								link_nodes)))
																																				: link_nodes;
																																SubLObject cdolist_list_var_134 = new_list_133;
																																SubLObject node_vars_link_node = NIL;
																																for (node_vars_link_node = cdolist_list_var_134
																																		.first(); NIL != cdolist_list_var_134; cdolist_list_var_134 = cdolist_list_var_134
																																				.rest(), node_vars_link_node = cdolist_list_var_134
																																						.first()) {
																																	if (NIL == sbhl_marking_utilities
																																			.sbhl_search_path_termination_p(
																																					node_vars_link_node,
																																					UNPROVIDED)) {
																																		sbhl_marking_utilities
																																				.sbhl_mark_node_marked(
																																						node_vars_link_node,
																																						UNPROVIDED);
																																		deck.deck_push(
																																				node_vars_link_node,
																																				recur_deck);
																																	}
																																}
																															}
																														} finally {
																															sbhl_link_vars.$sbhl_link_generator$
																																	.rebind(_prev_bind_0_132,
																																			thread);
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							} finally {
																								sbhl_search_vars.$genl_inverse_mode_p$
																										.rebind(_prev_bind_1_126,
																												thread);
																								sbhl_module_vars.$sbhl_module$
																										.rebind(_prev_bind_0_125,
																												thread);
																							}
																						}
																					}
																				}
																				node_var = deck.deck_pop(recur_deck);
																			}
																		} finally {
																			sbhl_search_vars.$genl_inverse_mode_p$
																					.rebind(_prev_bind_2_122, thread);
																			sbhl_link_vars.$sbhl_link_direction$
																					.rebind(_prev_bind_1_121, thread);
																			sbhl_search_vars.$sbhl_search_direction$
																					.rebind(_prev_bind_0_120, thread);
																		}
																	}
																} else {
																	sbhl_paranoia.sbhl_warn(TWO_INTEGER,
																			$str_alt284$Node__a_does_not_pass_sbhl_type_t,
																			col,
																			sbhl_module_utilities.get_sbhl_type_test(
																					sbhl_module_vars.get_sbhl_module(
																							UNPROVIDED)),
																			UNPROVIDED, UNPROVIDED, UNPROVIDED);
																}
															} finally {
																sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4,
																		thread);
																sbhl_search_vars.$genl_inverse_mode_p$
																		.rebind(_prev_bind_3, thread);
																sbhl_search_vars.$sbhl_add_node_to_result_test$
																		.rebind(_prev_bind_2, thread);
																sbhl_search_vars.$sbhl_search_module_type$
																		.rebind(_prev_bind_1_119, thread);
																sbhl_search_vars.$sbhl_search_module$
																		.rebind(_prev_bind_0_118, thread);
															}
														}
													} finally {
														sbhl_search_vars.$relevant_sbhl_tv_function$
																.rebind(_prev_bind_1_117, thread);
														sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_116, thread);
													}
												}
												sbhl_marking_vars.free_sbhl_marking_space(
														sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
											}
										} finally {
											sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_115, thread);
										}
									}
								}
							}
						}
					} finally {
						mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
						mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
					}
				}
				return list_utilities.remove_duplicate_forts(preds);
			}
		}
	}

	public static final SubLObject old_dump_sbhl_data(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject sbhl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt171$sbhl_modules,
						directory_path, UNPROVIDED);
				SubLObject filename_var = sbhl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_80 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_80);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt176$Dumping_SBHL_graphs___);
								{
									SubLObject sbhl_modules = dictionary
											.dictionary_values(sbhl_module_vars.get_sbhl_modules());
									cfasl_output(length(sbhl_modules), stream_80);
									{
										SubLObject cdolist_list_var = sbhl_modules;
										SubLObject module = NIL;
										for (module = cdolist_list_var
												.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
														.rest(), module = cdolist_list_var.first()) {
											cfasl_output(sbhl_module_vars.get_sbhl_module_link_pred(module), stream_80);
											cfasl_output(sbhl_module_vars.get_sbhl_module_graph(module), stream_80);
										}
									}
								}
								com.cyc.cycjava.cycl.dumper.dump_sbhl_miscellany(stream_80);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			com.cyc.cycjava.cycl.dumper.dump_sbhl_time_state(directory_path);
			return NIL;
		}
	}

	public static final SubLObject mal_constant_referencesP(SubLObject string) {
		return consp(com.cyc.cycjava.cycl.dumper.mal_constant_references(string));
	}

	public static final SubLObject mal_constant_references(SubLObject string) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			thread.resetMultipleValues();
			{
				SubLObject valid = string_utilities.constant_names_in_string(string, UNPROVIDED);
				SubLObject invalid = thread.secondMultipleValue();
				thread.resetMultipleValues();
				return invalid;
			}
		}
	}

	public static final SubLObject load_non_wff_store(SubLObject directory_path) {
		{
			SubLObject non_wff_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt128$non_wff_store,
					directory_path, $$$text);
			if (NIL != Filesys.probe_file(non_wff_file)) {
				wff_utilities.non_wff_store_load_internalized(non_wff_file);
			}
		}
		return NIL;
	}

	public static final SubLObject invalid_doc_stringP(SubLObject string) {
		if (string.isString()) {
			return com.cyc.cycjava.cycl.dumper.mal_constant_referencesP(string);
		}
		return NIL;
	}

	public static final SubLObject invalid_constant_in_string_assertions() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject result = NIL;
				{
					SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
					SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
					try {
						mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
						mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
						{
							SubLObject list_var = com.cyc.cycjava.cycl.dumper.preds_of_strings();
							$progress_note$.setDynamicValue($str_alt287$Finding_stale_documentation_refer, thread);
							$progress_start_time$.setDynamicValue(get_universal_time(), thread);
							$progress_total$.setDynamicValue(length(list_var), thread);
							$progress_sofar$.setDynamicValue(ZERO_INTEGER, thread);
							{
								SubLObject _prev_bind_0_136 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1_137 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
									{
										SubLObject csome_list_var = list_var;
										SubLObject pred = NIL;
										for (pred = csome_list_var
												.first(); NIL != csome_list_var; csome_list_var = csome_list_var
														.rest(), pred = csome_list_var.first()) {
											note_percent_progress($progress_sofar$.getDynamicValue(thread),
													$progress_total$.getDynamicValue(thread));
											$progress_sofar$.setDynamicValue(
													add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER), thread);
											{
												SubLObject pred_var = pred;
												if (NIL != kb_mapping_macros
														.do_predicate_extent_index_key_validator(pred_var)) {
													{
														SubLObject iterator_var = kb_mapping_macros
																.new_predicate_extent_final_index_spec_iterator(
																		pred_var);
														SubLObject done_var = NIL;
														SubLObject token_var = NIL;
														while (NIL == done_var) {
															{
																SubLObject final_index_spec = iteration
																		.iteration_next_without_values_macro_helper(
																				iterator_var, token_var);
																SubLObject valid = makeBoolean(
																		token_var != final_index_spec);
																if (NIL != valid) {
																	{
																		SubLObject final_index_iterator = NIL;
																		try {
																			final_index_iterator = kb_mapping_macros
																					.new_final_index_iterator(
																							final_index_spec, $GAF, NIL,
																							NIL);
																			{
																				SubLObject done_var_138 = NIL;
																				SubLObject token_var_139 = NIL;
																				while (NIL == done_var_138) {
																					{
																						SubLObject assertion = iteration
																								.iteration_next_without_values_macro_helper(
																										final_index_iterator,
																										token_var_139);
																						SubLObject valid_140 = makeBoolean(
																								token_var_139 != assertion);
																						if (NIL != valid_140) {
																							if (NIL != com.cyc.cycjava.cycl.dumper
																									.invalid_constant_in_string_assertionP(
																											assertion)) {
																								result = cons(assertion,
																										result);
																							}
																						}
																						done_var_138 = makeBoolean(
																								NIL == valid_140);
																					}
																				}
																			}
																		} finally {
																			{
																				SubLObject _prev_bind_0_141 = $is_thread_performing_cleanupP$
																						.currentBinding(thread);
																				try {
																					$is_thread_performing_cleanupP$
																							.bind(T, thread);
																					if (NIL != final_index_iterator) {
																						kb_mapping_macros
																								.destroy_final_index_iterator(
																										final_index_iterator);
																					}
																				} finally {
																					$is_thread_performing_cleanupP$
																							.rebind(_prev_bind_0_141,
																									thread);
																				}
																			}
																		}
																	}
																}
																done_var = makeBoolean(NIL == valid);
															}
														}
													}
												}
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1_137, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0_136, thread);
								}
							}
						}
					} finally {
						mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
						mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
					}
				}
				return result;
			}
		}
	}

	public static final SubLObject invalid_constant_in_string_assertionP(SubLObject assertion) {
		if (NIL != assertions_high.gaf_assertionP(assertion)) {
			{
				SubLObject literal = assertions_high.gaf_formula(assertion);
				SubLObject invalidP = NIL;
				if (NIL == invalidP) {
					{
						SubLObject csome_list_var = literal_args(literal, UNPROVIDED);
						SubLObject arg = NIL;
						for (arg = csome_list_var.first(); !((NIL != invalidP)
								|| (NIL == csome_list_var)); csome_list_var = csome_list_var
										.rest(), arg = csome_list_var.first()) {
							if (arg.isString()) {
								if (NIL != com.cyc.cycjava.cycl.dumper.invalid_doc_stringP(arg)) {
									invalidP = T;
								}
							}
						}
					}
				}
				return invalidP;
			}
		}
		return NIL;
	}

	public static final SubLObject generate_stale_documentation_report_to_file(SubLObject filename) {
		SubLTrampolineFile.checkType(filename, STRINGP);
		{
			SubLObject v_answer = NIL;
			SubLObject stream = NIL;
			try {
				stream = compatibility.open_text(filename, $OUTPUT, NIL);
				if (!stream.isStream()) {
					Errors.error($str_alt65$Unable_to_open__S, filename);
				}
				{
					SubLObject stream_114 = stream;
					com.cyc.cycjava.cycl.dumper.report_stale_documentation_references_to_stream(stream_114);
					com.cyc.cycjava.cycl.dumper.report_recent_renames_to_stream(stream_114);
					v_answer = T;
				}
			} finally {
				{
					SubLObject _prev_bind_0 = currentBinding($is_thread_performing_cleanupP$);
					try {
						bind($is_thread_performing_cleanupP$, T);
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
					} finally {
						rebind($is_thread_performing_cleanupP$, _prev_bind_0);
					}
				}
			}
			return v_answer;
		}
	}

	public static final SubLObject generate_stale_documentation_report(SubLObject directory) {
		if (directory == UNPROVIDED) {
			directory = NIL;
		}
		if (NIL == directory) {
			directory = com.cyc.cycjava.cycl.dumper.kb_dump_directory(UNPROVIDED, UNPROVIDED);
		}
		com.cyc.cycjava.cycl.dumper
				.generate_stale_documentation_report_to_file(
						file_utilities.relative_filename(directory,
								cconcatenate($str_alt268$stale_documentation_,
										format_nil.format_nil_a_no_copy(Environment.get_process_id(UNPROVIDED))),
								$$$text));
		return NIL;
	}

	/**
	 * Generate reports about the KB dump in directory-path and the transcript file
	 * specified by transcript-file. If directory-path is not supplied, then use the
	 * current KB dump directory.
	 */
	@LispMethod(comment = "Generate reports about the KB dump in directory-path and the transcript file specified by transcript-file.  If directory-path is not supplied, then use the current KB dump directory.")
	public static final SubLObject generate_kb_dump_reports(SubLObject directory_path, SubLObject transcript_file) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		if (transcript_file == UNPROVIDED) {
			transcript_file = NIL;
		}
		if (NIL == directory_path) {
			directory_path = com.cyc.cycjava.cycl.dumper.kb_dump_directory(UNPROVIDED, UNPROVIDED);
		}
		SubLTrampolineFile.checkType(directory_path, STRINGP);
		transcript_utilities.report_constant_modifications_in_transcript_to_file(
				file_utilities.relative_filename(directory_path,
						cconcatenate($str_alt267$modification_report_,
								format_nil.format_nil_a_no_copy(Environment.get_process_id(UNPROVIDED))),
						$$$text),
				transcript_file);
		com.cyc.cycjava.cycl.dumper.generate_stale_documentation_report(directory_path);
		return NIL;
	}

	public static final SubLObject dump_non_wff_store(SubLObject directory_path) {
		{
			SubLObject non_wff_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt128$non_wff_store,
					directory_path, $$$text);
			wff_utilities.non_wff_store_save_internalized(non_wff_file);
		}
		return NIL;
	}

	public static final SubLObject binary_preds_with_arg_isa(SubLObject col) {
		{
			SubLObject result = NIL;
			SubLObject cdolist_list_var = isa.all_fort_instances_in_all_mts($$ArgIsaBinaryPredicate);
			SubLObject arg_isa_pred = NIL;
			for (arg_isa_pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
					.rest(), arg_isa_pred = cdolist_list_var.first()) {
				{
					SubLObject cdolist_list_var_135 = kb_mapping_utilities.pred_values(col, arg_isa_pred, TWO_INTEGER,
							ONE_INTEGER, UNPROVIDED);
					SubLObject pred = NIL;
					for (pred = cdolist_list_var_135
							.first(); NIL != cdolist_list_var_135; cdolist_list_var_135 = cdolist_list_var_135
									.rest(), pred = cdolist_list_var_135.first()) {
						result = cons(pred, result);
					}
				}
			}
			return list_utilities.remove_duplicate_forts(result);
		}
	}

	public static final SubLFile me = new dumper();

	public static final String myName = "com.cyc.cycjava.cycl.dumper";

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $separate_file_for_complex_indexingP$ = makeSymbol(
			"*SEPARATE-FILE-FOR-COMPLEX-INDEXING?*");

	// defparameter
	// The default directory chain for KB dumps under the Cyc Home directory.
	/**
	 * The default directory chain for KB dumps under the Cyc Home directory.
	 */
	@LispMethod(comment = "The default directory chain for KB dumps under the Cyc Home directory.\ndefparameter")
	protected static final SubLSymbol $default_dump_path$ = makeSymbol("*DEFAULT-DUMP-PATH*");

	// defparameter
	// The default extension for all KB dump files.
	/**
	 * The default extension for all KB dump files.
	 */
	@LispMethod(comment = "The default extension for all KB dump files.\ndefparameter")
	protected static final SubLSymbol $default_dump_extension$ = makeSymbol("*DEFAULT-DUMP-EXTENSION*");

	// defparameter
	// The default extension for all KB dump product files.
	/**
	 * The default extension for all KB dump product files.
	 */
	@LispMethod(comment = "The default extension for all KB dump product files.\ndefparameter")
	protected static final SubLSymbol $default_dump_product_extension$ = makeSymbol("*DEFAULT-DUMP-PRODUCT-EXTENSION*");

	// deflexical
	@LispMethod(comment = "deflexical")
	public static final SubLSymbol $kb_dump_fvector_wide_mark_tag$ = makeSymbol("*KB-DUMP-FVECTOR-WIDE-MARK-TAG*");

	// deflexical
	// Dump size scaling factor in number of bytes per assertion.
	/**
	 * Dump size scaling factor in number of bytes per assertion.
	 */
	@LispMethod(comment = "Dump size scaling factor in number of bytes per assertion.\ndeflexical")
	protected static final SubLSymbol $dump_bytes_per_assertion$ = makeSymbol("*DUMP-BYTES-PER-ASSERTION*");

	// defparameter
	// Verify the existence of dump files when non-nil.
	/**
	 * Verify the existence of dump files when non-nil.
	 */
	@LispMethod(comment = "Verify the existence of dump files when non-nil.\ndefparameter")
	public static final SubLSymbol $dump_verify$ = makeSymbol("*DUMP-VERIFY*");

	// defparameter
	/**
	 * When T, the load process attempts to GC and make static the memory that has
	 * been recently allocated after each key point where a major chunk of KB
	 * content has been loaded.
	 */
	@LispMethod(comment = "When T, the load process attempts to GC and make static the memory that has\r\nbeen recently allocated after each key point where a major chunk of KB\r\ncontent has been loaded.\ndefparameter\nWhen T, the load process attempts to GC and make static the memory that has\nbeen recently allocated after each key point where a major chunk of KB\ncontent has been loaded.")
	protected static final SubLSymbol $kb_load_gc_checkpoints_enabledP$ = makeSymbol(
			"*KB-LOAD-GC-CHECKPOINTS-ENABLED?*");

	// defparameter
	@LispMethod(comment = "defparameter")
	protected static final SubLSymbol $perform_standard_pre_dump_kb_cleanups_completeP$ = makeSymbol(
			"*PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-COMPLETE?*");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $dump_verbose_detail$ = makeSymbol("*DUMP-VERBOSE-DETAIL*");

	// defparameter
	@LispMethod(comment = "defparameter")
	protected static final SubLSymbol $auto_increment_kb_number_on_dumpP$ = makeSymbol(
			"*AUTO-INCREMENT-KB-NUMBER-ON-DUMP?*");

	// defparameter
	@LispMethod(comment = "defparameter")
	protected static final SubLSymbol $snapshot_tombstoning_mode$ = makeSymbol("*SNAPSHOT-TOMBSTONING-MODE*");

	// deflexical
	@LispMethod(comment = "deflexical")
	public static final SubLSymbol $kb_units_fvector_descriptions$ = makeSymbol("*KB-UNITS-FVECTOR-DESCRIPTIONS*");

	// deflexical
	@LispMethod(comment = "deflexical")
	public static final SubLSymbol $kb_dump_default_common_symbols$ = makeSymbol("*KB-DUMP-DEFAULT-COMMON-SYMBOLS*");

	// defparameter
	@LispMethod(comment = "defparameter")
	protected static final SubLSymbol $kb_dump_common_symbols$ = makeSymbol("*KB-DUMP-COMMON-SYMBOLS*");

	// defconstant
	@LispMethod(comment = "defconstant")
	public static final SubLSymbol $dtp_index_writer$ = makeSymbol("*DTP-INDEX-WRITER*");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $compute_arg_type_cache_on_dumpP$ = makeSymbol("*COMPUTE-ARG-TYPE-CACHE-ON-DUMP?*");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $bootstrapping_constantsP$ = makeSymbol("BOOTSTRAPPING-CONSTANTS?");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $bootstrapping_nartsP$ = makeSymbol("BOOTSTRAPPING-NARTS?");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $bootstrapping_assertionsP$ = makeSymbol("BOOTSTRAPPING-ASSERTIONS?");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $bootstrapping_kb_hl_supportsP$ = makeSymbol("BOOTSTRAPPING-KB-HL-SUPPORTS?");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $bootstrapping_deductionsP$ = makeSymbol("BOOTSTRAPPING-DEDUCTIONS?");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $bootstrapping_bookkeeping_gafsP$ = makeSymbol("BOOTSTRAPPING-BOOKKEEPING-GAFS?");

	// deflexical
	@LispMethod(comment = "deflexical")
	protected static final SubLSymbol $essential_kb_evaluatable_file_type$ = makeSymbol(
			"ESSENTIAL-KB-EVALUATABLE-FILE-TYPE");

	// deflexical
	@LispMethod(comment = "deflexical")
	protected static final SubLSymbol $exportable_mtP_caching_state$ = makeSymbol("*EXPORTABLE-MT?-CACHING-STATE*");

	// deflexical
	@LispMethod(comment = "deflexical")
	protected static final SubLSymbol $exportable_deduction_supportP_caching_state$ = makeSymbol(
			"*EXPORTABLE-DEDUCTION-SUPPORT?-CACHING-STATE*");

	// deflexical
	@LispMethod(comment = "deflexical")
	protected static final SubLSymbol $exportable_deduction_supported_objectP_caching_state$ = makeSymbol(
			"*EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?-CACHING-STATE*");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $current_dump_assertion$ = makeSymbol("*CURRENT-DUMP-ASSERTION*");

	// defparameter
	@LispMethod(comment = "defparameter")
	public static final SubLSymbol $last_invalid_assertion$ = makeSymbol("*LAST-INVALID-ASSERTION*");

	// Internal Constants
	@LispMethod(comment = "Internal Constants")
	public static final SubLSymbol $force_monolithic_kb_assumption$ = makeSymbol("*FORCE-MONOLITHIC-KB-ASSUMPTION*");

	private static final SubLSymbol WITH_CONSTANT_DUMP_ID_TABLE = makeSymbol("WITH-CONSTANT-DUMP-ID-TABLE");

	private static final SubLSymbol WITH_NART_DUMP_ID_TABLE = makeSymbol("WITH-NART-DUMP-ID-TABLE");

	private static final SubLSymbol WITH_UNREPRESENTED_TERM_DUMP_ID_TABLE = makeSymbol(
			"WITH-UNREPRESENTED-TERM-DUMP-ID-TABLE");

	private static final SubLSymbol WITH_ASSERTION_DUMP_ID_TABLE = makeSymbol("WITH-ASSERTION-DUMP-ID-TABLE");

	private static final SubLSymbol WITH_DEDUCTION_DUMP_ID_TABLE = makeSymbol("WITH-DEDUCTION-DUMP-ID-TABLE");

	private static final SubLSymbol WITH_KB_HL_SUPPORT_DUMP_ID_TABLE = makeSymbol("WITH-KB-HL-SUPPORT-DUMP-ID-TABLE");

	private static final SubLSymbol WITH_CLAUSE_STRUC_DUMP_ID_TABLE = makeSymbol("WITH-CLAUSE-STRUC-DUMP-ID-TABLE");

	static private final SubLList $list9 = list(
			list(makeSymbol("*CFASL-CONSTANT-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-CONSTANT-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-NART-HANDLE-LOOKUP-FUNC*"), list(QUOTE, makeSymbol("FIND-NART-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-ASSERTION-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-ASSERTION-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-DEDUCTION-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-DEDUCTION-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-KB-HL-SUPPORT-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-KB-HL-SUPPORT-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-CLAUSE-STRUC-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-CLAUSE-STRUC-BY-DUMP-ID"))));

	static private final SubLList $list10 = list(list(makeSymbol("*STRUCTURE-RESOURCING-MAKE-STATIC*"), T),
			list(makeSymbol("*CFASL-INPUT-TO-STATIC-AREA*"), T));

	static private final SubLList $list11 = list(list(makeSymbol("*STRUCTURE-RESOURCING-MAKE-STATIC*"), NIL),
			list(makeSymbol("*CFASL-INPUT-TO-STATIC-AREA*"), NIL));

	static private final SubLList $list12 = list(list(makeSymbol("FILENAME-VAR"), makeSymbol("FILENAME")),
			makeSymbol("&BODY"), makeSymbol("BODY"));

	private static final SubLSymbol DISCARD_DUMP_FILENAME = makeSymbol("DISCARD-DUMP-FILENAME");

	static private final SubLList $list14 = list(
			list(makeSymbol("STREAM"), makeSymbol("FILENAME"), makeSymbol("DIRECTION")), makeSymbol("&BODY"),
			makeSymbol("BODY"));

	static private final SubLSymbol $sym15$FILENAME_VAR = makeUninternedSymbol("FILENAME-VAR");

	private static final SubLSymbol WITH_KB_DUMP_FILENAME = makeSymbol("WITH-KB-DUMP-FILENAME");

	private static final SubLList $list19 = list(makeKeyword("INPUT"));

	private static final SubLSymbol ENABLE_FILE_STREAM_MEMORY_MAPPING = makeSymbol("ENABLE-FILE-STREAM-MEMORY-MAPPING");

	private static final SubLSymbol $sym25$FILENAME_VAR = makeUninternedSymbol("FILENAME-VAR");

	private static final SubLList $list28 = list(list(makeSymbol("*SEPARATE-FILE-FOR-COMPLEX-INDEXING?*"), T));

	private static final SubLList $list29 = list(list(makeSymbol("*SEPARATE-FILE-FOR-COMPLEX-INDEXING?*")));

	private static final SubLList $list30 = list(makeString("units"));

	private static final SubLString $$$cfasl = makeString("cfasl");

	private static final SubLString $$$fht = makeString("fht");

	private static final SubLString $str33$_wide_mark = makeString("-wide-mark");

	private static final SubLInteger $int$192 = makeInteger(192);

	private static final SubLString $str35$file__s_not_found = makeString("file ~s not found");

	private static final SubLString $str36$Directory__S_does_not_exist_ = makeString("Directory ~S does not exist.");

	private static final SubLString $str37$Directory__S_is_not_different_fro = makeString(
			"Directory ~S is not different from the current KB directory.");

	private static final SubLString $str38$Directory__S_cannot_be_written_to = makeString(
			"Directory ~S cannot be written to.");

	private static final SubLString $str39$Directory__S_does_not_have_enough = makeString(
			"Directory ~S does not have enough space available, ~S bytes, for the KB dump.");

	private static final SubLString $str40$KB_Load_GC_checkpoint_reached____ = makeString(
			"KB Load GC checkpoint reached ...");

	private static final SubLString $str41$rule_utility_experience = makeString("rule-utility-experience");

	private static final SubLSymbol CONSTANT_DUMP_ID = makeSymbol("CONSTANT-DUMP-ID");

	private static final SubLSymbol NART_DUMP_ID = makeSymbol("NART-DUMP-ID");

	private static final SubLSymbol ASSERTION_DUMP_ID = makeSymbol("ASSERTION-DUMP-ID");

	private static final SubLSymbol DEDUCTION_DUMP_ID = makeSymbol("DEDUCTION-DUMP-ID");

	private static final SubLSymbol KB_HL_SUPPORT_DUMP_ID = makeSymbol("KB-HL-SUPPORT-DUMP-ID");

	private static final SubLSymbol CLAUSE_STRUC_DUMP_ID = makeSymbol("CLAUSE-STRUC-DUMP-ID");

	private static final SubLSymbol FIND_CONSTANT_BY_DUMP_ID = makeSymbol("FIND-CONSTANT-BY-DUMP-ID");

	private static final SubLSymbol FIND_NART_BY_DUMP_ID = makeSymbol("FIND-NART-BY-DUMP-ID");

	private static final SubLSymbol FIND_ASSERTION_BY_DUMP_ID = makeSymbol("FIND-ASSERTION-BY-DUMP-ID");

	private static final SubLSymbol FIND_DEDUCTION_BY_DUMP_ID = makeSymbol("FIND-DEDUCTION-BY-DUMP-ID");

	private static final SubLSymbol FIND_KB_HL_SUPPORT_BY_DUMP_ID = makeSymbol("FIND-KB-HL-SUPPORT-BY-DUMP-ID");

	private static final SubLSymbol FIND_CLAUSE_STRUC_BY_DUMP_ID = makeSymbol("FIND-CLAUSE-STRUC-BY-DUMP-ID");

	private static final SubLSymbol LOAD_NON_COMPUTABLE_KB_PLUS_REBUILD_AND_DUMP_COMPUTABLE_KB = makeSymbol(
			"LOAD-NON-COMPUTABLE-KB-PLUS-REBUILD-AND-DUMP-COMPUTABLE-KB");

	private static final SubLSymbol REBUILD_AND_RECONNECT_COMPUTABLE_KB = makeSymbol(
			"REBUILD-AND-RECONNECT-COMPUTABLE-KB");

	private static final SubLInteger $int$2048 = makeInteger(2048);

	public static final SubLSymbol $assertion_tile_size$ = makeSymbol("*ASSERTION-TILE-SIZE*");

	private static final SubLInteger $int$1000000 = makeInteger(1000000);

	private static final SubLString $str60$Re_Indexing_KB_in_ = makeString("Re-Indexing KB in ");

	private static final SubLString $str61$_parts__of_ = makeString(" parts (of ");

	private static final SubLString $str62$_assertions_ = makeString(" assertions)");

	private static final SubLString $$$cdolist = makeString("cdolist");

	private static final SubLString $str64$Reserving_known_TOP_N_indices = makeString("Reserving known TOP-N indices");

	private static final SubLList $list65 = list(makeSymbol("TERM"), makeSymbol("&REST"), makeSymbol("KEYS"));

	private static final SubLString $str66$Indexing_assertion_range__ = makeString("Indexing assertion range [");

	private static final SubLString $str67$_ = makeString(",");

	private static final SubLString $str68$_ = makeString("]");

	private static final SubLString $$$Dumping_partial_index_to_ = makeString("Dumping partial index to ");

	private static final SubLSymbol NEW_NINIVEH_CONSTANT_INDICES_ITERATOR = makeSymbol(
			"NEW-NINIVEH-CONSTANT-INDICES-ITERATOR");

	private static final SubLString $str72$Building_constant_indices_from_pa = makeString(
			"Building constant indices from partial results");

	private static final SubLSymbol NEW_NINIVEH_NART_INDICES_ITERATOR = makeSymbol("NEW-NINIVEH-NART-INDICES-ITERATOR");

	private static final SubLString $str74$Building_NART_indices_from_partia = makeString(
			"Building NART indices from partial results");

	private static final SubLSymbol NEW_NINIVEH_UNREPRESENTED_TERM_INDICES_ITERATOR = makeSymbol(
			"NEW-NINIVEH-UNREPRESENTED-TERM-INDICES-ITERATOR");

	private static final SubLSymbol FIND_UNREPRESENTED_TERM_BY_SUID = makeSymbol("FIND-UNREPRESENTED-TERM-BY-SUID");

	private static final SubLString $str77$Building_unrepresented_term_indic = makeString(
			"Building unrepresented term indices from partial results");

	private static final SubLString $str78$Building_index_from_partial_resul = makeString(
			"Building index from partial results");

	private static final SubLString $str81$Iterator__A_was_done_at_ID__A_of_ = makeString(
			"Iterator ~A was done at ID ~A of ~A.");

	private static final SubLList $list82 = cons(makeSymbol("TERM-ID"), makeSymbol("INDEX"));

	private static final SubLString $str83$Expected_index_for__A__got__A_ins = makeString(
			"Expected index for ~A, got ~A instead from ~A.");

	private static final SubLList $list84 = list(makeSymbol("MEMBERS"), makeSymbol("CLEANUP-FN"));

	private static final SubLSymbol ITERATION_FINALIZE = makeSymbol("ITERATION-FINALIZE");

	private static final SubLString $str86$_part = makeString(".part");

	private static final SubLString $str87$_ = makeString("/");

	private static final SubLString $str88$Cannot_create_part_directory__A__ = makeString(
			"Cannot create part directory ~A ... dirty units?");

	private static final SubLString $$$Cleaning_up_ = makeString("Cleaning up ");

	private static final SubLSymbol CYC_DUMP_KB = makeSymbol("CYC-DUMP-KB");

	private static final SubLString $str93$Setting_up_safe_KB_dump_environme = makeString(
			"Setting up safe KB dump environment");

	private static final SubLString $str94$Agenda_was_not_successfully_halte = makeString(
			"Agenda was not successfully halted!");

	private static final SubLString $str96$Restoring_pre_dump_environment = makeString(
			"Restoring pre-dump environment");

	private static final SubLSymbol CYC_DUMP_KB_UNSAFE = makeSymbol("CYC-DUMP-KB-UNSAFE");

	private static final SubLString $str98$Dump__A_KB_trivially_finished__du = makeString(
			"Dump ~A KB trivially finished: dump directory and current units are both ~S");

	private static final SubLSymbol $kw99$OVERWRITE_UNITS_ = makeKeyword("OVERWRITE-UNITS?");

	private static final SubLString $str100$done_txt = makeString("done.txt");

	private static final SubLString $str101$Cyc_units_aready_exist_in_directo = makeString(
			"Cyc units aready exist in directory ~A");

	private static final SubLSymbol $kw102$FORCE_DIRECTORY_CREATE_ = makeKeyword("FORCE-DIRECTORY-CREATE?");

	private static final SubLString $str118$Valid_DUMP_TYPE_not_specified = makeString("Valid DUMP-TYPE not specified");

	private static final SubLList $list119 = list(
			list(makeSymbol("START-LABEL"), makeSymbol("DIRECTION"), makeSymbol("END-LABEL"), makeSymbol("PATH")),
			makeSymbol("&BODY"), makeSymbol("BODY"));

	private static final SubLSymbol $sym120$OP_TIME = makeUninternedSymbol("OP-TIME");

	@LispMethod(comment = "defparameter")
	// defparameter
	public static final SubLSymbol $dump_verbose$ = makeSymbol("*DUMP-VERBOSE*");

	private static final SubLString $str123$_________A_KB = makeString("~&~%;;; ~A KB");

	static private final SubLList $list124 = list(makeSymbol("PWHEN"), list(makeSymbol("KB-LOADED")),
			list(makeSymbol("FORMAT"), T, makeString(" ~A"), list(makeSymbol("KB-VERSION-STRING"))));

	private static final SubLString $str125$__A__A_at__A__ = makeString(" ~A ~A at ~A~%");

	private static final SubLList $list126 = list(list(makeSymbol("TIMESTRING")));

	private static final SubLSymbol FORCE_FORMAT = makeSymbol("FORCE-FORMAT");

	private static final SubLString $str129$_________A_of_KB__A_completed___A = makeString(
			"~&~%;;; ~A of KB ~A completed (~A) at ~A~%");

	private static final SubLList $list130 = list(makeSymbol("KB-VERSION-STRING"));

	private static final SubLSymbol ELAPSED_TIME_ABBREVIATION_STRING = makeSymbol("ELAPSED-TIME-ABBREVIATION-STRING");

	private static final SubLString $$$Dumping = makeString("Dumping");

	private static final SubLString $str133$__A = makeString(" ~A");

	private static final SubLString $$$to = makeString("to");

	private static final SubLString $$$Dump = makeString("Dump");

	private static final SubLString $$$Loading = makeString("Loading");

	private static final SubLString $$$from = makeString("from");

	private static final SubLString $$$Load = makeString("Load");

	private static final SubLString $$$Snapshotting = makeString("Snapshotting");

	private static final SubLString $$$Snapshot = makeString("Snapshot");

	private static final SubLString $str144$Create_directory_and_continue_ = makeString(
			"Create directory and continue.");

	private static final SubLString $str145$_____S_transcript_operations_proc = makeString(
			"~&  ~S transcript operations processed~%");

	private static final SubLSymbol $kb_manifest$ = makeSymbol("*KB-MANIFEST*");

	private static final SubLString $str148$Could_not_load_KB_manifest_from__ = makeString(
			"Could not load KB manifest from ~A. Defaulting to undefined.~%");

	private static final SubLString $$$manifest = makeString("manifest");

	private static final SubLString $str152$Unable_to_open__S = makeString("Unable to open ~S");

	private static final SubLString $str155$_index = makeString("-index");

	private static final SubLString $$$constant = makeString("constant");

	private static final SubLString $$$indices = makeString("indices");

	private static final SubLString $str160$_indices = makeString("-indices");

	private static final SubLList $list161 = list(makeSymbol("&KEY"), makeSymbol("DATA-FILE"), makeSymbol("INDEX-FILE"),
			makeSymbol("TYPE"));

	private static final SubLList $list162 = list(makeKeyword("DATA-FILE"), makeKeyword("INDEX-FILE"), $TYPE);

	private static final SubLSymbol $ALLOW_OTHER_KEYS = makeKeyword("ALLOW-OTHER-KEYS");

	private static final SubLString $str164$_complex_indices = makeString("-complex-indices");

	private static final SubLSymbol $COMPLEX_DATA_FILE = makeKeyword("COMPLEX-DATA-FILE");

	private static final SubLSymbol $COMPLEX_INDEX_FILE = makeKeyword("COMPLEX-INDEX-FILE");

	private static final SubLString $$$assertion = makeString("assertion");

	private static final SubLString $$$deduction = makeString("deduction");

	private static final SubLString $str170$kb_hl_support = makeString("kb-hl-support");

	private static final SubLString $str171$nart_hl_formula = makeString("nart-hl-formula");

	private static final SubLString $$$nat = makeString("nat");

	private static final SubLString $str173$unrepresented_term = makeString("unrepresented-term");

	private static final SubLSymbol GET_KB_UNITS_FILE_VECTOR_DESCRIPTIONS = makeSymbol(
			"GET-KB-UNITS-FILE-VECTOR-DESCRIPTIONS");

	private static final SubLSymbol GET_KB_UNITS_FILE_VECTOR_CATEGORIES = makeSymbol(
			"GET-KB-UNITS-FILE-VECTOR-CATEGORIES");

	private static final SubLString $str177$ = makeString("");

	private static final SubLString $str178$File_Vector_category_description_ = makeString(
			"File Vector category description ~A has no type.~%");

	private static final SubLString $str179$Skipping_unknown_File_Vector_cate = makeString(
			"Skipping unknown File Vector category type ~A.~%");

	private static final SubLString $str181$________Dumping_essential_KB__ = makeString(
			"~&~%;;; Dumping essential KB~%");

	private static final SubLString $str182$________Snapshotting_essential_KB = makeString(
			"~&~%;;; Snapshotting essential KB~%");

	private static final SubLSymbol $KB_HL_SUPPORT_SHELLS = makeKeyword("KB-HL-SUPPORT-SHELLS");

	private static final SubLSymbol $CLAUSE_STRUC_DEFS = makeKeyword("CLAUSE-STRUC-DEFS");

	private static final SubLSymbol $KB_HL_SUPPORT_DEFS = makeKeyword("KB-HL-SUPPORT-DEFS");

	private static final SubLString $str193$________Loading_essential_KB_at__ = makeString(
			"~&~%;;; Loading essential KB at ~A~%");

	private static final SubLSymbol $NON_TRUE_ASSERTION_TV_CACHE = makeKeyword("NON-TRUE-ASSERTION-TV-CACHE");

	private static final SubLString $str199$________Loading_computable_KB_at_ = makeString(
			"~&~%;;; Loading computable KB at ~A~%");

	private static final SubLString $$$done = makeString("done");

	private static final SubLString $$$text = makeString("text");

	private static final SubLString $str203$________Loading_computable_remain = makeString(
			"~&~%;;; Loading computable remaining HL at ~A~%");

	private static final SubLSymbol $NART_HL_FORMULAS = makeKeyword("NART-HL-FORMULAS");

	private static final SubLSymbol $ARG_TYPE_CACHE = makeKeyword("ARG-TYPE-CACHE");

	private static final SubLSymbol $CAE_QUERY_SEARCH_TABLES = makeKeyword("CAE-QUERY-SEARCH-TABLES");

	private static final SubLString $str220$Cannot_initialize_reformulator_du = makeString(
			"Cannot initialize reformulator due to missing KB content.");

	private static final SubLString $str221$Cannot_initialize_lexicon_cache_d = makeString(
			"Cannot initialize lexicon cache due to missing KB content.");

	private static final SubLString $str222$________Rebuilding_computable_but = makeString(
			"~&~%;;; Rebuilding computable-but-not-dumpable-yet-KB at ~A~%");

	private static final SubLString $str223$Cannot_initialize_paraphrase_code = makeString(
			"Cannot initialize paraphrase code due to missing KB content.");

	private static final SubLString $str224$Cannot_initialize_SKSI_due_to_mis = makeString(
			"Cannot initialize SKSI due to missing KB content.");

	private static final SubLString $str227$_d_bytes_of_unread_stuff_in__S = makeString(
			"~d bytes of unread stuff in ~S");

	private static final SubLString $str228$_a__ = makeString("~a~%");

	private static final SubLString $$$id = makeString("id");

	private static final SubLString $$$_was = makeString(" was");

	private static final SubLString $$$s_were = makeString("s were");

	private static final SubLString $$$Noting_that_ = makeString("Noting that ");

	private static final SubLString $$$_ = makeString(" ");

	private static final SubLString $$$_deleted = makeString(" deleted");

	private static final SubLString $str236$Deleted_IDs_file__A_contained_no_ = makeString(
			"Deleted IDs file ~A contained no set -- ignoring.~%");

	private static final SubLList $list237 = list(makeSymbol("ID"), makeSymbol("PAYLOAD"));

	private static final SubLString $str238$__Dump_ID_regressed_from__A_to__A = makeString(
			"~&Dump ID regressed from ~A to ~A ... this is inefficient.~%");

	private static final SubLString $str239$______writing__S____A__index__i_e = makeString(
			"~&... writing ~S (#~A) index, i.e. FVECTOR[~A] = ~A~%");

	private static final SubLSymbol $sym240$_ = makeSymbol("<");

	private static final SubLString $str241$____tombstoning_companion_complex = makeString(
			"... tombstoning companion complex index.");

	private static final SubLString $str243$ID_ordering_regressed_from__A_to_ = makeString(
			"ID ordering regressed from ~A to ~A--iterator for new objects broken.~%");

	private static final SubLString $str244$______tombstoning____A__index__i_ = makeString(
			"~&... tombstoning (#~A) index, i.e. FVECTOR[~A] = [T]~%");

	private static final SubLString $str245$______appending__S____A__index__i = makeString(
			"~&... appending ~S (#~A) index, i.e. FVECTOR[~A] = ~A~%");

	private static final SubLString $str249$Inconsistent_state____already_for = makeString(
			"Inconsistent state -- already forced widening of simple ~A index but still threw exception.");

	private static final SubLString $str250$__Redoing__A_index_snap_shot_with = makeString(
			"~&Redoing ~A index snap-shot with wide simple index.~%");

	private static final SubLString $str251$Inconsistent_state____already_for = makeString(
			"Inconsistent state -- already forced widening of complex ~A index but still threw exception.");

	private static final SubLString $str252$__Redoing__A_index_snap_shot_with = makeString(
			"~&Redoing ~A index snap-shot with wide complex index.~%");

	private static final SubLString $str253$Unexpected_snapshot_state__A_____ = makeString(
			"Unexpected snapshot state ~A ... cannot snapshot ~A index.~%");

	private static final SubLString $$$Redoing_ = makeString("Redoing ");

	private static final SubLString $str255$_snapshot_with_wide_index_____ = makeString(
			" snapshot with wide index ....");

	private static final SubLString $str257$Cannot_find_required_file__A_ = makeString("Cannot find required file ~A.");

	private static final SubLList $list258 = list(new SubLObject[] { EQUAL, makeKeyword("TRUE-DEF"), EQ,
			makeKeyword("ASSERT-INFO"), makeKeyword("ASSERTED-TRUE-DEF"), EQUALP, makeKeyword("DEPENDENTS"),
			makeKeyword("TRUE-MON"), $CODE, makeKeyword("ASSERTED-TRUE-MON"), makeKeyword("COMPLEX"),
			makeKeyword("OPAQUE"), makeKeyword("INVERSE"), makeKeyword("SPEC-PRED"), $EVAL, makeKeyword("ISA"), $WEAK,
			makeKeyword("ACTION"), makeKeyword("DEFINITIONAL"), EQL, $SIGN, makeKeyword("DONT-CARE"),
			makeKeyword("PPH-UNKNOWN-ARG-POSITION"), makeKeyword("SUBJECT"), makeKeyword("GAF-ARG"),
			makeKeyword("VARIABLE-NAMES"), makeKeyword("ARG1"), makeKeyword("GENLS"), makeKeyword("PPH-UNKNOWN-CYCL"),
			makeKeyword("ARG2"), makeKeyword("OBJECT"), makeKeyword("BEGINNING-OF-TIME"), makeKeyword("END-OF-TIME"),
			makeKeyword("QUERY"), makeKeyword("BACKWARD"), makeKeyword("OTHER"), makeKeyword("EQUALITY"),
			makeKeyword("PPH-EMPTY-INFO-VECTOR"), makeKeyword("TVA"), makeKeyword("GENLPREDS"), $NOUN,
			makeKeyword("NART-ARG"), makeKeyword("OBLIQUE-OBJECT"), makeKeyword("ELEMENTOF"), QUOTE, T,
			makeKeyword("ADMIT"), makeKeyword("NEG"), makeKeyword("POS-PRED"), makeKeyword("CONSTANT-INDEX"),
			makeKeyword("NART-INDEX"), makeKeyword("NART-HL-FORMULA"), makeKeyword("ASSERTION-INDEX"),
			makeKeyword("DEDUCTION-INDEX"), makeKeyword("KB-HL-SUPPORT"), makeKeyword("UNREPRESENTED-TERM-INDEX") });

	private static final SubLString $str259$Dumping_special_objects_at__A____ = makeString(
			"Dumping special objects at ~A ...");

	private static final SubLString $$$special = makeString("special");

	private static final SubLString $str261$Loading_special_objects____ = makeString("Loading special objects ...");

	private static final SubLString $str263$constant_count = makeString("constant-count");

	private static final SubLString $str264$constant_shell = makeString("constant-shell");

	private static final SubLString $$$Dumping_constant_shells = makeString("Dumping constant shells");

	private static final SubLString $str267$deleted_constant_ids = makeString("deleted-constant-ids");

	private static final SubLString $$$Loading_constant_shells = makeString("Loading constant shells");

	private static final SubLString $str269$The_specified_file_position__A_is = makeString(
			"The specified file position ~A is past the length of the file ~A of ~A bytes.");

	private static final SubLString $str270$_A_lies_within_the_file_header__0 = makeString(
			"~A lies within the file header [0,~A) and designates no constant.");

	private static final SubLString $str271$_A_specifies_a_file_position_in_t = makeString(
			"~A specifies a file position in the definition of ~A (suid: ~A // guid: ~A).~%");

	private static final SubLString $str272$_A_should_have_been_found_but_was = makeString(
			"~A should have been found but was not ... error in the algorithm?");

	private static final SubLString $str273$nart_count = makeString("nart-count");

	private static final SubLString $str274$deleted_nart_ids = makeString("deleted-nart-ids");

	private static final SubLString $$$NART = makeString("NART");

	private static final SubLString $str276$nat_shell = makeString("nat-shell");

	private static final SubLString $$$Loading_NART_shells = makeString("Loading NART shells");

	private static final SubLString $str278$assertion_count = makeString("assertion-count");

	private static final SubLString $str279$deleted_assertion_ids = makeString("deleted-assertion-ids");

	private static final SubLString $str280$Enabling_lazy_assertion_handle_su = makeString(
			"Enabling lazy assertion handle support");

	private static final SubLString $str281$assertion_shell = makeString("assertion-shell");

	private static final SubLString $$$Loading_assertion_shells = makeString("Loading assertion shells");

	private static final SubLString $str283$kb_hl_support_count = makeString("kb-hl-support-count");

	private static final SubLString $str284$deleted_kb_hl_support_ids = makeString("deleted-kb-hl-support-ids");

	private static final SubLString $str285$KB_HL_support = makeString("KB HL-support");

	private static final SubLString $str286$Enabling_lazy_KB_HL_support_handl = makeString(
			"Enabling lazy KB HL support handle support");

	private static final SubLString $str287$kb_hl_support_shell = makeString("kb-hl-support-shell");

	private static final SubLString $$$Loading_KB_HL_support_shells = makeString("Loading KB HL support shells");

	private static final SubLString $str289$unrepresented_term_count = makeString("unrepresented-term-count");

	private static final SubLString $str290$unrepresented_terms = makeString("unrepresented-terms");

	private static final SubLString $$$Dumping_KB_unrepresented_terms = makeString("Dumping KB unrepresented terms");

	private static final SubLString $str292$____Old_Space = makeString(" -- Old Space");

	private static final SubLString $str293$____New_Space = makeString(" -- New Space");

	private static final SubLString $str294$Reconnecting_to_unrepresented_ter = makeString(
			"Reconnecting to unrepresented terms FHT ....");

	private static final SubLString $str295$Could_not_locate__A__faling_back_ = makeString(
			"Could not locate ~A, faling back on ID-INDEX implementation.~A");

	private static final SubLString $$$Loading_KB_unrepresented_terms = makeString("Loading KB unrepresented terms");

	private static final SubLInteger $int$500 = makeInteger(500);

	private static final SubLString $str298$clause_struc_count = makeString("clause-struc-count");

	private static final SubLString $str299$There_are__A_gaps_in_the_clause_s = makeString(
			"There are ~A gaps in the clause struct ID range.~%");

	private static final SubLString $str300$clause_struc = makeString("clause-struc");

	private static final SubLString $str301$Dumping_clause_struc_definitions = makeString(
			"Dumping clause-struc definitions");

	private static final SubLString $str302$deleted_clause_struc_ids = makeString("deleted-clause-struc-ids");

	private static final SubLString $$$shared_clauses = makeString("shared clauses");

	private static final SubLString $str304$Loading_clause_struc_definitions = makeString(
			"Loading clause-struc definitions");

	private static final SubLString $str305$__The__A_size_is_larger_than_4GB_ = makeString(
			"~&The ~A size is larger than 4GB.~%");

	private static final SubLString $str306$Persisting_wide_index_entry_suppo = makeString(
			"Persisting wide index entry support ....");

	private static final SubLString $str307$deduction_count = makeString("deduction-count");

	private static final SubLString $str308$deduction_index = makeString("deduction-index");

	private static final SubLString $$$Dumping_deduction_definitions = makeString("Dumping deduction definitions");

	private static final SubLString $$$deduction_defs = makeString("deduction defs");

	private static final SubLSymbol SNAPSHOT_DEDUCTION_DEFS_INTERNAL = makeSymbol("SNAPSHOT-DEDUCTION-DEFS-INTERNAL");

	private static final SubLList $list312 = list(makeString("deduction"));

	private static final SubLList $list313 = list(makeString("deduction-index"));

	private static final SubLString $str314$Copying_deduction_definitions_fro = makeString(
			"Copying deduction definitions from ");

	private static final SubLList $list315 = list(makeSymbol("NEW-DFILE"), makeSymbol("NEW-IFILE"),
			makeSymbol("NEW-WIDEMARK"));

	private static final SubLString $str316$Tombstoning_deleted_deduction_def = makeString(
			"Tombstoning deleted deduction definitions");

	private static final SubLSymbol DEDUCTION_ID = makeSymbol("DEDUCTION-ID");

	private static final SubLSymbol DUMP_DEDUCTION_DEF = makeSymbol("DUMP-DEDUCTION-DEF");

	private static final SubLString $str320$Appending_new_deduction_definitio = makeString(
			"Appending new deduction definitions");

	private static final SubLString $str321$__Deduction_definitions_will_be_s = makeString(
			"~&Deduction definitions will be swapped in lazily from~%   ~A~%   ~A~%");

	private static final SubLString $str322$Determining_deduction_max_ID_usin = makeString(
			"Determining deduction max ID using wide index entries ....");

	private static final SubLString $str323$Determining_deduction_max_ID_from = makeString(
			"Determining deduction max ID from index entries ....");

	private static final SubLString $str324$Enabling_lazy_deduction_handle_su = makeString(
			"Enabling lazy deduction handle support");

	private static final SubLString $str325$___Deduction_definitions_use_wide = makeString(
			"~&(Deduction definitions use wide index entries.)~%");

	private static final SubLString $str326$Not_yet_implemented_ = makeString("Not yet implemented.");

	private static final SubLString $$$Loading_deduction_definitions = makeString("Loading deduction definitions");

	private static final SubLString $str328$deleted_deduction_ids = makeString("deleted-deduction-ids");

	private static final SubLSymbol LOAD_DEDUCTION_DEF_FROM_CACHE = makeSymbol("LOAD-DEDUCTION-DEF-FROM-CACHE");

	private static final SubLString $str330$assertion_index = makeString("assertion-index");

	private static final SubLString $$$Dumping_assertion_definitions = makeString("Dumping assertion definitions");

	private static final SubLString $$$assertion_defs = makeString("assertion defs");

	private static final SubLSymbol SNAPSHOT_ASSERTION_DEFS_INTERNAL = makeSymbol("SNAPSHOT-ASSERTION-DEFS-INTERNAL");

	private static final SubLList $list334 = list(makeString("assertion"));

	private static final SubLList $list335 = list(makeString("assertion-index"));

	private static final SubLString $str336$Copying_assertion_definitions_fro = makeString(
			"Copying assertion definitions from ");

	private static final SubLList $list337 = list(makeSymbol("NEW-AFILE"), makeSymbol("NEW-IFILE"),
			makeSymbol("NEW-WIDEMARK"));

	private static final SubLString $str338$Tombstoning_deleted_assertion_def = makeString(
			"Tombstoning deleted assertion definitions");

	private static final SubLSymbol $NO_COMPLEX_FVECTOR = makeKeyword("NO-COMPLEX-FVECTOR");

	private static final SubLSymbol SNAPSHOT_ASSERTION_DEF = makeSymbol("SNAPSHOT-ASSERTION-DEF");

	private static final SubLString $str342$Updating_changed_assertion_defini = makeString(
			"Updating changed assertion definitions");

	private static final SubLSymbol DUMP_ASSERTION_DEF = makeSymbol("DUMP-ASSERTION-DEF");

	private static final SubLString $str345$Appending_new_assertion_definitio = makeString(
			"Appending new assertion definitions");

	private static final SubLString $str346$__Assertion_definitions_will_be_s = makeString(
			"~&Assertion definitions will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str347$___Assertion_definitions_use_wide = makeString(
			"~&(Assertion definitions use wide index entries.)~%");

	private static final SubLString $$$Loading_assertion_definitions = makeString("Loading assertion definitions");

	private static final SubLSymbol LOAD_ASSERTION_DEF_FROM_CACHE = makeSymbol("LOAD-ASSERTION-DEF-FROM-CACHE");

	private static final SubLString $str350$kb_hl_support_index = makeString("kb-hl-support-index");

	private static final SubLString $$$Dumping_KB_HL_support_definitions = makeString(
			"Dumping KB HL support definitions");

	private static final SubLString $str352$__KB_HL_supports_will_be_swapped_ = makeString(
			"~&KB HL supports will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $$$Loading_KB_HL_support_definitions = makeString(
			"Loading KB HL support definitions");

	private static final SubLSymbol LOAD_KB_HL_SUPPORT_DEF_FROM_CACHE = makeSymbol("LOAD-KB-HL-SUPPORT-DEF-FROM-CACHE");

	private static final SubLString $str355$kb_hl_support_indexing = makeString("kb-hl-support-indexing");

	private static final SubLString $str356$Dumping_KB_HL_support_indexing___ = makeString(
			"Dumping KB HL support indexing ...");

	private static final SubLString $str357$Loading_KB_HL_support_indexing___ = makeString(
			"Loading KB HL support indexing ...");

	private static final SubLString $str358$bookkeeping_assertions = makeString("bookkeeping-assertions");

	private static final SubLString $str359$Dumping_bookkeeping_assertions___ = makeString(
			"Dumping bookkeeping assertions ...");

	private static final SubLList $list360 = cons(makeSymbol("PRED"), makeSymbol("SUBINDEX"));

	private static final SubLString $str361$Loading_bookkeeping_assertions___ = makeString(
			"Loading bookkeeping assertions ...");

	private static final SubLString $str362$Dumping_rule_utility_experience__ = makeString(
			"Dumping rule utility experience ...");

	private static final SubLString $str363$Loading_rule_utility_experience__ = makeString(
			"Loading rule utility experience ...");

	private static final SubLString $str364$Cannot_locate__A_ = makeString("Cannot locate ~A.");

	private static final SubLString $str365$Cannot_open__A_for_reading___ = makeString("Cannot open ~A for reading.~%");

	private static final SubLSymbol $sym366$NINIVEH_INDEX_ITERATOR_DONE_ = makeSymbol("NINIVEH-INDEX-ITERATOR-DONE?");

	private static final SubLSymbol NINIVEH_INDEX_ITERATOR_NEXT = makeSymbol("NINIVEH-INDEX-ITERATOR-NEXT");

	private static final SubLSymbol NINIVEH_INDEX_ITERATOR_FINALIZE = makeSymbol("NINIVEH-INDEX-ITERATOR-FINALIZE");

	private static final SubLList $list370 = list(makeSymbol("STREAM"), makeSymbol("DONE?"), makeSymbol("CONS-CELL"));

	private static final SubLList $list371 = list(makeSymbol("STREAM"), makeSymbol("CACHE-LOAD-FN"),
			makeSymbol("DONE?"));

	private static final SubLSymbol $IGNORE_ERRORS_TARGET = makeKeyword("IGNORE-ERRORS-TARGET");

	private static final SubLSymbol IGNORE_ERRORS_HANDLER = makeSymbol("IGNORE-ERRORS-HANDLER", "SUBLISP");

	private static final SubLSymbol $UNREPRESENTED_TERM_INDEX = makeKeyword("UNREPRESENTED-TERM-INDEX");

	private static final SubLSymbol $KB_HL_SUPPORT_INDEX = makeKeyword("KB-HL-SUPPORT-INDEX");

	private static final SubLSymbol INDEX_WRITER = makeSymbol("INDEX-WRITER");

	private static final SubLSymbol INDEX_WRITER_P = makeSymbol("INDEX-WRITER-P");

	private static final SubLList $list383 = list(makeSymbol("DIRECTORY"), makeSymbol("FVECTOR"),
			makeSymbol("INDEX-FILE"), makeSymbol("INDEX-LABEL"), makeSymbol("COMPLEX-FVECTOR"),
			makeSymbol("COMPLEX-INDEX-FILE"), makeSymbol("COMPLEX-INDEX-LABEL"), makeSymbol("DUMP-FN"));

	private static final SubLList $list384 = list(makeKeyword("DIRECTORY"), makeKeyword("FVECTOR"),
			makeKeyword("INDEX-FILE"), makeKeyword("INDEX-LABEL"), makeKeyword("COMPLEX-FVECTOR"),
			makeKeyword("COMPLEX-INDEX-FILE"), makeKeyword("COMPLEX-INDEX-LABEL"), makeKeyword("DUMP-FN"));

	private static final SubLList $list385 = list(makeSymbol("IDXWRITER-DIRECTORY"), makeSymbol("IDXWRITER-FVECTOR"),
			makeSymbol("IDXWRITER-INDEX-FILE"), makeSymbol("IDXWRITER-INDEX-LABEL"),
			makeSymbol("IDXWRITER-COMPLEX-FVECTOR"), makeSymbol("IDXWRITER-COMPLEX-INDEX-FILE"),
			makeSymbol("IDXWRITER-COMPLEX-INDEX-LABEL"), makeSymbol("IDXWRITER-DUMP-FN"));

	private static final SubLList $list386 = list(makeSymbol("_CSETF-IDXWRITER-DIRECTORY"),
			makeSymbol("_CSETF-IDXWRITER-FVECTOR"), makeSymbol("_CSETF-IDXWRITER-INDEX-FILE"),
			makeSymbol("_CSETF-IDXWRITER-INDEX-LABEL"), makeSymbol("_CSETF-IDXWRITER-COMPLEX-FVECTOR"),
			makeSymbol("_CSETF-IDXWRITER-COMPLEX-INDEX-FILE"), makeSymbol("_CSETF-IDXWRITER-COMPLEX-INDEX-LABEL"),
			makeSymbol("_CSETF-IDXWRITER-DUMP-FN"));

	private static final SubLSymbol INDEX_WRITER_PRINT_FUNCTION_TRAMPOLINE = makeSymbol(
			"INDEX-WRITER-PRINT-FUNCTION-TRAMPOLINE");

	private static final SubLList $list389 = list(makeSymbol("OPTIMIZE-FUNCALL"), makeSymbol("INDEX-WRITER-P"));

	private static final SubLSymbol IDXWRITER_DIRECTORY = makeSymbol("IDXWRITER-DIRECTORY");

	private static final SubLSymbol _CSETF_IDXWRITER_DIRECTORY = makeSymbol("_CSETF-IDXWRITER-DIRECTORY");

	private static final SubLSymbol IDXWRITER_FVECTOR = makeSymbol("IDXWRITER-FVECTOR");

	private static final SubLSymbol _CSETF_IDXWRITER_FVECTOR = makeSymbol("_CSETF-IDXWRITER-FVECTOR");

	private static final SubLSymbol IDXWRITER_INDEX_FILE = makeSymbol("IDXWRITER-INDEX-FILE");

	private static final SubLSymbol _CSETF_IDXWRITER_INDEX_FILE = makeSymbol("_CSETF-IDXWRITER-INDEX-FILE");

	private static final SubLSymbol IDXWRITER_INDEX_LABEL = makeSymbol("IDXWRITER-INDEX-LABEL");

	private static final SubLSymbol _CSETF_IDXWRITER_INDEX_LABEL = makeSymbol("_CSETF-IDXWRITER-INDEX-LABEL");

	private static final SubLSymbol IDXWRITER_COMPLEX_FVECTOR = makeSymbol("IDXWRITER-COMPLEX-FVECTOR");

	private static final SubLSymbol _CSETF_IDXWRITER_COMPLEX_FVECTOR = makeSymbol("_CSETF-IDXWRITER-COMPLEX-FVECTOR");

	private static final SubLSymbol IDXWRITER_COMPLEX_INDEX_FILE = makeSymbol("IDXWRITER-COMPLEX-INDEX-FILE");

	private static final SubLSymbol _CSETF_IDXWRITER_COMPLEX_INDEX_FILE = makeSymbol(
			"_CSETF-IDXWRITER-COMPLEX-INDEX-FILE");

	private static final SubLSymbol IDXWRITER_COMPLEX_INDEX_LABEL = makeSymbol("IDXWRITER-COMPLEX-INDEX-LABEL");

	private static final SubLSymbol _CSETF_IDXWRITER_COMPLEX_INDEX_LABEL = makeSymbol(
			"_CSETF-IDXWRITER-COMPLEX-INDEX-LABEL");

	private static final SubLSymbol IDXWRITER_DUMP_FN = makeSymbol("IDXWRITER-DUMP-FN");

	private static final SubLSymbol _CSETF_IDXWRITER_DUMP_FN = makeSymbol("_CSETF-IDXWRITER-DUMP-FN");

	private static final SubLSymbol $COMPLEX_INDEX_LABEL = makeKeyword("COMPLEX-INDEX-LABEL");

	private static final SubLString $str411$Invalid_slot__S_for_construction_ = makeString(
			"Invalid slot ~S for construction function");

	private static final SubLSymbol MAKE_INDEX_WRITER = makeSymbol("MAKE-INDEX-WRITER");

	private static final SubLSymbol VISIT_DEFSTRUCT_OBJECT_INDEX_WRITER_METHOD = makeSymbol(
			"VISIT-DEFSTRUCT-OBJECT-INDEX-WRITER-METHOD");

	private static final SubLString $str416$indices_index = makeString("indices-index");

	private static final SubLString $$$constant_indices = makeString("constant indices");

	private static final SubLString $str418$constant_complex_indices = makeString("constant-complex-indices");

	private static final SubLString $str419$constant_complex_indices_index = makeString(
			"constant-complex-indices-index");

	private static final SubLString $$$constant_complex_indices = makeString("constant complex indices");

	private static final SubLSymbol DUMP_CONSTANT_INDEX = makeSymbol("DUMP-CONSTANT-INDEX");

	private static final SubLString $$$Dumping_constant_indices = makeString("Dumping constant indices");

	private static final SubLString $$$complex_constant_indices = makeString("complex constant indices");

	private static final SubLString $str424$Cleaning_up_empty_complex_indexin = makeString(
			"Cleaning up empty complex indexing files");

	private static final SubLSymbol SNAPSHOT_CONSTANT_INDICES_INTERNAL = makeSymbol(
			"SNAPSHOT-CONSTANT-INDICES-INTERNAL");

	private static final SubLList $list426 = list(makeString("indices"), makeString("constant-complex-indices"));

	private static final SubLList $list427 = list(makeString("indices-index"),
			makeString("constant-complex-indices-index"));

	private static final SubLString $$$Copying_constant_indices_from_ = makeString("Copying constant indices from ");

	private static final SubLList $list429 = list(makeSymbol("NEW-DFILE"), makeSymbol("NEW-IFILE"),
			makeSymbol("NEW-IWMARK"), makeSymbol("NEW-CDFILE"), makeSymbol("NEW-CIFILE"), makeSymbol("NEW-CWMARK"));

	private static final SubLString $str430$Tombstoning_deleted_constant_indi = makeString(
			"Tombstoning deleted constant indices");

	private static final SubLSymbol FIND_CONSTANT_BY_SUID = makeSymbol("FIND-CONSTANT-BY-SUID");

	private static final SubLSymbol SNAPSHOT_CONSTANT_INDEX = makeSymbol("SNAPSHOT-CONSTANT-INDEX");

	private static final SubLString $$$Updating_changed_constant_indices = makeString(
			"Updating changed constant indices");

	private static final SubLSymbol CONSTANT_SUID = makeSymbol("CONSTANT-SUID");

	private static final SubLString $$$Appending_new_constant_indices = makeString("Appending new constant indices");

	private static final SubLString $str436$__Constant_indexing_will_be_swapp = makeString(
			"~&Constant indexing will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str437$__Constant_complex_indexing_will_ = makeString(
			"~&Constant complex indexing will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str438$___Constant_indices_use_wide_inde = makeString(
			"~&(Constant indices use wide index entries.)~%");

	private static final SubLString $str439$___Constant_complex_indices_use_w = makeString(
			"~&(Constant complex indices use wide index entries.)~%");

	private static final SubLString $$$Loading_constant_indices = makeString("Loading constant indices");

	private static final SubLString $str441$Could_not_dump_the__A_index_for__ = makeString(
			"Could not dump the ~A index for ~A (id: ~A).~%  ~A~%");

	private static final SubLString $str442$Could_not_dump_the_constant_index = makeString(
			"Could not dump the constant index for ~A (id: ~A).~%  ~A~%");

	private static final SubLSymbol LOAD_CONSTANT_INDEX_FROM_CACHE = makeSymbol("LOAD-CONSTANT-INDEX-FROM-CACHE");

	private static final SubLString $str444$nat_indices = makeString("nat-indices");

	private static final SubLString $str445$nat_indices_index = makeString("nat-indices-index");

	private static final SubLString $$$NART_indices = makeString("NART indices");

	private static final SubLString $str447$nat_complex_indices = makeString("nat-complex-indices");

	private static final SubLString $str448$nat_complex_indices_index = makeString("nat-complex-indices-index");

	private static final SubLString $$$complex_NART_indices = makeString("complex NART indices");

	private static final SubLSymbol DUMP_NART_INDEX = makeSymbol("DUMP-NART-INDEX");

	private static final SubLString $$$Dumping_NART_indices = makeString("Dumping NART indices");

	private static final SubLString $str452$nart_complex_indices_index = makeString("nart-complex-indices-index");

	private static final SubLSymbol SNAPSHOT_NART_INDICES_INTERNAL = makeSymbol("SNAPSHOT-NART-INDICES-INTERNAL");

	private static final SubLString $$$NAT = makeString("NAT");

	private static final SubLList $list455 = list(makeString("nat-indices"), makeString("nat-complex-indices"));

	private static final SubLList $list456 = list(makeString("nat-indices-index"),
			makeString("nat-complex-indices-index"));

	private static final SubLString $$$Copying_NAT_indices_from_ = makeString("Copying NAT indices from ");

	private static final SubLString $$$Tombstoning_deleted_NAT_indices = makeString("Tombstoning deleted NAT indices");

	private static final SubLSymbol FIND_NART_BY_ID = makeSymbol("FIND-NART-BY-ID");

	private static final SubLSymbol SNAPSHOT_NART_INDEX = makeSymbol("SNAPSHOT-NART-INDEX");

	private static final SubLString $$$Updating_changed_NAT_indices = makeString("Updating changed NAT indices");

	private static final SubLSymbol NART_ID = makeSymbol("NART-ID");

	private static final SubLString $$$Appending_new_NAT_indices = makeString("Appending new NAT indices");

	private static final SubLString $$$NAT_indices = makeString("NAT indices");

	private static final SubLString $$$complex_NAT_indices = makeString("complex NAT indices");

	private static final SubLString $str466$__NART_indexing_will_be_swapped_i = makeString(
			"~&NART indexing will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str467$__NART_complex_indexing_will_be_s = makeString(
			"~&NART complex indexing will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str468$___NART_indices_use_wide_index_en = makeString(
			"~&(NART indices use wide index entries.)~%");

	private static final SubLString $str469$___NART_complex_indices_use_wide_ = makeString(
			"~&(NART complex indices use wide index entries.)~%");

	private static final SubLString $$$Loading_NART_indices = makeString("Loading NART indices");

	private static final SubLString $str471$Could_not_dump_the_NART_index_for = makeString(
			"Could not dump the NART index for ~A (id: ~A).~%  ~A~%");

	private static final SubLSymbol LOAD_NART_INDEX_FROM_CACHE = makeSymbol("LOAD-NART-INDEX-FROM-CACHE");

	private static final SubLString $str473$unrepresented_term_indices = makeString("unrepresented-term-indices");

	private static final SubLString $str474$unrepresented_term_indices_index = makeString(
			"unrepresented-term-indices-index");

	private static final SubLString $$$unrepresented_term_indices = makeString("unrepresented term indices");

	private static final SubLString $str476$unrepresented_term_complex_indice = makeString(
			"unrepresented-term-complex-indices");

	private static final SubLString $str477$unrepresented_term_complex_indice = makeString(
			"unrepresented-term-complex-indices-index");

	private static final SubLString $str478$complex_unrepresented_term_indice = makeString(
			"complex unrepresented term indices");

	private static final SubLSymbol DUMP_UNREPRESENTED_TERM_INDEX = makeSymbol("DUMP-UNREPRESENTED-TERM-INDEX");

	private static final SubLString $str480$Dumping_unrepresented_term_indice = makeString(
			"Dumping unrepresented term indices");

	private static final SubLSymbol SNAPSHOT_UNREPRESENTED_TERM_INDICES_INTERNAL = makeSymbol(
			"SNAPSHOT-UNREPRESENTED-TERM-INDICES-INTERNAL");

	private static final SubLString $$$unrepresented_term = makeString("unrepresented term");

	private static final SubLList $list483 = list(makeString("unrepresented-term-indices"),
			makeString("unrepresented-term-complex-indices"));

	private static final SubLList $list484 = list(makeString("unrepresented-term-indices-index"),
			makeString("unrepresented-term-complex-indices-index"));

	private static final SubLString $str485$Copying_unrepresented_term_indice = makeString(
			"Copying unrepresented term indices from ");

	private static final SubLString $str486$Tombstoning_deleted_unrepresented = makeString(
			"Tombstoning deleted unrepresented term indices");

	private static final SubLSymbol SNAPSHOT_UNREPRESENTED_TERM_INDEX = makeSymbol("SNAPSHOT-UNREPRESENTED-TERM-INDEX");

	private static final SubLString $str488$Updating_changed_unrepresented_te = makeString(
			"Updating changed unrepresented term indices");

	private static final SubLSymbol UNREPRESENTED_TERM_SUID = makeSymbol("UNREPRESENTED-TERM-SUID");

	private static final SubLString $str490$Appending_new_unrepresented_term_ = makeString(
			"Appending new unrepresented term indices");

	private static final SubLString $str491$__Unrepresented_term_indexing_wil = makeString(
			"~&Unrepresented term indexing will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str492$__Unrepresented_complex_term_inde = makeString(
			"~&Unrepresented complex term indexing will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str493$___Unrepresented_term_indices_use = makeString(
			"~&(Unrepresented term indices use wide index entries.)~%");

	private static final SubLString $str494$___Unrepresented_term_complex_ind = makeString(
			"~&(Unrepresented term complex indices use wide index entries.)~%");

	private static final SubLString $str495$Loading_unrepresented_term_indice = makeString(
			"Loading unrepresented term indices");

	private static final SubLString $str496$Could_not_dump_the_unrepresented_ = makeString(
			"Could not dump the unrepresented term index for ~A.~%  ~A~%");

	private static final SubLSymbol LOAD_UNREPRESENTED_TERM_INDEX_FROM_CACHE = makeSymbol(
			"LOAD-UNREPRESENTED-TERM-INDEX-FROM-CACHE");

	private static final SubLString $str498$assertion_indices = makeString("assertion-indices");

	private static final SubLString $$$Dumping_assertion_indices = makeString("Dumping assertion indices");

	private static final SubLString $$$Loading_assertion_indices = makeString("Loading assertion indices");

	private static final SubLString $str501$auxiliary_indices = makeString("auxiliary-indices");

	private static final SubLString $str502$Dumping_auxiliary_indices____ = makeString("Dumping auxiliary indices ...");

	private static final SubLString $$$Loading_auxiliary_indices = makeString("Loading auxiliary indices");

	private static final SubLString $str504$bookkeeping_indices = makeString("bookkeeping-indices");

	private static final SubLString $$$Dumping_bookkeeping_indices = makeString("Dumping bookkeeping indices");

	private static final SubLSymbol LOAD_BOOKKEEPING_INDICES = makeSymbol("LOAD-BOOKKEEPING-INDICES");

	private static final SubLString $str507$Loading_bookkeeping_indices____ = makeString(
			"Loading bookkeeping indices ...");

	private static final SubLString $str508$rule_set = makeString("rule-set");

	private static final SubLString $str509$Dumping_rule_set____ = makeString("Dumping rule set ...");

	private static final SubLSymbol LOAD_RULE_SET_FROM_STREAM = makeSymbol("LOAD-RULE-SET-FROM-STREAM");

	private static final SubLString $str511$Loading_rule_set____ = makeString("Loading rule set ...");

	private static final SubLString $str512$non_true_assertion_tv_cache = makeString("non-true-assertion-tv-cache");

	private static final SubLString $str513$Dumping_non_true_assertion_tv_cac = makeString(
			"Dumping non-true assertion tv cache ...");

	private static final SubLSymbol LOAD_NON_TRUE_ASSERTION_TV_CACHE_FROM_STREAM = makeSymbol(
			"LOAD-NON-TRUE-ASSERTION-TV-CACHE-FROM-STREAM");

	private static final SubLString $str515$Loading_non_true_assertion_tv_cac = makeString(
			"Loading non-true assertion tv cache ...");

	private static final SubLString $str516$nart_hl_formula_index = makeString("nart-hl-formula-index");

	private static final SubLSymbol $append_stack_traces_to_error_messagesP$ = makeSymbol(
			"*APPEND-STACK-TRACES-TO-ERROR-MESSAGES?*");

	private static final SubLList $list518 = list(makeSymbol("CSETQ"),
			makeSymbol("*APPEND-STACK-TRACES-TO-ERROR-MESSAGES?*"), NIL);

	private static final SubLString $$$Dumping_NART_HL_formulas = makeString("Dumping NART HL formulas");

	private static final SubLString $str520$_A = makeString("~A");

	private static final SubLString $str521$__NART_HL_formulas_will_be_swappe = makeString(
			"~&NART HL formulas will be swapped in lazily from:~%   ~A~%   ~A~%");

	private static final SubLString $str522$Loading_nart_hl_formula_definitio = makeString(
			"Loading nart-hl-formula definitions");

	private static final SubLString $$$misc = makeString("misc");

	private static final SubLString $str524$Dumping_miscellaneous_stuff____ = makeString(
			"Dumping miscellaneous stuff ...");

	private static final SubLString $str525$Loading_miscellaneous_stuff____ = makeString(
			"Loading miscellaneous stuff ...");

	private static final SubLString $str526$sbhl_modules = makeString("sbhl-modules");

	private static final SubLString $str527$sbhl_module_graphs = makeString("sbhl-module-graphs");

	private static final SubLString $str528$sbhl_module_graphs_index = makeString("sbhl-module-graphs-index");

	private static final SubLString $str529$Dumping_SBHL_modules_and_graphs__ = makeString(
			"Dumping SBHL modules and graphs ...");

	private static final SubLString $str533$Loading_SBHL_graphs____ = makeString("Loading SBHL graphs ...");

	private static final SubLString $str536$Cannot_initialize_SBHL_Time_due_t = makeString(
			"Cannot initialize SBHL Time due to missing KB content.");

	private static final SubLList $list539 = cons(makeUninternedSymbol("KEY"), makeSymbol("MODULE"));

	private static final SubLSymbol $ISA_ARG2_NAUT_TABLE = makeKeyword("ISA-ARG2-NAUT-TABLE");

	private static final SubLSymbol $NON_FORT_ISA_TABLE = makeKeyword("NON-FORT-ISA-TABLE");

	private static final SubLSymbol $NON_FORT_INSTANCE_TABLE = makeKeyword("NON-FORT-INSTANCE-TABLE");

	private static final SubLString $str543$Could_not_handle_SBHL_miscellany_ = makeString(
			"Could not handle SBHL miscellany token ~s");

	private static final SubLString $str544$sbhl_cache = makeString("sbhl-cache");

	private static final SubLString $str545$Dumping_SBHL_cache____ = makeString("Dumping SBHL cache ...");

	private static final SubLString $str546$Loading_SBHL_cache____ = makeString("Loading SBHL cache ...");

	private static final SubLString $str547$cardinality_estimates = makeString("cardinality-estimates");

	private static final SubLString $str548$Dumping_cardinality_estimates____ = makeString(
			"Dumping cardinality estimates ...");

	private static final SubLSymbol LOAD_CARDINALITY_ESTIMATES_FROM_STREAM = makeSymbol(
			"LOAD-CARDINALITY-ESTIMATES-FROM-STREAM");

	private static final SubLString $str550$Loading_cardinality_estimates____ = makeString(
			"Loading cardinality estimates ...");

	private static final SubLList $list551 = list(list(makeSymbol("*COMPUTE-ARG-TYPE-CACHE-ON-DUMP?*"), NIL));

	private static final SubLString $str552$arg_type_cache = makeString("arg-type-cache");

	private static final SubLString $str553$Dumping_arg_type_cache____ = makeString("Dumping arg-type cache ...");

	private static final SubLString $str554$Loading_arg_type_cache____ = makeString("Loading arg-type cache ...");

	private static final SubLString $str555$Rebuilding_arg_type_cache = makeString("Rebuilding arg-type cache");

	public static final SubLSymbol $cyc_alexandria_defns_dump_load_supportedP$ = makeSymbol(
			"*CYC-ALEXANDRIA-DEFNS-DUMP-LOAD-SUPPORTED?*");

	private static final SubLString $str557$defns_cache = makeString("defns-cache");

	private static final SubLString $str558$Dumping_defns_cache____ = makeString("Dumping defns cache ...");

	private static final SubLString $str559$Loading_defns_cache____ = makeString("Loading defns cache ...");

	private static final SubLString $str560$rule_connectivity_graph = makeString("rule-connectivity-graph");

	private static final SubLString $str561$Dumping_rule_connectivity_graph__ = makeString(
			"Dumping rule connectivity graph ...");

	private static final SubLSymbol LOAD_RULE_CONNECTIVITY_GRAPH_FROM_STREAM = makeSymbol(
			"LOAD-RULE-CONNECTIVITY-GRAPH-FROM-STREAM");

	private static final SubLString $str563$Loading_rule_connectivity_graph__ = makeString(
			"Loading rule connectivity graph ...");

	private static final SubLString $str564$tva_cache = makeString("tva-cache");

	private static final SubLString $str565$Dumping_TVA_cache____ = makeString("Dumping TVA cache ...");

	private static final SubLSymbol LOAD_TVA_CACHE_FROM_STREAM = makeSymbol("LOAD-TVA-CACHE-FROM-STREAM");

	private static final SubLString $str567$Loading_TVA_cache____ = makeString("Loading TVA cache ...");

	private static final SubLString $str568$reformulator_rules = makeString("reformulator-rules");

	private static final SubLString $str569$Dumping_reformulator_rules____ = makeString(
			"Dumping reformulator rules ...");

	private static final SubLSymbol LOAD_REFORMULATOR_RULES_FROM_STREAM = makeSymbol(
			"LOAD-REFORMULATOR-RULES-FROM-STREAM");

	private static final SubLString $str571$Loading_reformulator_rules____ = makeString(
			"Loading reformulator rules ...");

	private static final SubLString $str572$Dumping_English_units_of_measure_ = makeString(
			"Dumping English units of measure ...");

	private static final SubLString $str573$english_units_of_measure = makeString("english-units-of-measure");

	private static final SubLSymbol LOAD_ENGLISH_UNITS_OF_MEASURE_FROM_STREAM = makeSymbol(
			"LOAD-ENGLISH-UNITS-OF-MEASURE-FROM-STREAM");

	private static final SubLString $str575$Loading_English_units_of_measure_ = makeString(
			"Loading English units of measure ...");

	private static final SubLString $str576$Dumping_CAE_query_search_tables__ = makeString(
			"Dumping CAE query search tables ...");

	private static final SubLString $str577$cae_query_search_tables = makeString("cae-query-search-tables");

	private static final SubLSymbol LOAD_CAE_QUERY_SEARCH_TABLES_FROM_STREAM = makeSymbol(
			"LOAD-CAE-QUERY-SEARCH-TABLES-FROM-STREAM");

	private static final SubLString $str579$Loading_CAE_Query_Search_Tables__ = makeString(
			"Loading CAE Query Search Tables ...");

	private static final SubLString $str580$sbhl_time = makeString("sbhl-time");

	private static final SubLString $str581$Dumping_sbhl_time_state____ = makeString("Dumping sbhl time state ...");

	private static final SubLString $$$sbhl = makeString("sbhl");

	private static final SubLString $str583$Loading_SBHL_time_state____ = makeString("Loading SBHL time state ...");

	private static final SubLString $str584$_d_bytes_of_unread_sbhl_time_stat = makeString(
			"~d bytes of unread sbhl time state in ~S");

	private static final SubLString $str585$rtp_rules_cache = makeString("rtp-rules-cache");

	private static final SubLString $str586$Dumping_RTP_rules_cache____ = makeString("Dumping RTP rules cache ...");

	private static final SubLString $str587$Loading_RTP_rules_cache____ = makeString("Loading RTP rules cache ...");

	private static final SubLString $str588$somewhere_cache = makeString("somewhere-cache");

	private static final SubLString $str589$Dumping_somewhere_rules_cache____ = makeString(
			"Dumping somewhere rules cache ...");

	private static final SubLString $str590$Loading_somewhere_cache____ = makeString("Loading somewhere cache ...");

	private static final SubLString $str591$arity_cache = makeString("arity-cache");

	private static final SubLString $str592$Dumping_arity_cache____ = makeString("Dumping arity cache ...");

	private static final SubLString $str593$Loading_arity_cache____ = makeString("Loading arity cache ...");

	private static final SubLString $str594$pph_phrase_count = makeString("pph-phrase-count");

	private static final SubLString $str595$pph_phrase_shell = makeString("pph-phrase-shell");

	private static final SubLString $str596$Dumping_pph_phrase_shells = makeString("Dumping pph-phrase shells");

	private static final SubLString $str597$PPH_phrase__A_indexed_incorrectly = makeString(
			"PPH phrase ~A indexed incorrectly.");

	private static final SubLString $str598$Loading_pph_phrase_shells = makeString("Loading pph-phrase shells");

	private static final SubLString $str599$pph_phrase = makeString("pph-phrase");

	private static final SubLString $str600$pph_phrase_index = makeString("pph-phrase-index");

	private static final SubLString $str601$Dumping_pph_phrase_definitions = makeString(
			"Dumping pph-phrase definitions");

	private static final SubLString $str602$Loading_pph_phrase_definitions = makeString(
			"Loading pph-phrase definitions");

	private static final SubLString $str603$pph_phrase_definitions_out_of_syn = makeString(
			"pph-phrase definitions out of sync on load");

	private static final SubLString $str604$gen_template_store = makeString("gen-template-store");

	private static final SubLString $str605$Dumping___genTemplate_store____ = makeString(
			"Dumping #$genTemplate store ...");

	private static final SubLString $str606$Loading___genTemplate_store____ = makeString(
			"Loading #$genTemplate store ...");

	private static final SubLString $str607$pph_name_string_preds = makeString("pph-name-string-preds");

	private static final SubLString $str609$pph_phrase_fns = makeString("pph-phrase-fns");

	private static final SubLString $str611$Initializing_minor_paraphrase_Cyc = makeString(
			"Initializing minor paraphrase CycL structures ...");

	private static final SubLString $str612$________Performing_other_KB_dump_ = makeString(
			"~&~%;;; Performing other KB dump activities at ~A~%");

	private static final SubLString $str613$________Performing_KB_initializat = makeString(
			"~&~%;;; Performing KB initializations at ~A~%");

	private static final SubLString $str614$Reformulator___A__ = makeString("Reformulator: ~A~%");

	private static final SubLString $str615$Paraphrase___A__ = makeString("Paraphrase: ~A~%");

	private static final SubLString $str616$Cyc_Task_Scheduler___A__ = makeString("Cyc Task Scheduler: ~A~%");

	private static final SubLString $str617$SKSI___A__ = makeString("SKSI: ~A~%");

	private static final SubLString $str618$Quant___A__ = makeString("Quant: ~A~%");

	private static final SubLString $str619$Date___A__ = makeString("Date: ~A~%");

	private static final SubLString $str620$Time___A__ = makeString("Time: ~A~%");

	private static final SubLString $str621$Lexicon___A__ = makeString("Lexicon: ~A~%");

	private static final SubLString $str622$NL___A__ = makeString("NL: ~A~%");

	private static final SubLString $str623$RTP___A__ = makeString("RTP: ~A~%");

	private static final SubLString $str624$RKF___A__ = makeString("RKF: ~A~%");

	private static final SubLString $str625$Thesaurus___A__ = makeString("Thesaurus: ~A~%");

	private static final SubLString $str626$Wordnet___A__ = makeString("Wordnet: ~A~%");

	private static final SubLString $str627$Planner___A__ = makeString("Planner: ~A~%");

	private static final SubLString $str628$Secure___A__ = makeString("Secure: ~A~%");

	private static final SubLString $str629$_scratch_ = makeString("/scratch/");

	private static final SubLString $str630$load_all_constants_lisp = makeString("load-all-constants.lisp");

	private static final SubLString $str631$load_all_narts_lisp = makeString("load-all-narts.lisp");

	private static final SubLString $str632$load_all_assertions_lisp = makeString("load-all-assertions.lisp");

	private static final SubLString $str633$load_all_kb_hl_supports_lisp = makeString("load-all-kb-hl-supports.lisp");

	private static final SubLString $str634$load_all_kb_hl_supports_just_lisp = makeString(
			"load-all-kb-hl-supports-just.lisp");

	private static final SubLString $str635$load_all_deductions_lisp = makeString("load-all-deductions.lisp");

	private static final SubLString $str636$load_all_bookkeeping_gafs_lisp = makeString(
			"load-all-bookkeeping-gafs.lisp");

	private static final SubLSymbol ESSENTIAL_KB_EVALUATABLE_FILE_TYPE = makeSymbol(
			"ESSENTIAL-KB-EVALUATABLE-FILE-TYPE");

	private static final SubLList $list638 = list(makeKeyword("ALL"), makeKeyword("CONSTANTS"), makeKeyword("NARTS"),
			makeKeyword("ASSERTIONS"), makeKeyword("HL-SUPPORTS"), makeKeyword("HL-SUPPORT-JUSTIFICATIONS"),
			makeKeyword("DEDUCTIONS"), makeKeyword("BOOKKEEPING"));

	private static final SubLInteger $int$250 = makeInteger(250);

	private static final SubLString $str641$________Loading_evaluatable_essen = makeString(
			"~&~%;;; Loading evaluatable essential KB at ~A~%");

	private static final SubLString $$$Loading_constants = makeString("Loading constants");

	private static final SubLString $$$Loading_narts = makeString("Loading narts");

	private static final SubLString $$$Loading_assertions = makeString("Loading assertions");

	private static final SubLString $str645$Loading_definitions_for_KB_HL_sup = makeString(
			"Loading definitions for KB HL supports");

	private static final SubLString $str646$Loading_justifications_for_KB_HL_ = makeString(
			"Loading justifications for KB HL supports");

	private static final SubLString $$$Loading_deductions = makeString("Loading deductions");

	private static final SubLString $$$Loading_bookkeeping_data = makeString("Loading bookkeeping data");

	private static final SubLSymbol $sym650$_EXIT = makeSymbol("%EXIT");

	private static final SubLString $str651$________Rebuilding_Computable_KB_ = makeString(
			"~&~%;;; Rebuilding Computable KB at ~A~%");

	private static final SubLString $str653$________Dumping_Computable_KB_at_ = makeString(
			"~&~%;;; Dumping Computable KB at ~A~%");

	private static final SubLString $$$Dumping_rule_utility_experience = makeString("Dumping rule utility experience");

	private static final SubLString $str655$rule_utility_experience_cfasl = makeString("rule-utility-experience.cfasl");

	private static final SubLString $$$Dumping_sbhl_caching_policies = makeString("Dumping sbhl caching policies");

	private static final SubLString $str657$standard_kb_sbhl_caching_policies = makeString(
			"standard-kb-sbhl-caching-policies.cfasl");

	private static final SubLInteger $int$4000000 = makeInteger(4000000);

	private static final SubLInteger $int$15000000 = makeInteger(15000000);

	private static final SubLInteger $int$2000000000 = makeInteger(2000000000);

	private static final SubLInteger $int$32000000 = makeInteger(32000000);

	private static final SubLInteger $int$20000 = makeInteger(20000);

	private static final SubLString $str663$__Error_with_operation___A___A__ = makeString(
			"~%Error with operation: ~A~%~A~%");

	private static final SubLString $str664$Processed___A__A_operations_from_ = makeString(
			"Processed: ~A/~A operations from file: ~A~%");

	private static final SubLString $str665$Operation__S__ = makeString("Operation ~S~%");

	private static final SubLSymbol QUOTIFY = makeSymbol("QUOTIFY");

	private static final SubLString $str668$Failed_operation___S__Got___S__ = makeString(
			"Failed operation: ~S, Got: ~S~%");

	private static final SubLInteger $int$8000000 = makeInteger(8000000);

	private static final SubLSymbol $dump_invalid_constants$ = makeSymbol("*DUMP-INVALID-CONSTANTS*");

	private static final SubLSymbol $dump_invalid_narts$ = makeSymbol("*DUMP-INVALID-NARTS*");

	private static final SubLSymbol $dump_invalid_assertions$ = makeSymbol("*DUMP-INVALID-ASSERTIONS*");

	private static final SubLSymbol $dump_invalid_kb_hl_supports$ = makeSymbol("*DUMP-INVALID-KB-HL-SUPPORTS*");

	private static final SubLSymbol $dump_invalid_deductions$ = makeSymbol("*DUMP-INVALID-DEDUCTIONS*");

	private static final SubLSymbol $dump_invalid_bookkeeping_gafs$ = makeSymbol("*DUMP-INVALID-BOOKKEEPING-GAFS*");

	private static final SubLString $str676$Dumping_forms_to_create_all_const = makeString(
			"Dumping forms to create all constants ...");

	private static final SubLString $str677$Found_unfindable_constant___A_wit = makeString(
			"Found unfindable constant: ~A with id ~A.~%");

	private static final SubLString $str678$_kb_create_constant__A__A___ = makeString("(kb-create-constant ~A ~A)~%");

	private static final SubLInteger $int$150000 = makeInteger(150000);

	private static final SubLString $str680$Dumping_forms_to_create_all_narts = makeString(
			"Dumping forms to create all narts ....");

	private static final SubLString $str681$Found_unfindable_nart___A_with_id = makeString(
			"Found unfindable nart: ~A with id ~A.~%");

	private static final SubLString $str682$_kb_create_nart__A___ = makeString("(kb-create-nart ~A)~%");

	private static final SubLSymbol $sym683$EXPORTABLE_MT_ = makeSymbol("EXPORTABLE-MT?");

	private static final SubLSymbol $sym684$_EXPORTABLE_MT__CACHING_STATE_ = makeSymbol(
			"*EXPORTABLE-MT?-CACHING-STATE*");

	private static final SubLInteger $int$16000 = makeInteger(16000);

	private static final SubLSymbol $sym686$EXPORTABLE_DEDUCTION_SUPPORT_ = makeSymbol("EXPORTABLE-DEDUCTION-SUPPORT?");

	private static final SubLSymbol $sym687$_EXPORTABLE_DEDUCTION_SUPPORT__CACHING_STATE_ = makeSymbol(
			"*EXPORTABLE-DEDUCTION-SUPPORT?-CACHING-STATE*");

	private static final SubLInteger $int$300000 = makeInteger(300000);

	private static final SubLSymbol $sym689$EXPORTABLE_DEDUCTION_SUPPORTED_OBJECT_ = makeSymbol(
			"EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?");

	private static final SubLSymbol $sym690$_EXPORTABLE_DEDUCTION_SUPPORTED_OBJECT__CACHING_STATE_ = makeSymbol(
			"*EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?-CACHING-STATE*");

	private static final SubLInteger $int$350000 = makeInteger(350000);

	private static final SubLString $str692$Dumping_forms_to_create_all_asser = makeString(
			"Dumping forms to create all assertions ....");

	private static final SubLString $str693$Found_unfindable_assertion___A_wi = makeString(
			"Found unfindable assertion: ~A with id ~A.~%");

	private static final SubLString $str694$_progn__ = makeString("(progn~%");

	private static final SubLString $str695$_csetq__last_assertion___kb_creat = makeString(
			"(csetq *last-assertion* (kb-create-assertion ~A ~A '~S ~S ~S ~S ~S))~%");

	private static final SubLString $str696$_kb_timestamp_asserted_assertion_ = makeString(
			"(kb-timestamp-asserted-assertion *last-assertion* ~A ~S ~A ~S))~%");

	private static final SubLString $str697$Found_unfindable_assertion2___A_w = makeString(
			"Found unfindable assertion2: ~A with id ~A.~%");

	private static final SubLString $str698$Dumping_forms_to_create_all_KB_HL = makeString(
			"Dumping forms to create all KB HL supports...");

	private static final SubLString $str699$Found_unfindable_kb_hl_support__A = makeString(
			"Found unfindable kb-hl-support ~A with id ~A~%");

	private static final SubLString $str700$_create_kb_hl_support__A_NIL___ = makeString(
			"(create-kb-hl-support ~A NIL)~%");

	private static final SubLString $str701$_kb_hl_support_reset_justificatio = makeString(
			"(kb-hl-support-reset-justification (find-kb-hl-support ~A) ~A)~%");

	private static final SubLString $str702$_ = makeString("-");

	private static final SubLString $str703$Dumping_forms_to_create_all_deduc = makeString(
			"Dumping forms to create all deductions...");

	private static final SubLString $str704$Found_unfindable_deduction__A_wit = makeString(
			"Found unfindable deduction ~A with id ~A~%");

	private static final SubLString $str705$_kb_create_deduction__A__A__A__A_ = makeString(
			"(kb-create-deduction ~A ~A ~A ~A)~%");

	private static final SubLList $list706 = cons(makeSymbol("PRED"), makeUninternedSymbol("SUBINDEX"));

	private static final SubLString $str707$Got_bad_bookkeeping_gaf__S____S__ = makeString(
			"Got bad bookkeeping gaf ~S: (~S ~S ~S)");

	private static final SubLString $str708$_hl_assert_bookkeeping_binary_gaf = makeString(
			"(hl-assert-bookkeeping-binary-gaf ~A ~A ~A ~A)~%");

	private static final SubLString $str711$Testing_that_narts_are_findable__ = makeString(
			"Testing that narts are findable....");

	private static final SubLString $str712$Unfindable_nart__S___S = makeString("Unfindable nart ~S: ~S");

	private static final SubLString $str713$Testing_that_assertions_are_finda = makeString(
			"Testing that assertions are findable....");

	private static final SubLString $str714$__S__Unfindable_assertion_id__S__ = makeString(
			"(~S) Unfindable assertion id ~S: ~S");

	private static final SubLString $str715$Testing_that_deductions_are_finda = makeString(
			"Testing that deductions are findable....");

	private static final SubLString $str716$__S__Unfindable_deduction_id__S__ = makeString(
			"(~S) Unfindable deduction id ~S: ~S");

	private static final SubLSymbol IGNORE_ERRORS = makeSymbol("IGNORE-ERRORS");

	private static final SubLSymbol POSSIBLE_NART = makeSymbol("POSSIBLE-NART");

	private static final SubLList $list720 = list(makeSymbol("HL-TO-EL"),
			list(makeSymbol("NART-HL-FORMULA"), makeSymbol("POSSIBLE-NART")));

	private static final SubLList $list723 = list(list(makeSymbol("CYC-KILL"), makeSymbol("POSSIBLE-NART")));

	private static final SubLSymbol POSSIBLE_ASSERTION = makeSymbol("POSSIBLE-ASSERTION");

	private static final SubLList $list726 = list(makeSymbol("ASSERTION-MT"), makeSymbol("POSSIBLE-ASSERTION"));

	private static final SubLList $list727 = list(makeSymbol("HL-TO-EL"),
			list(makeSymbol("ASSERTION-CNF"), makeSymbol("POSSIBLE-ASSERTION")));

	private static final SubLList $list728 = list(
			list(makeSymbol("TMS-REMOVE-ASSERTION"), makeSymbol("POSSIBLE-ASSERTION")));

	private static final SubLString $str729$Deleting_potentially_bad_assertio = makeString(
			"Deleting potentially bad assertion ~A: ~A");

	private static final SubLString $str730$Recanonicalized__A___A = makeString("Recanonicalized ~A: ~A");

	private static final SubLString $str731$Finding_assertions_____ = makeString("Finding assertions ....");

	private static final SubLString $str732$Expected_a_deduction_got___S__ = makeString(
			"Expected a deduction got: ~S~%");

	private static final SubLString $str733$Finding_cnf_with_non_trivial_term = makeString(
			"Finding cnf with non trivial term order ....");

	private static final SubLString $str734$Found_cnf__A = makeString("Found cnf ~A");

	private static final SubLString $str735$Found_mt__A = makeString("Found mt ~A");

	private static final SubLString $str736$Found_id__A = makeString("Found id ~A");

	public static final SubLObject force_monolithic_kb_assumptionP_alt() {
		return $force_monolithic_kb_assumption$.getGlobalValue();
	}

	public static SubLObject force_monolithic_kb_assumptionP() {
		return dumper.$force_monolithic_kb_assumption$.getGlobalValue();
	}

	public static final SubLObject with_kb_dump_ids_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			SubLObject body = current;
			return list(WITH_CONSTANT_DUMP_ID_TABLE,
					list(WITH_NART_DUMP_ID_TABLE,
							list(WITH_UNREPRESENTED_TERM_DUMP_ID_TABLE,
									list(WITH_ASSERTION_DUMP_ID_TABLE,
											list(WITH_DEDUCTION_DUMP_ID_TABLE, list(WITH_KB_HL_SUPPORT_DUMP_ID_TABLE,
													bq_cons(WITH_CLAUSE_STRUC_DUMP_ID_TABLE, append(body, NIL))))))));
		}
	}

	public static SubLObject with_kb_dump_ids(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return list(dumper.WITH_CONSTANT_DUMP_ID_TABLE,
				list(dumper.WITH_NART_DUMP_ID_TABLE,
						list(dumper.WITH_UNREPRESENTED_TERM_DUMP_ID_TABLE, list(dumper.WITH_ASSERTION_DUMP_ID_TABLE,
								list(dumper.WITH_DEDUCTION_DUMP_ID_TABLE, list(dumper.WITH_KB_HL_SUPPORT_DUMP_ID_TABLE,
										bq_cons(dumper.WITH_CLAUSE_STRUC_DUMP_ID_TABLE, append(body, NIL))))))));
	}

	public static final SubLObject with_kb_load_ids_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			SubLObject body = current;
			return listS(CLET, $list_alt9, append(body, NIL));
		}
	}

	public static SubLObject with_kb_load_ids(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return listS(CLET, dumper.$list9, append(body, NIL));
	}

	/**
	 * perform all memory allocation inside BODY in the area intended for KB loads
	 */
	@LispMethod(comment = "perform all memory allocation inside BODY in the area intended for KB loads")
	public static final SubLObject with_kb_load_area_allocation_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			SubLObject body = current;
			return listS(CLET, $list_alt10, append(body, NIL));
		}
	}

	/**
	 * perform all memory allocation inside BODY in the area intended for KB loads
	 */
	@LispMethod(comment = "perform all memory allocation inside BODY in the area intended for KB loads")
	public static SubLObject with_kb_load_area_allocation(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return listS(CLET, dumper.$list10, append(body, NIL));
	}

	/**
	 * perform all memory allocation inside BODY outside of the aread intended for
	 * KB loads
	 */
	@LispMethod(comment = "perform all memory allocation inside BODY outside of the aread intended for KB loads")
	public static final SubLObject without_kb_load_area_allocation_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			SubLObject body = current;
			return listS(CLET, $list_alt11, append(body, NIL));
		}
	}

	/**
	 * perform all memory allocation inside BODY outside of the aread intended for
	 * KB loads
	 */
	@LispMethod(comment = "perform all memory allocation inside BODY outside of the aread intended for KB loads")
	public static SubLObject without_kb_load_area_allocation(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return listS(CLET, dumper.$list11, append(body, NIL));
	}

	public static final SubLObject with_kb_dump_filename_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			destructuring_bind_must_consp(current, datum, $list_alt12);
			{
				SubLObject temp = current.rest();
				current = current.first();
				{
					SubLObject filename_var = NIL;
					SubLObject filename = NIL;
					destructuring_bind_must_consp(current, datum, $list_alt12);
					filename_var = current.first();
					current = current.rest();
					destructuring_bind_must_consp(current, datum, $list_alt12);
					filename = current.first();
					current = current.rest();
					if (NIL == current) {
						current = temp;
						{
							SubLObject body = current;
							return listS(CLET, list(list(filename_var, filename)),
									append(body, list(list(DISCARD_DUMP_FILENAME, filename_var))));
						}
					} else {
						cdestructuring_bind_error(datum, $list_alt12);
					}
				}
			}
		}
		return NIL;
	}

	public static SubLObject with_kb_dump_filename(final SubLObject macroform, final SubLObject environment) {
		SubLObject current;
		final SubLObject datum = current = macroform.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list12);
		final SubLObject temp = current.rest();
		current = current.first();
		SubLObject filename_var = NIL;
		SubLObject filename = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list12);
		filename_var = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list12);
		filename = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject body;
			current = body = temp;
			return listS(CLET, list(list(filename_var, filename)),
					append(body, list(list(dumper.DISCARD_DUMP_FILENAME, filename_var))));
		}
		cdestructuring_bind_error(datum, dumper.$list12);
		return NIL;
	}

	public static final SubLObject with_kb_dump_binary_file_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			destructuring_bind_must_consp(current, datum, $list_alt14);
			{
				SubLObject temp = current.rest();
				current = current.first();
				{
					SubLObject stream = NIL;
					SubLObject filename = NIL;
					SubLObject direction = NIL;
					destructuring_bind_must_consp(current, datum, $list_alt14);
					stream = current.first();
					current = current.rest();
					destructuring_bind_must_consp(current, datum, $list_alt14);
					filename = current.first();
					current = current.rest();
					destructuring_bind_must_consp(current, datum, $list_alt14);
					direction = current.first();
					current = current.rest();
					if (NIL == current) {
						current = temp;
						{
							SubLObject body = current;
							SubLObject filename_var = $sym15$FILENAME_VAR;
							return list(WITH_KB_DUMP_FILENAME, list(filename_var, filename),
									listS(WITH_PRIVATE_BINARY_FILE, list(stream, filename_var, direction),
											append(body, NIL)));
						}
					} else {
						cdestructuring_bind_error(datum, $list_alt14);
					}
				}
			}
		}
		return NIL;
	}

	public static SubLObject with_kb_dump_binary_file(final SubLObject macroform, final SubLObject environment) {
		SubLObject current;
		final SubLObject datum = current = macroform.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		final SubLObject temp = current.rest();
		current = current.first();
		SubLObject stream = NIL;
		SubLObject filename = NIL;
		SubLObject direction = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		stream = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		filename = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		direction = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject body;
			current = body = temp;
			final SubLObject filename_var = dumper.$sym15$FILENAME_VAR;
			return list(dumper.WITH_KB_DUMP_FILENAME, list(filename_var, filename),
					list(WITH_PRIVATE_BINARY_FILE, list(stream, filename_var, direction),
							list(PWHEN, listS(EQ, direction, dumper.$list19),
									list(CSETQ, stream, list(dumper.ENABLE_FILE_STREAM_MEMORY_MAPPING, stream))),
							list(CUNWIND_PROTECT, bq_cons(PROGN, append(body, NIL)), list(CLOSE, stream))));
		}
		cdestructuring_bind_error(datum, dumper.$list14);
		return NIL;
	}

	public static final SubLObject with_kb_dump_text_file_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			destructuring_bind_must_consp(current, datum, $list_alt14);
			{
				SubLObject temp = current.rest();
				current = current.first();
				{
					SubLObject stream = NIL;
					SubLObject filename = NIL;
					SubLObject direction = NIL;
					destructuring_bind_must_consp(current, datum, $list_alt14);
					stream = current.first();
					current = current.rest();
					destructuring_bind_must_consp(current, datum, $list_alt14);
					filename = current.first();
					current = current.rest();
					destructuring_bind_must_consp(current, datum, $list_alt14);
					direction = current.first();
					current = current.rest();
					if (NIL == current) {
						current = temp;
						{
							SubLObject body = current;
							SubLObject filename_var = $sym18$FILENAME_VAR;
							return list(WITH_KB_DUMP_FILENAME, list(filename_var, filename), listS(
									WITH_PRIVATE_TEXT_FILE, list(stream, filename_var, direction), append(body, NIL)));
						}
					} else {
						cdestructuring_bind_error(datum, $list_alt14);
					}
				}
			}
		}
		return NIL;
	}

	public static SubLObject with_kb_dump_text_file(final SubLObject macroform, final SubLObject environment) {
		SubLObject current;
		final SubLObject datum = current = macroform.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		final SubLObject temp = current.rest();
		current = current.first();
		SubLObject stream = NIL;
		SubLObject filename = NIL;
		SubLObject direction = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		stream = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		filename = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list14);
		direction = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject body;
			current = body = temp;
			final SubLObject filename_var = dumper.$sym25$FILENAME_VAR;
			return list(dumper.WITH_KB_DUMP_FILENAME, list(filename_var, filename),
					list(WITH_PRIVATE_TEXT_FILE, list(stream, filename_var, direction),
							list(PWHEN, listS(EQ, direction, dumper.$list19),
									list(CSETQ, stream, list(dumper.ENABLE_FILE_STREAM_MEMORY_MAPPING, stream))),
							list(CUNWIND_PROTECT, bq_cons(PROGN, append(body, NIL)), list(CLOSE, stream))));
		}
		cdestructuring_bind_error(datum, dumper.$list14);
		return NIL;
	}

	public static final SubLObject discard_dump_filename_alt(SubLObject filename) {
		SubLTrampolineFile.checkType(filename, STRINGP);
		return fill(filename, CHAR_space, UNPROVIDED, UNPROVIDED);
	}

	public static SubLObject discard_dump_filename(final SubLObject filename) {
		assert NIL != stringp(filename) : "! stringp(filename) "
				+ ("Types.stringp(filename) " + "CommonSymbols.NIL != Types.stringp(filename) ") + filename;
		return fill(filename, CHAR_space, UNPROVIDED, UNPROVIDED);
	}

	public static SubLObject with_pergamom_style_units(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return listS(CLET, dumper.$list28, append(body, NIL));
	}

	public static SubLObject with_kelsos_style_units(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return listS(CLET, dumper.$list29, append(body, NIL));
	}

	/**
	 * Return the standard KB dump directory for a dump named DUMP-NAME
	 */
	@LispMethod(comment = "Return the standard KB dump directory for a dump named DUMP-NAME")
	public static final SubLObject kb_dump_directory_alt(SubLObject dump_name, SubLObject units_path) {
		if (dump_name == UNPROVIDED) {
			dump_name = kb_loaded();
		}
		if (units_path == UNPROVIDED) {
			units_path = $default_dump_path$.getDynamicValue();
		}
		{
			SubLObject dump_directory_name = (dump_name.isInteger())
					? ((SubLObject) (format(NIL, $str_alt24$_4__0D, dump_name)))
					: Strings.string(dump_name);
			SubLObject directory_path = append(units_path, list(dump_directory_name));
			return file_utilities.cyc_home_filename(directory_path, NIL, NIL);
		}
	}

	/**
	 * Return the standard KB dump directory for a dump named DUMP-NAME
	 */
	@LispMethod(comment = "Return the standard KB dump directory for a dump named DUMP-NAME")
	public static SubLObject kb_dump_directory(SubLObject dump_name, SubLObject units_path) {
		if (dump_name == UNPROVIDED) {
			dump_name = kb_loaded();
		}
		if (units_path == UNPROVIDED) {
			units_path = dumper.$default_dump_path$.getDynamicValue();
		}
		final SubLObject dump_directory_name = (dump_name.isInteger())
				? operation_communication.kb_number_string(dump_name)
				: Strings.string(dump_name);
		final SubLObject directory_path = append(units_path, list(dump_directory_name));
		return file_utilities.cyc_home_filename(directory_path, NIL, NIL);
	}

	public static SubLObject get_wide_mark_basename_from_index_basename(final SubLObject index_base_name) {
		return cconcatenate(index_base_name, dumper.$kb_dump_fvector_wide_mark_tag$.getGlobalValue());
	}

	/**
	 * Return the KB dump file NAME.EXTENSION in the dump directory DIRECTORY-PATH
	 */
	@LispMethod(comment = "Return the KB dump file NAME.EXTENSION in the dump directory DIRECTORY-PATH")
	public static final SubLObject kb_dump_file_alt(SubLObject name, SubLObject directory_path, SubLObject extension) {
		if (extension == UNPROVIDED) {
			extension = $default_dump_extension$.getDynamicValue();
		}
		return file_utilities.relative_filename(directory_path, name, extension);
	}

	/**
	 * Return the KB dump file NAME.EXTENSION in the dump directory DIRECTORY-PATH
	 */
	@LispMethod(comment = "Return the KB dump file NAME.EXTENSION in the dump directory DIRECTORY-PATH")
	public static SubLObject kb_dump_file(final SubLObject name, final SubLObject directory_path,
			SubLObject extension) {
		if (extension == UNPROVIDED) {
			extension = dumper.$default_dump_extension$.getDynamicValue();
		}
		return file_utilities.relative_filename(directory_path, name, extension);
	}

	/**
	 * Return the KB dump cache file NAME.EXTENSION in the dump directory
	 * DIRECTORY-PATH
	 */
	@LispMethod(comment = "Return the KB dump cache file NAME.EXTENSION in the dump directory DIRECTORY-PATH")
	public static final SubLObject kb_dump_product_file_alt(SubLObject name, SubLObject directory_path,
			SubLObject extension) {
		if (extension == UNPROVIDED) {
			extension = $default_dump_product_extension$.getDynamicValue();
		}
		return file_utilities.relative_filename(directory_path, name, extension);
	}

	/**
	 * Return the KB dump cache file NAME.EXTENSION in the dump directory
	 * DIRECTORY-PATH
	 */
	@LispMethod(comment = "Return the KB dump cache file NAME.EXTENSION in the dump directory DIRECTORY-PATH")
	public static SubLObject kb_dump_product_file(final SubLObject name, final SubLObject directory_path,
			SubLObject extension) {
		if (extension == UNPROVIDED) {
			extension = dumper.$default_dump_product_extension$.getDynamicValue();
		}
		return file_utilities.relative_filename(directory_path, name, extension);
	}

	/**
	 * Return the estimated amount of filespace in bytes needed for a KB dump with
	 * ASSERTION-COUNT assertions.
	 */
	@LispMethod(comment = "Return the estimated amount of filespace in bytes needed for a KB dump\r\nwith ASSERTION-COUNT assertions.\nReturn the estimated amount of filespace in bytes needed for a KB dump\nwith ASSERTION-COUNT assertions.")
	public static final SubLObject dump_estimated_size_alt(SubLObject assertion_count) {
		if (assertion_count == UNPROVIDED) {
			assertion_count = assertion_handles.assertion_count();
		}
		return multiply($dump_bytes_per_assertion$.getGlobalValue(), assertion_count);
	}

	/**
	 * Return the estimated amount of filespace in bytes needed for a KB dump with
	 * ASSERTION-COUNT assertions.
	 */
	@LispMethod(comment = "Return the estimated amount of filespace in bytes needed for a KB dump\r\nwith ASSERTION-COUNT assertions.\nReturn the estimated amount of filespace in bytes needed for a KB dump\nwith ASSERTION-COUNT assertions.")
	public static SubLObject dump_estimated_size(SubLObject assertion_count) {
		if (assertion_count == UNPROVIDED) {
			assertion_count = assertion_handles.assertion_count();
		}
		return multiply(dumper.$dump_bytes_per_assertion$.getGlobalValue(), assertion_count);
	}

	/**
	 * Generate an error if FILENAME does not exist.
	 *
	 * @param WARN-ONLY?; if t, warns instead of errors if FILENAME does not exist.
	 */
	@LispMethod(comment = "Generate an error if FILENAME does not exist.\r\n\r\n@param WARN-ONLY?;\r\n\t\tif t, warns instead of errors if FILENAME does not exist.")
	public static final SubLObject verify_file_existence_alt(SubLObject filename, SubLObject warn_onlyP) {
		if (warn_onlyP == UNPROVIDED) {
			warn_onlyP = NIL;
		}
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			SubLTrampolineFile.checkType(filename, STRINGP);
			if (NIL != $dump_verify$.getDynamicValue(thread)) {
				if (NIL == Filesys.probe_file(filename)) {
					if (NIL != warn_onlyP) {
						Errors.warn($str_alt26$file__s_not_found, filename);
					} else {
						Errors.error($str_alt26$file__s_not_found, filename);
					}
					return NIL;
				}
			}
			return T;
		}
	}

	/**
	 * Generate an error if FILENAME does not exist.
	 *
	 * @param WARN-ONLY?; if t, warns instead of errors if FILENAME does not exist.
	 */
	@LispMethod(comment = "Generate an error if FILENAME does not exist.\r\n\r\n@param WARN-ONLY?;\r\n\t\tif t, warns instead of errors if FILENAME does not exist.")
	public static SubLObject verify_file_existence(final SubLObject filename, SubLObject warn_onlyP) {
		if (warn_onlyP == UNPROVIDED) {
			warn_onlyP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		assert NIL != stringp(filename) : "! stringp(filename) "
				+ ("Types.stringp(filename) " + "CommonSymbols.NIL != Types.stringp(filename) ") + filename;
		if ((NIL != dumper.$dump_verify$.getDynamicValue(thread)) && (NIL == Filesys.probe_file(filename))) {
			if (NIL != warn_onlyP) {
				Errors.warn(dumper.$str35$file__s_not_found, filename);
			} else {
				Errors.error(dumper.$str35$file__s_not_found, filename);
			}
			return NIL;
		}
		return T;
	}

	public static final SubLObject validate_dump_directory_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			SubLTrampolineFile.checkType(directory_path, STRINGP);
			if (NIL != $dump_verify$.getDynamicValue(thread)) {
				if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
					if (NIL == Filesys.directory_p(directory_path)) {
						Errors.error($str_alt27$Directory__S_does_not_exist_, directory_path);
					}
				}
				if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
					if (NIL == file_utilities.directory_writeable_p(directory_path, UNPROVIDED)) {
						Errors.error($str_alt28$Directory__S_cannot_be_written_to, directory_path);
					}
				}
				{
					SubLObject dump_estimated_size = com.cyc.cycjava.cycl.dumper.dump_estimated_size(UNPROVIDED);
					if (NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) {
						if (NIL == file_utilities.directory_writeable_p(directory_path, dump_estimated_size)) {
							Errors.error($str_alt29$Directory__S_does_not_have_enough, directory_path,
									dump_estimated_size);
						}
					}
				}
			}
			return T;
		}
	}

	public static SubLObject validate_dump_directory(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		assert NIL != stringp(directory_path) : "! stringp(directory_path) "
				+ ("Types.stringp(directory_path) " + "CommonSymbols.NIL != Types.stringp(directory_path) ")
				+ directory_path;
		if (NIL != dumper.$dump_verify$.getDynamicValue(thread)) {
			if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread))
					&& (NIL == Filesys.directory_p(directory_path))) {
				Errors.error(dumper.$str36$Directory__S_does_not_exist_, directory_path);
			}
			if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread))
					&& directory_path.equalp(misc_utilities.hl_store_caches_directory())) {
				Errors.error(dumper.$str37$Directory__S_is_not_different_fro, directory_path);
			}
			if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread))
					&& (NIL == file_utilities.directory_writeable_p(directory_path, UNPROVIDED))) {
				Errors.error(dumper.$str38$Directory__S_cannot_be_written_to, directory_path);
			}
			final SubLObject dump_estimated_size = dumper.dump_estimated_size(UNPROVIDED);
			if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread))
					&& (NIL == file_utilities.directory_writeable_p(directory_path, dump_estimated_size))) {
				Errors.error(dumper.$str39$Directory__S_does_not_have_enough, directory_path, dump_estimated_size);
			}
		}
		return T;
	}

	public static final SubLObject kb_load_gc_checkpoint_alt() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $kb_load_gc_checkpoints_enabledP$.getDynamicValue(thread)) {
			}
			return NIL;
		}
	}

	public static SubLObject kb_load_gc_checkpoint() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$kb_load_gc_checkpoints_enabledP$.getDynamicValue(thread)) {
			final SubLObject str = dumper.$str40$KB_Load_GC_checkpoint_reached____;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				Storage.gc_dynamic();
				Storage.room(UNPROVIDED);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject preprocess_experience_and_dump_standard_kb_alt(SubLObject directory_path,
			SubLObject old_experience_file, SubLObject new_experience_directory) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		if (old_experience_file == UNPROVIDED) {
			old_experience_file = NIL;
		}
		if (new_experience_directory == UNPROVIDED) {
			new_experience_directory = NIL;
		}
		com.cyc.cycjava.cycl.dumper.preprocess_experience(old_experience_file, new_experience_directory);
		return com.cyc.cycjava.cycl.dumper.dump_standard_kb(directory_path);
	}

	public static SubLObject preprocess_experience_and_dump_standard_kb(SubLObject directory_path,
			SubLObject old_experience_file, SubLObject new_experience_directory) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		if (old_experience_file == UNPROVIDED) {
			old_experience_file = NIL;
		}
		if (new_experience_directory == UNPROVIDED) {
			new_experience_directory = NIL;
		}
		dumper.preprocess_experience(old_experience_file, new_experience_directory);
		return dumper.dump_standard_kb(directory_path);
	}

	/**
	 * Dump the KB to the directory DIRECTORY-PATH after performing the standard
	 * preparations.
	 */
	@LispMethod(comment = "Dump the KB to the directory DIRECTORY-PATH after performing the standard preparations.")
	public static final SubLObject dump_standard_kb_alt(SubLObject directory_path) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		com.cyc.cycjava.cycl.dumper.perform_standard_pre_dump_kb_cleanups();
		return com.cyc.cycjava.cycl.dumper.dump_kb(directory_path);
	}

	/**
	 * Dump the KB to the directory DIRECTORY-PATH after performing the standard
	 * preparations.
	 */
	@LispMethod(comment = "Dump the KB to the directory DIRECTORY-PATH after performing the standard preparations.")
	public static SubLObject dump_standard_kb(SubLObject directory_path) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		dumper.perform_standard_pre_dump_kb_cleanups();
		return dumper.dump_kb(directory_path);
	}

	public static final SubLObject perform_standard_pre_dump_kb_cleanups_alt() {
		com.cyc.cycjava.cycl.dumper.perform_kb_cleanups();
		com.cyc.cycjava.cycl.dumper.rebuild_kb_indexing();
		assertions_low.rebuild_rule_set();
		com.cyc.cycjava.cycl.dumper.rebuild_sbhl_data();
		com.cyc.cycjava.cycl.dumper.rebuild_sbhl_cache();
		cardinality_estimates.rebuild_cardinality_estimates();
		tva_cache.rebuild_tva_cache();
		reformulator_rule_unifier_datastructures.rebuild_reformulator_rules();
		lexicon_cache.initialize_lexicon_from_kb();
		com.cyc.cycjava.cycl.dumper.rebuild_pph_phrases();
		skolems.reset_skolem_defn_table(T, NIL);
		wff_utilities.possibly_load_newer_non_wff_store();
		return NIL;
	}

	public static SubLObject perform_standard_pre_dump_kb_cleanups() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		return NIL != dumper.$perform_standard_pre_dump_kb_cleanups_completeP$.getDynamicValue(thread)
				? dumper.perform_standard_pre_dump_kb_cleanups_complete()
				: dumper.perform_standard_pre_dump_kb_cleanups_partial();
	}

	public static SubLObject perform_standard_pre_dump_kb_cleanups_complete() {
		dumper.perform_kb_cleanups();
		dumper.rebuild_computable_kb();
		dumper.rebuild_computable_remaining_hl(UNPROVIDED);
		return NIL;
	}

	public static SubLObject perform_standard_pre_dump_kb_cleanups_partial() {
		dumper.perform_kb_cleanups();
		assertions_low.rebuild_rule_set();
		assertions_low.rebuild_non_true_assertion_tv_cache();
		dumper.rebuild_kb_indexing();
		dumper.rebuild_sbhl_data();
		dumper.rebuild_sbhl_cache();
		cardinality_estimates.rebuild_cardinality_estimates();
		tva_cache.rebuild_tva_cache();
		reformulator_rule_unifier_datastructures.rebuild_reformulator_rules();
		lexicon_cache.initialize_lexicon_from_kb();
		dumper.rebuild_pph_phrases();
		skolems.reset_skolem_defn_table(T, NIL);
		return NIL;
	}

	public static final SubLObject perform_kb_cleanups_alt() {
		assertions_high.remove_broken_assertions();
		kb_cleanup.reconsider_assertions_with_no_arguments(UNPROVIDED);
		kb_cleanup.forget_unneeded_knowledge();
		skolems.possibly_rehabilitate_skolem_defn_table();
		return NIL;
	}

	public static SubLObject perform_kb_cleanups() {
		assertions_high.remove_broken_assertions();
		kb_cleanup.reconsider_assertions_with_no_arguments(UNPROVIDED);
		kb_cleanup.forget_unneeded_knowledge(UNPROVIDED);
		return NIL;
	}

	/**
	 * Clears any local experience, replaces it with OLD-EXPERIENCE-FILE, then
	 * iterates over each experience transcript in NEW-EXPERIENCE-DIRECTORY, merging
	 * its experience in.
	 */
	@LispMethod(comment = "Clears any local experience, replaces it with OLD-EXPERIENCE-FILE,\r\nthen iterates over each experience transcript in NEW-EXPERIENCE-DIRECTORY,\r\nmerging its experience in.\nClears any local experience, replaces it with OLD-EXPERIENCE-FILE,\nthen iterates over each experience transcript in NEW-EXPERIENCE-DIRECTORY,\nmerging its experience in.")
	public static final SubLObject preprocess_experience_alt(SubLObject old_experience_file,
			SubLObject new_experience_directory) {
		if (old_experience_file == UNPROVIDED) {
			old_experience_file = NIL;
		}
		if (new_experience_directory == UNPROVIDED) {
			new_experience_directory = NIL;
		}
		if (NIL == old_experience_file) {
			{
				SubLObject previous_dump_directory = com.cyc.cycjava.cycl.dumper.kb_dump_directory(build_kb_loaded(),
						UNPROVIDED);
				old_experience_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt30$rule_utility_experience,
						previous_dump_directory, UNPROVIDED);
			}
		}
		if (NIL == new_experience_directory) {
			new_experience_directory = transcript_utilities.transcript_directory();
		}
		inference_analysis.replace_and_collate_experience(old_experience_file, new_experience_directory);
		return NIL;
	}

	/**
	 * Clears any local experience, replaces it with OLD-EXPERIENCE-FILE, then
	 * iterates over each experience transcript in NEW-EXPERIENCE-DIRECTORY, merging
	 * its experience in.
	 */
	@LispMethod(comment = "Clears any local experience, replaces it with OLD-EXPERIENCE-FILE,\r\nthen iterates over each experience transcript in NEW-EXPERIENCE-DIRECTORY,\r\nmerging its experience in.\nClears any local experience, replaces it with OLD-EXPERIENCE-FILE,\nthen iterates over each experience transcript in NEW-EXPERIENCE-DIRECTORY,\nmerging its experience in.")
	public static SubLObject preprocess_experience(SubLObject old_experience_file,
			SubLObject new_experience_directory) {
		if (old_experience_file == UNPROVIDED) {
			old_experience_file = NIL;
		}
		if (new_experience_directory == UNPROVIDED) {
			new_experience_directory = NIL;
		}
		if (NIL == old_experience_file) {
			final SubLObject previous_dump_directory = dumper.kb_dump_directory(build_kb_loaded(), UNPROVIDED);
			old_experience_file = dumper.kb_dump_file(dumper.$str41$rule_utility_experience, previous_dump_directory,
					UNPROVIDED);
		}
		if (NIL == new_experience_directory) {
			new_experience_directory = transcript_utilities.transcript_directory();
		}
		inference_analysis.replace_and_collate_experience(old_experience_file, new_experience_directory);
		return NIL;
	}

	public static final SubLObject preprocess_experience_and_dump_non_computable_kb_alt(
			SubLObject non_computable_directory_path, SubLObject old_experience_file,
			SubLObject new_experience_directory) {
		if (non_computable_directory_path == UNPROVIDED) {
			non_computable_directory_path = NIL;
		}
		if (old_experience_file == UNPROVIDED) {
			old_experience_file = NIL;
		}
		if (new_experience_directory == UNPROVIDED) {
			new_experience_directory = NIL;
		}
		com.cyc.cycjava.cycl.dumper.preprocess_experience(old_experience_file, new_experience_directory);
		com.cyc.cycjava.cycl.dumper.dump_non_computable_kb(non_computable_directory_path);
		com.cyc.cycjava.cycl.dumper.generate_kb_dump_reports(builder_utilities.builder_log_directory(), UNPROVIDED);
		return NIL;
	}

	public static SubLObject preprocess_experience_and_dump_non_computable_kb(SubLObject non_computable_directory_path,
			SubLObject old_experience_file, SubLObject new_experience_directory) {
		if (non_computable_directory_path == UNPROVIDED) {
			non_computable_directory_path = NIL;
		}
		if (old_experience_file == UNPROVIDED) {
			old_experience_file = NIL;
		}
		if (new_experience_directory == UNPROVIDED) {
			new_experience_directory = NIL;
		}
		dumper.preprocess_experience(old_experience_file, new_experience_directory);
		dumper.dump_non_computable_kb(non_computable_directory_path);
		return NIL;
	}

	public static final SubLObject dump_non_computable_kb_alt(SubLObject non_computable_directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.dump_special_objects(non_computable_directory_path);
			{
				SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
				try {
					$cfasl_common_symbols$.bind(NIL, thread);
					cfasl_set_common_symbols(com.cyc.cycjava.cycl.dumper.kb_dump_common_symbols());
					{
						SubLObject _prev_bind_0_1 = constants_high.$constant_dump_id_table$.currentBinding(thread);
						SubLObject _prev_bind_1 = api_control_vars.$cfasl_constant_handle_func$.currentBinding(thread);
						SubLObject _prev_bind_2 = narts_high.$nart_dump_id_table$.currentBinding(thread);
						SubLObject _prev_bind_3 = api_control_vars.$cfasl_nart_handle_func$.currentBinding(thread);
						SubLObject _prev_bind_4 = unrepresented_terms.$unrepresented_term_dump_id_table$
								.currentBinding(thread);
						SubLObject _prev_bind_5 = assertions_high.$assertion_dump_id_table$.currentBinding(thread);
						SubLObject _prev_bind_6 = api_control_vars.$cfasl_assertion_handle_func$.currentBinding(thread);
						SubLObject _prev_bind_7 = deductions_high.$deduction_dump_id_table$.currentBinding(thread);
						SubLObject _prev_bind_8 = api_control_vars.$cfasl_deduction_handle_func$.currentBinding(thread);
						SubLObject _prev_bind_9 = kb_hl_supports.$kb_hl_support_dump_id_table$.currentBinding(thread);
						SubLObject _prev_bind_10 = api_control_vars.$cfasl_kb_hl_support_handle_func$
								.currentBinding(thread);
						SubLObject _prev_bind_11 = clause_strucs.$clause_struc_dump_id_table$.currentBinding(thread);
						SubLObject _prev_bind_12 = api_control_vars.$cfasl_clause_struc_handle_func$
								.currentBinding(thread);
						try {
							constants_high.$constant_dump_id_table$.bind(create_constant_dump_id_table(), thread);
							api_control_vars.$cfasl_constant_handle_func$.bind(CONSTANT_DUMP_ID, thread);
							narts_high.$nart_dump_id_table$.bind(nart_handles.create_nart_dump_id_table(), thread);
							api_control_vars.$cfasl_nart_handle_func$.bind(NART_DUMP_ID, thread);
							unrepresented_terms.$unrepresented_term_dump_id_table$
									.bind(unrepresented_terms.create_unrepresented_term_dump_id_table(), thread);
							assertions_high.$assertion_dump_id_table$
									.bind(assertion_handles.create_assertion_dump_id_table(), thread);
							api_control_vars.$cfasl_assertion_handle_func$.bind(ASSERTION_DUMP_ID, thread);
							deductions_high.$deduction_dump_id_table$
									.bind(deduction_handles.create_deduction_dump_id_table(), thread);
							api_control_vars.$cfasl_deduction_handle_func$.bind(DEDUCTION_DUMP_ID, thread);
							kb_hl_supports.$kb_hl_support_dump_id_table$
									.bind(kb_hl_supports.create_kb_hl_support_dump_id_table(), thread);
							api_control_vars.$cfasl_kb_hl_support_handle_func$.bind(KB_HL_SUPPORT_DUMP_ID, thread);
							clause_strucs.$clause_struc_dump_id_table$
									.bind(clause_strucs.create_clause_struc_dump_id_table(), thread);
							api_control_vars.$cfasl_clause_struc_handle_func$.bind(CLAUSE_STRUC_DUMP_ID, thread);
							com.cyc.cycjava.cycl.dumper.dump_kb_ids(non_computable_directory_path);
							com.cyc.cycjava.cycl.dumper.dump_essential_kb(non_computable_directory_path);
						} finally {
							api_control_vars.$cfasl_clause_struc_handle_func$.rebind(_prev_bind_12, thread);
							clause_strucs.$clause_struc_dump_id_table$.rebind(_prev_bind_11, thread);
							api_control_vars.$cfasl_kb_hl_support_handle_func$.rebind(_prev_bind_10, thread);
							kb_hl_supports.$kb_hl_support_dump_id_table$.rebind(_prev_bind_9, thread);
							api_control_vars.$cfasl_deduction_handle_func$.rebind(_prev_bind_8, thread);
							deductions_high.$deduction_dump_id_table$.rebind(_prev_bind_7, thread);
							api_control_vars.$cfasl_assertion_handle_func$.rebind(_prev_bind_6, thread);
							assertions_high.$assertion_dump_id_table$.rebind(_prev_bind_5, thread);
							unrepresented_terms.$unrepresented_term_dump_id_table$.rebind(_prev_bind_4, thread);
							api_control_vars.$cfasl_nart_handle_func$.rebind(_prev_bind_3, thread);
							narts_high.$nart_dump_id_table$.rebind(_prev_bind_2, thread);
							api_control_vars.$cfasl_constant_handle_func$.rebind(_prev_bind_1, thread);
							constants_high.$constant_dump_id_table$.rebind(_prev_bind_0_1, thread);
						}
					}
				} finally {
					$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_non_computable_kb(final SubLObject non_computable_directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			dumper.dump_special_objects(non_computable_directory_path);
			final SubLObject _prev_bind_0_$1 = $cfasl_common_symbols$.currentBinding(thread);
			try {
				$cfasl_common_symbols$.bind(NIL, thread);
				cfasl_set_common_symbols(dumper.kb_dump_common_symbols());
				final SubLObject _prev_bind_0_$2 = constants_high.$constant_dump_id_table$.currentBinding(thread);
				final SubLObject _prev_bind_1_$3 = api_control_vars.$cfasl_constant_handle_func$.currentBinding(thread);
				final SubLObject _prev_bind_3 = narts_high.$nart_dump_id_table$.currentBinding(thread);
				final SubLObject _prev_bind_4 = api_control_vars.$cfasl_nart_handle_func$.currentBinding(thread);
				final SubLObject _prev_bind_5 = unrepresented_terms.$unrepresented_term_dump_id_table$
						.currentBinding(thread);
				final SubLObject _prev_bind_6 = assertions_high.$assertion_dump_id_table$.currentBinding(thread);
				final SubLObject _prev_bind_7 = api_control_vars.$cfasl_assertion_handle_func$.currentBinding(thread);
				final SubLObject _prev_bind_8 = deductions_high.$deduction_dump_id_table$.currentBinding(thread);
				final SubLObject _prev_bind_9 = api_control_vars.$cfasl_deduction_handle_func$.currentBinding(thread);
				final SubLObject _prev_bind_10 = kb_hl_supports_high.$kb_hl_support_dump_id_table$
						.currentBinding(thread);
				final SubLObject _prev_bind_11 = api_control_vars.$cfasl_kb_hl_support_handle_func$
						.currentBinding(thread);
				final SubLObject _prev_bind_12 = clause_strucs.$clause_struc_dump_id_table$.currentBinding(thread);
				final SubLObject _prev_bind_13 = api_control_vars.$cfasl_clause_struc_handle_func$
						.currentBinding(thread);
				try {
					constants_high.$constant_dump_id_table$.bind(create_constant_dump_id_table(), thread);
					api_control_vars.$cfasl_constant_handle_func$.bind(dumper.CONSTANT_DUMP_ID, thread);
					narts_high.$nart_dump_id_table$.bind(nart_handles.create_nart_dump_id_table(), thread);
					api_control_vars.$cfasl_nart_handle_func$.bind(dumper.NART_DUMP_ID, thread);
					unrepresented_terms.$unrepresented_term_dump_id_table$
							.bind(unrepresented_terms.create_unrepresented_term_dump_id_table(), thread);
					assertions_high.$assertion_dump_id_table$.bind(assertion_handles.create_assertion_dump_id_table(),
							thread);
					api_control_vars.$cfasl_assertion_handle_func$.bind(dumper.ASSERTION_DUMP_ID, thread);
					deductions_high.$deduction_dump_id_table$.bind(deduction_handles.create_deduction_dump_id_table(),
							thread);
					api_control_vars.$cfasl_deduction_handle_func$.bind(dumper.DEDUCTION_DUMP_ID, thread);
					kb_hl_supports_high.$kb_hl_support_dump_id_table$
							.bind(kb_hl_support_handles.create_kb_hl_support_dump_id_table(), thread);
					api_control_vars.$cfasl_kb_hl_support_handle_func$.bind(dumper.KB_HL_SUPPORT_DUMP_ID, thread);
					clause_strucs.$clause_struc_dump_id_table$.bind(clause_strucs.create_clause_struc_dump_id_table(),
							thread);
					api_control_vars.$cfasl_clause_struc_handle_func$.bind(dumper.CLAUSE_STRUC_DUMP_ID, thread);
					dumper.dump_kb_ids(non_computable_directory_path);
					dumper.dump_essential_kb(non_computable_directory_path);
				} finally {
					api_control_vars.$cfasl_clause_struc_handle_func$.rebind(_prev_bind_13, thread);
					clause_strucs.$clause_struc_dump_id_table$.rebind(_prev_bind_12, thread);
					api_control_vars.$cfasl_kb_hl_support_handle_func$.rebind(_prev_bind_11, thread);
					kb_hl_supports_high.$kb_hl_support_dump_id_table$.rebind(_prev_bind_10, thread);
					api_control_vars.$cfasl_deduction_handle_func$.rebind(_prev_bind_9, thread);
					deductions_high.$deduction_dump_id_table$.rebind(_prev_bind_8, thread);
					api_control_vars.$cfasl_assertion_handle_func$.rebind(_prev_bind_7, thread);
					assertions_high.$assertion_dump_id_table$.rebind(_prev_bind_6, thread);
					unrepresented_terms.$unrepresented_term_dump_id_table$.rebind(_prev_bind_5, thread);
					api_control_vars.$cfasl_nart_handle_func$.rebind(_prev_bind_4, thread);
					narts_high.$nart_dump_id_table$.rebind(_prev_bind_3, thread);
					api_control_vars.$cfasl_constant_handle_func$.rebind(_prev_bind_1_$3, thread);
					constants_high.$constant_dump_id_table$.rebind(_prev_bind_0_$2, thread);
				}
			} finally {
				$cfasl_common_symbols$.rebind(_prev_bind_0_$1, thread);
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_non_computable_kb_and_rebuild_computable_kb_and_write_image_alt(
			SubLObject kb_loaded, SubLObject non_computable_directory_path,
			SubLObject pre_non_computable_dump_image_filename) {
		com.cyc.cycjava.cycl.dumper.load_non_computable_kb(non_computable_directory_path);
		set_kb_loaded(kb_loaded);
		com.cyc.cycjava.cycl.dumper.rebuild_computable_content_dumpable();
		return Mapper.write_image(pre_non_computable_dump_image_filename, UNPROVIDED);
	}

	public static SubLObject load_non_computable_kb_and_rebuild_computable_kb_and_write_image(
			final SubLObject kb_loaded, final SubLObject non_computable_directory_path,
			final SubLObject pre_non_computable_dump_image_filename) {
		dumper.load_non_computable_kb_and_rebuild_computable_kb(kb_loaded, non_computable_directory_path);
		return Mapper.write_image(pre_non_computable_dump_image_filename, UNPROVIDED);
	}

	public static final SubLObject load_non_computable_kb_alt(SubLObject non_computable_directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject common_symbols = com.cyc.cycjava.cycl.dumper
						.load_special_objects(non_computable_directory_path);
				if (NIL == $force_monolithic_kb_assumption$.getGlobalValue()) {
					initialize_hl_store_cache_directory_and_shared_symbols(non_computable_directory_path,
							common_symbols);
				}
				{
					SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
					try {
						$cfasl_common_symbols$.bind(NIL, thread);
						cfasl_set_common_symbols(common_symbols);
						{
							SubLObject _prev_bind_0_2 = api_control_vars.$cfasl_constant_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_1 = api_control_vars.$cfasl_nart_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_2 = api_control_vars.$cfasl_assertion_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_3 = api_control_vars.$cfasl_deduction_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_4 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_5 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
									.currentBinding(thread);
							try {
								api_control_vars.$cfasl_constant_handle_lookup_func$.bind(FIND_CONSTANT_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_nart_handle_lookup_func$.bind(FIND_NART_BY_DUMP_ID, thread);
								api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(FIND_ASSERTION_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(FIND_DEDUCTION_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
										.bind(FIND_KB_HL_SUPPORT_BY_DUMP_ID, thread);
								api_control_vars.$cfasl_clause_struc_handle_lookup_func$
										.bind(FIND_CLAUSE_STRUC_BY_DUMP_ID, thread);
								com.cyc.cycjava.cycl.dumper.load_essential_kb(non_computable_directory_path);
							} finally {
								api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_5, thread);
								api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_4, thread);
								api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_3, thread);
								api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_2, thread);
								api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_1, thread);
								api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_2, thread);
							}
						}
					} finally {
						$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_non_computable_kb(final SubLObject non_computable_directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject common_symbols = dumper.load_special_objects(non_computable_directory_path, UNPROVIDED);
		if (NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue()) {
			misc_utilities.initialize_hl_store_cache_directory_and_shared_symbols(non_computable_directory_path,
					common_symbols);
		}
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(common_symbols);
			final SubLObject _prev_bind_0_$4 = api_control_vars.$cfasl_constant_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_2 = api_control_vars.$cfasl_nart_handle_lookup_func$.currentBinding(thread);
			final SubLObject _prev_bind_3 = api_control_vars.$cfasl_assertion_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_4 = api_control_vars.$cfasl_deduction_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_5 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_6 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
					.currentBinding(thread);
			try {
				api_control_vars.$cfasl_constant_handle_lookup_func$.bind(dumper.FIND_CONSTANT_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.bind(dumper.FIND_NART_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(dumper.FIND_ASSERTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(dumper.FIND_DEDUCTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.bind(dumper.FIND_KB_HL_SUPPORT_BY_DUMP_ID,
						thread);
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.bind(dumper.FIND_CLAUSE_STRUC_BY_DUMP_ID,
						thread);
				dumper.load_essential_kb(non_computable_directory_path);
			} finally {
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_6, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_5, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_4, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_3, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_2, thread);
				api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_$4, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject load_non_computable_kb_and_rebuild_computable_kb(final SubLObject kb_loaded,
			final SubLObject non_computable_directory_path) {
		dumper.load_non_computable_kb(non_computable_directory_path);
		set_kb_loaded(kb_loaded);
		dumper.rebuild_computable_content_dumpable(UNPROVIDED);
		return kb_loaded;
	}

	public static final SubLObject dump_computable_kb_and_content_alt(SubLObject non_computable_directory_path,
			SubLObject computable_directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject common_symbols = com.cyc.cycjava.cycl.dumper
						.load_special_objects(non_computable_directory_path);
				{
					SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
					try {
						$cfasl_common_symbols$.bind(NIL, thread);
						cfasl_set_common_symbols(common_symbols);
						{
							SubLObject _prev_bind_0_3 = constants_high.$constant_dump_id_table$.currentBinding(thread);
							SubLObject _prev_bind_1 = api_control_vars.$cfasl_constant_handle_func$
									.currentBinding(thread);
							SubLObject _prev_bind_2 = narts_high.$nart_dump_id_table$.currentBinding(thread);
							SubLObject _prev_bind_3 = api_control_vars.$cfasl_nart_handle_func$.currentBinding(thread);
							SubLObject _prev_bind_4 = unrepresented_terms.$unrepresented_term_dump_id_table$
									.currentBinding(thread);
							SubLObject _prev_bind_5 = assertions_high.$assertion_dump_id_table$.currentBinding(thread);
							SubLObject _prev_bind_6 = api_control_vars.$cfasl_assertion_handle_func$
									.currentBinding(thread);
							SubLObject _prev_bind_7 = deductions_high.$deduction_dump_id_table$.currentBinding(thread);
							SubLObject _prev_bind_8 = api_control_vars.$cfasl_deduction_handle_func$
									.currentBinding(thread);
							SubLObject _prev_bind_9 = kb_hl_supports.$kb_hl_support_dump_id_table$
									.currentBinding(thread);
							SubLObject _prev_bind_10 = api_control_vars.$cfasl_kb_hl_support_handle_func$
									.currentBinding(thread);
							SubLObject _prev_bind_11 = clause_strucs.$clause_struc_dump_id_table$
									.currentBinding(thread);
							SubLObject _prev_bind_12 = api_control_vars.$cfasl_clause_struc_handle_func$
									.currentBinding(thread);
							try {
								constants_high.$constant_dump_id_table$.bind(create_constant_dump_id_table(), thread);
								api_control_vars.$cfasl_constant_handle_func$.bind(CONSTANT_DUMP_ID, thread);
								narts_high.$nart_dump_id_table$.bind(nart_handles.create_nart_dump_id_table(), thread);
								api_control_vars.$cfasl_nart_handle_func$.bind(NART_DUMP_ID, thread);
								unrepresented_terms.$unrepresented_term_dump_id_table$
										.bind(unrepresented_terms.create_unrepresented_term_dump_id_table(), thread);
								assertions_high.$assertion_dump_id_table$
										.bind(assertion_handles.create_assertion_dump_id_table(), thread);
								api_control_vars.$cfasl_assertion_handle_func$.bind(ASSERTION_DUMP_ID, thread);
								deductions_high.$deduction_dump_id_table$
										.bind(deduction_handles.create_deduction_dump_id_table(), thread);
								api_control_vars.$cfasl_deduction_handle_func$.bind(DEDUCTION_DUMP_ID, thread);
								kb_hl_supports.$kb_hl_support_dump_id_table$
										.bind(kb_hl_supports.create_kb_hl_support_dump_id_table(), thread);
								api_control_vars.$cfasl_kb_hl_support_handle_func$.bind(KB_HL_SUPPORT_DUMP_ID, thread);
								clause_strucs.$clause_struc_dump_id_table$
										.bind(clause_strucs.create_clause_struc_dump_id_table(), thread);
								api_control_vars.$cfasl_clause_struc_handle_func$.bind(CLAUSE_STRUC_DUMP_ID, thread);
								com.cyc.cycjava.cycl.dumper.dump_computable_content(computable_directory_path);
							} finally {
								api_control_vars.$cfasl_clause_struc_handle_func$.rebind(_prev_bind_12, thread);
								clause_strucs.$clause_struc_dump_id_table$.rebind(_prev_bind_11, thread);
								api_control_vars.$cfasl_kb_hl_support_handle_func$.rebind(_prev_bind_10, thread);
								kb_hl_supports.$kb_hl_support_dump_id_table$.rebind(_prev_bind_9, thread);
								api_control_vars.$cfasl_deduction_handle_func$.rebind(_prev_bind_8, thread);
								deductions_high.$deduction_dump_id_table$.rebind(_prev_bind_7, thread);
								api_control_vars.$cfasl_assertion_handle_func$.rebind(_prev_bind_6, thread);
								assertions_high.$assertion_dump_id_table$.rebind(_prev_bind_5, thread);
								unrepresented_terms.$unrepresented_term_dump_id_table$.rebind(_prev_bind_4, thread);
								api_control_vars.$cfasl_nart_handle_func$.rebind(_prev_bind_3, thread);
								narts_high.$nart_dump_id_table$.rebind(_prev_bind_2, thread);
								api_control_vars.$cfasl_constant_handle_func$.rebind(_prev_bind_1, thread);
								constants_high.$constant_dump_id_table$.rebind(_prev_bind_0_3, thread);
							}
						}
					} finally {
						$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_computable_kb_and_content(final SubLObject non_computable_directory_path,
			final SubLObject computable_directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject common_symbols = dumper.load_special_objects(non_computable_directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(common_symbols);
			final SubLObject _prev_bind_0_$5 = constants_high.$constant_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_2 = api_control_vars.$cfasl_constant_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_3 = narts_high.$nart_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_4 = api_control_vars.$cfasl_nart_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_5 = unrepresented_terms.$unrepresented_term_dump_id_table$
					.currentBinding(thread);
			final SubLObject _prev_bind_6 = assertions_high.$assertion_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_7 = api_control_vars.$cfasl_assertion_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_8 = deductions_high.$deduction_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_9 = api_control_vars.$cfasl_deduction_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_10 = kb_hl_supports_high.$kb_hl_support_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_11 = api_control_vars.$cfasl_kb_hl_support_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_12 = clause_strucs.$clause_struc_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_13 = api_control_vars.$cfasl_clause_struc_handle_func$.currentBinding(thread);
			try {
				constants_high.$constant_dump_id_table$.bind(create_constant_dump_id_table(), thread);
				api_control_vars.$cfasl_constant_handle_func$.bind(dumper.CONSTANT_DUMP_ID, thread);
				narts_high.$nart_dump_id_table$.bind(nart_handles.create_nart_dump_id_table(), thread);
				api_control_vars.$cfasl_nart_handle_func$.bind(dumper.NART_DUMP_ID, thread);
				unrepresented_terms.$unrepresented_term_dump_id_table$
						.bind(unrepresented_terms.create_unrepresented_term_dump_id_table(), thread);
				assertions_high.$assertion_dump_id_table$.bind(assertion_handles.create_assertion_dump_id_table(),
						thread);
				api_control_vars.$cfasl_assertion_handle_func$.bind(dumper.ASSERTION_DUMP_ID, thread);
				deductions_high.$deduction_dump_id_table$.bind(deduction_handles.create_deduction_dump_id_table(),
						thread);
				api_control_vars.$cfasl_deduction_handle_func$.bind(dumper.DEDUCTION_DUMP_ID, thread);
				kb_hl_supports_high.$kb_hl_support_dump_id_table$
						.bind(kb_hl_support_handles.create_kb_hl_support_dump_id_table(), thread);
				api_control_vars.$cfasl_kb_hl_support_handle_func$.bind(dumper.KB_HL_SUPPORT_DUMP_ID, thread);
				clause_strucs.$clause_struc_dump_id_table$.bind(clause_strucs.create_clause_struc_dump_id_table(),
						thread);
				api_control_vars.$cfasl_clause_struc_handle_func$.bind(dumper.CLAUSE_STRUC_DUMP_ID, thread);
				dumper.dump_computable_content(computable_directory_path);
			} finally {
				api_control_vars.$cfasl_clause_struc_handle_func$.rebind(_prev_bind_13, thread);
				clause_strucs.$clause_struc_dump_id_table$.rebind(_prev_bind_12, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_func$.rebind(_prev_bind_11, thread);
				kb_hl_supports_high.$kb_hl_support_dump_id_table$.rebind(_prev_bind_10, thread);
				api_control_vars.$cfasl_deduction_handle_func$.rebind(_prev_bind_9, thread);
				deductions_high.$deduction_dump_id_table$.rebind(_prev_bind_8, thread);
				api_control_vars.$cfasl_assertion_handle_func$.rebind(_prev_bind_7, thread);
				assertions_high.$assertion_dump_id_table$.rebind(_prev_bind_6, thread);
				unrepresented_terms.$unrepresented_term_dump_id_table$.rebind(_prev_bind_5, thread);
				api_control_vars.$cfasl_nart_handle_func$.rebind(_prev_bind_4, thread);
				narts_high.$nart_dump_id_table$.rebind(_prev_bind_3, thread);
				api_control_vars.$cfasl_constant_handle_func$.rebind(_prev_bind_2, thread);
				constants_high.$constant_dump_id_table$.rebind(_prev_bind_0_$5, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject load_non_computable_kb_plus_rebuild_and_dump_computable_kb(final SubLObject kb_loaded,
			final SubLObject non_computable_directory_path, SubLObject computable_directory_path) {
		if (computable_directory_path == UNPROVIDED) {
			computable_directory_path = NIL;
		}
		dumper.load_non_computable_kb_and_rebuild_computable_kb(kb_loaded, non_computable_directory_path);
		misc_utilities.system_code_initializations(UNPROVIDED);
		if (NIL == computable_directory_path) {
			computable_directory_path = non_computable_directory_path;
		}
		dumper.dump_computable_kb_and_content(non_computable_directory_path, computable_directory_path);
		return kb_loaded;
	}

	public static SubLObject rebuild_and_reconnect_computable_kb(final SubLObject kb_loaded,
			final SubLObject non_computable_directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		dumper.load_non_computable_kb(non_computable_directory_path);
		set_kb_loaded(kb_loaded);
		kb_utilities.resize_kb_object_manager_lru_caches_for_rebuild();
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(misc_utilities.get_hl_store_caches_shared_symbols());
			dumper.rebuild_and_reconnect_kb_indexing();
			final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
			final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
				final SubLObject manager_$6 = deduction_manager.$deduction_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$7 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$6);
				final SubLObject memory_mappedP_$8 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$6);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$6);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$6);
					final SubLObject manager_$7 = kb_hl_support_manager.$kb_hl_support_content_manager$
							.getGlobalValue();
					final SubLObject maintaining_countsP_$8 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$7);
					final SubLObject memory_mappedP_$9 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$7);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$7);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$7);
						final SubLObject manager_$8 = nart_index_manager.$nart_index_manager$.getGlobalValue();
						final SubLObject maintaining_countsP_$9 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$8);
						final SubLObject memory_mappedP_$10 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$8);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$8);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$8);
							final SubLObject manager_$9 = constant_index_manager.$constant_index_manager$
									.getGlobalValue();
							final SubLObject maintaining_countsP_$10 = kb_object_manager
									.kb_object_usage_counts_enabledP(manager_$9);
							final SubLObject memory_mappedP_$11 = kb_object_manager
									.kb_object_manager_memory_mappedP(manager_$9);
							try {
								kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$9);
								kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$9);
								final SubLObject _prev_bind_0_$18 = $save_asked_queriesP$.currentBinding(thread);
								try {
									$save_asked_queriesP$.bind(NIL, thread);
									dumper.rebuild_computable_remaining_hl(UNPROVIDED);
									dumper.dump_computable_remaining_hl(non_computable_directory_path, UNPROVIDED);
								} finally {
									$save_asked_queriesP$.rebind(_prev_bind_0_$18, thread);
								}
							} finally {
								final SubLObject _prev_bind_0_$19 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values = getValuesAsVector();
									if (NIL != maintaining_countsP_$10) {
										kb_object_manager.maintain_kb_object_usage_counts(manager_$9);
									}
									if (NIL == memory_mappedP_$11) {
										kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$9,
												dumper.$int$2048, $int$256);
									}
									restoreValuesFromVector(_values);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$19, thread);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$20 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values2 = getValuesAsVector();
								if (NIL != maintaining_countsP_$9) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$8);
								}
								if (NIL == memory_mappedP_$10) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$8,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values2);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$20, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$21 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values3 = getValuesAsVector();
							if (NIL != maintaining_countsP_$8) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$7);
							}
							if (NIL == memory_mappedP_$9) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$7,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values3);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$21, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$22 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values4 = getValuesAsVector();
						if (NIL != maintaining_countsP_$7) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$6);
						}
						if (NIL == memory_mappedP_$8) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$6, dumper.$int$2048,
									$int$256);
						}
						restoreValuesFromVector(_values4);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$22, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$23 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values5 = getValuesAsVector();
					if (NIL != maintaining_countsP) {
						kb_object_manager.maintain_kb_object_usage_counts(manager);
					}
					if (NIL == memory_mappedP) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values5);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$23, thread);
				}
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return kb_loaded;
	}

	public static SubLObject rebuild_and_reconnect_kb_indexing() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		assertions_low.rebuild_rule_set();
		dumper.dump_rule_set(misc_utilities.generic_caches_directory());
		assertions_low.rebuild_non_true_assertion_tv_cache();
		dumper.dump_non_true_assertion_tv_cache(misc_utilities.generic_caches_directory());
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$24 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$25 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$24);
			final SubLObject memory_mappedP_$26 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$24);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$24);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$24);
				final SubLObject manager_$25 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$26 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$25);
				final SubLObject memory_mappedP_$27 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$25);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$25);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$25);
					final SubLObject manager_$26 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$27 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$26);
					final SubLObject memory_mappedP_$28 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$26);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$26);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$26);
						final SubLObject manager_$27 = constant_index_manager.$constant_index_manager$.getGlobalValue();
						final SubLObject maintaining_countsP_$28 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$27);
						final SubLObject memory_mappedP_$29 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$27);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$27);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$27);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								dumper.rebuild_assertion_indexing_for_reconnect();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$28) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$27);
								}
								if (NIL == memory_mappedP_$29) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$27,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$27) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$26);
							}
							if (NIL == memory_mappedP_$28) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$26,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$26) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$25);
						}
						if (NIL == memory_mappedP_$27) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$25,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$25) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$24);
					}
					if (NIL == memory_mappedP_$26) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$24, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		final SubLObject directory_path = misc_utilities.generic_caches_directory();
		unrepresented_terms.clear_unrepresented_term_table();
		dumper.load_kb_unrepresented_terms(directory_path);
		constant_index_manager.setup_constant_index_table(constant_count(), NIL);
		nart_index_manager.setup_nart_index_table(nart_handles.nart_count(), NIL);
		unrepresented_term_index_manager
				.setup_unrepresented_term_index_table(unrepresented_terms.kb_unrepresented_term_count(), NIL);
		kb_utilities.resize_kb_object_manager_lru_caches_for_rebuild();
		dumper.load_kb_assertion_indexing(directory_path);
		SubLObject manager2 = assertion_manager.$assertion_content_manager$.getGlobalValue();
		SubLObject maintaining_countsP2 = kb_object_manager.kb_object_usage_counts_enabledP(manager2);
		SubLObject memory_mappedP2 = kb_object_manager.kb_object_manager_memory_mappedP(manager2);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager2);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager2);
			final SubLObject manager_$28 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$29 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$28);
			final SubLObject memory_mappedP_$30 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$28);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$28);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$28);
				final SubLObject manager_$29 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$30 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$29);
				final SubLObject memory_mappedP_$31 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$29);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$29);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$29);
					final SubLObject manager_$30 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$31 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$30);
					final SubLObject memory_mappedP_$32 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$30);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$30);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$30);
						final SubLObject manager_$31 = constant_index_manager.$constant_index_manager$.getGlobalValue();
						final SubLObject maintaining_countsP_$32 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$31);
						final SubLObject memory_mappedP_$33 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$31);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$31);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$31);
							final SubLObject _prev_bind_7 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								bookkeeping_store.reindex_all_bookkeeping_assertions();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_7, thread);
							}
						} finally {
							final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values6 = getValuesAsVector();
								if (NIL != maintaining_countsP_$32) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$31);
								}
								if (NIL == memory_mappedP_$33) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$31,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values6);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values7 = getValuesAsVector();
							if (NIL != maintaining_countsP_$31) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$30);
							}
							if (NIL == memory_mappedP_$32) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$30,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values7);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values8 = getValuesAsVector();
						if (NIL != maintaining_countsP_$30) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$29);
						}
						if (NIL == memory_mappedP_$31) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$29,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values8);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values9 = getValuesAsVector();
					if (NIL != maintaining_countsP_$29) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$28);
					}
					if (NIL == memory_mappedP_$30) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$28, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values9);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_12 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values10 = getValuesAsVector();
				if (NIL != maintaining_countsP2) {
					kb_object_manager.maintain_kb_object_usage_counts(manager2);
				}
				if (NIL == memory_mappedP2) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager2, dumper.$int$2048,
							$int$256);
				}
				restoreValuesFromVector(_values10);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_12, thread);
			}
		}
		dumper.dump_bookkeeping_indices_file(directory_path);
		manager2 = assertion_manager.$assertion_content_manager$.getGlobalValue();
		maintaining_countsP2 = kb_object_manager.kb_object_usage_counts_enabledP(manager2);
		memory_mappedP2 = kb_object_manager.kb_object_manager_memory_mappedP(manager2);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager2);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager2);
			final SubLObject manager_$32 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$33 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$32);
			final SubLObject memory_mappedP_$34 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$32);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$32);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$32);
				final SubLObject manager_$33 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$34 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$33);
				final SubLObject memory_mappedP_$35 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$33);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$33);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$33);
					final SubLObject manager_$34 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$35 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$34);
					final SubLObject memory_mappedP_$36 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$34);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$34);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$34);
						final SubLObject manager_$35 = constant_index_manager.$constant_index_manager$.getGlobalValue();
						final SubLObject maintaining_countsP_$36 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$35);
						final SubLObject memory_mappedP_$37 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$35);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$35);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$35);
							final SubLObject _prev_bind_7 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								kb_hl_supports_low.reindex_all_kb_hl_supports();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_7, thread);
							}
						} finally {
							final SubLObject _prev_bind_13 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values11 = getValuesAsVector();
								if (NIL != maintaining_countsP_$36) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$35);
								}
								if (NIL == memory_mappedP_$37) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$35,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values11);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_13, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_14 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values12 = getValuesAsVector();
							if (NIL != maintaining_countsP_$35) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$34);
							}
							if (NIL == memory_mappedP_$36) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$34,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values12);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_14, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_15 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values13 = getValuesAsVector();
						if (NIL != maintaining_countsP_$34) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$33);
						}
						if (NIL == memory_mappedP_$35) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$33,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values13);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_15, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_16 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values14 = getValuesAsVector();
					if (NIL != maintaining_countsP_$33) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$32);
					}
					if (NIL == memory_mappedP_$34) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$32, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values14);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_16, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_17 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values15 = getValuesAsVector();
				if (NIL != maintaining_countsP2) {
					kb_object_manager.maintain_kb_object_usage_counts(manager2);
				}
				if (NIL == memory_mappedP2) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager2, dumper.$int$2048,
							$int$256);
				}
				restoreValuesFromVector(_values15);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_17, thread);
			}
		}
		dumper.dump_kb_hl_support_indexing(directory_path);
		return NIL;
	}

	public static SubLObject rebuild_assertion_indexing_for_reconnect() {
		kb_indexing.clear_all_existing_indexing();
		final SubLObject part_dirs = dumper.rebuild_and_dump_assertion_indexing();
		dumper.merge_and_redump_assertion_indexing(part_dirs);
		dumper.cleanup_rebuild_part_dirs(part_dirs);
		return NIL;
	}

	public static SubLObject rebuild_and_dump_assertion_indexing() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject max_tile_size = dumper.$assertion_tile_size$.getGlobalValue();
		final SubLObject num_of_tiles = ceiling(assertion_handles.assertion_count(), max_tile_size);
		final SubLObject tile_size = ceiling(assertion_handles.assertion_count(), num_of_tiles);
		final SubLObject outer_message = cconcatenate(dumper.$str60$Re_Indexing_KB_in_,
				new SubLObject[] { format_nil.format_nil_a_no_copy(num_of_tiles), dumper.$str61$_parts__of_,
						format_nil.format_nil_a_no_copy(tile_size), dumper.$str62$_assertions_ });
		final SubLObject part_dirs = dumper.compute_rebuild_part_dirs(num_of_tiles);
		SubLObject ass_id = ZERO_INTEGER;
		SubLObject known_top_n_indices = NIL;
		final SubLObject list_var = part_dirs;
		final SubLObject _prev_bind_0 = $progress_note$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_total$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_sofar$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $last_percent_progress_index$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $last_percent_progress_prediction$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $within_noting_percent_progress$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $percent_progress_start_time$.currentBinding(thread);
		try {
			$progress_note$.bind(NIL != outer_message ? outer_message : dumper.$$$cdolist, thread);
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_total$.bind(length(list_var), thread);
			$progress_sofar$.bind(ZERO_INTEGER, thread);
			$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
			$last_percent_progress_prediction$.bind(NIL, thread);
			$within_noting_percent_progress$.bind(T, thread);
			$percent_progress_start_time$.bind(get_universal_time(), thread);
			try {
				noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
				SubLObject csome_list_var = list_var;
				SubLObject part_dir = NIL;
				part_dir = csome_list_var.first();
				while (NIL != csome_list_var) {
					kb_indexing.clear_large_existing_indexing();
					if (NIL != known_top_n_indices) {
						final SubLObject list_var_$60 = known_top_n_indices;
						final SubLObject _prev_bind_0_$61 = $progress_note$.currentBinding(thread);
						final SubLObject _prev_bind_1_$62 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_2_$63 = $progress_total$.currentBinding(thread);
						final SubLObject _prev_bind_3_$64 = $progress_sofar$.currentBinding(thread);
						final SubLObject _prev_bind_4_$65 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_5_$66 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_6_$67 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_7_$68 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$progress_note$.bind(dumper.$str64$Reserving_known_TOP_N_indices, thread);
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_total$.bind(length(list_var_$60), thread);
							$progress_sofar$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
								SubLObject csome_list_var_$69 = list_var_$60;
								SubLObject top_n_index = NIL;
								top_n_index = csome_list_var_$69.first();
								while (NIL != csome_list_var_$69) {
									SubLObject current;
									final SubLObject datum = current = top_n_index;
									SubLObject v_term = NIL;
									destructuring_bind_must_consp(current, datum, dumper.$list65);
									v_term = current.first();
									final SubLObject keys;
									current = keys = current.rest();
									if (NIL == term_index(v_term)) {
										initialize_term_complex_index(v_term);
									}
									final SubLObject _prev_bind_0_$62 = $with_final_topn_index_tracking$
											.currentBinding(thread);
									try {
										$with_final_topn_index_tracking$.bind(NIL, thread);
										reserve_final_topn_index_for_term(v_term, keys);
									} finally {
										$with_final_topn_index_tracking$.rebind(_prev_bind_0_$62, thread);
									}
									$progress_sofar$.setDynamicValue(
											add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER), thread);
									note_percent_progress($progress_sofar$.getDynamicValue(thread),
											$progress_total$.getDynamicValue(thread));
									csome_list_var_$69 = csome_list_var_$69.rest();
									top_n_index = csome_list_var_$69.first();
								}
							} finally {
								final SubLObject _prev_bind_0_$63 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$63, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_7_$68, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_6_$67, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_5_$66, thread);
							$last_percent_progress_index$.rebind(_prev_bind_4_$65, thread);
							$progress_sofar$.rebind(_prev_bind_3_$64, thread);
							$progress_total$.rebind(_prev_bind_2_$63, thread);
							$progress_start_time$.rebind(_prev_bind_1_$62, thread);
							$progress_note$.rebind(_prev_bind_0_$61, thread);
						}
					}
					final SubLObject last_id = min(add(ass_id, tile_size), assertion_handles.assertion_count());
					final SubLObject msg = cconcatenate(dumper.$str66$Indexing_assertion_range__,
							new SubLObject[] { format_nil.format_nil_a_no_copy(ass_id), dumper.$str67$_,
									format_nil.format_nil_a_no_copy(last_id), dumper.$str68$_ });
					SubLObject new_top_n_indices = NIL;
					final SubLObject _prev_bind_0_$64 = $recent_final_topn_indices$.currentBinding(thread);
					final SubLObject _prev_bind_1_$63 = $with_final_topn_index_tracking$.currentBinding(thread);
					try {
						$recent_final_topn_indices$.bind(NIL, thread);
						$with_final_topn_index_tracking$.bind(T, thread);
						final SubLObject _prev_bind_0_$65 = $progress_note$.currentBinding(thread);
						final SubLObject _prev_bind_1_$64 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_2_$64 = $progress_total$.currentBinding(thread);
						final SubLObject _prev_bind_3_$65 = $progress_sofar$.currentBinding(thread);
						final SubLObject _prev_bind_4_$66 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_5_$67 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_6_$68 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_7_$69 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$progress_note$.bind(msg, thread);
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_total$.bind(tile_size, thread);
							$progress_sofar$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
								SubLObject i;
								SubLObject as;
								SubLObject _prev_bind_0_$66;
								for (i = NIL, i = ZERO_INTEGER; i
										.numL($progress_total$.getDynamicValue(thread)); i = add(i, ONE_INTEGER)) {
									as = assertion_handles.find_assertion_by_id(ass_id);
									if (NIL != as) {
										_prev_bind_0_$66 = Errors.$continue_cerrorP$.currentBinding(thread);
										try {
											Errors.$continue_cerrorP$.bind(T, thread);
											kb_indexing.reindex_one_of_all_assertions(as);
										} finally {
											Errors.$continue_cerrorP$.rebind(_prev_bind_0_$66, thread);
										}
									}
									ass_id = add(ass_id, ONE_INTEGER);
									$progress_sofar$.setDynamicValue(
											add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER), thread);
									note_percent_progress($progress_sofar$.getDynamicValue(thread),
											$progress_total$.getDynamicValue(thread));
								}
							} finally {
								final SubLObject _prev_bind_0_$67 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values2 = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values2);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$67, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_7_$69, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_6_$68, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_5_$67, thread);
							$last_percent_progress_index$.rebind(_prev_bind_4_$66, thread);
							$progress_sofar$.rebind(_prev_bind_3_$65, thread);
							$progress_total$.rebind(_prev_bind_2_$64, thread);
							$progress_start_time$.rebind(_prev_bind_1_$64, thread);
							$progress_note$.rebind(_prev_bind_0_$65, thread);
						}
						new_top_n_indices = copy_tree($recent_final_topn_indices$.getDynamicValue(thread));
					} finally {
						$with_final_topn_index_tracking$.rebind(_prev_bind_1_$63, thread);
						$recent_final_topn_indices$.rebind(_prev_bind_0_$64, thread);
					}
					known_top_n_indices = append(known_top_n_indices, new_top_n_indices);
					final SubLObject str;
					final SubLObject msg2 = str = cconcatenate(dumper.$$$Dumping_partial_index_to_,
							format_nil.format_nil_a_no_copy(part_dir));
					final SubLObject _prev_bind_0_$68 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_1_$65 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_2_$65 = $progress_elapsed_seconds_for_notification$
							.currentBinding(thread);
					final SubLObject _prev_bind_3_$66 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_4_$67 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_5_$68 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_6_$69 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_7_$70 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						final SubLObject _prev_bind_0_$69 = dumper.$separate_file_for_complex_indexingP$
								.currentBinding(thread);
						final SubLObject _prev_bind_1_$66 = StreamsLow.$stream_initial_input_buffer_size$
								.currentBinding(thread);
						final SubLObject _prev_bind_2_$66 = StreamsLow.$stream_initial_output_buffer_size$
								.currentBinding(thread);
						final SubLObject _prev_bind_3_$67 = $cfasl_common_symbols$.currentBinding(thread);
						try {
							dumper.$separate_file_for_complex_indexingP$.bind(NIL, thread);
							StreamsLow.$stream_initial_input_buffer_size$.bind(
									file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
							StreamsLow.$stream_initial_output_buffer_size$.bind(
									StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
							$cfasl_common_symbols$.bind(NIL, thread);
							cfasl_set_common_symbols(misc_utilities.get_hl_store_caches_shared_symbols());
							dumper.dump_kb_indexing(part_dir);
						} finally {
							$cfasl_common_symbols$.rebind(_prev_bind_3_$67, thread);
							StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2_$66, thread);
							StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_1_$66, thread);
							dumper.$separate_file_for_complex_indexingP$.rebind(_prev_bind_0_$69, thread);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_7_$70, thread);
						$is_noting_progressP$.rebind(_prev_bind_6_$69, thread);
						$progress_count$.rebind(_prev_bind_5_$68, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_4_$67, thread);
						$progress_notification_count$.rebind(_prev_bind_3_$66, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_2_$65, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_1_$65, thread);
						$progress_start_time$.rebind(_prev_bind_0_$68, thread);
					}
					$progress_sofar$.setDynamicValue(add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER),
							thread);
					note_percent_progress($progress_sofar$.getDynamicValue(thread),
							$progress_total$.getDynamicValue(thread));
					csome_list_var = csome_list_var.rest();
					part_dir = csome_list_var.first();
				}
			} finally {
				final SubLObject _prev_bind_0_$70 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					noting_percent_progress_postamble();
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$70, thread);
				}
			}
		} finally {
			$percent_progress_start_time$.rebind(_prev_bind_8, thread);
			$within_noting_percent_progress$.rebind(_prev_bind_7, thread);
			$last_percent_progress_prediction$.rebind(_prev_bind_6, thread);
			$last_percent_progress_index$.rebind(_prev_bind_5, thread);
			$progress_sofar$.rebind(_prev_bind_4, thread);
			$progress_total$.rebind(_prev_bind_3, thread);
			$progress_start_time$.rebind(_prev_bind_2, thread);
			$progress_note$.rebind(_prev_bind_0, thread);
		}
		return part_dirs;
	}

	public static SubLObject merge_and_redump_assertion_indexing(final SubLObject part_dirs) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		dumper.dump_kb_unrepresented_terms(misc_utilities.generic_caches_directory());
		final SubLObject _prev_bind_0 = dumper.$separate_file_for_complex_indexingP$.currentBinding(thread);
		try {
			dumper.$separate_file_for_complex_indexingP$.bind(T, thread);
			dumper.merge_and_redump_constant_assertion_indexing(part_dirs);
			dumper.merge_and_redump_nart_assertion_indexing(part_dirs);
			dumper.merge_and_redump_unrepresented_term_assertion_indexing(part_dirs);
		} finally {
			dumper.$separate_file_for_complex_indexingP$.rebind(_prev_bind_0, thread);
		}
		final SubLObject final_dir = last(part_dirs, UNPROVIDED).first();
		dumper.replicate_meta_assertion_indexing(final_dir);
		dumper.replicate_auxiliary_assertion_indexing(final_dir);
		return part_dirs;
	}

	public static SubLObject merge_and_redump_constant_assertion_indexing(final SubLObject part_dirs) {
		final SubLObject iterators = Mapping.mapcar(dumper.NEW_NINIVEH_CONSTANT_INDICES_ITERATOR, part_dirs);
		final SubLObject index_writer = dumper.new_constant_indices_writer(misc_utilities.generic_caches_directory());
		try {
			dumper.merge_index_from_partial_results(dumper.FIND_CONSTANT_BY_DUMP_ID, constant_count(), iterators,
					index_writer, $EQUAL_SIZED, dumper.$str72$Building_constant_indices_from_pa);
		} finally {
			final SubLObject _prev_bind_0 = currentBinding($is_thread_performing_cleanupP$);
			try {
				bind($is_thread_performing_cleanupP$, T);
				final SubLObject _values = getValuesAsVector();
				dumper.close_index_writer(index_writer);
				restoreValuesFromVector(_values);
			} finally {
				rebind($is_thread_performing_cleanupP$, _prev_bind_0);
			}
		}
		return part_dirs;
	}

	public static SubLObject merge_and_redump_nart_assertion_indexing(final SubLObject part_dirs) {
		final SubLObject iterators = Mapping.mapcar(dumper.NEW_NINIVEH_NART_INDICES_ITERATOR, part_dirs);
		final SubLObject index_writer = dumper.new_nart_indices_writer(misc_utilities.generic_caches_directory());
		try {
			dumper.merge_index_from_partial_results(dumper.FIND_NART_BY_DUMP_ID, nart_handles.nart_count(), iterators,
					index_writer, $EQUAL_SIZED, dumper.$str74$Building_NART_indices_from_partia);
		} finally {
			final SubLObject _prev_bind_0 = currentBinding($is_thread_performing_cleanupP$);
			try {
				bind($is_thread_performing_cleanupP$, T);
				final SubLObject _values = getValuesAsVector();
				dumper.close_index_writer(index_writer);
				restoreValuesFromVector(_values);
			} finally {
				rebind($is_thread_performing_cleanupP$, _prev_bind_0);
			}
		}
		return part_dirs;
	}

	public static SubLObject merge_and_redump_unrepresented_term_assertion_indexing(final SubLObject part_dirs) {
		final SubLObject iterators = Mapping.mapcar(dumper.NEW_NINIVEH_UNREPRESENTED_TERM_INDICES_ITERATOR, part_dirs);
		final SubLObject index_writer = dumper
				.new_unrepresented_term_indices_writer(misc_utilities.generic_caches_directory());
		final SubLObject different_sizes = NIL;
		try {
			dumper.merge_index_from_partial_results(dumper.FIND_UNREPRESENTED_TERM_BY_SUID,
					unrepresented_terms.kb_unrepresented_term_count(), iterators, index_writer, different_sizes,
					dumper.$str77$Building_unrepresented_term_indic);
		} finally {
			final SubLObject _prev_bind_0 = currentBinding($is_thread_performing_cleanupP$);
			try {
				bind($is_thread_performing_cleanupP$, T);
				final SubLObject _values = getValuesAsVector();
				dumper.close_index_writer(index_writer);
				restoreValuesFromVector(_values);
			} finally {
				rebind($is_thread_performing_cleanupP$, _prev_bind_0);
			}
		}
		return part_dirs;
	}

	public static SubLObject merge_index_from_partial_results(final SubLObject lookup_fn, final SubLObject count,
			final SubLObject iterators, final SubLObject index_writer, final SubLObject equal_sizedP, SubLObject msg) {
		if (msg == UNPROVIDED) {
			msg = dumper.$str78$Building_index_from_partial_resul;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		try {
			final SubLObject partial_indices = make_list(length(iterators), UNPROVIDED);
			final SubLObject cleanup_defs = kb_indexing.get_indexing_pre_dump_cleanup_defs();
			final SubLObject default_value = (NIL != equal_sizedP) ? $ERROR : cons($TERM_ID, new_simple_index());
			final SubLObject _prev_bind_0 = $progress_note$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_total$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_sofar$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $last_percent_progress_index$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $last_percent_progress_prediction$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $within_noting_percent_progress$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $percent_progress_start_time$.currentBinding(thread);
			try {
				$progress_note$.bind(msg, thread);
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_total$.bind(count, thread);
				$progress_sofar$.bind(ZERO_INTEGER, thread);
				$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
				$last_percent_progress_prediction$.bind(NIL, thread);
				$within_noting_percent_progress$.bind(T, thread);
				$percent_progress_start_time$.bind(get_universal_time(), thread);
				try {
					noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
					SubLObject i;
					SubLObject list_var;
					SubLObject iterator;
					SubLObject n;
					SubLObject item;
					SubLObject current;
					SubLObject datum;
					SubLObject term_id;
					SubLObject index;
					SubLObject v_term;
					SubLObject cdolist_list_var;
					SubLObject cleanup_def;
					SubLObject current2;
					SubLObject datum2;
					SubLObject members;
					SubLObject cleanup_fn;
					for (i = NIL, i = ZERO_INTEGER; i
							.numL($progress_total$.getDynamicValue(thread)); i = add(i, ONE_INTEGER)) {
						list_var = NIL;
						iterator = NIL;
						n = NIL;
						list_var = iterators;
						iterator = list_var.first();
						for (n = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest(), iterator = list_var
								.first(), n = add(ONE_INTEGER, n)) {
							if (NIL == equal_sizedP) {
								set_nth(ZERO_INTEGER, default_value, i);
							}
							item = iteration.iteration_next_without_values(iterator, default_value);
							if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && ($ERROR == item)) {
								Errors.error(dumper.$str81$Iterator__A_was_done_at_ID__A_of_, iterator, i, count);
							}
							datum = current = item;
							term_id = NIL;
							index = NIL;
							destructuring_bind_must_consp(current, datum, dumper.$list82);
							term_id = current.first();
							current = index = current.rest();
							if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (!i.numE(term_id))) {
								Errors.error(dumper.$str83$Expected_index_for__A__got__A_ins, i, term_id, iterator);
							}
							set_nth(n, partial_indices, index);
						}
						v_term = funcall(lookup_fn, i);
						kb_indexing.merge_term_indices(v_term, partial_indices);
						cdolist_list_var = cleanup_defs;
						cleanup_def = NIL;
						cleanup_def = cdolist_list_var.first();
						while (NIL != cdolist_list_var) {
							datum2 = current2 = cleanup_def;
							members = NIL;
							cleanup_fn = NIL;
							destructuring_bind_must_consp(current2, datum2, dumper.$list84);
							members = current2.first();
							current2 = current2.rest();
							destructuring_bind_must_consp(current2, datum2, dumper.$list84);
							cleanup_fn = current2.first();
							current2 = current2.rest();
							if (NIL == current2) {
								if (NIL != set.set_memberP(v_term, members)) {
									funcall(cleanup_fn, v_term);
								}
							} else {
								cdestructuring_bind_error(datum2, dumper.$list84);
							}
							cdolist_list_var = cdolist_list_var.rest();
							cleanup_def = cdolist_list_var.first();
						}
						dumper.index_writer_put_index_entry(index_writer, v_term);
						clear_term_index(v_term);
						$progress_sofar$.setDynamicValue(add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER),
								thread);
						note_percent_progress($progress_sofar$.getDynamicValue(thread),
								$progress_total$.getDynamicValue(thread));
					}
				} finally {
					final SubLObject _prev_bind_0_$97 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						noting_percent_progress_postamble();
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$97, thread);
					}
				}
			} finally {
				$percent_progress_start_time$.rebind(_prev_bind_8, thread);
				$within_noting_percent_progress$.rebind(_prev_bind_7, thread);
				$last_percent_progress_prediction$.rebind(_prev_bind_6, thread);
				$last_percent_progress_index$.rebind(_prev_bind_5, thread);
				$progress_sofar$.rebind(_prev_bind_4, thread);
				$progress_total$.rebind(_prev_bind_3, thread);
				$progress_start_time$.rebind(_prev_bind_2, thread);
				$progress_note$.rebind(_prev_bind_0, thread);
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				Mapping.mapcar(dumper.ITERATION_FINALIZE, iterators);
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return lookup_fn;
	}

	public static SubLObject compute_rebuild_part_dirs(final SubLObject dirs) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject units_dir = misc_utilities.generic_caches_directory();
		SubLObject parts = NIL;
		SubLObject i;
		SubLObject subdir;
		for (i = NIL, i = ZERO_INTEGER; i.numL(dirs); i = add(i, ONE_INTEGER)) {
			subdir = Filesys.make_directory(cconcatenate(format_nil.format_nil_a_no_copy(units_dir),
					new SubLObject[] { dumper.$str86$_part, format_nil.format_nil_a_no_copy(i), dumper.$str87$_ }),
					UNPROVIDED, UNPROVIDED);
			if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread))
					&& ((!subdir.isString()) || (NIL == Filesys.directory_p(subdir)))) {
				Errors.error(dumper.$str88$Cannot_create_part_directory__A__, subdir);
			}
			parts = cons(subdir, parts);
		}
		return nreverse(parts);
	}

	public static SubLObject cleanup_rebuild_part_dirs(final SubLObject dirs) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject cdolist_list_var = dirs;
		SubLObject dir = NIL;
		dir = cdolist_list_var.first();
		while (NIL != cdolist_list_var) {
			final SubLObject str = cconcatenate(dumper.$$$Cleaning_up_, format_nil.format_nil_a_no_copy(dir));
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				file_utilities.recursive_delete_directory(dir);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
			cdolist_list_var = cdolist_list_var.rest();
			dir = cdolist_list_var.first();
		}
		return $CLEAN;
	}

	public static SubLObject cyc_dump_kb(final SubLObject directory_path, final SubLObject dump_type,
			SubLObject options_plist) {
		if (options_plist == UNPROVIDED) {
			options_plist = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject agenda_timeout = getf(options_plist, $AGENDA_TIMEOUT, UNPROVIDED);
		SubLObject result = NIL;
		if (NIL == operation_queues.local_queue_empty()) {
			while (NIL == operation_queues.local_queue_empty()) {
				operation_queues.run_one_local_op();
			}
		}
		operation_communication.save_transcript_ops();
		inference_analysis.save_recent_experience();
		inference_analysis.save_recent_asked_queries();
		hl_transcript_tracing.flush_hl_transcript_trace();
		final SubLObject agenda_runningP = agenda.agenda_running();
		final SubLObject saved_local_transcript = transcript_utilities.$local_transcript$.getGlobalValue();
		final SubLObject saved_read_transcript = transcript_utilities.$read_transcript$.getGlobalValue();
		final SubLObject saved_communication_mode = $communication_mode$.getGlobalValue();
		final SubLObject saved_remote_queue = queues.queue_copy(operation_queues.$remote_queue$.getGlobalValue());
		final SubLObject saved_local_queue = queues.queue_copy(operation_queues.local_queue());
		final SubLObject saved_auxiliary_queue = queues.queue_copy(operation_queues.$auxiliary_queue$.getGlobalValue());
		final SubLObject saved_transcript_queue = queues
				.queue_copy(operation_queues.$transcript_queue$.getGlobalValue());
		SubLObject disabled_servers = NIL;
		try {
			final SubLObject str = dumper.$str93$Setting_up_safe_KB_dump_environme;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				Storage.room(UNPROVIDED);
				disabled_servers = tcp_server_utilities.disable_some_tcp_servers(UNPROVIDED);
				if (NIL != agenda_runningP) {
					operation_communication.ensure_agenda_halted(NIL);
				}
				if ((NIL != agenda_runningP) && (NIL != agenda.agenda_running())) {
					Errors.warn(dumper.$str94$Agenda_was_not_successfully_halte);
				}
				transcript_utilities.$master_transcript$.setGlobalValue(NIL);
				transcript_utilities.$local_transcript$.setGlobalValue(NIL);
				transcript_utilities.set_read_transcript(NIL);
				$communication_mode$.setGlobalValue($UNKNOWN);
				operation_queues.clear_remote_queue();
				operation_queues.clear_local_queue();
				operation_queues.clear_auxiliary_queue();
				operation_queues.clear_transcript_queue();
				kb_utilities.swap_out_all_pristine_kb_objects();
				misc_utilities.flush_all_logs();
				Storage.room(UNPROVIDED);
				kb_utilities.kb_statistics(UNPROVIDED, UNPROVIDED);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
			result = dumper.cyc_dump_kb_int(directory_path, dump_type, options_plist);
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values = getValuesAsVector();
				final SubLObject str2 = dumper.$str96$Restoring_pre_dump_environment;
				final SubLObject _prev_bind_0_$98 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_10 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_11 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_12 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_13 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_14 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_15 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_16 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str2 ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str2);
					transcript_utilities.set_master_transcript(UNPROVIDED);
					transcript_utilities.$local_transcript$.setGlobalValue(saved_local_transcript);
					transcript_utilities.set_read_transcript(saved_read_transcript);
					if (NIL != operation_communication.communication_modeP(saved_communication_mode)) {
						operation_communication.set_communication_mode(saved_communication_mode);
					}
					operation_queues.$remote_queue$.setGlobalValue(saved_remote_queue);
					operation_queues.set_local_queue(saved_local_queue);
					operation_queues.$auxiliary_queue$.setGlobalValue(saved_auxiliary_queue);
					operation_queues.$transcript_queue$.setGlobalValue(saved_transcript_queue);
					if (NIL != agenda_runningP) {
						agenda.start_agenda(UNPROVIDED);
					}
					tcp_server_utilities.re_enable_disabled_tcp_servers(disabled_servers);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_16, thread);
					$is_noting_progressP$.rebind(_prev_bind_15, thread);
					$progress_count$.rebind(_prev_bind_14, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_13, thread);
					$progress_notification_count$.rebind(_prev_bind_12, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_11, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_10, thread);
					$progress_start_time$.rebind(_prev_bind_0_$98, thread);
				}
				restoreValuesFromVector(_values);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return result;
	}

	public static SubLObject cyc_dump_kb_unsafe(final SubLObject directory_path, final SubLObject dump_type,
			SubLObject options_plist) {
		if (options_plist == UNPROVIDED) {
			options_plist = NIL;
		}
		return dumper.cyc_dump_kb_int(directory_path, dump_type, options_plist);
	}

	public static SubLObject cyc_dump_kb_int(final SubLObject directory_path, final SubLObject dump_type,
			SubLObject options_plist) {
		if (options_plist == UNPROVIDED) {
			options_plist = NIL;
		}
		if (misc_utilities.generic_caches_directory().isString()
				&& (NIL != Strings.stringE(misc_utilities.generic_caches_directory(), directory_path, UNPROVIDED,
						UNPROVIDED, UNPROVIDED, UNPROVIDED))) {
			Errors.warn(dumper.$str98$Dump__A_KB_trivially_finished__du, dump_type, directory_path);
			return directory_path;
		}
		if ((NIL == getf(options_plist, dumper.$kw99$OVERWRITE_UNITS_, NIL))
				&& (NIL != Filesys.probe_file(cconcatenate(directory_path, dumper.$str100$done_txt)))) {
			Errors.error(dumper.$str101$Cyc_units_aready_exist_in_directo, directory_path);
		}
		if (NIL != getf(options_plist, dumper.$kw102$FORCE_DIRECTORY_CREATE_, T)) {
			file_utilities.make_directory_recursive(directory_path, UNPROVIDED, UNPROVIDED);
		}
		SubLObject result = NIL;
		if (dump_type.eql($STANDARD)) {
			result = dumper.dump_standard_kb(directory_path);
		} else if (dump_type.eql($INCREMENTAL) || dump_type.eql($INCREMENTAL_STANDARD)) {
			result = operation_communication.dump_incremental_kb(directory_path, $STANDARD);
		} else if (dump_type.eql($SNAPSHOT) || dump_type.eql($SNAPSHOT_MINIMAL)) {
			result = dumper.snapshot_kb(misc_utilities.generic_caches_directory(), directory_path, $MINIMAL);
		} else if (dump_type.eql($RAW)) {
			result = dumper.dump_kb(directory_path);
		} else if (dump_type.eql($INCREMENTAL_RAW)) {
			result = operation_communication.dump_incremental_kb(directory_path, $FULL);
		} else if (dump_type.eql($INCREMENTAL_ESSENTIAL)) {
			result = operation_communication.dump_incremental_kb(directory_path, $ESSENTIAL);
		} else if (dump_type.eql($SNAPSHOT_MEDIUM)) {
			result = dumper.snapshot_kb(misc_utilities.generic_caches_directory(), directory_path, $MEDIUM);
		} else if (dump_type.eql($SNAPSHOT_MAXIMAL)) {
			result = dumper.snapshot_kb(misc_utilities.generic_caches_directory(), directory_path, $MAXIMAL);
		} else {
			Errors.error(dumper.$str118$Valid_DUMP_TYPE_not_specified);
		}

		return result;
	}

	public static SubLObject with_timed_kb_store_operation(final SubLObject macroform, final SubLObject environment) {
		SubLObject current;
		final SubLObject datum = current = macroform.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list119);
		final SubLObject temp = current.rest();
		current = current.first();
		SubLObject start_label = NIL;
		SubLObject direction = NIL;
		SubLObject end_label = NIL;
		SubLObject path = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list119);
		start_label = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list119);
		direction = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list119);
		end_label = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list119);
		path = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject body;
			current = body = temp;
			final SubLObject op_time = dumper.$sym120$OP_TIME;
			return list(CLET, list(op_time),
					list(PWHEN, dumper.$dump_verbose$, list(FORMAT, T, dumper.$str123$_________A_KB, start_label),
							dumper.$list124,
							listS(FORMAT, T, dumper.$str125$__A__A_at__A__, direction, path, dumper.$list126)),
					list(CTIME, op_time, bq_cons(PROGN, append(body, NIL))),
					list(PWHEN, dumper.$dump_verbose$,
							listS(dumper.FORCE_FORMAT,
									new SubLObject[] { T, dumper.$str129$_________A_of_KB__A_completed___A, end_label,
											dumper.$list130, list(dumper.ELAPSED_TIME_ABBREVIATION_STRING, op_time),
											dumper.$list126 })));
		}
		cdestructuring_bind_error(datum, dumper.$list119);
		return NIL;
	}

	/**
	 * Dump the current state of the KB to the directory DIRECTORY-PATH. If NIL, the
	 * dump directory for the next higher KB is used.
	 */
	@LispMethod(comment = "Dump the current state of the KB to the directory DIRECTORY-PATH.\r\nIf NIL, the dump directory for the next higher KB is used.\nDump the current state of the KB to the directory DIRECTORY-PATH.\nIf NIL, the dump directory for the next higher KB is used.")
	public static final SubLObject dump_kb_alt(SubLObject directory_path) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL == directory_path) {
				{
					SubLObject next_kb = add(ONE_INTEGER, kb_loaded());
					directory_path = com.cyc.cycjava.cycl.dumper.kb_dump_directory(next_kb, UNPROVIDED);
				}
			}
			if (NIL == Filesys.probe_file(directory_path)) {
				Errors.cerror($str_alt43$Create_directory_and_continue_, $str_alt27$Directory__S_does_not_exist_,
						directory_path);
				file_utilities.make_directory_recursive(directory_path, UNPROVIDED, UNPROVIDED);
			}
			com.cyc.cycjava.cycl.dumper.validate_dump_directory(directory_path);
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt44$________Dumping_KB__A_to__A_at__A, new SubLObject[] { kb_loaded(), directory_path,
								numeric_date_utilities.timestring(UNPROVIDED) });
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			{
				SubLObject dump_time = NIL;
				if (NIL != $dump_verbose$.getDynamicValue(thread)) {
					if ((kb_loaded().isInteger() && kb_op_number().isInteger()) && kb_op_number().numG(ZERO_INTEGER)) {
						format(T, $str_alt45$_____S_transcript_operations_proc, kb_op_number());
					}
					force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
				}
				{
					SubLObject time_var = get_internal_real_time();
					com.cyc.cycjava.cycl.dumper.dump_special_objects(directory_path);
					{
						SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
						try {
							$cfasl_common_symbols$.bind(NIL, thread);
							cfasl_set_common_symbols(com.cyc.cycjava.cycl.dumper.kb_dump_common_symbols());
							{
								SubLObject _prev_bind_0_4 = constants_high.$constant_dump_id_table$
										.currentBinding(thread);
								SubLObject _prev_bind_1 = api_control_vars.$cfasl_constant_handle_func$
										.currentBinding(thread);
								SubLObject _prev_bind_2 = narts_high.$nart_dump_id_table$.currentBinding(thread);
								SubLObject _prev_bind_3 = api_control_vars.$cfasl_nart_handle_func$
										.currentBinding(thread);
								SubLObject _prev_bind_4 = unrepresented_terms.$unrepresented_term_dump_id_table$
										.currentBinding(thread);
								SubLObject _prev_bind_5 = assertions_high.$assertion_dump_id_table$
										.currentBinding(thread);
								SubLObject _prev_bind_6 = api_control_vars.$cfasl_assertion_handle_func$
										.currentBinding(thread);
								SubLObject _prev_bind_7 = deductions_high.$deduction_dump_id_table$
										.currentBinding(thread);
								SubLObject _prev_bind_8 = api_control_vars.$cfasl_deduction_handle_func$
										.currentBinding(thread);
								SubLObject _prev_bind_9 = kb_hl_supports.$kb_hl_support_dump_id_table$
										.currentBinding(thread);
								SubLObject _prev_bind_10 = api_control_vars.$cfasl_kb_hl_support_handle_func$
										.currentBinding(thread);
								SubLObject _prev_bind_11 = clause_strucs.$clause_struc_dump_id_table$
										.currentBinding(thread);
								SubLObject _prev_bind_12 = api_control_vars.$cfasl_clause_struc_handle_func$
										.currentBinding(thread);
								try {
									constants_high.$constant_dump_id_table$.bind(create_constant_dump_id_table(),
											thread);
									api_control_vars.$cfasl_constant_handle_func$.bind(CONSTANT_DUMP_ID, thread);
									narts_high.$nart_dump_id_table$.bind(nart_handles.create_nart_dump_id_table(),
											thread);
									api_control_vars.$cfasl_nart_handle_func$.bind(NART_DUMP_ID, thread);
									unrepresented_terms.$unrepresented_term_dump_id_table$.bind(
											unrepresented_terms.create_unrepresented_term_dump_id_table(), thread);
									assertions_high.$assertion_dump_id_table$
											.bind(assertion_handles.create_assertion_dump_id_table(), thread);
									api_control_vars.$cfasl_assertion_handle_func$.bind(ASSERTION_DUMP_ID, thread);
									deductions_high.$deduction_dump_id_table$
											.bind(deduction_handles.create_deduction_dump_id_table(), thread);
									api_control_vars.$cfasl_deduction_handle_func$.bind(DEDUCTION_DUMP_ID, thread);
									kb_hl_supports.$kb_hl_support_dump_id_table$
											.bind(kb_hl_supports.create_kb_hl_support_dump_id_table(), thread);
									api_control_vars.$cfasl_kb_hl_support_handle_func$.bind(KB_HL_SUPPORT_DUMP_ID,
											thread);
									clause_strucs.$clause_struc_dump_id_table$
											.bind(clause_strucs.create_clause_struc_dump_id_table(), thread);
									api_control_vars.$cfasl_clause_struc_handle_func$.bind(CLAUSE_STRUC_DUMP_ID,
											thread);
									com.cyc.cycjava.cycl.dumper.kb_dump_to_directory(directory_path);
									com.cyc.cycjava.cycl.dumper.dump_computable_remaining_hl(directory_path);
								} finally {
									api_control_vars.$cfasl_clause_struc_handle_func$.rebind(_prev_bind_12, thread);
									clause_strucs.$clause_struc_dump_id_table$.rebind(_prev_bind_11, thread);
									api_control_vars.$cfasl_kb_hl_support_handle_func$.rebind(_prev_bind_10, thread);
									kb_hl_supports.$kb_hl_support_dump_id_table$.rebind(_prev_bind_9, thread);
									api_control_vars.$cfasl_deduction_handle_func$.rebind(_prev_bind_8, thread);
									deductions_high.$deduction_dump_id_table$.rebind(_prev_bind_7, thread);
									api_control_vars.$cfasl_assertion_handle_func$.rebind(_prev_bind_6, thread);
									assertions_high.$assertion_dump_id_table$.rebind(_prev_bind_5, thread);
									unrepresented_terms.$unrepresented_term_dump_id_table$.rebind(_prev_bind_4, thread);
									api_control_vars.$cfasl_nart_handle_func$.rebind(_prev_bind_3, thread);
									narts_high.$nart_dump_id_table$.rebind(_prev_bind_2, thread);
									api_control_vars.$cfasl_constant_handle_func$.rebind(_prev_bind_1, thread);
									constants_high.$constant_dump_id_table$.rebind(_prev_bind_0_4, thread);
								}
							}
						} finally {
							$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
						}
					}
					dump_time = divide(subtract(get_internal_real_time(), time_var),
							time_high.$internal_time_units_per_second$.getGlobalValue());
				}
				if (NIL != $dump_verbose$.getDynamicValue(thread)) {
					format(T, $str_alt46$________Dump_of_KB__A_completed__,
							new SubLObject[] { kb_loaded(),
									numeric_date_utilities.elapsed_time_abbreviation_string(dump_time),
									numeric_date_utilities.timestring(UNPROVIDED) });
					force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
				}
			}
			return NIL;
		}
	}

	/**
	 * Dump the current state of the KB to the directory DIRECTORY-PATH. If NIL, the
	 * dump directory for the next higher KB is used.
	 */
	@LispMethod(comment = "Dump the current state of the KB to the directory DIRECTORY-PATH.\r\nIf NIL, the dump directory for the next higher KB is used.\nDump the current state of the KB to the directory DIRECTORY-PATH.\nIf NIL, the dump directory for the next higher KB is used.")
	public static SubLObject dump_kb(SubLObject directory_path) {
		if (directory_path == UNPROVIDED) {
			directory_path = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		directory_path = dumper.ensure_valid_dump_directory(directory_path);
		SubLObject op_time = NIL;
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(T, dumper.$str123$_________A_KB, dumper.$$$Dumping);
			if (NIL != kb_loaded()) {
				format(T, dumper.$str133$__A, operation_communication.kb_version_string());
			}
			format(T, dumper.$str125$__A__A_at__A__,
					new SubLObject[] { dumper.$$$to, directory_path, numeric_date_utilities.timestring(UNPROVIDED) });
		}
		final SubLObject time_var = get_internal_real_time();
		dumper.possibly_note_transcript_operations_processed();
		dumper.dump_special_objects(directory_path);
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(dumper.kb_dump_common_symbols());
			final SubLObject _prev_bind_0_$99 = constants_high.$constant_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_2 = api_control_vars.$cfasl_constant_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_3 = narts_high.$nart_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_4 = api_control_vars.$cfasl_nart_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_5 = unrepresented_terms.$unrepresented_term_dump_id_table$
					.currentBinding(thread);
			final SubLObject _prev_bind_6 = assertions_high.$assertion_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_7 = api_control_vars.$cfasl_assertion_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_8 = deductions_high.$deduction_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_9 = api_control_vars.$cfasl_deduction_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_10 = kb_hl_supports_high.$kb_hl_support_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_11 = api_control_vars.$cfasl_kb_hl_support_handle_func$.currentBinding(thread);
			final SubLObject _prev_bind_12 = clause_strucs.$clause_struc_dump_id_table$.currentBinding(thread);
			final SubLObject _prev_bind_13 = api_control_vars.$cfasl_clause_struc_handle_func$.currentBinding(thread);
			try {
				constants_high.$constant_dump_id_table$.bind(create_constant_dump_id_table(), thread);
				api_control_vars.$cfasl_constant_handle_func$.bind(dumper.CONSTANT_DUMP_ID, thread);
				narts_high.$nart_dump_id_table$.bind(nart_handles.create_nart_dump_id_table(), thread);
				api_control_vars.$cfasl_nart_handle_func$.bind(dumper.NART_DUMP_ID, thread);
				unrepresented_terms.$unrepresented_term_dump_id_table$
						.bind(unrepresented_terms.create_unrepresented_term_dump_id_table(), thread);
				assertions_high.$assertion_dump_id_table$.bind(assertion_handles.create_assertion_dump_id_table(),
						thread);
				api_control_vars.$cfasl_assertion_handle_func$.bind(dumper.ASSERTION_DUMP_ID, thread);
				deductions_high.$deduction_dump_id_table$.bind(deduction_handles.create_deduction_dump_id_table(),
						thread);
				api_control_vars.$cfasl_deduction_handle_func$.bind(dumper.DEDUCTION_DUMP_ID, thread);
				kb_hl_supports_high.$kb_hl_support_dump_id_table$
						.bind(kb_hl_support_handles.create_kb_hl_support_dump_id_table(), thread);
				api_control_vars.$cfasl_kb_hl_support_handle_func$.bind(dumper.KB_HL_SUPPORT_DUMP_ID, thread);
				clause_strucs.$clause_struc_dump_id_table$.bind(clause_strucs.create_clause_struc_dump_id_table(),
						thread);
				api_control_vars.$cfasl_clause_struc_handle_func$.bind(dumper.CLAUSE_STRUC_DUMP_ID, thread);
				dumper.kb_dump_to_directory(directory_path);
				dumper.dump_computable_remaining_hl(directory_path, UNPROVIDED);
			} finally {
				api_control_vars.$cfasl_clause_struc_handle_func$.rebind(_prev_bind_13, thread);
				clause_strucs.$clause_struc_dump_id_table$.rebind(_prev_bind_12, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_func$.rebind(_prev_bind_11, thread);
				kb_hl_supports_high.$kb_hl_support_dump_id_table$.rebind(_prev_bind_10, thread);
				api_control_vars.$cfasl_deduction_handle_func$.rebind(_prev_bind_9, thread);
				deductions_high.$deduction_dump_id_table$.rebind(_prev_bind_8, thread);
				api_control_vars.$cfasl_assertion_handle_func$.rebind(_prev_bind_7, thread);
				assertions_high.$assertion_dump_id_table$.rebind(_prev_bind_6, thread);
				unrepresented_terms.$unrepresented_term_dump_id_table$.rebind(_prev_bind_5, thread);
				api_control_vars.$cfasl_nart_handle_func$.rebind(_prev_bind_4, thread);
				narts_high.$nart_dump_id_table$.rebind(_prev_bind_3, thread);
				api_control_vars.$cfasl_constant_handle_func$.rebind(_prev_bind_2, thread);
				constants_high.$constant_dump_id_table$.rebind(_prev_bind_0_$99, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		op_time = divide(subtract(get_internal_real_time(), time_var),
				time_high.$internal_time_units_per_second$.getGlobalValue());
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format_nil.force_format(T, dumper.$str129$_________A_of_KB__A_completed___A, dumper.$$$Dump,
					operation_communication.kb_version_string(),
					numeric_date_utilities.elapsed_time_abbreviation_string(op_time),
					numeric_date_utilities.timestring(UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
		}
		return NIL;
	}

	/**
	 * Load the KB from the dump directory in DIRECTORY-PATH.
	 */
	@LispMethod(comment = "Load the KB from the dump directory in DIRECTORY-PATH.")
	public static final SubLObject load_kb_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt47$________Loading_KB_from__A_at__A_, directory_path,
						numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			{
				SubLObject load_time = NIL;
				{
					SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
					try {
						$save_asked_queriesP$.bind(NIL, thread);
						{
							SubLObject time_var = get_internal_real_time();
							com.cyc.cycjava.cycl.dumper.kb_load_from_directory(directory_path);
							com.cyc.cycjava.cycl.dumper.load_kb_initializations();
							if (NIL != com.cyc.cycjava.cycl.dumper.force_monolithic_kb_assumptionP()) {
								sbhl_caching_policies.enforce_monolithic_kb_sbhl_caching_policies();
								com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
							} else {
								swap_out_all_pristine_kb_objects();
								sbhl_caching_policies.enforce_standard_kb_sbhl_caching_policies(directory_path);
								com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
							}
							load_time = divide(subtract(get_internal_real_time(), time_var),
									time_high.$internal_time_units_per_second$.getGlobalValue());
							if (NIL != $dump_verbose$.getDynamicValue(thread)) {
								format(T, $str_alt48$________Load_of_KB__A_completed__,
										new SubLObject[] { kb_loaded(),
												numeric_date_utilities.elapsed_time_abbreviation_string(load_time),
												numeric_date_utilities.timestring(UNPROVIDED) });
								kb_statistics(StreamsLow.$standard_output$.getDynamicValue(thread));
								force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
							}
						}
					} finally {
						$save_asked_queriesP$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return kb_loaded();
		}
	}

	/**
	 * Load the KB from the dump directory in DIRECTORY-PATH.
	 */
	@LispMethod(comment = "Load the KB from the dump directory in DIRECTORY-PATH.")
	public static SubLObject load_kb(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_component$.currentBinding(thread);
		final SubLObject _prev_bind_2 = cfasl_kb_methods.$report_cfasl_invalid_objectsP$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_component$.bind($LOAD_KB, thread);
			cfasl_kb_methods.$report_cfasl_invalid_objectsP$.bind(T, thread);
			SubLObject op_time = NIL;
			if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
				format(T, dumper.$str123$_________A_KB, dumper.$$$Loading);
				if (NIL != kb_loaded()) {
					format(T, dumper.$str133$__A, operation_communication.kb_version_string());
				}
				format(T, dumper.$str125$__A__A_at__A__, new SubLObject[] { dumper.$$$from, directory_path,
						numeric_date_utilities.timestring(UNPROVIDED) });
			}
			final SubLObject time_var = get_internal_real_time();
			final SubLObject _prev_bind_0_$100 = $save_asked_queriesP$.currentBinding(thread);
			try {
				$save_asked_queriesP$.bind(NIL, thread);
				kb_store_utils.alexandria_prefetch_kb_content();
				dumper.kb_load_from_directory(directory_path);
				dumper.load_kb_initializations();
				if (NIL != dumper.force_monolithic_kb_assumptionP()) {
					enforce_monolithic_kb_sbhl_caching_policies();
					dumper.kb_load_gc_checkpoint();
				} else {
					kb_utilities.swap_out_all_pristine_kb_objects();
					final SubLObject _prev_bind_0_$101 = kb_health_statistics.$kb_health_current_context$
							.currentBinding(thread);
					try {
						kb_health_statistics.$kb_health_current_context$.bind($POLICIES, thread);
						enforce_standard_kb_sbhl_caching_policies(directory_path);
					} finally {
						kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$101, thread);
					}
					dumper.kb_load_gc_checkpoint();
				}
			} finally {
				$save_asked_queriesP$.rebind(_prev_bind_0_$100, thread);
			}
			op_time = divide(subtract(get_internal_real_time(), time_var),
					time_high.$internal_time_units_per_second$.getGlobalValue());
			if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
				format_nil.force_format(T, dumper.$str129$_________A_of_KB__A_completed___A, dumper.$$$Load,
						operation_communication.kb_version_string(),
						numeric_date_utilities.elapsed_time_abbreviation_string(op_time),
						numeric_date_utilities.timestring(UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
			}
			kb_utilities.kb_statistics(StreamsLow.$standard_output$.getDynamicValue(thread), UNPROVIDED);
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			research_cyc_init.perform_research_cyc_load_finalizations();
		} finally {
			cfasl_kb_methods.$report_cfasl_invalid_objectsP$.rebind(_prev_bind_2, thread);
			kb_health_statistics.$kb_health_current_component$.rebind(_prev_bind_0, thread);
		}
		return kb_loaded();
	}

	public static SubLObject minimal_tombstoning_modeP() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		return eq($MINIMAL, dumper.$snapshot_tombstoning_mode$.getDynamicValue(thread));
	}

	public static SubLObject medium_tombstoning_modeP() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		return eq($MEDIUM, dumper.$snapshot_tombstoning_mode$.getDynamicValue(thread));
	}

	public static SubLObject maximal_tombstoning_modeP() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		return eq($MAXIMAL, dumper.$snapshot_tombstoning_mode$.getDynamicValue(thread));
	}

	public static SubLObject snapshot_kb(final SubLObject active_dir, SubLObject snapshot_dir,
			SubLObject tomb_stoning_mode) {
		if (snapshot_dir == UNPROVIDED) {
			snapshot_dir = NIL;
		}
		if (tomb_stoning_mode == UNPROVIDED) {
			tomb_stoning_mode = $MINIMAL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		snapshot_dir = dumper.ensure_valid_dump_directory(snapshot_dir);
		final SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_component$.currentBinding(thread);
		final SubLObject _prev_bind_2 = cfasl_kb_methods.$report_cfasl_invalid_objectsP$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_component$.bind($SNAPSHOT_KB, thread);
			cfasl_kb_methods.$report_cfasl_invalid_objectsP$.bind(T, thread);
			SubLObject op_time = NIL;
			if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
				format(T, dumper.$str123$_________A_KB, dumper.$$$Snapshotting);
				if (NIL != kb_loaded()) {
					format(T, dumper.$str133$__A, operation_communication.kb_version_string());
				}
				format(T, dumper.$str125$__A__A_at__A__,
						new SubLObject[] { dumper.$$$to, snapshot_dir, numeric_date_utilities.timestring(UNPROVIDED) });
			}
			final SubLObject time_var = get_internal_real_time();
			kb_utilities.show_new_kb_state(UNPROVIDED);
			dumper.possibly_note_transcript_operations_processed();
			dumper.dump_special_objects(snapshot_dir);
			final SubLObject _prev_bind_0_$102 = $cfasl_common_symbols$.currentBinding(thread);
			try {
				$cfasl_common_symbols$.bind(NIL, thread);
				cfasl_set_common_symbols(dumper.kb_dump_common_symbols());
				final SubLObject _prev_bind_0_$103 = dumper.$snapshot_tombstoning_mode$.currentBinding(thread);
				try {
					dumper.$snapshot_tombstoning_mode$.bind(tomb_stoning_mode, thread);
					dumper.kb_snapshot_to_directory(active_dir, snapshot_dir);
				} finally {
					dumper.$snapshot_tombstoning_mode$.rebind(_prev_bind_0_$103, thread);
				}
				final SubLObject _prev_bind_0_$104 = dumper.$auto_increment_kb_number_on_dumpP$.currentBinding(thread);
				try {
					dumper.$auto_increment_kb_number_on_dumpP$.bind(NIL, thread);
					dumper.snapshot_computable_remaining_hl(snapshot_dir, UNPROVIDED);
				} finally {
					dumper.$auto_increment_kb_number_on_dumpP$.rebind(_prev_bind_0_$104, thread);
				}
			} finally {
				$cfasl_common_symbols$.rebind(_prev_bind_0_$102, thread);
			}
			operation_communication.dump_incremental_stats_information(snapshot_dir);
			op_time = divide(subtract(get_internal_real_time(), time_var),
					time_high.$internal_time_units_per_second$.getGlobalValue());
			if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
				format_nil.force_format(T, dumper.$str129$_________A_of_KB__A_completed___A, dumper.$$$Snapshot,
						operation_communication.kb_version_string(),
						numeric_date_utilities.elapsed_time_abbreviation_string(op_time),
						numeric_date_utilities.timestring(UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
			}
		} finally {
			cfasl_kb_methods.$report_cfasl_invalid_objectsP$.rebind(_prev_bind_2, thread);
			kb_health_statistics.$kb_health_current_component$.rebind(_prev_bind_0, thread);
		}
		return snapshot_dir;
	}

	public static SubLObject ensure_valid_dump_directory(SubLObject directory_path) {
		if (NIL == directory_path) {
			final SubLObject next_kb = add(ONE_INTEGER, kb_loaded());
			directory_path = dumper.kb_dump_directory(next_kb, UNPROVIDED);
		}
		if (NIL == Filesys.probe_file(directory_path)) {
			Errors.cerror(dumper.$str144$Create_directory_and_continue_, dumper.$str36$Directory__S_does_not_exist_,
					directory_path);
			file_utilities.make_directory_recursive(directory_path, UNPROVIDED, UNPROVIDED);
		}
		dumper.validate_dump_directory(directory_path);
		return directory_path;
	}

	public static SubLObject possibly_note_transcript_operations_processed() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (((NIL != dumper.$dump_verbose$.getDynamicValue(thread)) && kb_loaded().isInteger())
				&& (NIL != subl_promotions.positive_integer_p(operation_communication.kb_op_number()))) {
			format_nil.force_format(T, dumper.$str145$_____S_transcript_operations_proc,
					operation_communication.kb_op_number(), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED,
					UNPROVIDED, UNPROVIDED);
		}
		return NIL;
	}

	public static SubLObject kb_manifest() {
		return dumper.$kb_manifest$.getGlobalValue();
	}

	public static SubLObject kb_possibly_load_manifest_from_directory(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject msg = NIL;
		try {
			thread.throwStack.push($catch_error_message_target$.getGlobalValue());
			final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
			try {
				Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
				try {
					dumper.kb_load_manifest_from_directory(directory_path);
				} catch (final Throwable catch_var) {
					Errors.handleThrowable(catch_var, NIL);
				}
			} finally {
				Errors.$error_handler$.rebind(_prev_bind_0, thread);
			}
		} catch (final Throwable ccatch_env_var) {
			msg = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
		} finally {
			thread.throwStack.pop();
		}
		if (msg.isString()) {
			Errors.warn(dumper.$str148$Could_not_load_KB_manifest_from__, directory_path);
			dumper.$kb_manifest$.setGlobalValue(list($ID, $UNKNOWN));
		}
		return dumper.kb_manifest();
	}

	public static SubLObject kb_load_manifest_from_directory(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manifest_file = dumper.kb_dump_file(dumper.$$$manifest, directory_path, NIL);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_text(manifest_file, $INPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, manifest_file);
			}
			final SubLObject s = stream;
			dumper.$kb_manifest$.setGlobalValue(read(s, UNPROVIDED, UNPROVIDED, UNPROVIDED));
		} finally {
			final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
			}
		}
		return dumper.kb_manifest();
	}

	public static SubLObject describe_knowledge_fvector_files(final SubLObject type_base) {
		return list($DATA_FILE, type_base, $INDEX_FILE, cconcatenate(type_base, dumper.$str155$_index), $TYPE,
				$KNOWLEDGE);
	}

	public static SubLObject describe_index_fvector_files(final SubLObject type_base) {
		SubLObject simple_df = NIL;
		SubLObject simple_if = NIL;
		SubLObject complex_df = NIL;
		SubLObject complex_if = NIL;
		final SubLObject current;
		final SubLObject datum = current = dumper.describe_knowledge_fvector_files(
				NIL != Strings.stringE(dumper.$$$constant, type_base, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED)
						? dumper.$$$indices
						: cconcatenate(type_base, dumper.$str160$_indices));
		SubLObject allow_other_keys_p = NIL;
		SubLObject rest = current;
		SubLObject bad = NIL;
		SubLObject current_$105 = NIL;
		while (NIL != rest) {
			destructuring_bind_must_consp(rest, datum, dumper.$list161);
			current_$105 = rest.first();
			rest = rest.rest();
			destructuring_bind_must_consp(rest, datum, dumper.$list161);
			if (NIL == member(current_$105, dumper.$list162, UNPROVIDED, UNPROVIDED)) {
				bad = T;
			}
			if (current_$105 == dumper.$ALLOW_OTHER_KEYS) {
				allow_other_keys_p = rest.first();
			}
			rest = rest.rest();
		}
		if ((NIL != bad) && (NIL == allow_other_keys_p)) {
			cdestructuring_bind_error(datum, dumper.$list161);
		}
		final SubLObject data_file_tail = property_list_member($DATA_FILE, current);
		final SubLObject data_file = (NIL != data_file_tail) ? cadr(data_file_tail) : NIL;
		final SubLObject index_file_tail = property_list_member($INDEX_FILE, current);
		final SubLObject index_file = (NIL != index_file_tail) ? cadr(index_file_tail) : NIL;
		final SubLObject type_tail = property_list_member($TYPE, current);
		final SubLObject type = (NIL != type_tail) ? cadr(type_tail) : NIL;
		simple_df = data_file;
		simple_if = index_file;
		final SubLObject current_$106;
		final SubLObject datum_$106 = current_$106 = dumper
				.describe_knowledge_fvector_files(cconcatenate(type_base, dumper.$str164$_complex_indices));
		SubLObject allow_other_keys_p_$108 = NIL;
		SubLObject rest_$109 = current_$106;
		SubLObject bad_$110 = NIL;
		SubLObject current_$107 = NIL;
		while (NIL != rest_$109) {
			destructuring_bind_must_consp(rest_$109, datum_$106, dumper.$list161);
			current_$107 = rest_$109.first();
			rest_$109 = rest_$109.rest();
			destructuring_bind_must_consp(rest_$109, datum_$106, dumper.$list161);
			if (NIL == member(current_$107, dumper.$list162, UNPROVIDED, UNPROVIDED)) {
				bad_$110 = T;
			}
			if (current_$107 == dumper.$ALLOW_OTHER_KEYS) {
				allow_other_keys_p_$108 = rest_$109.first();
			}
			rest_$109 = rest_$109.rest();
		}
		if ((NIL != bad_$110) && (NIL == allow_other_keys_p_$108)) {
			cdestructuring_bind_error(datum_$106, dumper.$list161);
		}
		final SubLObject data_file_tail2 = property_list_member($DATA_FILE, current_$106);
		final SubLObject data_file2 = (NIL != data_file_tail2) ? cadr(data_file_tail2) : NIL;
		final SubLObject index_file_tail2 = property_list_member($INDEX_FILE, current_$106);
		final SubLObject index_file2 = (NIL != index_file_tail2) ? cadr(index_file_tail2) : NIL;
		final SubLObject type_tail2 = property_list_member($TYPE, current_$106);
		final SubLObject type2 = (NIL != type_tail2) ? cadr(type_tail2) : NIL;
		complex_df = data_file2;
		complex_if = index_file2;
		return list(new SubLObject[] { $DATA_FILE, simple_df, $INDEX_FILE, simple_if, dumper.$COMPLEX_DATA_FILE,
				complex_df, dumper.$COMPLEX_INDEX_FILE, complex_if, $TYPE, $INDEXING });
	}

	public static SubLObject get_kb_units_file_vector_descriptions() {
		return copy_tree(dumper.$kb_units_fvector_descriptions$.getGlobalValue());
	}

	public static SubLObject get_kb_units_file_vector_categories() {
		SubLObject categories = NIL;
		SubLObject cdolist_list_var = dumper.$kb_units_fvector_descriptions$.getGlobalValue();
		SubLObject description = NIL;
		description = cdolist_list_var.first();
		while (NIL != cdolist_list_var) {
			final SubLObject pcase_var;
			final SubLObject type = pcase_var = getf(description, $TYPE, $NOT_FOUND);
			if (pcase_var.eql($KNOWLEDGE)) {
				categories = cons(getf(description, $DATA_FILE, dumper.$str177$), categories);
			} else if (pcase_var.eql($INDEXING)) {
				categories = cons(getf(description, $DATA_FILE, dumper.$str177$), categories);
				categories = cons(getf(description, dumper.$COMPLEX_DATA_FILE, dumper.$str177$), categories);
			} else if (pcase_var.eql($NOT_FOUND)) {
				Errors.error(dumper.$str178$File_Vector_category_description_, description);
			} else {
				Errors.warn(dumper.$str179$Skipping_unknown_File_Vector_cate, type);
			}

			cdolist_list_var = cdolist_list_var.rest();
			description = cdolist_list_var.first();
		}
		return nreverse(categories);
	}

	public static final SubLObject kb_dump_to_directory_alt(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.dump_kb_ids(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_essential_kb(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_computable_kb(directory_path);
		return NIL;
	}

	public static SubLObject kb_dump_to_directory(final SubLObject directory_path) {
		dumper.dump_kb_ids(directory_path);
		dumper.dump_essential_kb(directory_path);
		dumper.dump_computable_kb(directory_path);
		return NIL;
	}

	public static SubLObject kb_snapshot_to_directory(final SubLObject active_dir, final SubLObject snapshot_dir) {
		dumper.snapshot_essential_kb(active_dir, snapshot_dir);
		dumper.snapshot_computable_kb(active_dir, snapshot_dir);
		return NIL;
	}

	public static final SubLObject kb_load_from_directory_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			{
				SubLObject common_symbols = com.cyc.cycjava.cycl.dumper.load_special_objects(directory_path);
				if (NIL == $force_monolithic_kb_assumption$.getGlobalValue()) {
					initialize_hl_store_cache_directory_and_shared_symbols(directory_path, common_symbols);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
				}
				{
					SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
					try {
						$cfasl_common_symbols$.bind(NIL, thread);
						cfasl_set_common_symbols(common_symbols);
						{
							SubLObject _prev_bind_0_5 = api_control_vars.$cfasl_constant_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_1 = api_control_vars.$cfasl_nart_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_2 = api_control_vars.$cfasl_assertion_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_3 = api_control_vars.$cfasl_deduction_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_4 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_5 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
									.currentBinding(thread);
							try {
								api_control_vars.$cfasl_constant_handle_lookup_func$.bind(FIND_CONSTANT_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_nart_handle_lookup_func$.bind(FIND_NART_BY_DUMP_ID, thread);
								api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(FIND_ASSERTION_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(FIND_DEDUCTION_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
										.bind(FIND_KB_HL_SUPPORT_BY_DUMP_ID, thread);
								api_control_vars.$cfasl_clause_struc_handle_lookup_func$
										.bind(FIND_CLAUSE_STRUC_BY_DUMP_ID, thread);
								com.cyc.cycjava.cycl.dumper.load_essential_kb(directory_path);
								com.cyc.cycjava.cycl.dumper.load_computable_content(directory_path);
							} finally {
								api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_5, thread);
								api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_4, thread);
								api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_3, thread);
								api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_2, thread);
								api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_1, thread);
								api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_5, thread);
							}
						}
					} finally {
						$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject kb_load_from_directory(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		dumper.kb_load_gc_checkpoint();
		final SubLObject common_symbols = dumper.load_special_objects(directory_path, UNPROVIDED);
		misc_utilities.initialize_hl_store_cache_directory_and_shared_symbols(directory_path, common_symbols);
		dumper.kb_load_gc_checkpoint();
		dumper.kb_possibly_load_manifest_from_directory(directory_path);
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(common_symbols);
			final SubLObject _prev_bind_0_$112 = api_control_vars.$cfasl_constant_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_2 = api_control_vars.$cfasl_nart_handle_lookup_func$.currentBinding(thread);
			final SubLObject _prev_bind_3 = api_control_vars.$cfasl_assertion_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_4 = api_control_vars.$cfasl_deduction_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_5 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_6 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
					.currentBinding(thread);
			try {
				api_control_vars.$cfasl_constant_handle_lookup_func$.bind(dumper.FIND_CONSTANT_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.bind(dumper.FIND_NART_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(dumper.FIND_ASSERTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(dumper.FIND_DEDUCTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.bind(dumper.FIND_KB_HL_SUPPORT_BY_DUMP_ID,
						thread);
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.bind(dumper.FIND_CLAUSE_STRUC_BY_DUMP_ID,
						thread);
				final SubLObject _prev_bind_0_$113 = kb_health_statistics.$kb_health_current_context$
						.currentBinding(thread);
				try {
					kb_health_statistics.$kb_health_current_context$.bind($ESSENTIAL, thread);
					dumper.load_essential_kb(directory_path);
				} finally {
					kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$113, thread);
				}
				final SubLObject _prev_bind_0_$114 = kb_health_statistics.$kb_health_current_context$
						.currentBinding(thread);
				try {
					kb_health_statistics.$kb_health_current_context$.bind($COMPUTABLE, thread);
					dumper.load_computable_content(directory_path);
				} finally {
					kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$114, thread);
				}
			} finally {
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_6, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_5, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_4, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_3, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_2, thread);
				api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_$112, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_kb_ids_alt(SubLObject directory_path) {
		return NIL;
	}

	public static SubLObject dump_kb_ids(final SubLObject directory_path) {
		return NIL;
	}

	public static final SubLObject dump_essential_kb_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread), $str_alt49$________Dumping_essential_KB__);
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			com.cyc.cycjava.cycl.dumper.dump_constant_shells(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_nart_count(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_assertion_count(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_kb_hl_support_count(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_clause_struc_defs(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_deduction_defs(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_assertion_defs(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_kb_hl_support_defs(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_bookkeeping_assertions(directory_path);
			com.cyc.cycjava.cycl.dumper.dump_experience(directory_path);
			sbhl_caching_policies.dump_active_kb_sbhl_caching_policies(directory_path, UNPROVIDED);
			return NIL;
		}
	}

	public static SubLObject dump_essential_kb(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread), dumper.$str181$________Dumping_essential_KB__);
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		dumper.dump_constant_shells(directory_path);
		dumper.dump_nart_count(directory_path);
		dumper.dump_assertion_count(directory_path);
		dumper.dump_kb_hl_support_count(directory_path);
		dumper.dump_clause_struc_defs(directory_path);
		dumper.dump_deduction_defs(directory_path);
		dumper.dump_assertion_defs(directory_path);
		dumper.dump_kb_hl_support_defs(directory_path);
		dumper.dump_bookkeeping_assertions(directory_path);
		dumper.dump_experience(directory_path, UNPROVIDED);
		dump_active_kb_sbhl_caching_policies(directory_path, UNPROVIDED);
		return NIL;
	}

	public static SubLObject snapshot_essential_kb(final SubLObject active_dir, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str182$________Snapshotting_essential_KB);
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($CONSTANT_SHELLS, thread);
			dumper.snapshot_constant_shells(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($NART_SHELLS, thread);
			dumper.snapshot_nart_count(directory_path);
			dumper.snapshot_deleted_nart_id_set(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($ASSERTION_SHELLS, thread);
			dumper.snapshot_assertion_count(directory_path);
			dumper.snapshot_deleted_assertion_id_set(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($DEDUCTION_DEFS, thread);
			dumper.snapshot_deleted_deduction_id_set(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind(dumper.$KB_HL_SUPPORT_SHELLS, thread);
			dumper.snapshot_kb_hl_support_count(directory_path);
			dumper.snapshot_deleted_kb_hl_support_id_set(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind(dumper.$CLAUSE_STRUC_DEFS, thread);
			dumper.snapshot_clause_struc_defs(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($DEDUCTION_DEFS, thread);
			dumper.snapshot_deduction_count(directory_path);
			dumper.snapshot_deduction_defs(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($ASSERTION_DEFS, thread);
			dumper.snapshot_assertion_defs(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind(dumper.$KB_HL_SUPPORT_DEFS, thread);
			dumper.snapshot_kb_hl_support_defs(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($BOOKEEPING_ASSERTIONS, thread);
			dumper.dump_bookkeeping_assertions(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($EXPERIENCE, thread);
			dumper.dump_experience(directory_path, UNPROVIDED);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($POLICIES, thread);
			dump_active_kb_sbhl_caching_policies(directory_path, UNPROVIDED);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_essential_kb_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt50$________Loading_essential_KB_at__, numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			{
				SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
				SubLObject _prev_bind_1 = $cfasl_input_to_static_area$.currentBinding(thread);
				try {
					$structure_resourcing_make_static$.bind(T, thread);
					$cfasl_input_to_static_area$.bind(T, thread);
					com.cyc.cycjava.cycl.dumper.setup_kb_state_from_dump(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_constant_shells(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_nart_shells(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_assertion_shells(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_kb_hl_support_shells(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_clause_struc_defs(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_deduction_defs(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_assertion_defs(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_kb_hl_support_defs(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_bookkeeping_assertions(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_experience(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
				} finally {
					$cfasl_input_to_static_area$.rebind(_prev_bind_1, thread);
					$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
				}
			}
			com.cyc.cycjava.cycl.dumper.load_essential_kb_initializations();
			return NIL;
		}
	}

	public static SubLObject load_essential_kb(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str193$________Loading_essential_KB_at__, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		final SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $cfasl_input_to_static_area$.currentBinding(thread);
		try {
			$structure_resourcing_make_static$.bind(T, thread);
			$cfasl_input_to_static_area$.bind(T, thread);
			final SubLObject _prev_bind_0_$115 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($SETUP, thread);
				dumper.setup_kb_state_from_dump(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$115, thread);
			}
			final SubLObject _prev_bind_0_$116 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($CONSTANT_SHELLS, thread);
				dumper.load_constant_shells(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$116, thread);
			}
			final SubLObject _prev_bind_0_$117 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($NART_SHELLS, thread);
				dumper.load_nart_shells(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$117, thread);
			}
			final SubLObject _prev_bind_0_$118 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($ASSERTION_SHELLS, thread);
				dumper.load_assertion_shells(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$118, thread);
			}
			final SubLObject _prev_bind_0_$119 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$KB_HL_SUPPORT_SHELLS, thread);
				dumper.load_kb_hl_support_shells(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$119, thread);
			}
			final SubLObject _prev_bind_0_$120 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$CLAUSE_STRUC_DEFS, thread);
				dumper.load_clause_struc_defs(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$120, thread);
			}
			final SubLObject _prev_bind_0_$121 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($DEDUCTION_DEFS, thread);
				dumper.load_deduction_defs(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$121, thread);
			}
			final SubLObject _prev_bind_0_$122 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($ASSERTION_DEFS, thread);
				dumper.load_assertion_defs(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$122, thread);
			}
			final SubLObject _prev_bind_0_$123 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$KB_HL_SUPPORT_DEFS, thread);
				dumper.load_kb_hl_support_defs(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$123, thread);
			}
			final SubLObject _prev_bind_0_$124 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($BOOKEEPING_ASSERTIONS, thread);
				dumper.load_bookkeeping_assertions(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$124, thread);
			}
			final SubLObject _prev_bind_0_$125 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($EXPERIENCE, thread);
				dumper.load_experience(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$125, thread);
			}
		} finally {
			$cfasl_input_to_static_area$.rebind(_prev_bind_2, thread);
			$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
		}
		dumper.load_essential_kb_initializations();
		return NIL;
	}

	/**
	 * Initialize the non-dumpable but computable KB aspects exclusively dependent
	 * on the essential KB that other computable KB aspects, whether dumpable or
	 * not, are dependent upon
	 */
	@LispMethod(comment = "Initialize the non-dumpable but computable KB aspects exclusively\r\ndependent on the essential KB that other computable KB aspects,\r\nwhether dumpable or not, are dependent upon\nInitialize the non-dumpable but computable KB aspects exclusively\ndependent on the essential KB that other computable KB aspects,\nwhether dumpable or not, are dependent upon")
	public static final SubLObject load_essential_kb_initializations_alt() {
		com.cyc.cycjava.cycl.dumper.initialize_kb_features();
		return NIL;
	}

	/**
	 * Initialize the non-dumpable but computable KB aspects exclusively dependent
	 * on the essential KB that other computable KB aspects, whether dumpable or
	 * not, are dependent upon
	 */
	@LispMethod(comment = "Initialize the non-dumpable but computable KB aspects exclusively\r\ndependent on the essential KB that other computable KB aspects,\r\nwhether dumpable or not, are dependent upon\nInitialize the non-dumpable but computable KB aspects exclusively\ndependent on the essential KB that other computable KB aspects,\nwhether dumpable or not, are dependent upon")
	public static SubLObject load_essential_kb_initializations() {
		dumper.initialize_kb_features();
		return NIL;
	}

	/**
	 * Initialize the non-dumpable but computable KB aspects exclusively dependent
	 * on the computable KB (e.g.indexing), but not on the remaining HL
	 */
	@LispMethod(comment = "Initialize the non-dumpable but computable KB aspects exclusively\r\ndependent on the computable KB (e.g.indexing), but not on the remaining HL\nInitialize the non-dumpable but computable KB aspects exclusively\ndependent on the computable KB (e.g.indexing), but not on the remaining HL")
	public static final SubLObject load_computable_kb_initializations_alt() {
		return NIL;
	}

	/**
	 * Initialize the non-dumpable but computable KB aspects exclusively dependent
	 * on the computable KB (e.g.indexing), but not on the remaining HL
	 */
	@LispMethod(comment = "Initialize the non-dumpable but computable KB aspects exclusively\r\ndependent on the computable KB (e.g.indexing), but not on the remaining HL\nInitialize the non-dumpable but computable KB aspects exclusively\ndependent on the computable KB (e.g.indexing), but not on the remaining HL")
	public static SubLObject load_computable_kb_initializations() {
		return NIL;
	}

	/**
	 * Initialize the non-dumpable but computable KB aspects dependent on SBHL and
	 * arg type caches.
	 */
	@LispMethod(comment = "Initialize the non-dumpable but computable KB aspects\r\ndependent on SBHL and arg type caches.\nInitialize the non-dumpable but computable KB aspects\ndependent on SBHL and arg type caches.")
	public static final SubLObject load_computable_remaining_hl_low_initializations_alt() {
		subl_identifier.initialize_sublid_mappings();
		return NIL;
	}

	/**
	 * Initialize the non-dumpable but computable KB aspects dependent on SBHL and
	 * arg type caches.
	 */
	@LispMethod(comment = "Initialize the non-dumpable but computable KB aspects\r\ndependent on SBHL and arg type caches.\nInitialize the non-dumpable but computable KB aspects\ndependent on SBHL and arg type caches.")
	public static SubLObject load_computable_remaining_hl_low_initializations() {
		subl_identifier.initialize_sublid_mappings();
		somewhere_cache.initialize_somewhere_cached_pred_argnum_dict();
		return NIL;
	}

	public static final SubLObject dump_computable_content_alt(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.dump_computable_kb(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_computable_remaining_hl(directory_path);
		return NIL;
	}

	public static SubLObject dump_computable_content(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$126 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$127 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$126);
			final SubLObject memory_mappedP_$128 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$126);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$126);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$126);
				final SubLObject manager_$127 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$128 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$127);
				final SubLObject memory_mappedP_$129 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$127);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$127);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$127);
					final SubLObject manager_$128 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$129 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$128);
					final SubLObject memory_mappedP_$130 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$128);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$128);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$128);
						final SubLObject manager_$129 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$130 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$129);
						final SubLObject memory_mappedP_$131 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$129);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$129);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$129);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								dumper.dump_computable_kb(directory_path);
								dumper.dump_computable_remaining_hl(directory_path, UNPROVIDED);
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$130) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$129);
								}
								if (NIL == memory_mappedP_$131) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$129,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$129) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$128);
							}
							if (NIL == memory_mappedP_$130) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$128,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$128) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$127);
						}
						if (NIL == memory_mappedP_$129) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$127,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$127) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$126);
					}
					if (NIL == memory_mappedP_$128) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$126, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject load_computable_content_alt(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.load_computable_kb(directory_path);
		com.cyc.cycjava.cycl.dumper.load_computable_remaining_hl(directory_path);
		return NIL;
	}

	public static SubLObject load_computable_content(final SubLObject directory_path) {
		dumper.load_computable_kb(directory_path);
		dumper.load_computable_remaining_hl(directory_path);
		return NIL;
	}

	public static final SubLObject rebuild_computable_content_alt() {
		com.cyc.cycjava.cycl.dumper.rebuild_computable_kb();
		com.cyc.cycjava.cycl.dumper.rebuild_computable_remaining_hl();
		com.cyc.cycjava.cycl.dumper.rebuild_computable_but_not_dumpable_yet();
		return NIL;
	}

	public static SubLObject rebuild_computable_content() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$138 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$139 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$138);
			final SubLObject memory_mappedP_$140 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$138);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$138);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$138);
				final SubLObject manager_$139 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$140 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$139);
				final SubLObject memory_mappedP_$141 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$139);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$139);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$139);
					final SubLObject manager_$140 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$141 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$140);
					final SubLObject memory_mappedP_$142 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$140);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$140);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$140);
						final SubLObject manager_$141 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$142 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$141);
						final SubLObject memory_mappedP_$143 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$141);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$141);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$141);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								dumper.rebuild_computable_kb();
								dumper.rebuild_computable_remaining_hl(UNPROVIDED);
								dumper.rebuild_computable_but_not_dumpable_yet();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$142) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$141);
								}
								if (NIL == memory_mappedP_$143) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$141,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$141) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$140);
							}
							if (NIL == memory_mappedP_$142) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$140,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$140) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$139);
						}
						if (NIL == memory_mappedP_$141) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$139,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$139) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$138);
					}
					if (NIL == memory_mappedP_$140) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$138, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject rebuild_computable_content_dumpable() {
		com.cyc.cycjava.cycl.dumper.rebuild_computable_kb();
		com.cyc.cycjava.cycl.dumper.rebuild_computable_remaining_hl();
		return NIL;
	}

	public static SubLObject rebuild_computable_content_dumpable(SubLObject rebuild_for_alexandriaP) {
		if (rebuild_for_alexandriaP == UNPROVIDED) {
			rebuild_for_alexandriaP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$150 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$151 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$150);
			final SubLObject memory_mappedP_$152 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$150);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$150);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$150);
				final SubLObject manager_$151 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$152 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$151);
				final SubLObject memory_mappedP_$153 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$151);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$151);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$151);
					final SubLObject manager_$152 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$153 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$152);
					final SubLObject memory_mappedP_$154 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$152);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$152);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$152);
						final SubLObject manager_$153 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$154 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$153);
						final SubLObject memory_mappedP_$155 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$153);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$153);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$153);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								if (NIL == rebuild_for_alexandriaP) {
									dumper.rebuild_computable_kb();
								}
								dumper.rebuild_computable_remaining_hl(rebuild_for_alexandriaP);
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$154) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$153);
								}
								if (NIL == memory_mappedP_$155) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$153,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$153) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$152);
							}
							if (NIL == memory_mappedP_$154) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$152,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$152) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$151);
						}
						if (NIL == memory_mappedP_$153) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$151,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$151) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$150);
					}
					if (NIL == memory_mappedP_$152) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$150, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject rebuild_computable_content_dumpable_low_alt() {
		com.cyc.cycjava.cycl.dumper.rebuild_computable_kb();
		com.cyc.cycjava.cycl.dumper.rebuild_computable_remaining_hl_low();
		com.cyc.cycjava.cycl.dumper.load_computable_remaining_hl_low_initializations();
		return NIL;
	}

	public static SubLObject rebuild_computable_content_dumpable_low() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$162 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$163 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$162);
			final SubLObject memory_mappedP_$164 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$162);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$162);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$162);
				final SubLObject manager_$163 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$164 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$163);
				final SubLObject memory_mappedP_$165 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$163);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$163);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$163);
					final SubLObject manager_$164 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$165 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$164);
					final SubLObject memory_mappedP_$166 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$164);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$164);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$164);
						final SubLObject manager_$165 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$166 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$165);
						final SubLObject memory_mappedP_$167 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$165);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$165);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$165);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								dumper.rebuild_computable_kb();
								dumper.rebuild_computable_remaining_hl_low(UNPROVIDED);
								dumper.load_computable_remaining_hl_low_initializations();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$166) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$165);
								}
								if (NIL == memory_mappedP_$167) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$165,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$165) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$164);
							}
							if (NIL == memory_mappedP_$166) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$164,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$164) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$163);
						}
						if (NIL == memory_mappedP_$165) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$163,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$163) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$162);
					}
					if (NIL == memory_mappedP_$164) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$162, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_computable_kb_alt(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.dump_kb_unrepresented_terms(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_kb_indexing(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_rule_set(directory_path);
		return NIL;
	}

	public static SubLObject dump_computable_kb(final SubLObject directory_path) {
		dumper.dump_kb_unrepresented_terms(directory_path);
		dumper.dump_kb_indexing(directory_path);
		dumper.dump_rule_set(directory_path);
		dumper.dump_non_true_assertion_tv_cache(directory_path);
		return NIL;
	}

	public static SubLObject snapshot_computable_kb(final SubLObject active_dir, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($UNREPRESENTED_TERMS, thread);
			dumper.snapshot_kb_unrepresented_terms(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($KB_INDEXING, thread);
			dumper.snapshot_kb_indexing(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind($RULE_SET, thread);
			dumper.dump_rule_set(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_context$.bind(dumper.$NON_TRUE_ASSERTION_TV_CACHE, thread);
			dumper.dump_non_true_assertion_tv_cache(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_computable_kb_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt51$________Loading_computable_KB_at_, numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			{
				SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
				SubLObject _prev_bind_1 = $cfasl_input_to_static_area$.currentBinding(thread);
				try {
					$structure_resourcing_make_static$.bind(T, thread);
					$cfasl_input_to_static_area$.bind(T, thread);
					com.cyc.cycjava.cycl.dumper.load_kb_unrepresented_terms(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_kb_indexing(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_rule_set(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
				} finally {
					$cfasl_input_to_static_area$.rebind(_prev_bind_1, thread);
					$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
				}
			}
			com.cyc.cycjava.cycl.dumper.load_computable_kb_initializations();
			return NIL;
		}
	}

	public static SubLObject load_computable_kb(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str199$________Loading_computable_KB_at_, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		final SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $cfasl_input_to_static_area$.currentBinding(thread);
		try {
			$structure_resourcing_make_static$.bind(T, thread);
			$cfasl_input_to_static_area$.bind(T, thread);
			final SubLObject _prev_bind_0_$174 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($UNREPRESENTED_TERMS, thread);
				dumper.load_kb_unrepresented_terms(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$174, thread);
			}
			final SubLObject _prev_bind_0_$175 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($KB_INDEXING, thread);
				dumper.load_kb_indexing(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$175, thread);
			}
			final SubLObject _prev_bind_0_$176 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($RULE_SET, thread);
				dumper.load_rule_set(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$176, thread);
			}
			final SubLObject _prev_bind_0_$177 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$NON_TRUE_ASSERTION_TV_CACHE, thread);
				dumper.load_non_true_assertion_tv_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$177, thread);
			}
		} finally {
			$cfasl_input_to_static_area$.rebind(_prev_bind_2, thread);
			$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
		}
		dumper.load_computable_kb_initializations();
		return NIL;
	}

	public static final SubLObject rebuild_computable_kb_alt() {
		com.cyc.cycjava.cycl.dumper.rebuild_kb_indexing();
		assertions_low.rebuild_rule_set();
		com.cyc.cycjava.cycl.dumper.load_computable_kb_initializations();
		return NIL;
	}

	public static SubLObject rebuild_computable_kb() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$178 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$179 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$178);
			final SubLObject memory_mappedP_$180 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$178);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$178);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$178);
				final SubLObject manager_$179 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$180 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$179);
				final SubLObject memory_mappedP_$181 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$179);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$179);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$179);
					final SubLObject manager_$180 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$181 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$180);
					final SubLObject memory_mappedP_$182 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$180);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$180);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$180);
						final SubLObject manager_$181 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$182 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$181);
						final SubLObject memory_mappedP_$183 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$181);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$181);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$181);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								assertions_low.rebuild_rule_set();
								assertions_low.rebuild_non_true_assertion_tv_cache();
								dumper.rebuild_kb_indexing();
								dumper.load_computable_kb_initializations();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$182) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$181);
								}
								if (NIL == memory_mappedP_$183) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$181,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$181) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$180);
							}
							if (NIL == memory_mappedP_$182) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$180,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$180) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$179);
						}
						if (NIL == memory_mappedP_$181) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$179,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$179) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$178);
					}
					if (NIL == memory_mappedP_$180) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$178, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_computable_remaining_hl(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.dump_nart_hl_formulas(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_miscellaneous(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_sbhl_data(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_sbhl_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_cardinality_estimates(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_arg_type_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_defns_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_somewhere_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_arity_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_tva_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_reformulator_rules(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_non_wff_store(directory_path);
		lexicon_cache.dump_lexicon_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_rtp_rules_cache(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_paraphrase_cycl_caches(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_english_units_of_measure(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_cae_query_search_tables(directory_path);
		lexicon_subword_index.dump_nl_trie_subword_index(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_kb_activities(directory_path);
		return NIL;
	}

	public static SubLObject dump_computable_remaining_hl(final SubLObject directory_path, SubLObject alexandriaP) {
		if (alexandriaP == UNPROVIDED) {
			alexandriaP = NIL;
		}
		if (NIL == alexandriaP) {
			dumper.dump_nart_hl_formulas(directory_path);
		}
		return dumper.dump_computable_remaining_hl_shared(directory_path, alexandriaP);
	}

	public static SubLObject dump_computable_remaining_hl_shared(final SubLObject directory_path,
			final SubLObject alexandriaP) {
		//
		// This method could not be decompiled.
		//
		// Original Bytecode:
		//
		// 0: aload_1
		// 1: getstatic
		// com/cyc/cycjava/cycl/UNPROVIDED:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 4: if_acmpne 11
		// 7: getstatic
		// com/cyc/cycjava/cycl/NIL:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLNil;
		// 10: astore_1
		// 11: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/type/core/SubLProcess.currentSubLThread:()Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;
		// 14: astore_2
		// 15: aload_0
		// 16: invokestatic
		// com/cyc/cycjava/cycl/dump_miscellaneous:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 19: pop
		// 20: aload_0
		// 21: invokestatic
		// com/cyc/cycjava/cycl/dump_sbhl_data:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 24: pop
		// 25: aload_0
		// 26: invokestatic
		// com/cyc/cycjava/cycl/dump_sbhl_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 29: pop
		// 30: aload_0
		// 31: invokestatic
		// com/cyc/cycjava/cycl/dump_cardinality_estimates:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 34: pop
		// 35: aload_0
		// 36: invokestatic
		// com/cyc/cycjava/cycl/dump_arg_type_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 39: pop
		// 40: aload_0
		// 41: invokestatic
		// com/cyc/cycjava/cycl/dump_defns_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 44: pop
		// 45: aload_0
		// 46: invokestatic
		// com/cyc/cycjava/cycl/dump_somewhere_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 49: pop
		// 50: aload_0
		// 51: invokestatic
		// com/cyc/cycjava/cycl/dump_arity_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 54: pop
		// 55: aload_0
		// 56: invokestatic
		// com/cyc/cycjava/cycl/dump_tva_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 59: pop
		// 60: aload_0
		// 61: invokestatic
		// com/cyc/cycjava/cycl/dump_reformulator_rules:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 64: pop
		// 65: aload_0
		// 66: invokestatic
		// com/cyc/cycjava/cycl/lexicon_cache.dump_lexicon_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 69: pop
		// 70: aload_0
		// 71: invokestatic
		// com/cyc/cycjava/cycl/dump_rtp_rules_cache:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 74: pop
		// 75: aload_0
		// 76: invokestatic
		// com/cyc/cycjava/cycl/dump_paraphrase_cycl_caches:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 79: pop
		// 80: aload_0
		// 81: invokestatic
		// com/cyc/cycjava/cycl/dump_english_units_of_measure:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 84: pop
		// 85: aload_0
		// 86: invokestatic
		// com/cyc/cycjava/cycl/lexicon_subword_index.dump_nl_trie_subword_index:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 89: pop
		// 90: getstatic
		// com/cyc/cycjava/cycl/NIL:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLNil;
		// 93: aload_1
		// 94: if_acmpeq 110
		// 97: getstatic
		// com/cyc/cycjava/cycl/$kb_dump_common_symbols$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 100: aload_2
		// 101: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.getDynamicValue:(Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 106: invokestatic
		// com/cyc/cycjava/cycl/kb_store_utils.persist_alexandria_special_objects:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 109: pop
		// 110: getstatic
		// com/cyc/cycjava/cycl/NIL:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLNil;
		// 113: aload_1
		// 114: if_acmpne 577
		// 117: aload_0
		// 118: invokestatic
		// com/cyc/cycjava/cycl/dump_kb_activities:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 121: pop
		// 122: getstatic
		// com/cyc/cycjava/cycl/$str200$done:Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLString;
		// 125: aload_0
		// 126: getstatic
		// com/cyc/cycjava/cycl/$str201$text:Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLString;
		// 129: invokestatic
		// com/cyc/cycjava/cycl/kb_dump_file:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 132: astore_3
		// 133: aload_3
		// 134: astore filename_var
		// 136: getstatic
		// com/cyc/cycjava/cycl/NIL:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLNil;
		// 139: astore stream
		// 141: getstatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/stream_macros.$stream_requires_locking$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 144: aload_2
		// 145: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.currentBinding:(Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 150: astore _prev_bind_0
		// 152: getstatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/stream_macros.$stream_requires_locking$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 155: getstatic
		// com/cyc/cycjava/cycl/NIL:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLNil;
		// 158: aload_2
		// 159: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.bind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 164: aload filename_var
		// 166: getstatic
		// com/cyc/cycjava/cycl/$kw202$OUTPUT:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 169: invokestatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/compatibility.open_text:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 172: astore stream
		// 174: getstatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/stream_macros.$stream_requires_locking$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 177: aload _prev_bind_0
		// 179: aload_2
		// 180: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 185: goto 204
		// 188: astore 7
		// 190: getstatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/stream_macros.$stream_requires_locking$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 193: aload _prev_bind_0
		// 195: aload_2
		// 196: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 201: aload 7
		// 203: athrow
		// 204: aload stream
		// 206: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject.isStream:()Z
		// 211: ifne 223
		// 214: getstatic
		// com/cyc/cycjava/cycl/$str152$Unable_to_open__S:Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLString;
		// 217: aload filename_var
		// 219: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Errors.error:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 222: pop
		// 223: aload stream
		// 225: astore stream_$190
		// 227: getstatic
		// com/cyc/cycjava/cycl/$kw202$OUTPUT:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 230: getstatic
		// com/cyc/cycjava/cycl/$kw151$INPUT:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 233: if_acmpne 243
		// 236: aload stream_$190
		// 238: invokestatic
		// com/cyc/cycjava/cycl/file_utilities.enable_file_stream_memory_mapping:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 241: astore stream_$190
		// 243: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 246: aload_2
		// 247: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.currentBinding:(Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 252: astore _prev_bind_0
		// 254: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 257: getstatic
		// com/cyc/cycjava/cycl/T:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLT;
		// 260: aload_2
		// 261: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.bind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 266: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.getValuesAsVector:()Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 269: astore _values
		// 271: aload stream_$190
		// 273: getstatic
		// com/cyc/cycjava/cycl/UNPROVIDED:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 276: invokestatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/streams_high.close:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 279: pop
		// 280: aload _values
		// 282: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.restoreValuesFromVector:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 285: pop
		// 286: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 289: aload _prev_bind_0
		// 291: aload_2
		// 292: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 297: goto 316
		// 300: astore 9
		// 302: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 305: aload _prev_bind_0
		// 307: aload_2
		// 308: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 313: aload 9
		// 315: athrow
		// 316: goto 397
		// 319: astore 10
		// 321: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 324: aload_2
		// 325: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.currentBinding:(Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 330: astore _prev_bind_0
		// 332: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 335: getstatic
		// com/cyc/cycjava/cycl/T:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLT;
		// 338: aload_2
		// 339: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.bind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 344: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.getValuesAsVector:()Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 347: astore _values
		// 349: aload stream_$190
		// 351: getstatic
		// com/cyc/cycjava/cycl/UNPROVIDED:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 354: invokestatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/streams_high.close:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 357: pop
		// 358: aload _values
		// 360: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.restoreValuesFromVector:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 363: pop
		// 364: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 367: aload _prev_bind_0
		// 369: aload_2
		// 370: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 375: goto 394
		// 378: astore 13
		// 380: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 383: aload _prev_bind_0
		// 385: aload_2
		// 386: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 391: aload 13
		// 393: athrow
		// 394: aload 10
		// 396: athrow
		// 397: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 400: aload_2
		// 401: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.currentBinding:(Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 406: astore _prev_bind_0
		// 408: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 411: getstatic
		// com/cyc/cycjava/cycl/T:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLT;
		// 414: aload_2
		// 415: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.bind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 420: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.getValuesAsVector:()Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 423: astore _values
		// 425: aload stream
		// 427: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject.isStream:()Z
		// 432: ifeq 444
		// 435: aload stream
		// 437: getstatic
		// com/cyc/cycjava/cycl/UNPROVIDED:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 440: invokestatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/streams_high.close:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 443: pop
		// 444: aload _values
		// 446: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.restoreValuesFromVector:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 449: pop
		// 450: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 453: aload _prev_bind_0
		// 455: aload_2
		// 456: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 461: goto 480
		// 464: astore 14
		// 466: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 469: aload _prev_bind_0
		// 471: aload_2
		// 472: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 477: aload 14
		// 479: athrow
		// 480: goto 571
		// 483: astore 15
		// 485: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 488: aload_2
		// 489: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.currentBinding:(Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 494: astore _prev_bind_0
		// 496: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 499: getstatic
		// com/cyc/cycjava/cycl/T:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLT;
		// 502: aload_2
		// 503: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.bind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 508: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.getValuesAsVector:()Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 511: astore _values
		// 513: aload stream
		// 515: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject.isStream:()Z
		// 520: ifeq 532
		// 523: aload stream
		// 525: getstatic
		// com/cyc/cycjava/cycl/UNPROVIDED:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 528: invokestatic
		// com/cyc/tool/subl/jrtl/translatedCode/sublisp/streams_high.close:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 531: pop
		// 532: aload _values
		// 534: invokestatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Values.restoreValuesFromVector:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 537: pop
		// 538: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 541: aload _prev_bind_0
		// 543: aload_2
		// 544: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 549: goto 568
		// 552: astore 18
		// 554: getstatic
		// com/cyc/tool/subl/jrtl/nativeCode/subLisp/Threads.$is_thread_performing_cleanupP$:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol;
		// 557: aload _prev_bind_0
		// 559: aload_2
		// 560: invokeinterface
		// com/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLSymbol.rebind:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;)V
		// 565: aload 18
		// 567: athrow
		// 568: aload 15
		// 570: athrow
		// 571: aload filename_var
		// 573: invokestatic
		// com/cyc/cycjava/cycl/discard_dump_filename:(Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;)Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 576: pop
		// 577: getstatic
		// com/cyc/cycjava/cycl/NIL:Lcom/cyc/tool/subl/jrtl/nativeCode/type/symbol/SubLNil;
		// 580: areturn
		// LocalVariableTable:
		// Start Length Slot Name Signature
		// ----- ------ ---- --------------
		// --------------------------------------------------------
		// 152 52 6 _prev_bind_0
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 271 15 8 _values Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 254 62 7 _prev_bind_0
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 349 15 12 _values
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 332 62 11 _prev_bind_0
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 227 170 6 stream_$190
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 425 25 7 _values Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 408 72 6 _prev_bind_0
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 513 25 17 _values
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 496 72 16 _prev_bind_0
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 133 444 3 file Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 136 441 4 filename_var
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 141 436 5 stream Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 15 566 2 thread Lcom/cyc/tool/subl/jrtl/nativeCode/subLisp/SubLThread;
		// 0 581 0 directory_path
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// 0 581 1 alexandriaP
		// Lcom/cyc/tool/subl/jrtl/nativeCode/type/core/SubLObject;
		// Exceptions:
		// Try Handler
		// Start End Start End Type
		// ----- ----- ----- ----- ----
		// 152 174 188 204 Any
		// 188 190 188 204 Any
		// 254 286 300 316 Any
		// 300 302 300 316 Any
		// 332 364 378 380 Any
		// 378 380 378 380 Any
		// 319 321 319 321 Any
		// 408 450 464 480 Any
		// 464 466 464 480 Any
		// 141 397 483 571 Any
		// 496 538 552 568 Any
		// 552 554 552 568 Any
		// 483 485 483 571 Any
		//
		// The error that occurred was:
		//
		// java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
		// at java.util.ArrayList.rangeCheck(ArrayList.java:653)
		// at java.util.ArrayList.get(ArrayList.java:429)
		// at
		// com.strobel.decompiler.ast.AstBuilder.convertLocalVariables(AstBuilder.java:3035)
		// at
		// com.strobel.decompiler.ast.AstBuilder.performStackAnalysis(AstBuilder.java:2445)
		// at com.strobel.decompiler.ast.AstBuilder.build(AstBuilder.java:108)
		// at
		// com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:210)
		// at
		// com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:99)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:757)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:655)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:532)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:499)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:141)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:130)
		// at
		// com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:105)
		// at
		// com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)
		// at
		// com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)
		// at
		// org.sf.feeling.decompiler.actions.ExportSourceAction.exportPackageSources(ExportSourceAction.java:362)
		// at
		// org.sf.feeling.decompiler.actions.ExportSourceAction.access$0(ExportSourceAction.java:288)
		// at
		// org.sf.feeling.decompiler.actions.ExportSourceAction$1.run(ExportSourceAction.java:194)
		// at
		// org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119)
		//
		throw new IllegalStateException("An error occurred while decompiling this method.");
	}

	public static SubLObject snapshot_computable_remaining_hl(final SubLObject directory_path, SubLObject alexandriaP) {
		if (alexandriaP == UNPROVIDED) {
			alexandriaP = NIL;
		}
		if (NIL == alexandriaP) {
			dumper.snapshot_nart_hl_formulas(directory_path);
		}
		return dumper.dump_computable_remaining_hl_shared(directory_path, alexandriaP);
	}

	public static final SubLObject load_computable_remaining_hl_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt52$________Loading_computable_remain, numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			{
				SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
				SubLObject _prev_bind_1 = $cfasl_input_to_static_area$.currentBinding(thread);
				try {
					$structure_resourcing_make_static$.bind(T, thread);
					$cfasl_input_to_static_area$.bind(T, thread);
					com.cyc.cycjava.cycl.dumper.load_nart_hl_formulas(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_miscellaneous(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_sbhl_data(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_sbhl_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_cardinality_estimates(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_arg_type_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_defns_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_somewhere_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_arity_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_tva_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_computable_remaining_hl_low_initializations();
					com.cyc.cycjava.cycl.dumper.load_reformulator_rules(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_non_wff_store(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					lexicon_cache.load_lexicon_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_rtp_rules_cache(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_paraphrase_cycl_caches(directory_path);
					com.cyc.cycjava.cycl.dumper.load_english_units_of_measure(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
					com.cyc.cycjava.cycl.dumper.load_cae_query_search_tables(directory_path);
					com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
				} finally {
					$cfasl_input_to_static_area$.rebind(_prev_bind_1, thread);
					$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_computable_remaining_hl(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str203$________Loading_computable_remain, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		final SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $cfasl_input_to_static_area$.currentBinding(thread);
		try {
			$structure_resourcing_make_static$.bind(T, thread);
			$cfasl_input_to_static_area$.bind(T, thread);
			final SubLObject _prev_bind_0_$191 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$NART_HL_FORMULAS, thread);
				dumper.load_nart_hl_formulas(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$191, thread);
			}
			final SubLObject _prev_bind_0_$192 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($MISC, thread);
				dumper.load_miscellaneous(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$192, thread);
			}
			final SubLObject _prev_bind_0_$193 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($SBHL_DATA, thread);
				dumper.load_sbhl_data(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$193, thread);
			}
			final SubLObject _prev_bind_0_$194 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($SBHL_CACHE, thread);
				dumper.load_sbhl_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$194, thread);
			}
			final SubLObject _prev_bind_0_$195 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($CARDINALITY_ESTIMATES, thread);
				dumper.load_cardinality_estimates(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$195, thread);
			}
			final SubLObject _prev_bind_0_$196 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$ARG_TYPE_CACHE, thread);
				dumper.load_arg_type_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$196, thread);
			}
			final SubLObject _prev_bind_0_$197 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($DEFNS_CACHE, thread);
				dumper.load_defns_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$197, thread);
			}
			final SubLObject _prev_bind_0_$198 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($SOMEWHERE_CACHE, thread);
				dumper.load_somewhere_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$198, thread);
			}
			final SubLObject _prev_bind_0_$199 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($ARITY_CACHE, thread);
				dumper.load_arity_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$199, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$200 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($TVA_CACHE, thread);
				dumper.load_tva_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$200, thread);
			}
			dumper.load_computable_remaining_hl_low_initializations();
			final SubLObject _prev_bind_0_$201 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($REFORMULATOR_RULES, thread);
				dumper.load_reformulator_rules(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$201, thread);
			}
			final SubLObject _prev_bind_0_$202 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($LEXICON_CACHE, thread);
				lexicon_cache.load_lexicon_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$202, thread);
			}
			final SubLObject _prev_bind_0_$203 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($RTP_RULES, thread);
				dumper.load_rtp_rules_cache(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$203, thread);
			}
			final SubLObject _prev_bind_0_$204 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($PARAPHRASE_CACHE, thread);
				dumper.load_paraphrase_cycl_caches(directory_path);
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$204, thread);
			}
			final SubLObject _prev_bind_0_$205 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind($ENGLISH_UOM, thread);
				dumper.load_english_units_of_measure(directory_path);
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$205, thread);
			}
			dumper.kb_load_gc_checkpoint();
			final SubLObject _prev_bind_0_$206 = kb_health_statistics.$kb_health_current_context$
					.currentBinding(thread);
			try {
				kb_health_statistics.$kb_health_current_context$.bind(dumper.$CAE_QUERY_SEARCH_TABLES, thread);
				dumper.load_cae_query_search_tables(directory_path);
				dumper.kb_load_gc_checkpoint();
			} finally {
				kb_health_statistics.$kb_health_current_context$.rebind(_prev_bind_0_$206, thread);
			}
		} finally {
			$cfasl_input_to_static_area$.rebind(_prev_bind_2, thread);
			$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	/**
	 * Rebuilding analog of @xref LOAD-COMPUTABLE-CONTENT
	 */
	@LispMethod(comment = "Rebuilding analog of @xref LOAD-COMPUTABLE-CONTENT")
	public static final SubLObject rebuild_computable_remaining_hl() {
		com.cyc.cycjava.cycl.dumper.rebuild_computable_remaining_hl_low();
		com.cyc.cycjava.cycl.dumper.load_computable_remaining_hl_low_initializations();
		com.cyc.cycjava.cycl.dumper.rebuild_computable_remaining_hl_high();
		return NIL;
	}

	public static SubLObject rebuild_computable_remaining_hl(SubLObject rebuild_for_alexandriaP) {
		if (rebuild_for_alexandriaP == UNPROVIDED) {
			rebuild_for_alexandriaP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$207 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$208 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$207);
			final SubLObject memory_mappedP_$209 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$207);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$207);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$207);
				final SubLObject manager_$208 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$209 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$208);
				final SubLObject memory_mappedP_$210 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$208);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$208);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$208);
					final SubLObject manager_$209 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$210 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$209);
					final SubLObject memory_mappedP_$211 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$209);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$209);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$209);
						final SubLObject manager_$210 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$211 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$210);
						final SubLObject memory_mappedP_$212 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$210);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$210);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$210);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								dumper.rebuild_computable_remaining_hl_low(rebuild_for_alexandriaP);
								dumper.load_computable_remaining_hl_low_initializations();
								dumper.rebuild_computable_remaining_hl_high(UNPROVIDED);
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$211) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$210);
								}
								if (NIL == memory_mappedP_$212) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$210,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$210) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$209);
							}
							if (NIL == memory_mappedP_$211) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$209,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$209) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$208);
						}
						if (NIL == memory_mappedP_$210) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$208,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$208) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$207);
					}
					if (NIL == memory_mappedP_$209) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$207, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject rebuild_computable_remaining_hl_low() {
		narts_interface.rebuild_nart_hl_formulas();
		arity.rebuild_arity_cache();
		rebuild_somewhere_cache();
		com.cyc.cycjava.cycl.dumper.rebuild_sbhl_data();
		sbhl_link_methods.rebuild_non_fort_isa_tables();
		com.cyc.cycjava.cycl.dumper.rebuild_sbhl_cache();
		cardinality_estimates.rebuild_cardinality_estimates();
		skolems.reset_skolem_defn_table(T, NIL);
		com.cyc.cycjava.cycl.dumper.rebuild_arg_type_cache();
		defns.rebuild_defns_cache();
		tva_cache.rebuild_tva_cache();
		if (NIL != kb_control_vars.reformulator_kb_loaded_p()) {
			reformulator_rule_unifier_datastructures.rebuild_reformulator_rules();
		} else {
			Errors.warn($str_alt53$Cannot_initialize_reformulator_du);
		}
		if (NIL != kb_control_vars.lexicon_kb_loaded_p()) {
			lexicon_cache.initialize_lexicon_modules();
			if (NIL == lexicon_cache.lexicon_cache_builtP()) {
				lexicon_cache.rebuild_lexicon_cache();
			}
		} else {
			Errors.warn($str_alt54$Cannot_initialize_lexicon_cache_d);
		}
		if (NIL != kb_control_vars.paraphrase_kb_loaded_p()) {
			pph_main.initialize_paraphrase_cycl();
		}
		return NIL;
	}

	public static SubLObject rebuild_computable_remaining_hl_low(SubLObject rebuild_for_alexandriaP) {
		if (rebuild_for_alexandriaP == UNPROVIDED) {
			rebuild_for_alexandriaP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$219 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$220 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$219);
			final SubLObject memory_mappedP_$221 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$219);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$219);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$219);
				final SubLObject manager_$220 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$221 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$220);
				final SubLObject memory_mappedP_$222 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$220);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$220);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$220);
					final SubLObject manager_$221 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$222 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$221);
					final SubLObject memory_mappedP_$223 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$221);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$221);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$221);
						final SubLObject manager_$222 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$223 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$222);
						final SubLObject memory_mappedP_$224 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$222);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$222);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$222);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								if (NIL == rebuild_for_alexandriaP) {
									narts_interface.rebuild_nart_hl_formulas();
								}
								arity.rebuild_arity_cache();
								alexandria_iterators.clear_alexandria_caches();
								somewhere_cache.rebuild_somewhere_cache();
								alexandria_iterators.clear_alexandria_caches();
								dumper.rebuild_sbhl_data();
								alexandria_iterators.clear_alexandria_caches();
								rebuild_non_fort_isa_tables();
								alexandria_iterators.clear_alexandria_caches();
								dumper.rebuild_sbhl_cache();
								alexandria_iterators.clear_alexandria_caches();
								cardinality_estimates.rebuild_cardinality_estimates();
								alexandria_iterators.clear_alexandria_caches();
								skolems.reset_skolem_defn_table(T, NIL);
								alexandria_iterators.clear_alexandria_caches();
								dumper.rebuild_arg_type_cache();
								alexandria_iterators.clear_alexandria_caches();
								defns.rebuild_defns_cache();
								alexandria_iterators.clear_alexandria_caches();
								tva_cache.rebuild_tva_cache();
								alexandria_iterators.clear_alexandria_caches();
								if (NIL != kb_control_vars.reformulator_kb_loaded_p()) {
									reformulator_rule_unifier_datastructures.rebuild_reformulator_rules();
								} else {
									Errors.warn(dumper.$str220$Cannot_initialize_reformulator_du);
								}
								alexandria_iterators.clear_alexandria_caches();
								if (NIL != kb_control_vars.lexicon_kb_loaded_p()) {
									lexicon_cache.initialize_lexicon_modules();
									if (NIL == lexicon_cache.lexicon_cache_builtP()) {
										lexicon_cache.rebuild_lexicon_cache();
									}
								} else {
									Errors.warn(dumper.$str221$Cannot_initialize_lexicon_cache_d);
								}
								alexandria_iterators.clear_alexandria_caches();
								if (NIL != kb_control_vars.paraphrase_kb_loaded_p()) {
									alexandria_iterators.clear_alexandria_caches();
									pph_main.initialize_paraphrase_cycl();
								}
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$223) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$222);
								}
								if (NIL == memory_mappedP_$224) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$222,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$222) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$221);
							}
							if (NIL == memory_mappedP_$223) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$221,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$221) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$220);
						}
						if (NIL == memory_mappedP_$222) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$220,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$220) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$219);
					}
					if (NIL == memory_mappedP_$221) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$219, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		alexandria_iterators.clear_alexandria_caches();
		return NIL;
	}

	public static final SubLObject rebuild_computable_remaining_hl_high() {
		if (NIL != kb_control_vars.rtp_kb_loaded_p()) {
			rtp_initialize.initialize_and_populate_rtp(UNPROVIDED, UNPROVIDED);
		} else {
			Errors.warn($str_alt55$Cannot_initialize_recursive_templ);
		}
		if ((NIL != kb_control_vars.lexicon_kb_loaded_p()) && (NIL != lexicon_initialized_p())) {
			lexicon_subword_index.build_nl_trie_subword_index();
		}
		return NIL;
	}

	public static SubLObject rebuild_computable_remaining_hl_high(SubLObject rebuild_for_alexandriaP) {
		if (rebuild_for_alexandriaP == UNPROVIDED) {
			rebuild_for_alexandriaP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$231 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$232 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$231);
			final SubLObject memory_mappedP_$233 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$231);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$231);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$231);
				final SubLObject manager_$232 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$233 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$232);
				final SubLObject memory_mappedP_$234 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$232);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$232);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$232);
					final SubLObject manager_$233 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$234 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$233);
					final SubLObject memory_mappedP_$235 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$233);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$233);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$233);
						final SubLObject manager_$234 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$235 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$234);
						final SubLObject memory_mappedP_$236 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$234);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$234);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$234);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								if ((NIL != kb_control_vars.lexicon_kb_loaded_p())
										&& (NIL != lexicon_initialized_p())) {
									lexicon_subword_index.build_nl_trie_subword_index();
								}
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$235) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$234);
								}
								if (NIL == memory_mappedP_$236) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$234,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$234) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$233);
							}
							if (NIL == memory_mappedP_$235) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$233,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$233) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$232);
						}
						if (NIL == memory_mappedP_$234) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$232,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$232) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$231);
					}
					if (NIL == memory_mappedP_$233) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$231, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	/**
	 * These are former 'initializations' that are rebuilding expensive (in both
	 * time and space) structures and so should *not* be part of
	 * load-kb-initializations, but part of
	 * [dump/load/rebuild]-computable-remaining-hl. The refactoring to do that
	 * requires: identifying the initializations the rebuild depends on and adding
	 * it before the rebuild in rebuild-computable-remaining-hl (@see
	 * lexicon-cache's dependency on initialize-lexicon-modules), then making the
	 * structures dump/loadable, which in the case of most of these is non-trivial.
	 */
	@LispMethod(comment = "These are former \'initializations\' that are rebuilding expensive (in both time and space) structures and so should *not* be part of load-kb-initializations, but part of [dump/load/rebuild]-computable-remaining-hl.  The refactoring to do that requires: identifying the initializations the rebuild depends on and adding it before the rebuild in rebuild-computable-remaining-hl (@see lexicon-cache\'s dependency on initialize-lexicon-modules), then making the structures dump/loadable, which in the case of most of these is non-trivial.")
	public static final SubLObject rebuild_computable_but_not_dumpable_yet_alt() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt56$________Rebuilding_computable_but, numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			{
				SubLObject _prev_bind_0 = wff_vars.$wff_memoization_state$.currentBinding(thread);
				try {
					wff_vars.$wff_memoization_state$.bind(wff_macros.possibly_new_wff_memoization_state(), thread);
					{
						SubLObject local_state = wff_vars.$wff_memoization_state$.getDynamicValue(thread);
						{
							SubLObject _prev_bind_0_6 = memoization_state.$memoization_state$.currentBinding(thread);
							try {
								memoization_state.$memoization_state$.bind(local_state, thread);
								{
									SubLObject original_memoization_process = NIL;
									if ((NIL != local_state)
											&& (NIL == memoization_state.memoization_state_lock(local_state))) {
										original_memoization_process = memoization_state
												.memoization_state_get_current_process_internal(local_state);
										{
											SubLObject current_proc = current_process();
											if (NIL == original_memoization_process) {
												memoization_state.memoization_state_set_current_process_internal(
														local_state, current_proc);
											} else {
												if (original_memoization_process != current_proc) {
													Errors.error($str_alt57$Invalid_attempt_to_reuse_memoizat);
												}
											}
										}
									}
									try {
										if (NIL == wff_macros.within_wffP()) {
											wff.reset_wff_state();
										}
									} finally {
										{
											SubLObject _prev_bind_0_7 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												{
													SubLObject already_resourcing_p = sbhl_marking_vars.$resourcing_sbhl_marking_spaces_p$
															.getDynamicValue(thread);
													{
														SubLObject _prev_bind_0_8 = sbhl_marking_vars.$resourced_sbhl_marking_space_limit$
																.currentBinding(thread);
														SubLObject _prev_bind_1 = sbhl_marking_vars.$resourced_sbhl_marking_spaces$
																.currentBinding(thread);
														SubLObject _prev_bind_2 = sbhl_marking_vars.$resourcing_sbhl_marking_spaces_p$
																.currentBinding(thread);
														try {
															sbhl_marking_vars.$resourced_sbhl_marking_space_limit$.bind(
																	sbhl_marking_vars.determine_resource_limit(
																			already_resourcing_p, TWELVE_INTEGER),
																	thread);
															sbhl_marking_vars.$resourced_sbhl_marking_spaces$.bind(
																	sbhl_marking_vars.possibly_new_marking_resource(
																			already_resourcing_p),
																	thread);
															sbhl_marking_vars.$resourcing_sbhl_marking_spaces_p$.bind(T,
																	thread);
															if (NIL != kb_control_vars.paraphrase_kb_loaded_p()) {
																pph_main.ensure_pph_initialized();
																com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
															} else {
																Errors.warn(
																		$str_alt58$Cannot_initialize_paraphrase_code);
															}
															if (NIL != kb_control_vars.sksi_kb_loaded_p()) {
																sksi_infrastructure_utilities
																		.initialize_sksi_data_structures();
																com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
															} else {
																Errors.warn(
																		$str_alt59$Cannot_initialize_SKSI_due_to_mis);
															}
															if ((NIL != kb_control_vars.rtp_kb_loaded_p())
																	&& (NIL != kb_control_vars.nl_kb_loaded_p())) {
																rtp_initialize.initialize_and_repopulate_rtp(UNPROVIDED,
																		UNPROVIDED);
																com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
															} else {
																Errors.warn(
																		$str_alt60$Cannot_initialize_recursive_templ);
															}
															if (NIL != api_widgets.fet_categorized_source_pred()) {
																api_widgets.initialize_fet_sources();
																com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
															} else {
																Errors.warn(
																		$str_alt61$Cannot_initialize_fact_entry_tool);
															}
															if (NIL != kb_control_vars.cyc_secure_kb_loaded_p()) {
																// infrastructure_vars.initialize_cycsecure_data_structures();
																com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
															} else {
																Errors.warn(
																		$str_alt62$Cannot_initialize_cycsecure_due_t);
															}
														} finally {
															sbhl_marking_vars.$resourcing_sbhl_marking_spaces_p$
																	.rebind(_prev_bind_2, thread);
															sbhl_marking_vars.$resourced_sbhl_marking_spaces$
																	.rebind(_prev_bind_1, thread);
															sbhl_marking_vars.$resourced_sbhl_marking_space_limit$
																	.rebind(_prev_bind_0_8, thread);
														}
													}
												}
												if ((NIL != local_state) && (NIL == original_memoization_process)) {
													memoization_state.memoization_state_set_current_process_internal(
															local_state, NIL);
												}
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_7, thread);
											}
										}
									}
								}
							} finally {
								memoization_state.$memoization_state$.rebind(_prev_bind_0_6, thread);
							}
						}
					}
				} finally {
					wff_vars.$wff_memoization_state$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	/**
	 * These are former 'initializations' that are rebuilding expensive (in both
	 * time and space) structures and so should *not* be part of
	 * load-kb-initializations, but part of
	 * [dump/load/rebuild]-computable-remaining-hl. The refactoring to do that
	 * requires: identifying the initializations the rebuild depends on and adding
	 * it before the rebuild in rebuild-computable-remaining-hl (@see
	 * lexicon-cache's dependency on initialize-lexicon-modules), then making the
	 * structures dump/loadable, which in the case of most of these is non-trivial.
	 */
	@LispMethod(comment = "These are former \'initializations\' that are rebuilding expensive (in both time and space) structures and so should *not* be part of load-kb-initializations, but part of [dump/load/rebuild]-computable-remaining-hl.  The refactoring to do that requires: identifying the initializations the rebuild depends on and adding it before the rebuild in rebuild-computable-remaining-hl (@see lexicon-cache\'s dependency on initialize-lexicon-modules), then making the structures dump/loadable, which in the case of most of these is non-trivial.")
	public static SubLObject rebuild_computable_but_not_dumpable_yet() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format_nil.force_format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str222$________Rebuilding_computable_but, numeric_date_utilities.timestring(UNPROVIDED),
					UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
		}
		final SubLObject _prev_bind_0 = wff_vars.$wff_memoization_state$.currentBinding(thread);
		try {
			wff_vars.$wff_memoization_state$.bind(wff_macros.possibly_new_wff_memoization_state(), thread);
			final SubLObject local_state = wff_vars.$wff_memoization_state$.getDynamicValue(thread);
			final SubLObject _prev_bind_0_$243 = memoization_state.$memoization_state$.currentBinding(thread);
			try {
				memoization_state.$memoization_state$.bind(local_state, thread);
				final SubLObject original_memoization_process = memoization_state
						.memoization_state_original_process(local_state);
				try {
					if (NIL == wff_macros.within_wffP()) {
						wff.reset_wff_state();
					}
					final SubLObject already_resourcing_p = $resourcing_sbhl_marking_spaces_p$.getDynamicValue(thread);
					final SubLObject _prev_bind_0_$244 = $resourced_sbhl_marking_space_limit$.currentBinding(thread);
					final SubLObject _prev_bind_2 = $resourced_sbhl_marking_spaces$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $resourcing_sbhl_marking_spaces_p$.currentBinding(thread);
					try {
						$resourced_sbhl_marking_space_limit$
								.bind(determine_resource_limit(already_resourcing_p, TWELVE_INTEGER), thread);
						$resourced_sbhl_marking_spaces$.bind(possibly_new_marking_resource(already_resourcing_p),
								thread);
						$resourcing_sbhl_marking_spaces_p$.bind(T, thread);
						if (NIL != kb_control_vars.paraphrase_kb_loaded_p()) {
							pph_main.ensure_pph_initialized();
							dumper.kb_load_gc_checkpoint();
						} else {
							Errors.warn(dumper.$str223$Cannot_initialize_paraphrase_code);
						}
						if (NIL != kb_control_vars.sksi_kb_loaded_p()) {
							sksi_infrastructure_utilities.initialize_sksi_data_structures();
							dumper.kb_load_gc_checkpoint();
						} else {
							Errors.warn(dumper.$str224$Cannot_initialize_SKSI_due_to_mis);
						}
					} finally {
						$resourcing_sbhl_marking_spaces_p$.rebind(_prev_bind_3, thread);
						$resourced_sbhl_marking_spaces$.rebind(_prev_bind_2, thread);
						$resourced_sbhl_marking_space_limit$.rebind(_prev_bind_0_$244, thread);
					}
				} finally {
					final SubLObject _prev_bind_0_$245 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						memoization_state.memoization_state_possibly_clear_original_process(local_state,
								original_memoization_process);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$245, thread);
					}
				}
			} finally {
				memoization_state.$memoization_state$.rebind(_prev_bind_0_$243, thread);
			}
		} finally {
			wff_vars.$wff_memoization_state$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_copyright_alt(SubLObject stream) {
		return cfasl_output(copyright_notice(), stream);
	}

	public static SubLObject dump_copyright(final SubLObject stream) {
		return cfasl_output(misc_utilities.copyright_notice(), stream);
	}

	public static SubLObject kb_dump_stamp_file_vector_for_references(final SubLObject fvector) {
		return file_vector_utilities.stamp_file_vector_for_references(fvector, misc_utilities.copyright_notice(),
				UNPROVIDED);
	}

	public static final SubLObject load_copyright_alt(SubLObject stream) {
		{
			SubLObject copyright = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			SubLTrampolineFile.checkType(copyright, STRINGP);
			return copyright;
		}
	}

	public static SubLObject load_copyright(final SubLObject stream) {
		final SubLObject copyright = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		assert NIL != stringp(copyright) : "! stringp(copyright) "
				+ ("Types.stringp(copyright) " + "CommonSymbols.NIL != Types.stringp(copyright) ") + copyright;
		return copyright;
	}

	/**
	 * A helper used for a few of the KB object load methods.
	 *
	 * @param LOAD-FUNC; a unary function-spec-p that takes a stream as its single
	 *                   argument.
	 */
	@LispMethod(comment = "A helper used for a few of the KB object load methods.\r\n\r\n@param LOAD-FUNC;\r\n\t\ta unary function-spec-p that takes a stream as its single argument.")
	public static final SubLObject load_unit_file_alt(SubLObject dump_directory, SubLObject filename,
			SubLObject load_func, SubLObject progress_message) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			SubLTrampolineFile.checkType(dump_directory, STRINGP);
			SubLTrampolineFile.checkType(filename, STRINGP);
			SubLTrampolineFile.checkType(load_func, SYMBOLP);
			SubLTrampolineFile.checkType(progress_message, STRINGP);
			{
				SubLObject unit_file = com.cyc.cycjava.cycl.dumper.kb_dump_file(filename, dump_directory, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(unit_file, T)) {
					{
						SubLObject filename_var = unit_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_9 = stream;
								SubLObject total = file_length(stream_9);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_9);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble(progress_message);
										funcall(load_func, stream_9);
										if (cfasl_input(stream_9, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_9)),
													unit_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	/**
	 * A helper used for a few of the KB object load methods.
	 *
	 * @param LOAD-FUNC; a unary function-spec-p that takes a stream as its single
	 *                   argument.
	 */
	@LispMethod(comment = "A helper used for a few of the KB object load methods.\r\n\r\n@param LOAD-FUNC;\r\n\t\ta unary function-spec-p that takes a stream as its single argument.")
	public static SubLObject load_unit_file(final SubLObject dump_directory, final SubLObject filename,
			final SubLObject load_func, final SubLObject progress_message) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		assert NIL != stringp(dump_directory) : "! stringp(dump_directory) "
				+ ("Types.stringp(dump_directory) " + "CommonSymbols.NIL != Types.stringp(dump_directory) ")
				+ dump_directory;
		assert NIL != stringp(filename) : "! stringp(filename) "
				+ ("Types.stringp(filename) " + "CommonSymbols.NIL != Types.stringp(filename) ") + filename;
		assert NIL != symbolp(load_func) : "! symbolp(load_func) "
				+ ("Types.symbolp(load_func) " + "CommonSymbols.NIL != Types.symbolp(load_func) ") + load_func;
		assert NIL != stringp(progress_message) : "! stringp(progress_message) "
				+ ("Types.stringp(progress_message) " + "CommonSymbols.NIL != Types.stringp(progress_message) ")
				+ progress_message;
		final SubLObject unit_file = dumper.kb_dump_file(filename, dump_directory, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(unit_file, T)) {
			final SubLObject filename_var = unit_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$246 = stream;
				if ($INPUT == $INPUT) {
					stream_$246 = file_utilities.enable_file_stream_memory_mapping(stream_$246);
				}
				try {
					final SubLObject total = file_length(stream_$246);
					dumper.load_copyright(stream_$246);
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$
								.bind(NIL != progress_message ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(progress_message);
						funcall(load_func, stream_$246);
						if (cfasl_input(stream_$246, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$246)), unit_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$246, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject dump_kb_object_count_alt(SubLObject directory_path, SubLObject filename,
			SubLObject count) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject count_file = com.cyc.cycjava.cycl.dumper.kb_dump_file(filename, directory_path, $$$text);
				SubLObject filename_var = count_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_text(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_10 = stream;
						format(stream_10, $str_alt70$_a__, count);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_kb_object_count(final SubLObject directory_path, final SubLObject filename,
			final SubLObject count) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject count_file = filename_var = dumper.kb_dump_file(filename, directory_path, dumper.$$$text);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_text(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$247 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$247 = file_utilities.enable_file_stream_memory_mapping(stream_$247);
			}
			try {
				format(stream_$247, dumper.$str228$_a__, count);
			} finally {
				final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$247, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_kb_object_count_alt(SubLObject directory_path, SubLObject filename) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject result = NIL;
				SubLObject text_file = com.cyc.cycjava.cycl.dumper.kb_dump_file(filename, directory_path, $$$text);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(text_file, T)) {
					{
						SubLObject filename_var = text_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_text(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_11 = stream;
								SubLObject count = read(stream_11, UNPROVIDED, UNPROVIDED, UNPROVIDED);
								SubLTrampolineFile.checkType(count, NON_NEGATIVE_INTEGER_P);
								result = count;
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
				return result;
			}
		}
	}

	public static SubLObject load_kb_object_count(final SubLObject directory_path, final SubLObject filename) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		final SubLObject text_file = dumper.kb_dump_file(filename, directory_path, dumper.$$$text);
		if (NIL != dumper.verify_file_existence(text_file, T)) {
			final SubLObject filename_var = text_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_text(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$248 = stream;
				if ($INPUT == $INPUT) {
					stream_$248 = file_utilities.enable_file_stream_memory_mapping(stream_$248);
				}
				try {
					final SubLObject count = read(stream_$248, UNPROVIDED, UNPROVIDED, UNPROVIDED);
					assert NIL != subl_promotions
							.non_negative_integer_p(count) : "! subl_promotions.non_negative_integer_p(count) "
									+ ("subl_promotions.non_negative_integer_p(count) "
											+ "CommonSymbols.NIL != subl_promotions.non_negative_integer_p(count) ")
									+ count;
					result = count;
				} finally {
					final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$248, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return result;
	}

	public static SubLObject snapshot_kb_object_deleted_id_set(final SubLObject directory_path,
			final SubLObject filename, final SubLObject deleted_ids, SubLObject id_type) {
		if (id_type == UNPROVIDED) {
			id_type = dumper.$$$id;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject deleted_ids_file = dumper.kb_dump_file(filename, directory_path, UNPROVIDED);
		if (NIL == set.set_emptyP(deleted_ids)) {
			final SubLObject deletions = set.set_size(deleted_ids);
			final SubLObject modification = (ONE_INTEGER.numE(deletions)) ? dumper.$$$_was : dumper.$$$s_were;
			final SubLObject str;
			final SubLObject msg = str = cconcatenate(dumper.$$$Noting_that_,
					new SubLObject[] { format_nil.format_nil_d_no_copy(deletions), dumper.$$$_,
							format_nil.format_nil_a_no_copy(id_type), format_nil.format_nil_a_no_copy(modification),
							dumper.$$$_deleted });
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				cfasl_utilities.cfasl_save(deleted_ids, deleted_ids_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return NIL;
	}

	public static SubLObject load_kb_object_deleted_id_set(final SubLObject directory_path, final SubLObject filename) {
		final SubLObject deleted_ids_file = dumper.kb_dump_file(filename, directory_path, UNPROVIDED);
		if (NIL != Filesys.probe_file(deleted_ids_file)) {
			final SubLObject deletes = cfasl_utilities.cfasl_load(deleted_ids_file);
			if (NIL != set.set_p(deletes)) {
				return deletes;
			}
			Errors.warn(dumper.$str236$Deleted_IDs_file__A_contained_no_, deleted_ids_file);
		}
		return set.new_set(EQL, UNPROVIDED);
	}

	public static SubLObject snapshot_changed_managed_objects(final SubLObject fvector,
			final SubLObject complex_fvector, final SubLObject muted_iterator, final SubLObject id_to_object_fn,
			final SubLObject snapshot_fn, final SubLObject message) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != message ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(message);
			final SubLObject data_stream = file_vector.get_file_vector_data_stream(fvector);
			final SubLObject complex_index_changes = set.new_set(UNPROVIDED, UNPROVIDED);
			SubLObject previous = MINUS_ONE_INTEGER;
			final SubLObject _prev_bind_0_$249 = $changed_index_entry_hints$.currentBinding(thread);
			try {
				$changed_index_entry_hints$.bind(complex_index_changes, thread);
				SubLObject valid;
				for (SubLObject done_var = NIL; NIL == done_var; done_var = makeBoolean(NIL == valid)) {
					thread.resetMultipleValues();
					final SubLObject tuple = iteration.iteration_next(muted_iterator);
					valid = thread.secondMultipleValue();
					thread.resetMultipleValues();
					if (NIL != valid) {
						SubLObject current;
						final SubLObject datum = current = tuple;
						SubLObject id = NIL;
						SubLObject payload = NIL;
						destructuring_bind_must_consp(current, datum, dumper.$list237);
						id = current.first();
						current = current.rest();
						destructuring_bind_must_consp(current, datum, dumper.$list237);
						payload = current.first();
						current = current.rest();
						if (NIL == current) {
							if ((NIL != dumper.$dump_verbose$.getDynamicValue(thread)) && id.numL(previous)) {
								Errors.warn(T, dumper.$str238$__Dump_ID_regressed_from__A_to__A, previous, id);
							}
							previous = id;
							final SubLObject v_object = funcall(id_to_object_fn, id);
							file_vector.position_file_vector_index_for_update(fvector, id);
							if (NIL != dumper.$dump_verbose_detail$.getDynamicValue(thread)) {
								format(T, dumper.$str239$______writing__S____A__index__i_e, new SubLObject[] { v_object,
										id,
										file_position(file_vector.get_file_vector_index_stream(fvector), UNPROVIDED),
										file_position(file_vector.get_file_vector_data_stream(fvector), UNPROVIDED) });
							}
							file_vector.overwrite_file_vector_index(fvector);
							final SubLObject _prev_bind_0_$250 = kb_health_statistics.$kb_health_current_sub_context$
									.currentBinding(thread);
							try {
								kb_health_statistics.$kb_health_current_sub_context$.bind(v_object, thread);
								funcall(snapshot_fn, v_object, payload, data_stream, complex_fvector);
							} finally {
								kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0_$250, thread);
							}
						} else {
							cdestructuring_bind_error(datum, dumper.$list237);
						}
					}
				}
				if (NIL == set.set_emptyP(complex_index_changes)) {
					final SubLObject change_iterator = iteration.new_list_iterator(
							Sort.sort(set.set_element_list(complex_index_changes), dumper.$sym240$_, UNPROVIDED));
					dumper.snapshot_deleted_object_tombstones(complex_fvector, change_iterator,
							dumper.$str241$____tombstoning_companion_complex);
				}
			} finally {
				$changed_index_entry_hints$.rebind(_prev_bind_0_$249, thread);
			}
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return fvector;
	}

	public static SubLObject snapshot_new_managed_objects(final SubLObject fvector, final SubLObject new_iterator,
			final SubLObject id_threshold, final SubLObject object_to_id_fn, final SubLObject snapshot_fn,
			final SubLObject message, SubLObject complex_fvector) {
		if (complex_fvector == UNPROVIDED) {
			complex_fvector = $UNPROVIDED;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject expected_id = id_threshold;
		final SubLObject wide_fvectorP = file_vector.wide_file_vectorP(fvector);
		final SubLObject wide_complex_fvectorP = (NIL != file_vector.file_vector_p(complex_fvector))
				? file_vector.wide_file_vectorP(complex_fvector)
				: NIL;
		final SubLObject data_stream = file_vector.get_file_vector_data_stream(fvector);
		file_vector.position_file_vector_index(fvector, expected_id);
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != message ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(message);
			SubLObject valid;
			for (SubLObject done_var = NIL; NIL == done_var; done_var = makeBoolean(NIL == valid)) {
				thread.resetMultipleValues();
				final SubLObject v_object = iteration.iteration_next(new_iterator);
				valid = thread.secondMultipleValue();
				thread.resetMultipleValues();
				if (NIL != valid) {
					final SubLObject curr_id = funcall(object_to_id_fn, v_object);
					if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && curr_id.numL(expected_id)) {
						Errors.error(dumper.$str243$ID_ordering_regressed_from__A_to_, expected_id, curr_id);
					}
					while (expected_id.numL(curr_id)) {
						if (NIL != dumper.$dump_verbose_detail$.getDynamicValue(thread)) {
							format(T, dumper.$str244$______tombstoning____A__index__i_, expected_id,
									file_position(file_vector.get_file_vector_index_stream(fvector), UNPROVIDED));
						}
						file_vector.place_file_vector_index_tombstone_linear(fvector);
						expected_id = add(expected_id, ONE_INTEGER);
					}
					if (NIL != dumper.$dump_verbose_detail$.getDynamicValue(thread)) {
						format(T, dumper.$str245$______appending__S____A__index__i,
								new SubLObject[] { v_object, curr_id,
										file_position(file_vector.get_file_vector_index_stream(fvector), UNPROVIDED),
										file_position(file_vector.get_file_vector_data_stream(fvector), UNPROVIDED) });
					}
					file_vector.update_file_vector_index_linear(fvector);
					if (NIL != file_vector.file_vector_p(complex_fvector)) {
						funcall(snapshot_fn, v_object, data_stream, complex_fvector);
						if ((NIL == wide_complex_fvectorP) && (NIL != file_vector.wide_file_vectorP(complex_fvector))) {
							sublisp_throw($OVERFLOW, $COMPLEX);
						}
					} else {
						funcall(snapshot_fn, v_object, data_stream);
						if ((NIL == wide_fvectorP) && (NIL != file_vector.wide_file_vectorP(fvector))) {
							sublisp_throw($OVERFLOW, $FVECTOR);
						}
					}
					expected_id = add(ONE_INTEGER, curr_id);
				}
			}
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return fvector;
	}

	public static SubLObject snapshot_managed_object_simple_complex_index(final SubLObject snapshot_function,
			final SubLObject index_type, final SubLObject active_dir, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject widen_fvectorP = NIL;
		SubLObject widen_complexP = NIL;
		SubLObject result = NIL;
		SubLObject doneP = NIL;
		while (NIL == doneP) {
			try {
				thread.throwStack.push($OVERFLOW);
				funcall(snapshot_function, active_dir, directory_path, widen_fvectorP, widen_complexP);
			} catch (final Throwable ccatch_env_var) {
				result = Errors.handleThrowable(ccatch_env_var, $OVERFLOW);
			} finally {
				thread.throwStack.pop();
			}
			if (NIL == result) {
				doneP = T;
			} else if (result == $FVECTOR) {
				if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL != widen_fvectorP)) {
					Errors.error(dumper.$str249$Inconsistent_state____already_for, index_type);
				}
				widen_fvectorP = T;
				format(T, dumper.$str250$__Redoing__A_index_snap_shot_with, index_type);
			} else if (result == $COMPLEX) {
				if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL != widen_complexP)) {
					Errors.error(dumper.$str251$Inconsistent_state____already_for, index_type);
				}
				widen_complexP = T;
				format(T, dumper.$str252$__Redoing__A_index_snap_shot_with, index_type);
			} else {
				Errors.error(dumper.$str253$Unexpected_snapshot_state__A_____, result, index_type);
			}

		}
		return NIL;
	}

	public static SubLObject snapshot_managed_object_simple_index(final SubLObject snapshot_function,
			final SubLObject type, final SubLObject active_dir, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		try {
			thread.throwStack.push($OVERFLOW);
			funcall(snapshot_function, active_dir, directory_path);
		} catch (final Throwable ccatch_env_var) {
			result = Errors.handleThrowable(ccatch_env_var, $OVERFLOW);
		} finally {
			thread.throwStack.pop();
		}
		if (NIL != list_utilities.sublisp_boolean(result)) {
			final SubLObject str = cconcatenate(dumper.$$$Redoing_, new SubLObject[] {
					format_nil.format_nil_a_no_copy(type), dumper.$str255$_snapshot_with_wide_index_____ });
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				funcall(snapshot_function, active_dir, directory_path, $WIDEN_INDEX);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return NIL;
	}

	public static SubLObject snapshot_deleted_object_tombstones(final SubLObject fvector, final SubLObject iterator,
			final SubLObject message) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL == dumper.minimal_tombstoning_modeP()) {
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != message ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(message);
				final SubLObject max_id = file_vector.file_vector_length(fvector);
				SubLObject valid;
				for (SubLObject done_var = NIL; NIL == done_var; done_var = makeBoolean(NIL == valid)) {
					thread.resetMultipleValues();
					final SubLObject id = iteration.iteration_next(iterator);
					valid = thread.secondMultipleValue();
					thread.resetMultipleValues();
					if ((NIL != valid) && id.numL(max_id)) {
						file_vector.position_file_vector_index_for_update(fvector, id);
						file_vector.place_file_vector_index_tombstone(fvector);
					}
				}
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return fvector;
	}

	public static SubLObject replicate_fv_dump_files(final SubLObject data_files, final SubLObject index_files,
			final SubLObject wide_mark_files, final SubLObject widen_flags, final SubLObject src_dir,
			final SubLObject target_dir, final SubLObject message) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject dump_files = NIL;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != message ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(message);
			SubLObject list_var = NIL;
			SubLObject data_file = NIL;
			SubLObject n = NIL;
			list_var = data_files;
			data_file = list_var.first();
			for (n = ZERO_INTEGER; NIL != list_var; list_var = list_var.rest(), data_file = list_var
					.first(), n = add(ONE_INTEGER, n)) {
				dump_files = cons(dumper.replicate_one_dump_file(data_file, src_dir, target_dir, UNPROVIDED),
						dump_files);
				final SubLObject index_file = nth(n, index_files);
				final SubLObject wide_mark_file = nth(n, wide_mark_files);
				final SubLObject widen_flag = nth(n, widen_flags);
				thread.resetMultipleValues();
				final SubLObject new_index_file = dumper.replicate_one_index_file(index_file, wide_mark_file,
						widen_flag, src_dir, target_dir);
				final SubLObject new_wide_mark_file = thread.secondMultipleValue();
				thread.resetMultipleValues();
				dump_files = cons(new_index_file, dump_files);
				dump_files = cons(new_wide_mark_file, dump_files);
			}
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return nreverse(dump_files);
	}

	public static SubLObject replicate_one_dump_file(final SubLObject file_name, final SubLObject src_dir,
			final SubLObject target_dir, SubLObject optional_file_p) {
		if (optional_file_p == UNPROVIDED) {
			optional_file_p = NIL;
		}
		final SubLObject src_file = dumper.kb_dump_file(file_name, src_dir, UNPROVIDED);
		final SubLObject trg_file = dumper.kb_dump_file(file_name, target_dir, UNPROVIDED);
		if (NIL != Filesys.probe_file(src_file)) {
			file_utilities.copy_file_checked(src_file, trg_file);
		} else if (NIL == list_utilities.sublisp_boolean(optional_file_p)) {
			Errors.error(dumper.$str257$Cannot_find_required_file__A_, src_file);
		}

		return trg_file;
	}

	public static SubLObject replicate_one_index_file(final SubLObject index_file, final SubLObject wide_mark_file,
			final SubLObject widen_flag, final SubLObject src_dir, final SubLObject target_dir) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject src_index_file = dumper.kb_dump_file(index_file, src_dir, UNPROVIDED);
		if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL == Filesys.probe_file(src_index_file))) {
			Errors.error(dumper.$str257$Cannot_find_required_file__A_, src_index_file);
		}
		final SubLObject src_wide_mark_file = dumper.kb_dump_file(wide_mark_file, src_dir, UNPROVIDED);
		final SubLObject src_wide_mark = file_vector.possibly_load_file_vector_wide_mark(src_wide_mark_file);
		final SubLObject trg_index_file = dumper.kb_dump_file(index_file, target_dir, UNPROVIDED);
		final SubLObject trg_wide_mark_file = dumper.kb_dump_file(wide_mark_file, target_dir, UNPROVIDED);
		if (((NIL == src_wide_mark) && (NIL != widen_flag))
				|| (NIL != subl_promotions.positive_integer_p(src_wide_mark))) {
			file_vector.widen_file_vector_index(trg_index_file, trg_wide_mark_file, src_index_file,
					NIL != list_utilities.sublisp_boolean(src_wide_mark) ? src_wide_mark_file : NIL);
		} else {
			file_utilities.copy_file_checked(src_index_file, trg_index_file);
			if (NIL != list_utilities.sublisp_boolean(src_wide_mark)) {
				file_utilities.copy_file_checked(src_wide_mark_file, trg_wide_mark_file);
			}
		}
		return values(trg_index_file, trg_wide_mark_file);
	}

	public static SubLObject kb_dump_default_common_symbols() {
		return dumper.$kb_dump_default_common_symbols$.getGlobalValue();
	}

	public static final SubLObject kb_dump_common_symbols_alt() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			return $kb_dump_common_symbols$.getDynamicValue(thread);
		}
	}

	public static SubLObject kb_dump_common_symbols() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		return dumper.$kb_dump_common_symbols$.getDynamicValue(thread);
	}

	public static final SubLObject dump_special_objects_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
				try {
					$noting_progress_start_time$.bind(get_universal_time(), thread);
					noting_progress_preamble(format(NIL, $str_alt73$Dumping_special_objects_at__A___,
							numeric_date_utilities.timestring(UNPROVIDED)));
					{
						SubLObject special_objects_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$special,
								directory_path, UNPROVIDED);
						SubLObject filename_var = special_objects_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0_12 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_12, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_13 = stream;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_13);
								com.cyc.cycjava.cycl.dumper.dump_special_objects_internal(
										com.cyc.cycjava.cycl.dumper.kb_dump_common_symbols(), stream_13);
							}
						} finally {
							{
								SubLObject _prev_bind_0_14 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_14, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
					noting_progress_postamble();
				} finally {
					$noting_progress_start_time$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_special_objects(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject str = format(NIL, dumper.$str259$Dumping_special_objects_at__A____,
				numeric_date_utilities.timestring(UNPROVIDED));
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			final SubLObject filename_var;
			final SubLObject special_objects_file = filename_var = dumper.kb_dump_file(dumper.$$$special,
					directory_path, UNPROVIDED);
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$251 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$251, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$252 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$252 = file_utilities.enable_file_stream_memory_mapping(stream_$252);
				}
				try {
					dumper.dump_copyright(stream_$252);
					dumper.dump_special_objects_internal(dumper.kb_dump_common_symbols(), stream_$252);
				} finally {
					final SubLObject _prev_bind_0_$252 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$252, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$252, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$253 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$253, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_special_objects_internal_alt(SubLObject common_symbols, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
				try {
					$cfasl_common_symbols$.bind(NIL, thread);
					cfasl_set_common_symbols(NIL);
					cfasl_output(common_symbols, stream);
				} finally {
					$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_special_objects_internal(final SubLObject common_symbols, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(NIL);
			cfasl_output(common_symbols, stream);
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_special_objects(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject special_objects_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$special, directory_path,
						UNPROVIDED);
				SubLObject ans = NIL;
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(special_objects_file, UNPROVIDED)) {
					{
						SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
						try {
							$noting_progress_start_time$.bind(get_universal_time(), thread);
							noting_progress_preamble($str_alt75$Loading_special_objects___);
							{
								SubLObject filename_var = special_objects_file;
								SubLObject stream = NIL;
								try {
									{
										SubLObject _prev_bind_0_15 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream = compatibility.open_binary(filename_var, $INPUT, NIL);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_15, thread);
										}
									}
									if (!stream.isStream()) {
										Errors.error($str_alt65$Unable_to_open__S, filename_var);
									}
									{
										SubLObject stream_16 = stream;
										{
											SubLObject _prev_bind_0_17 = $cfasl_common_symbols$.currentBinding(thread);
											try {
												$cfasl_common_symbols$.bind(NIL, thread);
												cfasl_set_common_symbols(NIL);
												com.cyc.cycjava.cycl.dumper.load_copyright(stream_16);
												ans = cfasl_input(stream_16, UNPROVIDED, UNPROVIDED);
											} finally {
												$cfasl_common_symbols$.rebind(_prev_bind_0_17, thread);
											}
										}
									}
								} finally {
									{
										SubLObject _prev_bind_0_18 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											if (stream.isStream()) {
												close(stream, UNPROVIDED);
											}
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_18, thread);
										}
									}
								}
								com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
							}
							noting_progress_postamble();
						} finally {
							$noting_progress_start_time$.rebind(_prev_bind_0, thread);
						}
					}
				}
				return ans;
			}
		}
	}

	public static SubLObject load_special_objects(final SubLObject directory_path,
			SubLObject load_from_alexandria_persistenceP) {
		if (load_from_alexandria_persistenceP == UNPROVIDED) {
			load_from_alexandria_persistenceP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != load_from_alexandria_persistenceP) {
			return kb_store_utils.load_alexandria_special_objects();
		}
		final SubLObject special_objects_file = dumper.kb_dump_file(dumper.$$$special, directory_path, UNPROVIDED);
		SubLObject ans = NIL;
		if (NIL != dumper.verify_file_existence(special_objects_file, UNPROVIDED)) {
			final SubLObject str = dumper.$str261$Loading_special_objects____;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				final SubLObject filename_var = special_objects_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$255 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $INPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$255, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$256 = stream;
					if ($INPUT == $INPUT) {
						stream_$256 = file_utilities.enable_file_stream_memory_mapping(stream_$256);
					}
					try {
						final SubLObject _prev_bind_0_$256 = $cfasl_common_symbols$.currentBinding(thread);
						try {
							$cfasl_common_symbols$.bind(NIL, thread);
							cfasl_set_common_symbols(NIL);
							dumper.load_copyright(stream_$256);
							ans = cfasl_input(stream_$256, UNPROVIDED, UNPROVIDED);
						} finally {
							$cfasl_common_symbols$.rebind(_prev_bind_0_$256, thread);
						}
					} finally {
						final SubLObject _prev_bind_0_$257 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$256, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$257, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$258 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$258, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return ans;
	}

	/**
	 * An accessor for load-special-objects, currently required by HL module stores.
	 * Also quieter than load-special-objects since callers should print their own
	 * progress at a higher level.
	 */
	@LispMethod(comment = "An accessor for load-special-objects, currently required by HL module stores.  Also quieter than load-special-objects since callers should print their own progress at a higher level.")
	public static final SubLObject load_kb_product_shared_symbols_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject result = NIL;
				{
					SubLObject _prev_bind_0 = $dump_verbose$.currentBinding(thread);
					SubLObject _prev_bind_1 = $silent_progressP$.currentBinding(thread);
					try {
						$dump_verbose$.bind(NIL, thread);
						$silent_progressP$.bind(T, thread);
						result = com.cyc.cycjava.cycl.dumper.load_special_objects(directory_path);
					} finally {
						$silent_progressP$.rebind(_prev_bind_1, thread);
						$dump_verbose$.rebind(_prev_bind_0, thread);
					}
				}
				return result;
			}
		}
	}

	/**
	 * An accessor for load-special-objects, currently required by HL module stores.
	 * Also quieter than load-special-objects since callers should print their own
	 * progress at a higher level.
	 */
	@LispMethod(comment = "An accessor for load-special-objects, currently required by HL module stores.  Also quieter than load-special-objects since callers should print their own progress at a higher level.")
	public static SubLObject load_kb_product_shared_symbols(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		final SubLObject _prev_bind_0 = dumper.$dump_verbose$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $silent_progressP$.currentBinding(thread);
		try {
			dumper.$dump_verbose$.bind(NIL, thread);
			$silent_progressP$.bind(T, thread);
			result = dumper.load_special_objects(directory_path, UNPROVIDED);
		} finally {
			$silent_progressP$.rebind(_prev_bind_2, thread);
			dumper.$dump_verbose$.rebind(_prev_bind_0, thread);
		}
		return result;
	}

	public static final SubLObject setup_kb_state_from_dump_alt(SubLObject directory_path) {
		{
			SubLObject constant_count = com.cyc.cycjava.cycl.dumper.load_constant_count(directory_path);
			SubLObject nart_count = com.cyc.cycjava.cycl.dumper.load_nart_count(directory_path);
			SubLObject assertion_count = com.cyc.cycjava.cycl.dumper.load_assertion_count(directory_path);
			SubLObject deduction_count = com.cyc.cycjava.cycl.dumper.load_deduction_count(directory_path);
			SubLObject kb_hl_support_count = com.cyc.cycjava.cycl.dumper.load_kb_hl_support_count(directory_path);
			SubLObject clause_struc_count = com.cyc.cycjava.cycl.dumper.load_clause_struc_count(directory_path);
			SubLObject kb_unrepresented_term_count = com.cyc.cycjava.cycl.dumper
					.load_kb_unrepresented_term_count(directory_path);
			SubLTrampolineFile.checkType(constant_count, INTEGERP);
			if ((((((NIL != nart_count) && (NIL != assertion_count)) && (NIL != deduction_count))
					&& (NIL != kb_hl_support_count)) && (NIL != clause_struc_count))
					&& (NIL != kb_unrepresented_term_count)) {
				setup_kb_tables_int(T, constant_count, nart_count, assertion_count, deduction_count,
						kb_hl_support_count, clause_struc_count, kb_unrepresented_term_count);
				clear_kb_state_int();
			} else {
				clear_kb_state(constant_count);
			}
		}
		return NIL;
	}

	public static SubLObject setup_kb_state_from_dump(final SubLObject directory_path) {
		final SubLObject constant_count = dumper.load_constant_count(directory_path);
		final SubLObject nart_count = dumper.load_nart_count(directory_path);
		final SubLObject assertion_count = dumper.load_assertion_count(directory_path);
		final SubLObject deduction_count = dumper.load_deduction_count(directory_path);
		final SubLObject kb_hl_support_count = dumper.load_kb_hl_support_count(directory_path);
		final SubLObject clause_struc_count = dumper.load_clause_struc_count(directory_path);
		final SubLObject kb_unrepresented_term_count = dumper.load_kb_unrepresented_term_count(directory_path);
		assert NIL != integerp(constant_count) : "! integerp(constant_count) "
				+ ("Types.integerp(constant_count) " + "CommonSymbols.NIL != Types.integerp(constant_count) ")
				+ constant_count;
		if (((((NIL != nart_count) && (NIL != assertion_count)) && (NIL != deduction_count))
				&& (NIL != kb_hl_support_count)) && (NIL != clause_struc_count)) {
			kb_utilities.setup_kb_tables_int(T, constant_count, nart_count, assertion_count, deduction_count,
					kb_hl_support_count, clause_struc_count, kb_unrepresented_term_count);
			kb_utilities.clear_kb_state_int();
		} else {
			kb_utilities.clear_kb_state(constant_count);
		}
		return NIL;
	}

	/**
	 * Accessor for the first constant ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first constant ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_constant_internal_id_limit_for_kb_alt(SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_constant_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first constant ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first constant ID not represented in a specific KB.")
	public static SubLObject get_exclusive_constant_internal_id_limit_for_kb(final SubLObject directory_path) {
		final SubLObject count = dumper.load_constant_count(directory_path);
		return count;
	}

	public static final SubLObject dump_constant_shells_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt77$constant_count,
					constant_count());
			{
				SubLObject constant_shell_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt78$constant_shell,
						directory_path, UNPROVIDED);
				SubLObject filename_var = constant_shell_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_19 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_19);
						cfasl_output(constant_count(), stream_19);
						{
							SubLObject idx = do_constants_table();
							SubLObject total = id_index_count(idx);
							SubLObject sofar = ZERO_INTEGER;
							SubLTrampolineFile.checkType($$$Dumping_constant_shells, STRINGP);
							{
								SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($$$Dumping_constant_shells);
									if (NIL == do_id_index_empty_p(idx, $SKIP)) {
										{
											SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
											SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
											SubLObject constant = NIL;
											while (NIL != id) {
												constant = do_id_index_state_object(idx, $SKIP, id, state_var);
												if (NIL != do_id_index_id_and_object_validP(id, constant, $SKIP)) {
													note_percent_progress(sofar, total);
													sofar = add(sofar, ONE_INTEGER);
													com.cyc.cycjava.cycl.dumper.dump_constant_shell(constant,
															stream_19);
												}
												id = do_id_index_next_id(idx, T, id, state_var);
												state_var = do_id_index_next_state(idx, T, id, state_var);
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0, thread);
								}
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_constant_shells(final SubLObject directory_path) {
		dumper.dump_kb_object_count(directory_path, dumper.$str263$constant_count, constant_count());
		dumper.dump_constant_shells_int(directory_path);
		return NIL;
	}

	public static SubLObject dump_constant_shells_int(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject constant_shell_file = filename_var = dumper.kb_dump_file(dumper.$str264$constant_shell,
				directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$260 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$260 = file_utilities.enable_file_stream_memory_mapping(stream_$260);
			}
			try {
				dumper.dump_copyright(stream_$260);
				cfasl_output(constant_count(), stream_$260);
				final SubLObject idx = do_constants_table();
				final SubLObject mess = dumper.$$$Dumping_constant_shells;
				final SubLObject total = id_index_count(idx);
				SubLObject sofar = ZERO_INTEGER;
				assert NIL != stringp(mess) : "! stringp(mess) "
						+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
				final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
				try {
					$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
					$last_percent_progress_prediction$.bind(NIL, thread);
					$within_noting_percent_progress$.bind(T, thread);
					$percent_progress_start_time$.bind(get_universal_time(), thread);
					try {
						noting_percent_progress_preamble(mess);
						final SubLObject idx_$261 = idx;
						if (NIL == id_index_objects_empty_p(idx_$261, $SKIP)) {
							final SubLObject idx_$262 = idx_$261;
							if (NIL == id_index_dense_objects_empty_p(idx_$262, $SKIP)) {
								final SubLObject vector_var = id_index_dense_objects(idx_$262);
								final SubLObject backwardP_var = NIL;
								SubLObject length;
								SubLObject v_iteration;
								SubLObject id;
								SubLObject constant;
								for (length = length(
										vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
												.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
									id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
											: v_iteration;
									constant = aref(vector_var, id);
									if ((NIL == id_index_tombstone_p(constant))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										if (NIL != id_index_tombstone_p(constant)) {
											constant = $SKIP;
										}
										dumper.dump_constant_shell(constant, stream_$260);
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
								}
							}
							final SubLObject idx_$263 = idx_$261;
							if ((NIL == id_index_sparse_objects_empty_p(idx_$263))
									|| (NIL == id_index_skip_tombstones_p($SKIP))) {
								final SubLObject sparse = id_index_sparse_objects(idx_$263);
								SubLObject id2 = id_index_sparse_id_threshold(idx_$263);
								final SubLObject end_id = id_index_next_id(idx_$263);
								final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL : $SKIP;
								while (id2.numL(end_id)) {
									final SubLObject constant2 = gethash_without_values(id2, sparse, v_default);
									if ((NIL == id_index_skip_tombstones_p($SKIP))
											|| (NIL == id_index_tombstone_p(constant2))) {
										dumper.dump_constant_shell(constant2, stream_$260);
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
									id2 = add(id2, ONE_INTEGER);
								}
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$264 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							noting_percent_progress_postamble();
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$264, thread);
						}
					}
				} finally {
					$percent_progress_start_time$.rebind(_prev_bind_5, thread);
					$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
					$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
					$last_percent_progress_index$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					close(stream_$260, UNPROVIDED);
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values3 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values3);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static SubLObject snapshot_constant_shells(final SubLObject directory_path) {
		dumper.dump_kb_object_count(directory_path, dumper.$str263$constant_count, next_constant_suid());
		dumper.dump_constant_shells_int(directory_path);
		return NIL;
	}

	public static SubLObject snapshot_deleted_constant_set(final SubLObject directory_path) {
		return dumper.snapshot_kb_object_deleted_id_set(directory_path, dumper.$str267$deleted_constant_ids,
				missing_constant_id_set(), dumper.$$$constant);
	}

	public static SubLObject has_deleted_constant_id_setP(final SubLObject directory_path) {
		return Filesys.probe_file(dumper.kb_dump_file(dumper.$str267$deleted_constant_ids, directory_path, UNPROVIDED));
	}

	/**
	 *
	 *
	 * @return 0 integerp; the constant count
	 * @return 1 booleanp; whether the constants are dense
	 */
	@LispMethod(comment = "@return 0 integerp; the constant count\r\n@return 1 booleanp; whether the constants are dense")
	public static final SubLObject load_constant_count_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject count = com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path,
						$str_alt77$constant_count);
				if (NIL != count) {
					return values(count, T);
				} else {
					{
						SubLObject result = NIL;
						SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt78$constant_shell,
								directory_path, UNPROVIDED);
						if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
							{
								SubLObject filename_var = cfasl_file;
								SubLObject stream = NIL;
								try {
									{
										SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream = compatibility.open_binary(filename_var, $INPUT, NIL);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
										}
									}
									if (!stream.isStream()) {
										Errors.error($str_alt65$Unable_to_open__S, filename_var);
									}
									{
										SubLObject stream_20 = stream;
										com.cyc.cycjava.cycl.dumper.load_copyright(stream_20);
										{
											SubLObject constant_count = cfasl_input(stream_20, UNPROVIDED, UNPROVIDED);
											result = constant_count;
										}
									}
								} finally {
									{
										SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											if (stream.isStream()) {
												close(stream, UNPROVIDED);
											}
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
										}
									}
								}
								com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
							}
						}
						return values(result, NIL);
					}
				}
			}
		}
	}

	/**
	 *
	 *
	 * @return 0 integerp; the constant count
	 * @return 1 booleanp; whether the constants are dense
	 */
	@LispMethod(comment = "@return 0 integerp; the constant count\r\n@return 1 booleanp; whether the constants are dense")
	public static SubLObject load_constant_count(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject count = dumper.load_kb_object_count(directory_path, dumper.$str263$constant_count);
		if (NIL != count) {
			return values(count, T);
		}
		SubLObject result = NIL;
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str264$constant_shell, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$265 = stream;
				if ($INPUT == $INPUT) {
					stream_$265 = file_utilities.enable_file_stream_memory_mapping(stream_$265);
				}
				try {
					dumper.load_copyright(stream_$265);
					final SubLObject constant_count = result = cfasl_input(stream_$265, UNPROVIDED, UNPROVIDED);
				} finally {
					final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$265, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return values(result, NIL);
	}

	public static final SubLObject load_constant_shells_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt78$constant_shell,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_21 = stream;
								SubLObject total = file_length(stream_21);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_21);
								{
									SubLObject constant_count = cfasl_input(stream_21, UNPROVIDED, UNPROVIDED);
								}
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($$$Loading_constant_shells);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_21, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_21, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_21),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_constant_shell(dump_id, stream_21);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			thread.resetMultipleValues();
			{
				SubLObject constant_count = com.cyc.cycjava.cycl.dumper.load_constant_count(directory_path);
				SubLObject exactP = thread.secondMultipleValue();
				thread.resetMultipleValues();
				if (NIL == exactP) {
					constant_count = NIL;
				}
				finalize_constants(constant_count);
			}
			return NIL;
		}
	}

	public static SubLObject load_constant_shells(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str264$constant_shell, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$266 = stream;
				if ($INPUT == $INPUT) {
					stream_$266 = file_utilities.enable_file_stream_memory_mapping(stream_$266);
				}
				try {
					final SubLObject total = file_length(stream_$266);
					dumper.load_copyright(stream_$266);
					final SubLObject constant_count = cfasl_input(stream_$266, UNPROVIDED, UNPROVIDED);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_constant_shells);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$266, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$266, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$266), total);
								if (dump_id.isInteger()) {
									dumper.load_constant_shell(dump_id, stream_$266);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$267 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$267, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$266, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		thread.resetMultipleValues();
		final SubLObject constant_count2 = dumper.load_constant_count(directory_path);
		final SubLObject exactP = thread.secondMultipleValue();
		thread.resetMultipleValues();
		finalize_constants(NIL != exactP ? subtract(constant_count2, ONE_INTEGER) : NIL);
		return NIL;
	}

	public static SubLObject debug_map_constant_shell_file_position_to_constant_id(final SubLObject directory_path,
			final SubLObject filepos) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str264$constant_shell, directory_path, UNPROVIDED);
		SubLObject id = MINUS_ONE_INTEGER;
		SubLObject name = NIL;
		SubLObject guid = NIL;
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$268 = stream;
				if ($INPUT == $INPUT) {
					stream_$268 = file_utilities.enable_file_stream_memory_mapping(stream_$268);
				}
				try {
					final SubLObject total = file_length(stream_$268);
					if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (!filepos.numL(total))) {
						Errors.error(dumper.$str269$The_specified_file_position__A_is, filepos, cfasl_file, total);
					}
					dumper.load_copyright(stream_$268);
					final SubLObject constant_count = cfasl_input(stream_$268, UNPROVIDED, UNPROVIDED);
					final SubLObject currpos = compatibility.get_file_position(stream_$268);
					if (filepos.numL(currpos)) {
						Errors.error(dumper.$str270$_A_lies_within_the_file_header__0, filepos, currpos);
					}
					SubLObject dump_id;
					for (dump_id = NIL, dump_id = cfasl_input(stream_$268, NIL, UNPROVIDED); (dump_id != $EOF)
							&& (NIL == subl_promotions.non_negative_integer_p(id)); dump_id = cfasl_input(stream_$268,
									NIL, UNPROVIDED)) {
						name = cfasl_input(stream_$268, UNPROVIDED, UNPROVIDED);
						guid = cfasl_input(stream_$268, UNPROVIDED, UNPROVIDED);
						if (filepos.numL(compatibility.get_file_position(stream_$268))) {
							id = dump_id;
						}
					}
				} finally {
					final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$268, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		if (NIL != subl_promotions.non_negative_integer_p(id)) {
			Errors.warn(dumper.$str271$_A_specifies_a_file_position_in_t, new SubLObject[] { filepos, name, id, guid });
			return id;
		}
		Errors.error(dumper.$str272$_A_should_have_been_found_but_was, filepos);
		return MINUS_ONE_INTEGER;
	}

	public static final SubLObject dump_constant_shell_alt(SubLObject constant, SubLObject stream) {
		{
			SubLObject dump_id = constants_high.constant_dump_id(constant);
			SubLObject name = constants_high.constant_name(constant);
			SubLObject guid = constants_high.constant_guid(constant);
			com.cyc.cycjava.cycl.dumper.dump_constant_shell_internal(stream, dump_id, name, guid);
		}
		return constant;
	}

	public static SubLObject dump_constant_shell(final SubLObject constant, final SubLObject stream) {
		final SubLObject dump_id = constants_high.constant_dump_id(constant);
		final SubLObject name = constants_high.constant_dump_name(constant);
		final SubLObject guid = constants_high.constant_guid(constant);
		dumper.dump_constant_shell_internal(stream, dump_id, name, guid);
		return constant;
	}

	public static final SubLObject dump_constant_shell_internal_alt(SubLObject stream, SubLObject dump_id,
			SubLObject name, SubLObject guid) {
		cfasl_output(dump_id, stream);
		cfasl_output(name, stream);
		cfasl_output(guid, stream);
		return NIL;
	}

	public static SubLObject dump_constant_shell_internal(final SubLObject stream, final SubLObject dump_id,
			final SubLObject name, final SubLObject guid) {
		cfasl_output(dump_id, stream);
		cfasl_output(name, stream);
		cfasl_output(guid, stream);
		return NIL;
	}

	public static final SubLObject load_constant_shell_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject name = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			SubLObject guid = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			return com.cyc.cycjava.cycl.dumper.load_constant_shell_internal(dump_id, name, guid);
		}
	}

	public static SubLObject load_constant_shell(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject name = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		final SubLObject guid = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		return dumper.load_constant_shell_internal(dump_id, name, guid);
	}

	public static final SubLObject load_constant_shell_internal_alt(SubLObject dump_id, SubLObject name,
			SubLObject guid) {
		{
			SubLObject constant = make_constant_shell(name, T);
			constants_low.load_install_constant_ids(constant, dump_id, guid);
			return constant;
		}
	}

	public static SubLObject load_constant_shell_internal(final SubLObject dump_id, final SubLObject name,
			final SubLObject guid) {
		final SubLObject constant = make_constant_shell(name, T);
		constants_low.load_install_constant_ids(constant, dump_id, guid);
		return constant;
	}

	/**
	 * Save the latest version of 'constant-shell.text' into DIRECTORY
	 */
	@LispMethod(comment = "Save the latest version of \'constant-shell.text\' into DIRECTORY")
	public static final SubLObject generate_constant_shell_file_alt(SubLObject directory) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			SubLTrampolineFile.checkType(directory, STRINGP);
			{
				SubLObject constant_shell_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt78$constant_shell,
						directory, $$$text);
				SubLObject filename_var = constant_shell_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_text(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_22 = stream;
						write_char(CHAR_space, stream_22);
						prin1(copyright_notice(), stream_22);
						terpri(stream_22);
						write_char(CHAR_space, stream_22);
						prin1(constant_count(), stream_22);
						terpri(stream_22);
						{
							SubLObject idx = do_constants_table();
							SubLObject total = id_index_count(idx);
							SubLObject sofar = ZERO_INTEGER;
							SubLTrampolineFile.checkType($$$Dumping_constant_shells, STRINGP);
							{
								SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($$$Dumping_constant_shells);
									if (NIL == do_id_index_empty_p(idx, $SKIP)) {
										{
											SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
											SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
											SubLObject constant = NIL;
											while (NIL != id) {
												constant = do_id_index_state_object(idx, $SKIP, id, state_var);
												if (NIL != do_id_index_id_and_object_validP(id, constant, $SKIP)) {
													note_percent_progress(sofar, total);
													sofar = add(sofar, ONE_INTEGER);
													{
														SubLObject name = constants_high.constant_name(constant);
														if (name.isString()) {
															prin1(name, stream_22);
															write_char(CHAR_space, stream_22);
														}
														prin1(constants_high.constant_dump_id(constant), stream_22);
														terpri(stream_22);
													}
												}
												id = do_id_index_next_id(idx, T, id, state_var);
												state_var = do_id_index_next_state(idx, T, id, state_var);
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0, thread);
								}
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	/**
	 * Save the latest version of 'constant-shell.text' into DIRECTORY
	 */
	@LispMethod(comment = "Save the latest version of \'constant-shell.text\' into DIRECTORY")
	public static SubLObject generate_constant_shell_file(final SubLObject directory) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		assert NIL != stringp(directory) : "! stringp(directory) "
				+ ("Types.stringp(directory) " + "CommonSymbols.NIL != Types.stringp(directory) ") + directory;
		final SubLObject filename_var;
		final SubLObject constant_shell_file = filename_var = dumper.kb_dump_file(dumper.$str264$constant_shell,
				directory, dumper.$$$text);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_text(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$269 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$269 = file_utilities.enable_file_stream_memory_mapping(stream_$269);
			}
			try {
				write_char(CHAR_space, stream_$269);
				prin1(misc_utilities.copyright_notice(), stream_$269);
				terpri(stream_$269);
				write_char(CHAR_space, stream_$269);
				prin1(constant_count(), stream_$269);
				terpri(stream_$269);
				final SubLObject idx = do_constants_table();
				final SubLObject mess = dumper.$$$Dumping_constant_shells;
				final SubLObject total = id_index_count(idx);
				SubLObject sofar = ZERO_INTEGER;
				assert NIL != stringp(mess) : "! stringp(mess) "
						+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
				final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
				try {
					$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
					$last_percent_progress_prediction$.bind(NIL, thread);
					$within_noting_percent_progress$.bind(T, thread);
					$percent_progress_start_time$.bind(get_universal_time(), thread);
					try {
						noting_percent_progress_preamble(mess);
						final SubLObject idx_$270 = idx;
						if (NIL == id_index_objects_empty_p(idx_$270, $SKIP)) {
							final SubLObject idx_$271 = idx_$270;
							if (NIL == id_index_dense_objects_empty_p(idx_$271, $SKIP)) {
								final SubLObject vector_var = id_index_dense_objects(idx_$271);
								final SubLObject backwardP_var = NIL;
								SubLObject length;
								SubLObject v_iteration;
								SubLObject id;
								SubLObject constant;
								SubLObject name;
								for (length = length(
										vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
												.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
									id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
											: v_iteration;
									constant = aref(vector_var, id);
									if ((NIL == id_index_tombstone_p(constant))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										if (NIL != id_index_tombstone_p(constant)) {
											constant = $SKIP;
										}
										name = constants_high.constant_dump_name(constant);
										if (name.isString()) {
											prin1(name, stream_$269);
											write_char(CHAR_space, stream_$269);
										}
										prin1(constants_high.constant_dump_id(constant), stream_$269);
										terpri(stream_$269);
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
								}
							}
							final SubLObject idx_$272 = idx_$270;
							if ((NIL == id_index_sparse_objects_empty_p(idx_$272))
									|| (NIL == id_index_skip_tombstones_p($SKIP))) {
								final SubLObject sparse = id_index_sparse_objects(idx_$272);
								SubLObject id2 = id_index_sparse_id_threshold(idx_$272);
								final SubLObject end_id = id_index_next_id(idx_$272);
								final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL : $SKIP;
								while (id2.numL(end_id)) {
									final SubLObject constant2 = gethash_without_values(id2, sparse, v_default);
									if ((NIL == id_index_skip_tombstones_p($SKIP))
											|| (NIL == id_index_tombstone_p(constant2))) {
										final SubLObject name2 = constants_high.constant_dump_name(constant2);
										if (name2.isString()) {
											prin1(name2, stream_$269);
											write_char(CHAR_space, stream_$269);
										}
										prin1(constants_high.constant_dump_id(constant2), stream_$269);
										terpri(stream_$269);
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
									id2 = add(id2, ONE_INTEGER);
								}
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$273 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							noting_percent_progress_postamble();
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$273, thread);
						}
					}
				} finally {
					$percent_progress_start_time$.rebind(_prev_bind_5, thread);
					$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
					$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
					$last_percent_progress_index$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					close(stream_$269, UNPROVIDED);
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values3 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values3);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	/**
	 * Accessor for the first nart ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first nart ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_nart_internal_id_limit_for_kb_alt(SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_nart_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first nart ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first nart ID not represented in a specific KB.")
	public static SubLObject get_exclusive_nart_internal_id_limit_for_kb(final SubLObject directory_path) {
		final SubLObject count = dumper.load_nart_count(directory_path);
		return count;
	}

	public static final SubLObject dump_nart_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt82$nart_count,
				nart_handles.nart_count());
	}

	public static SubLObject dump_nart_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str273$nart_count, nart_handles.nart_count());
	}

	public static SubLObject snapshot_nart_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str273$nart_count, nart_handles.next_nart_id());
	}

	public static SubLObject snapshot_deleted_nart_id_set(final SubLObject directory_path) {
		return dumper.snapshot_kb_object_deleted_id_set(directory_path, dumper.$str274$deleted_nart_ids,
				nart_handles.missing_nart_id_set(), dumper.$$$NART);
	}

	public static final SubLObject load_nart_shells_alt(SubLObject directory_path) {
		{
			SubLObject nart_count = com.cyc.cycjava.cycl.dumper.load_nart_count(directory_path);
			if (NIL != nart_count) {
				com.cyc.cycjava.cycl.dumper.initialize_nart_shells(nart_count);
			} else {
				com.cyc.cycjava.cycl.dumper.load_nart_shells_legacy(directory_path);
			}
		}
		return NIL;
	}

	public static SubLObject load_nart_shells(final SubLObject directory_path) {
		final SubLObject nart_count = dumper.load_nart_count(directory_path);
		final SubLObject deleted_narts = dumper.load_deleted_nart_id_set(directory_path);
		if (NIL != nart_count) {
			dumper.initialize_nart_shells(nart_count, deleted_narts);
		} else {
			dumper.load_nart_shells_legacy(directory_path);
		}
		return NIL;
	}

	public static final SubLObject load_nart_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt82$nart_count);
	}

	public static SubLObject load_nart_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str273$nart_count);
	}

	public static SubLObject load_deleted_nart_id_set(final SubLObject directory_path) {
		return dumper.load_kb_object_deleted_id_set(directory_path, dumper.$str274$deleted_nart_ids);
	}

	public static SubLObject has_deleted_nart_id_setP(final SubLObject directory_path) {
		return Filesys.probe_file(dumper.kb_dump_file(dumper.$str274$deleted_nart_ids, directory_path, UNPROVIDED));
	}

	public static final SubLObject initialize_nart_shells(SubLObject nart_count) {
		{
			SubLObject id = NIL;
			for (id = ZERO_INTEGER; id.numL(nart_count); id = add(id, ONE_INTEGER)) {
				nart_handles.make_nart_shell(id);
			}
		}
		return nart_handles.finalize_narts(nart_count);
	}

	public static SubLObject initialize_nart_shells(final SubLObject nart_count, final SubLObject deleted_nart_ids) {
		SubLObject id;
		for (id = NIL, id = ZERO_INTEGER; id.numL(nart_count); id = add(id, ONE_INTEGER)) {
			if (NIL == set.set_memberP(id, deleted_nart_ids)) {
				nart_handles.make_nart_shell(id);
			}
		}
		return nart_handles.finalize_narts(subtract(nart_count, ONE_INTEGER));
	}

	public static final SubLObject load_nart_shells_legacy_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt83$nat_shell, directory_path,
						UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_23 = stream;
								SubLObject total = file_length(stream_23);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_23);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($$$Loading_NART_shells);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_23, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_23, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_23),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_nart_shell(dump_id, stream_23);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			nart_handles.finalize_narts(UNPROVIDED);
			return NIL;
		}
	}

	public static SubLObject load_nart_shells_legacy(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str276$nat_shell, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$274 = stream;
				if ($INPUT == $INPUT) {
					stream_$274 = file_utilities.enable_file_stream_memory_mapping(stream_$274);
				}
				try {
					final SubLObject total = file_length(stream_$274);
					dumper.load_copyright(stream_$274);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_NART_shells);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$274, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$274, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$274), total);
								if (dump_id.isInteger()) {
									dumper.load_nart_shell(dump_id, stream_$274);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$275 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$275, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$274, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		nart_handles.finalize_narts(UNPROVIDED);
		return NIL;
	}

	public static final SubLObject dump_nart_shell_alt(SubLObject nart, SubLObject stream) {
		cfasl_output(narts_high.nart_dump_id(nart), stream);
		return nart;
	}

	public static SubLObject dump_nart_shell(final SubLObject nart, final SubLObject stream) {
		cfasl_output(narts_high.nart_dump_id(nart), stream);
		return nart;
	}

	public static final SubLObject load_nart_shell_alt(SubLObject dump_id, SubLObject stream) {
		return nart_handles.make_nart_shell(dump_id);
	}

	public static SubLObject load_nart_shell(final SubLObject dump_id, final SubLObject stream) {
		return nart_handles.make_nart_shell(dump_id);
	}

	/**
	 * Accessor for the first assertion ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first assertion ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_assertion_internal_id_limit_for_kb_alt(SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_assertion_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first assertion ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first assertion ID not represented in a specific KB.")
	public static SubLObject get_exclusive_assertion_internal_id_limit_for_kb(final SubLObject directory_path) {
		final SubLObject count = dumper.load_assertion_count(directory_path);
		return count;
	}

	public static final SubLObject dump_assertion_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt85$assertion_count,
				assertion_handles.assertion_count());
	}

	public static SubLObject dump_assertion_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str278$assertion_count,
				assertion_handles.assertion_count());
	}

	public static SubLObject snapshot_assertion_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str278$assertion_count,
				assertion_handles.next_assertion_id());
	}

	public static SubLObject snapshot_deleted_assertion_id_set(final SubLObject directory_path) {
		return dumper.snapshot_kb_object_deleted_id_set(directory_path, dumper.$str279$deleted_assertion_ids,
				assertion_handles.missing_assertion_id_set(), dumper.$$$assertion);
	}

	public static final SubLObject load_assertion_shells_alt(SubLObject directory_path) {
		{
			SubLObject assertion_count = com.cyc.cycjava.cycl.dumper.load_assertion_count(directory_path);
			if (NIL != assertion_count) {
				com.cyc.cycjava.cycl.dumper.initialize_assertion_shells(assertion_count);
			} else {
				com.cyc.cycjava.cycl.dumper.load_assertion_shells_legacy(directory_path);
			}
		}
		return NIL;
	}

	public static SubLObject load_assertion_shells(final SubLObject directory_path) {
		final SubLObject assertion_count = dumper.load_assertion_count(directory_path);
		final SubLObject deleted_assertion_ids = dumper.load_deleted_assertion_id_set(directory_path);
		if (NIL != assertion_count) {
			dumper.initialize_assertion_shells(assertion_count, deleted_assertion_ids);
		} else {
			dumper.load_assertion_shells_legacy(directory_path);
		}
		return NIL;
	}

	public static final SubLObject load_assertion_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt85$assertion_count);
	}

	public static SubLObject load_assertion_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str278$assertion_count);
	}

	public static SubLObject load_deleted_assertion_id_set(final SubLObject directory_path) {
		return dumper.load_kb_object_deleted_id_set(directory_path, dumper.$str279$deleted_assertion_ids);
	}

	public static SubLObject has_deleted_assertion_id_setP(final SubLObject directory_path) {
		return Filesys
				.probe_file(dumper.kb_dump_file(dumper.$str279$deleted_assertion_ids, directory_path, UNPROVIDED));
	}

	public static final SubLObject initialize_assertion_shells(SubLObject assertion_count) {
		{
			SubLObject id = NIL;
			for (id = ZERO_INTEGER; id.numL(assertion_count); id = add(id, ONE_INTEGER)) {
				assertion_handles.make_assertion_shell(id);
			}
		}
		assertion_handles.finalize_assertions(assertion_count);
		return NIL;
	}

	public static SubLObject initialize_assertion_shells(final SubLObject assertion_count,
			final SubLObject deleted_assertion_ids) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject str = dumper.$str280$Enabling_lazy_assertion_handle_su;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			assertion_handles.mark_available_assertions(assertion_count, deleted_assertion_ids);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		assertion_handles.finalize_assertions(subtract(assertion_count, ONE_INTEGER));
		return NIL;
	}

	public static final SubLObject load_assertion_shells_legacy_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt86$assertion_shell,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_24 = stream;
								SubLObject total = file_length(stream_24);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_24);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($$$Loading_assertion_shells);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_24, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_24, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_24),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_assertion_shell(dump_id,
															stream_24);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			assertion_handles.finalize_assertions(UNPROVIDED);
			return NIL;
		}
	}

	public static SubLObject load_assertion_shells_legacy(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str281$assertion_shell, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$276 = stream;
				if ($INPUT == $INPUT) {
					stream_$276 = file_utilities.enable_file_stream_memory_mapping(stream_$276);
				}
				try {
					final SubLObject total = file_length(stream_$276);
					dumper.load_copyright(stream_$276);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_assertion_shells);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$276, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$276, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$276), total);
								if (dump_id.isInteger()) {
									dumper.load_assertion_shell(dump_id, stream_$276);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$277 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$277, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$276, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		assertion_handles.finalize_assertions(UNPROVIDED);
		return NIL;
	}

	public static final SubLObject dump_assertion_shell_alt(SubLObject assertion, SubLObject stream) {
		cfasl_output(assertions_high.assertion_dump_id(assertion), stream);
		return assertion;
	}

	public static SubLObject dump_assertion_shell(final SubLObject assertion, final SubLObject stream) {
		cfasl_output(assertions_high.assertion_dump_id(assertion), stream);
		return assertion;
	}

	public static final SubLObject load_assertion_shell_alt(SubLObject dump_id, SubLObject stream) {
		return assertion_handles.make_assertion_shell(dump_id);
	}

	public static SubLObject load_assertion_shell(final SubLObject dump_id, final SubLObject stream) {
		return assertion_handles.make_assertion_shell(dump_id);
	}

	/**
	 * Accessor for the first kb-hl-support ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first kb-hl-support ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_kb_hl_support_internal_id_limit_for_kb_alt(SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_kb_hl_support_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first kb-hl-support ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first kb-hl-support ID not represented in a specific KB.")
	public static SubLObject get_exclusive_kb_hl_support_internal_id_limit_for_kb(final SubLObject directory_path) {
		final SubLObject count = dumper.load_kb_hl_support_count(directory_path);
		return count;
	}

	public static final SubLObject dump_kb_hl_support_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt88$kb_hl_support_count,
				kb_hl_supports.kb_hl_support_count());
	}

	public static SubLObject dump_kb_hl_support_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str283$kb_hl_support_count,
				kb_hl_support_handles.kb_hl_support_count());
	}

	public static SubLObject snapshot_kb_hl_support_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str283$kb_hl_support_count,
				kb_hl_support_handles.next_kb_hl_support_id());
	}

	public static SubLObject snapshot_deleted_kb_hl_support_id_set(final SubLObject directory_path) {
		return dumper.snapshot_kb_object_deleted_id_set(directory_path, dumper.$str284$deleted_kb_hl_support_ids,
				kb_hl_support_handles.missing_kb_hl_support_id_set(), dumper.$str285$KB_HL_support);
	}

	public static final SubLObject load_kb_hl_support_shells_alt(SubLObject directory_path) {
		{
			SubLObject kb_hl_support_count = com.cyc.cycjava.cycl.dumper.load_kb_hl_support_count(directory_path);
			if (NIL != kb_hl_support_count) {
				com.cyc.cycjava.cycl.dumper.initialize_kb_hl_support_shells(kb_hl_support_count);
			} else {
				com.cyc.cycjava.cycl.dumper.load_kb_hl_support_shells_legacy(directory_path);
			}
		}
		return NIL;
	}

	public static SubLObject load_kb_hl_support_shells(final SubLObject directory_path) {
		final SubLObject kb_hl_support_count = dumper.load_kb_hl_support_count(directory_path);
		final SubLObject deleted_hl_support_ids = dumper.load_deleted_kb_hl_support_id_set(directory_path);
		if (NIL != kb_hl_support_count) {
			dumper.initialize_kb_hl_support_shells(kb_hl_support_count, deleted_hl_support_ids);
		} else {
			dumper.load_kb_hl_support_shells_legacy(directory_path);
		}
		return NIL;
	}

	public static final SubLObject load_kb_hl_support_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt88$kb_hl_support_count);
	}

	public static SubLObject load_kb_hl_support_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str283$kb_hl_support_count);
	}

	public static SubLObject load_deleted_kb_hl_support_id_set(final SubLObject directory_path) {
		return dumper.load_kb_object_deleted_id_set(directory_path, dumper.$str284$deleted_kb_hl_support_ids);
	}

	public static SubLObject has_deleted_kb_hl_support_id_setP(final SubLObject directory_path) {
		return Filesys
				.probe_file(dumper.kb_dump_file(dumper.$str284$deleted_kb_hl_support_ids, directory_path, UNPROVIDED));
	}

	public static final SubLObject initialize_kb_hl_support_shells(SubLObject kb_hl_support_count) {
		{
			SubLObject id = NIL;
			for (id = ZERO_INTEGER; id.numL(kb_hl_support_count); id = add(id, ONE_INTEGER)) {
				kb_hl_supports.make_kb_hl_support_shell(id);
			}
		}
		return kb_hl_supports.finalize_kb_hl_supports(kb_hl_support_count);
	}

	public static SubLObject initialize_kb_hl_support_shells(final SubLObject kb_hl_support_count,
			final SubLObject deleted_kb_hl_support_ids) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject str = dumper.$str286$Enabling_lazy_KB_HL_support_handl;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			kb_hl_support_handles.mark_available_kb_hl_supports(kb_hl_support_count, deleted_kb_hl_support_ids);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return kb_hl_support_handles.finalize_kb_hl_supports(subtract(kb_hl_support_count, ONE_INTEGER));
	}

	public static final SubLObject load_kb_hl_support_shells_legacy_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt89$kb_hl_support_shell,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_25 = stream;
								SubLObject total = file_length(stream_25);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_25);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($$$Loading_KB_HL_support_shells);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_25, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_25, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_25),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_kb_hl_support_shell(dump_id,
															stream_25);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			kb_hl_supports.finalize_kb_hl_supports(UNPROVIDED);
			return NIL;
		}
	}

	public static SubLObject load_kb_hl_support_shells_legacy(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str287$kb_hl_support_shell, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$278 = stream;
				if ($INPUT == $INPUT) {
					stream_$278 = file_utilities.enable_file_stream_memory_mapping(stream_$278);
				}
				try {
					final SubLObject total = file_length(stream_$278);
					dumper.load_copyright(stream_$278);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_KB_HL_support_shells);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$278, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$278, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$278), total);
								if (dump_id.isInteger()) {
									dumper.load_kb_hl_support_shell(dump_id, stream_$278);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$279 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$279, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$278, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		kb_hl_support_handles.finalize_kb_hl_supports(UNPROVIDED);
		return NIL;
	}

	public static final SubLObject dump_kb_hl_support_shell_alt(SubLObject kb_hl_support, SubLObject stream) {
		cfasl_output(kb_hl_supports.kb_hl_support_dump_id(kb_hl_support), stream);
		return kb_hl_support;
	}

	public static SubLObject dump_kb_hl_support_shell(final SubLObject kb_hl_support, final SubLObject stream) {
		cfasl_output(kb_hl_supports_high.kb_hl_support_dump_id(kb_hl_support), stream);
		return kb_hl_support;
	}

	public static final SubLObject load_kb_hl_support_shell_alt(SubLObject dump_id, SubLObject stream) {
		return kb_hl_supports.make_kb_hl_support_shell(dump_id);
	}

	public static SubLObject load_kb_hl_support_shell(final SubLObject dump_id, final SubLObject stream) {
		return kb_hl_support_handles.make_kb_hl_support_shell(dump_id);
	}

	/**
	 * Accessor for the first kb-unrepresented-term ID not represented in a specific
	 * KB.
	 */
	@LispMethod(comment = "Accessor for the first kb-unrepresented-term ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_kb_unrepresented_term_internal_id_limit_for_kb_alt(
			SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_kb_unrepresented_term_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first kb-unrepresented-term ID not represented in a specific
	 * KB.
	 */
	@LispMethod(comment = "Accessor for the first kb-unrepresented-term ID not represented in a specific KB.")
	public static SubLObject get_exclusive_kb_unrepresented_term_internal_id_limit_for_kb(
			final SubLObject directory_path) {
		final SubLObject count = dumper.load_kb_unrepresented_term_count(directory_path);
		return count;
	}

	public static final SubLObject dump_kb_unrepresented_terms_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt91$unrepresented_term_count,
					unrepresented_terms.kb_unrepresented_term_count());
			{
				SubLObject unrepresented_terms_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt92$unrepresented_terms, directory_path, UNPROVIDED);
				SubLObject filename_var = unrepresented_terms_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_26 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_26);
						{
							SubLObject idx = unrepresented_terms.do_unrepresented_terms_table();
							SubLObject total = id_index_count(idx);
							SubLObject sofar = ZERO_INTEGER;
							SubLTrampolineFile.checkType($$$Dumping_KB_unrepresented_terms, STRINGP);
							{
								SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($$$Dumping_KB_unrepresented_terms);
									if (NIL == do_id_index_empty_p(idx, $SKIP)) {
										{
											SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
											SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
											SubLObject v_term = NIL;
											while (NIL != id) {
												v_term = do_id_index_state_object(idx, $SKIP, id, state_var);
												if (NIL != do_id_index_id_and_object_validP(id, v_term, $SKIP)) {
													note_percent_progress(sofar, total);
													sofar = add(sofar, ONE_INTEGER);
													com.cyc.cycjava.cycl.dumper.dump_kb_unrepresented_term(v_term,
															stream_26);
												}
												id = do_id_index_next_id(idx, T, id, state_var);
												state_var = do_id_index_next_state(idx, T, id, state_var);
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0, thread);
								}
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_kb_unrepresented_terms(final SubLObject directory_path) {
		dumper.dump_kb_object_count(directory_path, dumper.$str289$unrepresented_term_count,
				unrepresented_terms.kb_unrepresented_term_count());
		dumper.dump_kb_unrepresented_terms_int(directory_path);
		return NIL;
	}

	public static SubLObject dump_kb_unrepresented_terms_int(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject unrepresented_terms_file = dumper.kb_dump_file(dumper.$str290$unrepresented_terms,
				directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = unrepresented_terms_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$280 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$280, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$281 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$281 = file_utilities.enable_file_stream_memory_mapping(stream_$281);
				}
				try {
					dumper.dump_copyright(stream_$281);
					if (NIL != unrepresented_terms.use_unrepresented_term_fhtP()) {
						SubLObject msg = cconcatenate(dumper.$$$Dumping_KB_unrepresented_terms,
								dumper.$str292$____Old_Space);
						SubLObject release = NIL;
						try {
							release = seize_lock(unrepresented_terms.$unrepresented_term_fht_lock$.getGlobalValue());
							final SubLObject table_var = unrepresented_terms.get_unrepresented_term_fht();
							$progress_note$.setDynamicValue(msg, thread);
							$progress_start_time$.setDynamicValue(get_universal_time(), thread);
							$progress_total$.setDynamicValue(file_hash_table.file_hash_table_count(table_var), thread);
							$progress_sofar$.setDynamicValue(ZERO_INTEGER, thread);
							final SubLObject _prev_bind_0_$281 = $last_percent_progress_index$.currentBinding(thread);
							final SubLObject _prev_bind_1_$283 = $last_percent_progress_prediction$
									.currentBinding(thread);
							final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
							try {
								$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
								$last_percent_progress_prediction$.bind(NIL, thread);
								$within_noting_percent_progress$.bind(T, thread);
								$percent_progress_start_time$.bind(get_universal_time(), thread);
								try {
									noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
									SubLObject continuation = NIL;
									SubLObject next;
									for (SubLObject completeP = NIL; NIL == completeP; completeP = sublisp_null(next)) {
										thread.resetMultipleValues();
										final SubLObject the_key = file_hash_table.get_file_hash_table_any(table_var,
												continuation, NIL);
										final SubLObject the_value = thread.secondMultipleValue();
										next = thread.thirdMultipleValue();
										thread.resetMultipleValues();
										if (NIL != next) {
											final SubLObject key = the_key;
											final SubLObject v_term = the_value;
											note_percent_progress($progress_sofar$.getDynamicValue(thread),
													$progress_total$.getDynamicValue(thread));
											$progress_sofar$.setDynamicValue(
													add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER), thread);
											if ((NIL == unrepresented_terms.deleted_unrepresented_term_itemP(key))
													&& (NIL != unrepresented_terms.fht_suid_item_p(key))) {
												final SubLObject id = unrepresented_terms.get_fht_suid_item_suid(key);
												dumper.dump_kb_unrepresented_term(v_term, stream_$281);
											}
										}
										continuation = next;
									}
								} finally {
									final SubLObject _prev_bind_0_$282 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values = getValuesAsVector();
										noting_percent_progress_postamble();
										restoreValuesFromVector(_values);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$282, thread);
									}
								}
							} finally {
								$percent_progress_start_time$.rebind(_prev_bind_4, thread);
								$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
								$last_percent_progress_prediction$.rebind(_prev_bind_1_$283, thread);
								$last_percent_progress_index$.rebind(_prev_bind_0_$281, thread);
							}
						} finally {
							if (NIL != release) {
								release_lock(unrepresented_terms.$unrepresented_term_fht_lock$.getGlobalValue());
							}
						}
						msg = cconcatenate(dumper.$$$Dumping_KB_unrepresented_terms, dumper.$str293$____New_Space);
						if (NIL != unrepresented_terms.use_unrepresented_term_fhtP()) {
							final SubLObject list_var = unrepresented_terms
									.get_unrepresented_term_new_space_ascending_suid_keys();
							final SubLObject _prev_bind_0_$283 = $progress_note$.currentBinding(thread);
							final SubLObject _prev_bind_1_$284 = $progress_start_time$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $progress_total$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $progress_sofar$.currentBinding(thread);
							final SubLObject _prev_bind_5 = $last_percent_progress_index$.currentBinding(thread);
							final SubLObject _prev_bind_6 = $last_percent_progress_prediction$.currentBinding(thread);
							final SubLObject _prev_bind_7 = $within_noting_percent_progress$.currentBinding(thread);
							final SubLObject _prev_bind_8 = $percent_progress_start_time$.currentBinding(thread);
							try {
								$progress_note$.bind(NIL != msg ? msg : dumper.$$$cdolist, thread);
								$progress_start_time$.bind(get_universal_time(), thread);
								$progress_total$.bind(length(list_var), thread);
								$progress_sofar$.bind(ZERO_INTEGER, thread);
								$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
								$last_percent_progress_prediction$.bind(NIL, thread);
								$within_noting_percent_progress$.bind(T, thread);
								$percent_progress_start_time$.bind(get_universal_time(), thread);
								try {
									noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
									SubLObject csome_list_var = list_var;
									SubLObject suid_item = NIL;
									suid_item = csome_list_var.first();
									while (NIL != csome_list_var) {
										final SubLObject id2 = unrepresented_terms.get_fht_suid_item_suid(suid_item);
										final SubLObject v_term2 = unrepresented_terms
												.find_unrepresented_term_by_suid(id2);
										dumper.dump_kb_unrepresented_term(v_term2, stream_$281);
										$progress_sofar$.setDynamicValue(
												add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER), thread);
										note_percent_progress($progress_sofar$.getDynamicValue(thread),
												$progress_total$.getDynamicValue(thread));
										csome_list_var = csome_list_var.rest();
										suid_item = csome_list_var.first();
									}
								} finally {
									final SubLObject _prev_bind_0_$284 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values2 = getValuesAsVector();
										noting_percent_progress_postamble();
										restoreValuesFromVector(_values2);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$284, thread);
									}
								}
							} finally {
								$percent_progress_start_time$.rebind(_prev_bind_8, thread);
								$within_noting_percent_progress$.rebind(_prev_bind_7, thread);
								$last_percent_progress_prediction$.rebind(_prev_bind_6, thread);
								$last_percent_progress_index$.rebind(_prev_bind_5, thread);
								$progress_sofar$.rebind(_prev_bind_4, thread);
								$progress_total$.rebind(_prev_bind_3, thread);
								$progress_start_time$.rebind(_prev_bind_1_$284, thread);
								$progress_note$.rebind(_prev_bind_0_$283, thread);
							}
						} else {
							final SubLObject table_var = unrepresented_terms.do_unrepresented_terms_table();
							final SubLObject first_id_var = unrepresented_terms.new_unrepresented_term_id_threshold();
							final SubLObject total = subtract(id_index_next_id(table_var), first_id_var);
							SubLObject sofar = ZERO_INTEGER;
							final SubLObject _prev_bind_0_$285 = $last_percent_progress_index$.currentBinding(thread);
							final SubLObject _prev_bind_1_$285 = $last_percent_progress_prediction$
									.currentBinding(thread);
							final SubLObject _prev_bind_9 = $within_noting_percent_progress$.currentBinding(thread);
							final SubLObject _prev_bind_10 = $percent_progress_start_time$.currentBinding(thread);
							try {
								$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
								$last_percent_progress_prediction$.bind(NIL, thread);
								$within_noting_percent_progress$.bind(T, thread);
								$percent_progress_start_time$.bind(get_universal_time(), thread);
								try {
									noting_percent_progress_preamble(msg);
									SubLObject v_term;
									SubLObject end_var;
									SubLObject end;
									SubLObject id3;
									SubLObject id_$290;
									for (end = end_var = id_index_next_id(
											table_var), id3 = NIL, id3 = first_id_var; !id3
													.numGE(end_var); id3 = number_utilities.f_1X(id3)) {
										v_term = id_index_lookup(table_var, id3, UNPROVIDED);
										if (NIL != v_term) {
											note_percent_progress(sofar, total);
											sofar = add(sofar, ONE_INTEGER);
											id_$290 = unrepresented_terms.unrepresented_term_suid(v_term);
											dumper.dump_kb_unrepresented_term(v_term, stream_$281);
										}
									}
								} finally {
									final SubLObject _prev_bind_0_$286 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values3 = getValuesAsVector();
										noting_percent_progress_postamble();
										restoreValuesFromVector(_values3);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$286, thread);
									}
								}
							} finally {
								$percent_progress_start_time$.rebind(_prev_bind_10, thread);
								$within_noting_percent_progress$.rebind(_prev_bind_9, thread);
								$last_percent_progress_prediction$.rebind(_prev_bind_1_$285, thread);
								$last_percent_progress_index$.rebind(_prev_bind_0_$285, thread);
							}
						}
					} else {
						final SubLObject idx = unrepresented_terms.do_unrepresented_terms_table();
						final SubLObject mess = dumper.$$$Dumping_KB_unrepresented_terms;
						final SubLObject total2 = id_index_count(idx);
						SubLObject sofar2 = ZERO_INTEGER;
						assert NIL != stringp(mess) : "! stringp(mess) "
								+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
						final SubLObject _prev_bind_0_$287 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_1_$286 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_11 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_12 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble(mess);
								final SubLObject idx_$294 = idx;
								if (NIL == id_index_objects_empty_p(idx_$294, $SKIP)) {
									final SubLObject idx_$295 = idx_$294;
									if (NIL == id_index_dense_objects_empty_p(idx_$295, $SKIP)) {
										final SubLObject vector_var = id_index_dense_objects(idx_$295);
										final SubLObject backwardP_var = NIL;
										SubLObject id;
										SubLObject length;
										SubLObject v_iteration;
										SubLObject v_term3;
										for (length = length(
												vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
														.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
											id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
													: v_iteration;
											v_term3 = aref(vector_var, id);
											if ((NIL == id_index_tombstone_p(v_term3))
													|| (NIL == id_index_skip_tombstones_p($SKIP))) {
												if (NIL != id_index_tombstone_p(v_term3)) {
													v_term3 = $SKIP;
												}
												dumper.dump_kb_unrepresented_term(v_term3, stream_$281);
												sofar2 = add(sofar2, ONE_INTEGER);
												note_percent_progress(sofar2, total2);
											}
										}
									}
									final SubLObject idx_$296 = idx_$294;
									if ((NIL == id_index_sparse_objects_empty_p(idx_$296))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										final SubLObject sparse = id_index_sparse_objects(idx_$296);
										SubLObject id4 = id_index_sparse_id_threshold(idx_$296);
										final SubLObject end_id = id_index_next_id(idx_$296);
										final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL
												: $SKIP;
										while (id4.numL(end_id)) {
											final SubLObject v_term2 = gethash_without_values(id4, sparse, v_default);
											if ((NIL == id_index_skip_tombstones_p($SKIP))
													|| (NIL == id_index_tombstone_p(v_term2))) {
												dumper.dump_kb_unrepresented_term(v_term2, stream_$281);
												sofar2 = add(sofar2, ONE_INTEGER);
												note_percent_progress(sofar2, total2);
											}
											id4 = add(id4, ONE_INTEGER);
										}
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$288 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values4 = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values4);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$288, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_12, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_11, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_1_$286, thread);
							$last_percent_progress_index$.rebind(_prev_bind_0_$287, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$289 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values5 = getValuesAsVector();
						close(stream_$281, UNPROVIDED);
						restoreValuesFromVector(_values5);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$289, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$290 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values6 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values6);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$290, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject snapshot_kb_unrepresented_terms(final SubLObject active_dir,
			final SubLObject directory_path) {
		dumper.dump_kb_object_count(directory_path, dumper.$str289$unrepresented_term_count,
				unrepresented_terms.next_unrepresented_term_suid());
		return dumper.dump_kb_unrepresented_terms_int(directory_path);
	}

	public static final SubLObject load_kb_unrepresented_terms_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt92$unrepresented_terms,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_27 = stream;
								SubLObject total = file_length(stream_27);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_27);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($$$Loading_KB_unrepresented_terms);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_27, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_27, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_27),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_kb_unrepresented_term(dump_id,
															stream_27);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			{
				SubLObject unrepresented_term_count = com.cyc.cycjava.cycl.dumper
						.load_kb_unrepresented_term_count(directory_path);
				unrepresented_terms.finalize_unrepresented_terms(unrepresented_term_count);
			}
			return NIL;
		}
	}

	public static SubLObject load_kb_unrepresented_terms(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if ((NIL != unrepresented_terms.use_unrepresented_term_fhtP()) && (NIL != Filesys.probe_file(
				dumper.kb_dump_product_file(dumper.$str290$unrepresented_terms, directory_path, UNPROVIDED)))) {
			final SubLObject str = dumper.$str294$Reconnecting_to_unrepresented_ter;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				unrepresented_terms.reconnect_unrepresented_term_fht(
						dumper.kb_dump_product_file(dumper.$str290$unrepresented_terms, directory_path, UNPROVIDED));
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		} else {
			if (NIL != unrepresented_terms.use_unrepresented_term_fhtP()) {
				Errors.warn(dumper.$str295$Could_not_locate__A__faling_back_,
						dumper.kb_dump_product_file(dumper.$str290$unrepresented_terms, directory_path, UNPROVIDED));
			}
			final SubLObject _prev_bind_9 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
			final SubLObject _prev_bind_10 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
			try {
				StreamsLow.$stream_initial_input_buffer_size$
						.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
				StreamsLow.$stream_initial_output_buffer_size$
						.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
				final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str290$unrepresented_terms, directory_path,
						UNPROVIDED);
				final SubLObject term_from_suid_id_index = unrepresented_terms.$unrepresented_term_from_suid$
						.getGlobalValue();
				final SubLObject term_to_suid_hashtable = unrepresented_terms.$unrepresented_term_to_suid$
						.getGlobalValue();
				if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
					final SubLObject filename_var = cfasl_file;
					SubLObject stream = NIL;
					try {
						final SubLObject _prev_bind_0_$300 = stream_macros.$stream_requires_locking$
								.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $INPUT);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$300, thread);
						}
						if (!stream.isStream()) {
							Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
						}
						SubLObject stream_$301 = stream;
						if ($INPUT == $INPUT) {
							stream_$301 = file_utilities.enable_file_stream_memory_mapping(stream_$301);
						}
						try {
							final SubLObject id_index_lock = id_index_lock(term_from_suid_id_index);
							SubLObject release = NIL;
							try {
								release = seize_lock(id_index_lock);
								final SubLObject total = file_length(stream_$301);
								SubLObject i = ZERO_INTEGER;
								dumper.load_copyright(stream_$301);
								final SubLObject _prev_bind_0_$301 = $last_percent_progress_index$
										.currentBinding(thread);
								final SubLObject _prev_bind_1_$303 = $last_percent_progress_prediction$
										.currentBinding(thread);
								final SubLObject _prev_bind_11 = $within_noting_percent_progress$
										.currentBinding(thread);
								final SubLObject _prev_bind_12 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									try {
										noting_percent_progress_preamble(dumper.$$$Loading_KB_unrepresented_terms);
										SubLObject dump_id;
										for (dump_id = NIL, dump_id = cfasl_input(stream_$301, NIL,
												UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$301, NIL,
														UNPROVIDED)) {
											i = add(i, ONE_INTEGER);
											if (i.numE(dumper.$int$500)) {
												note_percent_progress(compatibility.get_file_position(stream_$301),
														total);
												i = ZERO_INTEGER;
											}
											if (dump_id.isInteger()) {
												dumper.load_kb_unrepresented_term(dump_id, stream_$301,
														term_from_suid_id_index, term_to_suid_hashtable);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$302 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values = getValuesAsVector();
											noting_percent_progress_postamble();
											restoreValuesFromVector(_values);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$302, thread);
										}
									}
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_12, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_11, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1_$303, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0_$301, thread);
								}
							} finally {
								if (NIL != release) {
									release_lock(id_index_lock);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$303 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values2 = getValuesAsVector();
								close(stream_$301, UNPROVIDED);
								restoreValuesFromVector(_values2);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$303, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$304 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values3 = getValuesAsVector();
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
							restoreValuesFromVector(_values3);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$304, thread);
						}
					}
					dumper.discard_dump_filename(filename_var);
				}
			} finally {
				StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_10, thread);
				StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_9, thread);
			}
		}
		final SubLObject unrepresented_term_count = dumper.load_kb_unrepresented_term_count(directory_path);
		unrepresented_terms.finalize_unrepresented_terms(subtract(unrepresented_term_count, ONE_INTEGER));
		return NIL;
	}

	public static final SubLObject dump_kb_unrepresented_term_alt(SubLObject v_term, SubLObject stream) {
		{
			SubLObject dump_id = unrepresented_terms.unrepresented_term_dump_id(v_term);
			cfasl_output(dump_id, stream);
			cfasl_output(v_term, stream);
		}
		return v_term;
	}

	public static SubLObject dump_kb_unrepresented_term(final SubLObject v_term, final SubLObject stream) {
		final SubLObject dump_id = unrepresented_terms.unrepresented_term_dump_id(v_term);
		cfasl_output(dump_id, stream);
		cfasl_output(v_term, stream);
		return v_term;
	}

	public static final SubLObject load_kb_unrepresented_term(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject v_term = cfasl_input(stream, NIL, UNPROVIDED);
			if (NIL != indexed_unrepresented_term_p(v_term)) {
				unrepresented_terms.register_unrepresented_term_suid(v_term, dump_id);
				return v_term;
			} else {
				return NIL;
			}
		}
	}

	public static SubLObject load_kb_unrepresented_term(final SubLObject dump_id, final SubLObject stream,
			final SubLObject term_from_suid_id_index, final SubLObject term_to_suid_hashtable) {
		final SubLObject v_term = cfasl_input(stream, NIL, UNPROVIDED);
		if (NIL != indexed_unrepresented_term_p(v_term)) {
			unrepresented_terms.register_unrepresented_term_suid_new(v_term, dump_id, term_from_suid_id_index,
					term_to_suid_hashtable);
			return v_term;
		}
		return NIL;
	}

	public static final SubLObject load_kb_unrepresented_term_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt91$unrepresented_term_count);
	}

	public static SubLObject load_kb_unrepresented_term_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str289$unrepresented_term_count);
	}

	/**
	 * Accessor for the first clause-struc ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first clause-struc ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_clause_struc_internal_id_limit_for_kb_alt(SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_clause_struc_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first clause-struc ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first clause-struc ID not represented in a specific KB.")
	public static SubLObject get_exclusive_clause_struc_internal_id_limit_for_kb(final SubLObject directory_path) {
		final SubLObject count = dumper.load_clause_struc_count(directory_path);
		return count;
	}

	public static final SubLObject dump_clause_struc_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt95$clause_struc_count,
					clause_strucs.clause_struc_count());
			{
				SubLObject clause_struc_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt96$clause_struc,
						directory_path, UNPROVIDED);
				SubLObject filename_var = clause_struc_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_28 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_28);
						{
							SubLObject idx = clause_strucs.clause_struc_table();
							SubLObject total = id_index_count(idx);
							SubLObject sofar = ZERO_INTEGER;
							SubLTrampolineFile.checkType($str_alt97$Dumping_clause_struc_definitions, STRINGP);
							{
								SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($str_alt97$Dumping_clause_struc_definitions);
									if (NIL == do_id_index_empty_p(idx, $SKIP)) {
										{
											SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
											SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
											SubLObject clause_struc = NIL;
											while (NIL != id) {
												clause_struc = do_id_index_state_object(idx, $SKIP, id, state_var);
												if (NIL != do_id_index_id_and_object_validP(id, clause_struc, $SKIP)) {
													note_percent_progress(sofar, total);
													sofar = add(sofar, ONE_INTEGER);
													com.cyc.cycjava.cycl.dumper.dump_clause_struc_def(clause_struc,
															stream_28);
												}
												id = do_id_index_next_id(idx, T, id, state_var);
												state_var = do_id_index_next_state(idx, T, id, state_var);
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0, thread);
								}
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_clause_struc_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		dumper.dump_kb_object_count(directory_path, dumper.$str298$clause_struc_count,
				clause_strucs.clause_struc_count());
		final SubLObject missing_ids = dumper.dump_clause_struc_defs_internal(directory_path);
		if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL == set.set_emptyP(missing_ids))) {
			Errors.error(dumper.$str299$There_are__A_gaps_in_the_clause_s, set.set_size(missing_ids));
		}
		return NIL;
	}

	public static SubLObject dump_clause_struc_defs_internal(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject clause_struc_file = dumper.kb_dump_file(dumper.$str300$clause_struc, directory_path,
				UNPROVIDED);
		final SubLObject missing_ids = set.new_set(EQL, UNPROVIDED);
		final SubLObject filename_var = clause_struc_file;
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$307 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$307 = file_utilities.enable_file_stream_memory_mapping(stream_$307);
			}
			try {
				dumper.dump_copyright(stream_$307);
				SubLObject expected_id = ZERO_INTEGER;
				final SubLObject idx = clause_strucs.clause_struc_table();
				final SubLObject mess = dumper.$str301$Dumping_clause_struc_definitions;
				final SubLObject total = id_index_count(idx);
				SubLObject sofar = ZERO_INTEGER;
				assert NIL != stringp(mess) : "! stringp(mess) "
						+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
				final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
				try {
					$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
					$last_percent_progress_prediction$.bind(NIL, thread);
					$within_noting_percent_progress$.bind(T, thread);
					$percent_progress_start_time$.bind(get_universal_time(), thread);
					try {
						noting_percent_progress_preamble(mess);
						final SubLObject idx_$308 = idx;
						if (NIL == id_index_objects_empty_p(idx_$308, $SKIP)) {
							final SubLObject idx_$309 = idx_$308;
							if (NIL == id_index_dense_objects_empty_p(idx_$309, $SKIP)) {
								final SubLObject vector_var = id_index_dense_objects(idx_$309);
								final SubLObject backwardP_var = NIL;
								SubLObject length;
								SubLObject v_iteration;
								SubLObject id;
								SubLObject clause_struc;
								for (length = length(
										vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
												.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
									id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
											: v_iteration;
									clause_struc = aref(vector_var, id);
									if ((NIL == id_index_tombstone_p(clause_struc))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										if (NIL != id_index_tombstone_p(clause_struc)) {
											clause_struc = $SKIP;
										}
										while (expected_id.numL(clause_strucs.clause_struc_dump_id(clause_struc))) {
											set.set_add(expected_id, missing_ids);
											expected_id = add(expected_id, ONE_INTEGER);
										}
										dumper.dump_clause_struc_def(clause_struc, stream_$307);
										expected_id = add(ONE_INTEGER,
												clause_strucs.clause_struc_dump_id(clause_struc));
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
								}
							}
							final SubLObject idx_$310 = idx_$308;
							if ((NIL == id_index_sparse_objects_empty_p(idx_$310))
									|| (NIL == id_index_skip_tombstones_p($SKIP))) {
								final SubLObject sparse = id_index_sparse_objects(idx_$310);
								SubLObject id2 = id_index_sparse_id_threshold(idx_$310);
								final SubLObject end_id = id_index_next_id(idx_$310);
								final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL : $SKIP;
								while (id2.numL(end_id)) {
									final SubLObject clause_struc2 = gethash_without_values(id2, sparse, v_default);
									if ((NIL == id_index_skip_tombstones_p($SKIP))
											|| (NIL == id_index_tombstone_p(clause_struc2))) {
										while (expected_id.numL(clause_strucs.clause_struc_dump_id(clause_struc2))) {
											set.set_add(expected_id, missing_ids);
											expected_id = add(expected_id, ONE_INTEGER);
										}
										dumper.dump_clause_struc_def(clause_struc2, stream_$307);
										expected_id = add(ONE_INTEGER,
												clause_strucs.clause_struc_dump_id(clause_struc2));
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
									id2 = add(id2, ONE_INTEGER);
								}
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$311 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							noting_percent_progress_postamble();
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$311, thread);
						}
					}
				} finally {
					$percent_progress_start_time$.rebind(_prev_bind_5, thread);
					$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
					$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
					$last_percent_progress_index$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					close(stream_$307, UNPROVIDED);
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values3 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values3);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return missing_ids;
	}

	public static SubLObject snapshot_deleted_clause_struc_id_set(final SubLObject directory_path,
			final SubLObject missing_ids) {
		return dumper.snapshot_kb_object_deleted_id_set(directory_path, dumper.$str302$deleted_clause_struc_ids,
				missing_ids, dumper.$$$shared_clauses);
	}

	public static SubLObject snapshot_clause_struc_defs(final SubLObject directory_path) {
		dumper.dump_kb_object_count(directory_path, dumper.$str298$clause_struc_count,
				clause_strucs.next_clause_struc_id());
		final SubLObject missing_ids = dumper.dump_clause_struc_defs_internal(directory_path);
		if (NIL == set.set_emptyP(missing_ids)) {
			dumper.snapshot_deleted_clause_struc_id_set(directory_path, missing_ids);
		}
		return NIL;
	}

	public static SubLObject load_deleted_clause_struc_id_set(final SubLObject directory_path) {
		return dumper.load_kb_object_deleted_id_set(directory_path, dumper.$str302$deleted_clause_struc_ids);
	}

	public static SubLObject has_deleted_clause_struc_id_setP(final SubLObject directory_path) {
		return Filesys
				.probe_file(dumper.kb_dump_file(dumper.$str302$deleted_clause_struc_ids, directory_path, UNPROVIDED));
	}

	public static final SubLObject load_clause_struc_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt96$clause_struc,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_29 = stream;
								SubLObject total = file_length(stream_29);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_29);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($str_alt98$Loading_clause_struc_definitions);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_29, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_29, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_29),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_clause_struc_def(dump_id,
															stream_29);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			{
				SubLObject clause_struc_count = com.cyc.cycjava.cycl.dumper.load_clause_struc_count(directory_path);
				clause_strucs.finalize_clause_strucs(clause_struc_count);
			}
			return NIL;
		}
	}

	public static SubLObject load_clause_struc_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str300$clause_struc, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$312 = stream;
				if ($INPUT == $INPUT) {
					stream_$312 = file_utilities.enable_file_stream_memory_mapping(stream_$312);
				}
				try {
					final SubLObject total = file_length(stream_$312);
					dumper.load_copyright(stream_$312);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$str304$Loading_clause_struc_definitions);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$312, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$312, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$312), total);
								if (dump_id.isInteger()) {
									dumper.load_clause_struc_def(dump_id, stream_$312);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$313 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$313, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$312, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		final SubLObject clause_struc_count = dumper.load_clause_struc_count(directory_path);
		clause_strucs.finalize_clause_strucs(subtract(clause_struc_count, ONE_INTEGER));
		return NIL;
	}

	public static final SubLObject dump_clause_struc_def_alt(SubLObject clause_struc, SubLObject stream) {
		cfasl_output(clause_strucs.clause_struc_dump_id(clause_struc), stream);
		cfasl_output(clause_strucs.clause_struc_cnf(clause_struc), stream);
		cfasl_output(clause_strucs.clause_struc_assertions(clause_struc), stream);
		return clause_struc;
	}

	public static SubLObject dump_clause_struc_def(final SubLObject clause_struc, final SubLObject stream) {
		cfasl_output(clause_strucs.clause_struc_dump_id(clause_struc), stream);
		cfasl_output(clause_strucs.clause_struc_cnf(clause_struc), stream);
		cfasl_output(clause_strucs.clause_struc_assertions(clause_struc), stream);
		return clause_struc;
	}

	public static final SubLObject load_clause_struc_def_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject cnf = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			SubLObject clause_struc = clause_strucs.make_clause_struc_shell(cnf, dump_id);
			clause_strucs.reset_clause_struc_assertions(clause_struc, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
			return clause_struc;
		}
	}

	public static SubLObject load_clause_struc_def(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject cnf = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		final SubLObject clause_struc = clause_strucs.make_clause_struc_shell(cnf, dump_id);
		clause_strucs.reset_clause_struc_assertions(clause_struc, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return clause_struc;
	}

	public static final SubLObject load_clause_struc_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt95$clause_struc_count);
	}

	public static SubLObject load_clause_struc_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str298$clause_struc_count);
	}

	public static SubLObject possibly_persist_wide_fvector_mark(final SubLObject fvector, final SubLObject file_stem,
			final SubLObject directory_path, final SubLObject kb_object_type) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != file_vector.wide_file_vectorP(fvector)) {
			final SubLObject wide_mark_file = dumper.kb_dump_file(
					dumper.get_wide_mark_basename_from_index_basename(file_stem), directory_path, UNPROVIDED);
			format(T, dumper.$str305$__The__A_size_is_larger_than_4GB_, kb_object_type);
			final SubLObject str = dumper.$str306$Persisting_wide_index_entry_suppo;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				file_vector.persist_file_vector_wide_mark(fvector, wide_mark_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return fvector;
	}

	/**
	 * Accessor for the first deduction ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first deduction ID not represented in a specific KB.")
	public static final SubLObject get_exclusive_deduction_internal_id_limit_for_kb_alt(SubLObject directory_path) {
		{
			SubLObject count = com.cyc.cycjava.cycl.dumper.load_deduction_count(directory_path);
			return count;
		}
	}

	/**
	 * Accessor for the first deduction ID not represented in a specific KB.
	 */
	@LispMethod(comment = "Accessor for the first deduction ID not represented in a specific KB.")
	public static SubLObject get_exclusive_deduction_internal_id_limit_for_kb(final SubLObject directory_path) {
		final SubLObject count = dumper.load_deduction_count(directory_path);
		return count;
	}

	public static SubLObject snapshot_deduction_count(final SubLObject directory_path) {
		return dumper.dump_kb_object_count(directory_path, dumper.$str307$deduction_count,
				deduction_handles.next_deduction_id());
	}

	public static final SubLObject dump_deduction_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt99$deduction_count,
					deduction_handles.deduction_count());
			{
				SubLObject deduction_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$deduction, directory_path,
						UNPROVIDED);
				SubLObject deduction_index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt101$deduction_index,
						directory_path, UNPROVIDED);
				SubLObject filename_var = deduction_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_30 = stream;
						SubLObject filename_var_31 = deduction_index_file;
						SubLObject stream_32 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_32 = compatibility.open_binary(filename_var_31, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_32.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_31);
							}
							{
								SubLObject index_stream = stream_32;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_30);
								{
									SubLObject fvector = create_file_vector(stream_30, index_stream);
									SubLObject idx = deduction_handles.do_deductions_table();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($$$Dumping_deduction_definitions, STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Dumping_deduction_definitions);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
													SubLObject deduction = NIL;
													while (NIL != id) {
														deduction = do_id_index_state_object(idx, $SKIP, id, state_var);
														if (NIL != do_id_index_id_and_object_validP(id, deduction,
																$SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															update_file_vector_index_linear(fvector);
															com.cyc.cycjava.cycl.dumper.dump_deduction_def(deduction,
																	stream_30);
														}
														id = do_id_index_next_id(idx, T, id, state_var);
														state_var = do_id_index_next_state(idx, T, id, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_32.isStream()) {
										close(stream_32, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_31);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_deduction_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$314 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$315 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$314);
			final SubLObject memory_mappedP_$316 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$314);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$314);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$314);
				final SubLObject manager_$315 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$316 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$315);
				final SubLObject memory_mappedP_$317 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$315);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$315);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$315);
					final SubLObject manager_$316 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$317 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$316);
					final SubLObject memory_mappedP_$318 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$316);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$316);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$316);
						final SubLObject manager_$317 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$318 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$317);
						final SubLObject memory_mappedP_$319 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$317);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$317);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$317);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								dumper.dump_kb_object_count(directory_path, dumper.$str307$deduction_count,
										deduction_handles.deduction_count());
								final SubLObject deduction_file = dumper.kb_dump_file(dumper.$$$deduction,
										directory_path, UNPROVIDED);
								final SubLObject deduction_index_file = dumper
										.kb_dump_file(dumper.$str308$deduction_index, directory_path, UNPROVIDED);
								final SubLObject _prev_bind_0_$326 = StreamsLow.$stream_initial_input_buffer_size$
										.currentBinding(thread);
								final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$
										.currentBinding(thread);
								try {
									StreamsLow.$stream_initial_input_buffer_size$.bind(
											file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread),
											thread);
									StreamsLow.$stream_initial_output_buffer_size$.bind(
											StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread),
											thread);
									final SubLObject filename_var = deduction_file;
									SubLObject stream = NIL;
									try {
										final SubLObject _prev_bind_0_$327 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream = compatibility.open_binary(filename_var, $OUTPUT);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$327, thread);
										}
										if (!stream.isStream()) {
											Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
										}
										SubLObject stream_$328 = stream;
										if ($OUTPUT == $INPUT) {
											stream_$328 = file_utilities.enable_file_stream_memory_mapping(stream_$328);
										}
										try {
											final SubLObject filename_var_$329 = deduction_index_file;
											SubLObject stream_$329 = NIL;
											try {
												final SubLObject _prev_bind_0_$328 = stream_macros.$stream_requires_locking$
														.currentBinding(thread);
												try {
													stream_macros.$stream_requires_locking$.bind(NIL, thread);
													stream_$329 = compatibility.open_binary(filename_var_$329, $OUTPUT);
												} finally {
													stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$328,
															thread);
												}
												if (!stream_$329.isStream()) {
													Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$329);
												}
												SubLObject index_stream = stream_$329;
												if ($OUTPUT == $INPUT) {
													index_stream = file_utilities
															.enable_file_stream_memory_mapping(index_stream);
												}
												try {
													dumper.dump_copyright(stream_$328);
													final SubLObject fvector = file_vector
															.create_file_vector(stream_$328, index_stream);
													final SubLObject idx = deduction_handles.do_deductions_table();
													final SubLObject mess = dumper.$$$Dumping_deduction_definitions;
													final SubLObject total = id_index_count(idx);
													SubLObject sofar = ZERO_INTEGER;
													assert NIL != stringp(mess) : "! stringp(mess) "
															+ ("Types.stringp(mess) "
																	+ "CommonSymbols.NIL != Types.stringp(mess) ")
															+ mess;
													final SubLObject _prev_bind_0_$329 = $last_percent_progress_index$
															.currentBinding(thread);
													final SubLObject _prev_bind_1_$333 = $last_percent_progress_prediction$
															.currentBinding(thread);
													final SubLObject _prev_bind_3 = $within_noting_percent_progress$
															.currentBinding(thread);
													final SubLObject _prev_bind_4 = $percent_progress_start_time$
															.currentBinding(thread);
													try {
														$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
														$last_percent_progress_prediction$.bind(NIL, thread);
														$within_noting_percent_progress$.bind(T, thread);
														$percent_progress_start_time$.bind(get_universal_time(),
																thread);
														try {
															noting_percent_progress_preamble(mess);
															final SubLObject idx_$334 = idx;
															if (NIL == id_index_objects_empty_p(idx_$334, $SKIP)) {
																final SubLObject idx_$335 = idx_$334;
																if (NIL == id_index_dense_objects_empty_p(idx_$335,
																		$SKIP)) {
																	final SubLObject vector_var = id_index_dense_objects(
																			idx_$335);
																	final SubLObject backwardP_var = NIL;
																	SubLObject length;
																	SubLObject v_iteration;
																	SubLObject d_id;
																	SubLObject d_handle;
																	SubLObject deduction;
																	for (length = length(
																			vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																					.numL(length); v_iteration = add(
																							v_iteration, ONE_INTEGER)) {
																		d_id = (NIL != backwardP_var)
																				? subtract(length, v_iteration,
																						ONE_INTEGER)
																				: v_iteration;
																		d_handle = aref(vector_var, d_id);
																		if ((NIL == id_index_tombstone_p(d_handle))
																				|| (NIL == id_index_skip_tombstones_p(
																						$SKIP))) {
																			if (NIL != id_index_tombstone_p(d_handle)) {
																				d_handle = $SKIP;
																			}
																			deduction = deduction_handles
																					.resolve_deduction_id_value_pair(
																							d_id, d_handle);
																			file_vector.update_file_vector_index_linear(
																					fvector);
																			dumper.dump_deduction_def(deduction,
																					stream_$328);
																			sofar = add(sofar, ONE_INTEGER);
																			note_percent_progress(sofar, total);
																		}
																	}
																}
																final SubLObject idx_$336 = idx_$334;
																if ((NIL == id_index_sparse_objects_empty_p(idx_$336))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	final SubLObject sparse = id_index_sparse_objects(
																			idx_$336);
																	SubLObject d_id2 = id_index_sparse_id_threshold(
																			idx_$336);
																	final SubLObject end_id = id_index_next_id(
																			idx_$336);
																	final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																			$SKIP)) ? NIL : $SKIP;
																	while (d_id2.numL(end_id)) {
																		final SubLObject d_handle2 = gethash_without_values(
																				d_id2, sparse, v_default);
																		if ((NIL == id_index_skip_tombstones_p($SKIP))
																				|| (NIL == id_index_tombstone_p(
																						d_handle2))) {
																			final SubLObject deduction2 = deduction_handles
																					.resolve_deduction_id_value_pair(
																							d_id2, d_handle2);
																			file_vector.update_file_vector_index_linear(
																					fvector);
																			dumper.dump_deduction_def(deduction2,
																					stream_$328);
																			sofar = add(sofar, ONE_INTEGER);
																			note_percent_progress(sofar, total);
																		}
																		d_id2 = add(d_id2, ONE_INTEGER);
																	}
																}
															}
														} finally {
															final SubLObject _prev_bind_0_$330 = $is_thread_performing_cleanupP$
																	.currentBinding(thread);
															try {
																$is_thread_performing_cleanupP$.bind(T, thread);
																final SubLObject _values = getValuesAsVector();
																noting_percent_progress_postamble();
																restoreValuesFromVector(_values);
															} finally {
																$is_thread_performing_cleanupP$
																		.rebind(_prev_bind_0_$330, thread);
															}
														}
													} finally {
														$percent_progress_start_time$.rebind(_prev_bind_4, thread);
														$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
														$last_percent_progress_prediction$.rebind(_prev_bind_1_$333,
																thread);
														$last_percent_progress_index$.rebind(_prev_bind_0_$329, thread);
													}
													dumper.possibly_persist_wide_fvector_mark(fvector,
															dumper.$str308$deduction_index, directory_path,
															dumper.$$$deduction_defs);
												} finally {
													final SubLObject _prev_bind_0_$331 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values2 = getValuesAsVector();
														close(index_stream, UNPROVIDED);
														restoreValuesFromVector(_values2);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$331,
																thread);
													}
												}
											} finally {
												final SubLObject _prev_bind_0_$332 = $is_thread_performing_cleanupP$
														.currentBinding(thread);
												try {
													$is_thread_performing_cleanupP$.bind(T, thread);
													final SubLObject _values3 = getValuesAsVector();
													if (stream_$329.isStream()) {
														close(stream_$329, UNPROVIDED);
													}
													restoreValuesFromVector(_values3);
												} finally {
													$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$332, thread);
												}
											}
											dumper.discard_dump_filename(filename_var_$329);
										} finally {
											final SubLObject _prev_bind_0_$333 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values4 = getValuesAsVector();
												close(stream_$328, UNPROVIDED);
												restoreValuesFromVector(_values4);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$333, thread);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$334 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values5 = getValuesAsVector();
											if (stream.isStream()) {
												close(stream, UNPROVIDED);
											}
											restoreValuesFromVector(_values5);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$334, thread);
										}
									}
									dumper.discard_dump_filename(filename_var);
								} finally {
									StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
									StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0_$326, thread);
								}
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values6 = getValuesAsVector();
								if (NIL != maintaining_countsP_$318) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$317);
								}
								if (NIL == memory_mappedP_$319) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$317,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values6);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values7 = getValuesAsVector();
							if (NIL != maintaining_countsP_$317) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$316);
							}
							if (NIL == memory_mappedP_$318) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$316,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values7);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values8 = getValuesAsVector();
						if (NIL != maintaining_countsP_$316) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$315);
						}
						if (NIL == memory_mappedP_$317) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$315,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values8);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values9 = getValuesAsVector();
					if (NIL != maintaining_countsP_$315) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$314);
					}
					if (NIL == memory_mappedP_$316) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$314, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values9);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values10 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values10);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject snapshot_deduction_defs(final SubLObject active_dir, final SubLObject directory_path) {
		return dumper.snapshot_managed_object_simple_index(dumper.SNAPSHOT_DEDUCTION_DEFS_INTERNAL, dumper.$$$deduction,
				active_dir, directory_path);
	}

	public static SubLObject snapshot_deduction_defs_internal(final SubLObject active_dir,
			final SubLObject directory_path, SubLObject widen_indexP) {
		if (widen_indexP == UNPROVIDED) {
			widen_indexP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject current;
		final SubLObject datum = current = dumper.replicate_fv_dump_files(dumper.$list312, dumper.$list313,
				list(dumper.get_wide_mark_basename_from_index_basename(dumper.$str308$deduction_index)),
				list(widen_indexP), active_dir, directory_path, cconcatenate(
						dumper.$str314$Copying_deduction_definitions_fro, format_nil.format_nil_a_no_copy(active_dir)));
		SubLObject new_dfile = NIL;
		SubLObject new_ifile = NIL;
		SubLObject new_widemark = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list315);
		new_dfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list315);
		new_ifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list315);
		new_widemark = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject bufsize = file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject small_bufsize = file_utilities.$default_small_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject fvector = file_vector.open_file_vector_for_rewrite(new_dfile, new_ifile, new_widemark,
					bufsize, small_bufsize, UNPROVIDED);
			try {
				dumper.snapshot_deleted_object_tombstones(fvector, deduction_handles.deleted_deduction_id_iterator(),
						dumper.$str316$Tombstoning_deleted_deduction_def);
				compatibility.set_file_position(file_vector.get_file_vector_data_stream(fvector), $END);
				if (NIL != deduction_handles.has_new_deductionsP()) {
					file_vector.file_vector_change_stream_buffer_sizes(fvector, bufsize, bufsize);
					dumper.snapshot_new_managed_objects(fvector, deduction_handles.new_new_deductions_iterator(),
							deduction_manager.get_file_backed_deduction_id_threshold(), dumper.DEDUCTION_ID,
							dumper.DUMP_DEDUCTION_DEF, dumper.$str320$Appending_new_deduction_definitio, UNPROVIDED);
				}
				dumper.possibly_persist_wide_fvector_mark(fvector, dumper.$str308$deduction_index, directory_path,
						dumper.$$$deduction_defs);
			} finally {
				final SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					file_vector.close_file_vector(fvector);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
				}
			}
		} else {
			cdestructuring_bind_error(datum, dumper.$list315);
		}
		return NIL;
	}

	public static final SubLObject load_deduction_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject deduction_cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$deduction, directory_path,
						UNPROVIDED);
				SubLObject deduction_index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt101$deduction_index,
						directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(deduction_index_file))) {
					format(T, $str_alt103$__Deduction_definitions_will_be_s, deduction_cfasl_file,
							deduction_index_file);
					{
						SubLObject max_dump_id = NIL;
						{
							SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
							SubLObject _prev_bind_1 = $cfasl_input_to_static_area$.currentBinding(thread);
							try {
								$structure_resourcing_make_static$.bind(NIL, thread);
								$cfasl_input_to_static_area$.bind(NIL, thread);
								max_dump_id = file_vector_length_from_index(deduction_index_file);
							} finally {
								$cfasl_input_to_static_area$.rebind(_prev_bind_1, thread);
								$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
							}
						}
						$progress_note$.setDynamicValue($str_alt104$Initializing_deduction_handles_on, thread);
						$progress_start_time$.setDynamicValue(get_universal_time(), thread);
						$progress_total$.setDynamicValue(max_dump_id, thread);
						$progress_sofar$.setDynamicValue(ZERO_INTEGER, thread);
						{
							SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
							SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
							SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
							SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
							try {
								$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
								$last_percent_progress_prediction$.bind(NIL, thread);
								$within_noting_percent_progress$.bind(T, thread);
								$percent_progress_start_time$.bind(get_universal_time(), thread);
								noting_percent_progress_preamble($progress_note$.getDynamicValue(thread));
								{
									SubLObject dump_id = NIL;
									for (dump_id = ZERO_INTEGER; dump_id.numL($progress_total$
											.getDynamicValue(thread)); dump_id = add(dump_id, ONE_INTEGER)) {
										note_percent_progress($progress_sofar$.getDynamicValue(thread),
												$progress_total$.getDynamicValue(thread));
										$progress_sofar$.setDynamicValue(
												add($progress_sofar$.getDynamicValue(thread), ONE_INTEGER), thread);
										{
											SubLObject _prev_bind_0_33 = $structure_resourcing_make_static$
													.currentBinding(thread);
											SubLObject _prev_bind_1_34 = $cfasl_input_to_static_area$
													.currentBinding(thread);
											try {
												$structure_resourcing_make_static$.bind(T, thread);
												$cfasl_input_to_static_area$.bind(T, thread);
												deduction_handles.make_deduction_shell(dump_id);
											} finally {
												$cfasl_input_to_static_area$.rebind(_prev_bind_1_34, thread);
												$structure_resourcing_make_static$.rebind(_prev_bind_0_33, thread);
											}
										}
									}
								}
								noting_percent_progress_postamble();
							} finally {
								$percent_progress_start_time$.rebind(_prev_bind_3, thread);
								$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
								$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
								$last_percent_progress_index$.rebind(_prev_bind_0, thread);
							}
						}
					}
					initialize_deduction_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(deduction_cfasl_file, UNPROVIDED)) {
						{
							SubLObject deduction_file = deduction_cfasl_file;
							SubLObject filename_var = deduction_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_35 = stream;
									SubLObject total = file_length(stream_35);
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_35);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Loading_deduction_definitions);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_35, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_35,
																NIL, UNPROVIDED)) {
													note_percent_progress(compatibility.get_file_position(stream_35),
															total);
													if (dump_id.isInteger()) {
														deduction_handles.make_deduction_shell(dump_id);
														com.cyc.cycjava.cycl.dumper.load_deduction_def(dump_id,
																stream_35);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			{
				SubLObject deduction_count = com.cyc.cycjava.cycl.dumper.load_deduction_count(directory_path);
				deduction_handles.finalize_deductions(deduction_count);
			}
			return NIL;
		}
	}

	public static SubLObject load_deduction_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject deduction_cfasl_file = dumper.kb_dump_file(dumper.$$$deduction, directory_path, UNPROVIDED);
		final SubLObject deduction_index_file = dumper.kb_dump_file(dumper.$str308$deduction_index, directory_path,
				UNPROVIDED);
		final SubLObject deduction_wide_mark_file = dumper.kb_dump_file(
				dumper.get_wide_mark_basename_from_index_basename(dumper.$str308$deduction_index), directory_path,
				UNPROVIDED);
		final SubLObject deleted_deduction_ids = dumper.load_deleted_deduction_id_set(directory_path);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(deduction_index_file))) {
			format(T, dumper.$str321$__Deduction_definitions_will_be_s, deduction_cfasl_file, deduction_index_file);
			SubLObject max_dump_id = NIL;
			final SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $cfasl_input_to_static_area$.currentBinding(thread);
			try {
				$structure_resourcing_make_static$.bind(NIL, thread);
				$cfasl_input_to_static_area$.bind(NIL, thread);
				if (NIL != Filesys.probe_file(deduction_wide_mark_file)) {
					final SubLObject str = dumper.$str322$Determining_deduction_max_ID_usin;
					final SubLObject _prev_bind_0_$342 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_1_$343 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						max_dump_id = file_vector.wide_file_vector_length_from_index(deduction_index_file,
								deduction_wide_mark_file);
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_8, thread);
						$is_noting_progressP$.rebind(_prev_bind_7, thread);
						$progress_count$.rebind(_prev_bind_6, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
						$progress_notification_count$.rebind(_prev_bind_4, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_1_$343, thread);
						$progress_start_time$.rebind(_prev_bind_0_$342, thread);
					}
				} else {
					final SubLObject str = dumper.$str323$Determining_deduction_max_ID_from;
					final SubLObject _prev_bind_0_$343 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_1_$344 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						max_dump_id = file_vector.file_vector_length_from_index(deduction_index_file);
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_8, thread);
						$is_noting_progressP$.rebind(_prev_bind_7, thread);
						$progress_count$.rebind(_prev_bind_6, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
						$progress_notification_count$.rebind(_prev_bind_4, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_1_$344, thread);
						$progress_start_time$.rebind(_prev_bind_0_$343, thread);
					}
				}
			} finally {
				$cfasl_input_to_static_area$.rebind(_prev_bind_2, thread);
				$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
			}
			final SubLObject str2 = dumper.$str324$Enabling_lazy_deduction_handle_su;
			final SubLObject _prev_bind_9 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_10 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_11 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_12 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_13 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_14 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_15 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_16 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str2 ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str2);
				deduction_handles.mark_available_deductions(max_dump_id, deleted_deduction_ids);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_16, thread);
				$is_noting_progressP$.rebind(_prev_bind_15, thread);
				$progress_count$.rebind(_prev_bind_14, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_13, thread);
				$progress_notification_count$.rebind(_prev_bind_12, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_11, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_10, thread);
				$progress_start_time$.rebind(_prev_bind_9, thread);
			}
			deduction_manager.initialize_deduction_hl_store_cache();
			if (NIL != deduction_manager.wide_deduction_hl_store_cacheP()) {
				format(T, dumper.$str325$___Deduction_definitions_use_wide);
			}
		} else if ((NIL != dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != dumper.has_deleted_deduction_id_setP(directory_path))) {
			Errors.error(dumper.$str326$Not_yet_implemented_);
		} else if (NIL != dumper.verify_file_existence(deduction_cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var;
			final SubLObject deduction_file = filename_var = deduction_cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_17 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_17, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$346 = stream;
				if ($INPUT == $INPUT) {
					stream_$346 = file_utilities.enable_file_stream_memory_mapping(stream_$346);
				}
				try {
					final SubLObject total = file_length(stream_$346);
					dumper.load_copyright(stream_$346);
					final SubLObject _prev_bind_18 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_19 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_20 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_21 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_deduction_definitions);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$346, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$346, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$346), total);
								if (dump_id.isInteger()) {
									deduction_handles.make_deduction_shell(dump_id);
									dumper.load_deduction_def(dump_id, stream_$346);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$344 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$344, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_21, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_20, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_19, thread);
						$last_percent_progress_index$.rebind(_prev_bind_18, thread);
					}
				} finally {
					final SubLObject _prev_bind_22 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$346, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_22, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_23 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_23, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		final SubLObject deduction_count = dumper.load_deduction_count(directory_path);
		deduction_handles.finalize_deductions(subtract(deduction_count, ONE_INTEGER));
		return NIL;
	}

	static private final SubLList $list_alt9 = list(
			list(makeSymbol("*CFASL-CONSTANT-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-CONSTANT-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-NART-HANDLE-LOOKUP-FUNC*"), list(QUOTE, makeSymbol("FIND-NART-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-ASSERTION-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-ASSERTION-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-DEDUCTION-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-DEDUCTION-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-KB-HL-SUPPORT-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-KB-HL-SUPPORT-BY-DUMP-ID"))),
			list(makeSymbol("*CFASL-CLAUSE-STRUC-HANDLE-LOOKUP-FUNC*"),
					list(QUOTE, makeSymbol("FIND-CLAUSE-STRUC-BY-DUMP-ID"))));

	static private final SubLList $list_alt10 = list(list(makeSymbol("*STRUCTURE-RESOURCING-MAKE-STATIC*"), T),
			list(makeSymbol("*CFASL-INPUT-TO-STATIC-AREA*"), T));

	static private final SubLList $list_alt11 = list(list(makeSymbol("*STRUCTURE-RESOURCING-MAKE-STATIC*"), NIL),
			list(makeSymbol("*CFASL-INPUT-TO-STATIC-AREA*"), NIL));

	static private final SubLList $list_alt12 = list(list(makeSymbol("FILENAME-VAR"), makeSymbol("FILENAME")),
			makeSymbol("&BODY"), makeSymbol("BODY"));

	static private final SubLList $list_alt14 = list(
			list(makeSymbol("STREAM"), makeSymbol("FILENAME"), makeSymbol("DIRECTION")), makeSymbol("&BODY"),
			makeSymbol("BODY"));

	static private final SubLSymbol $sym18$FILENAME_VAR = makeUninternedSymbol("FILENAME-VAR");

	static private final SubLList $list_alt21 = list(makeString("units"));

	static private final SubLString $str_alt24$_4__0D = makeString("~4,'0D");

	static private final SubLString $str_alt26$file__s_not_found = makeString("file ~s not found");

	static private final SubLString $str_alt27$Directory__S_does_not_exist_ = makeString(
			"Directory ~S does not exist.");

	static private final SubLString $str_alt28$Directory__S_cannot_be_written_to = makeString(
			"Directory ~S cannot be written to.");

	static private final SubLString $str_alt29$Directory__S_does_not_have_enough = makeString(
			"Directory ~S does not have enough space available, ~S bytes, for the KB dump.");

	static private final SubLString $str_alt30$rule_utility_experience = makeString("rule-utility-experience");

	static private final SubLString $str_alt43$Create_directory_and_continue_ = makeString(
			"Create directory and continue.");

	static private final SubLString $str_alt44$________Dumping_KB__A_to__A_at__A = makeString(
			"~&~%;;; Dumping KB ~A to ~A at ~A~%");

	static private final SubLString $str_alt45$_____S_transcript_operations_proc = makeString(
			"~&  ~S transcript operations processed~%");

	static private final SubLString $str_alt46$________Dump_of_KB__A_completed__ = makeString(
			"~&~%;;; Dump of KB ~A completed (~A) at ~A~%");

	static private final SubLString $str_alt47$________Loading_KB_from__A_at__A_ = makeString(
			"~&~%;;; Loading KB from ~A at ~A~%");

	static private final SubLString $str_alt48$________Load_of_KB__A_completed__ = makeString(
			"~&~%;;; Load of KB ~A completed (~A) at ~A~%");

	static private final SubLString $str_alt49$________Dumping_essential_KB__ = makeString(
			"~&~%;;; Dumping essential KB~%");

	static private final SubLString $str_alt50$________Loading_essential_KB_at__ = makeString(
			"~&~%;;; Loading essential KB at ~A~%");

	static private final SubLString $str_alt51$________Loading_computable_KB_at_ = makeString(
			"~&~%;;; Loading computable KB at ~A~%");

	static private final SubLString $str_alt52$________Loading_computable_remain = makeString(
			"~&~%;;; Loading computable remaining HL at ~A~%");

	static private final SubLString $str_alt53$Cannot_initialize_reformulator_du = makeString(
			"Cannot initialize reformulator due to missing KB content.");

	static private final SubLString $str_alt54$Cannot_initialize_lexicon_cache_d = makeString(
			"Cannot initialize lexicon cache due to missing KB content.");

	static private final SubLString $str_alt55$Cannot_initialize_recursive_templ = makeString(
			"Cannot initialize recursive template parser rules due to missing KB content.");

	static private final SubLString $str_alt56$________Rebuilding_computable_but = makeString(
			"~&~%;;; Rebuilding computable-but-not-dumpable-yet-KB at ~A~%");

	static private final SubLString $str_alt57$Invalid_attempt_to_reuse_memoizat = makeString(
			"Invalid attempt to reuse memoization state in multiple threads simultaneously.");

	static private final SubLString $str_alt58$Cannot_initialize_paraphrase_code = makeString(
			"Cannot initialize paraphrase code due to missing KB content.");

	static private final SubLString $str_alt59$Cannot_initialize_SKSI_due_to_mis = makeString(
			"Cannot initialize SKSI due to missing KB content.");

	static private final SubLString $str_alt60$Cannot_initialize_recursive_templ = makeString(
			"Cannot initialize recursive template parser due to missing KB content.");

	static private final SubLString $str_alt61$Cannot_initialize_fact_entry_tool = makeString(
			"Cannot initialize fact entry tool due to missing KB content.");

	static private final SubLString $str_alt62$Cannot_initialize_cycsecure_due_t = makeString(
			"Cannot initialize cycsecure due to missing KB content.");

	static private final SubLString $str_alt65$Unable_to_open__S = makeString("Unable to open ~S");

	static private final SubLString $str_alt67$_d_bytes_of_unread_stuff_in__S = makeString(
			"~d bytes of unread stuff in ~S");

	static private final SubLString $str_alt70$_a__ = makeString("~a~%");

	static private final SubLList $list_alt72 = list(makeKeyword("UNNAMED"), makeKeyword("VARIABLE-NAMES"),
			makeKeyword("DEPENDENTS"), makeKeyword("INDEX"), makeKeyword("ASSERT-INFO"));

	static private final SubLString $str_alt73$Dumping_special_objects_at__A___ = makeString(
			"Dumping special objects at ~A...");

	static private final SubLString $str_alt75$Loading_special_objects___ = makeString("Loading special objects...");

	static private final SubLString $str_alt77$constant_count = makeString("constant-count");

	static private final SubLString $str_alt78$constant_shell = makeString("constant-shell");

	static private final SubLString $str_alt82$nart_count = makeString("nart-count");

	static private final SubLString $str_alt83$nat_shell = makeString("nat-shell");

	static private final SubLString $str_alt85$assertion_count = makeString("assertion-count");

	static private final SubLString $str_alt86$assertion_shell = makeString("assertion-shell");

	static private final SubLString $str_alt88$kb_hl_support_count = makeString("kb-hl-support-count");

	static private final SubLString $str_alt89$kb_hl_support_shell = makeString("kb-hl-support-shell");

	static private final SubLString $str_alt91$unrepresented_term_count = makeString("unrepresented-term-count");

	static private final SubLString $str_alt92$unrepresented_terms = makeString("unrepresented-terms");

	static private final SubLString $str_alt95$clause_struc_count = makeString("clause-struc-count");

	static private final SubLString $str_alt96$clause_struc = makeString("clause-struc");

	static private final SubLString $str_alt97$Dumping_clause_struc_definitions = makeString(
			"Dumping clause-struc definitions");

	static private final SubLString $str_alt98$Loading_clause_struc_definitions = makeString(
			"Loading clause-struc definitions");

	static private final SubLString $str_alt99$deduction_count = makeString("deduction-count");

	static private final SubLString $str_alt101$deduction_index = makeString("deduction-index");

	static private final SubLString $str_alt103$__Deduction_definitions_will_be_s = makeString(
			"~&Deduction definitions will be swapped in lazily from ~A and ~A~%");

	static private final SubLString $str_alt104$Initializing_deduction_handles_on = makeString(
			"Initializing deduction handles only");

	static private final SubLString $str_alt108$assertion_index = makeString("assertion-index");

	static private final SubLString $str_alt110$__Assertion_definitions_will_be_s = makeString(
			"~&Assertion definitions will be swapped in lazily from ~A and ~A~%");

	static private final SubLString $str_alt113$kb_hl_support = makeString("kb-hl-support");

	static private final SubLString $str_alt114$kb_hl_support_index = makeString("kb-hl-support-index");

	static private final SubLString $str_alt116$__KB_HL_supports_will_be_swapped_ = makeString(
			"~&KB HL supports will be swapped in lazily from ~A and ~A~%");

	static private final SubLString $str_alt119$kb_hl_support_indexing = makeString("kb-hl-support-indexing");

	static private final SubLString $str_alt120$Dumping_KB_HL_support_indexing___ = makeString(
			"Dumping KB HL support indexing...");

	static private final SubLString $str_alt121$Loading_KB_HL_support_indexing___ = makeString(
			"Loading KB HL support indexing...");

	static private final SubLString $str_alt122$bookkeeping_assertions = makeString("bookkeeping-assertions");

	static private final SubLString $str_alt123$Dumping_bookkeeping_assertions___ = makeString(
			"Dumping bookkeeping assertions...");

	static private final SubLList $list_alt124 = cons(makeSymbol("PRED"), makeSymbol("SUBINDEX"));

	static private final SubLString $str_alt125$Loading_bookkeeping_assertions___ = makeString(
			"Loading bookkeeping assertions...");

	static private final SubLString $str_alt126$Dumping_rule_utility_experience__ = makeString(
			"Dumping rule utility experience...");

	public static final SubLObject dump_deduction_def_alt(SubLObject deduction, SubLObject stream) {
		cfasl_output(deductions_high.deduction_dump_id(deduction), stream);
		deductions_low.dump_deduction_content(deduction, stream);
		return deduction;
	}

	public static SubLObject dump_deduction_def(final SubLObject deduction, final SubLObject stream) {
		cfasl_output(deductions_high.deduction_dump_id(deduction), stream);
		deductions_low.dump_deduction_content(deduction, stream);
		return deduction;
	}

	static private final SubLString $str_alt127$Loading_rule_utility_experience__ = makeString(
			"Loading rule utility experience...");

	static private final SubLString $str_alt128$non_wff_store = makeString("non-wff-store");

	public static SubLObject snapshot_deleted_deduction_id_set(final SubLObject directory_path) {
		return dumper.snapshot_kb_object_deleted_id_set(directory_path, dumper.$str328$deleted_deduction_ids,
				deduction_handles.missing_deduction_id_set(), dumper.$$$deduction);
	}

	static private final SubLString $str_alt130$indices_index = makeString("indices-index");

	public static final SubLObject load_deduction_def_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject deduction = deductions_high.find_deduction_by_dump_id(dump_id);
			deductions_low.load_deduction_content(deduction, stream);
			return deduction;
		}
	}

	public static SubLObject load_deduction_def(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject deduction = deductions_high.find_deduction_by_dump_id(dump_id);
		deductions_low.load_deduction_content(deduction, stream);
		return deduction;
	}

	static private final SubLString $str_alt132$__Constant_indexing_will_be_swapp = makeString(
			"~&Constant indexing will be swapped in lazily from ~A and ~A~%");

	public static final SubLObject load_deduction_def_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject deduction = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						deduction = com.cyc.cycjava.cycl.dumper.load_deduction_def(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return deduction;
			}
		}
	}

	public static SubLObject load_deduction_def_from_cache(final SubLObject dump_id, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject deduction = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			deduction = dumper.load_deduction_def(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return deduction;
	}

	static private final SubLString $str_alt135$nat_indices = makeString("nat-indices");

	static private final SubLString $str_alt136$nat_indices_index = makeString("nat-indices-index");

	static private final SubLString $str_alt138$__NART_indexing_will_be_swapped_i = makeString(
			"~&NART indexing will be swapped in lazily from ~A and ~A~%");

	public static final SubLObject load_deduction_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt99$deduction_count);
	}

	public static SubLObject load_deduction_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str307$deduction_count);
	}

	public static SubLObject load_deleted_deduction_id_set(final SubLObject directory_path) {
		return dumper.load_kb_object_deleted_id_set(directory_path, dumper.$str328$deleted_deduction_ids);
	}

	static private final SubLString $str_alt141$unrepresented_term_indices = makeString("unrepresented-term-indices");

	static private final SubLString $str_alt142$unrepresented_term_indices_index = makeString(
			"unrepresented-term-indices-index");

	public static SubLObject has_deleted_deduction_id_setP(final SubLObject directory_path) {
		return Filesys
				.probe_file(dumper.kb_dump_file(dumper.$str328$deleted_deduction_ids, directory_path, UNPROVIDED));
	}

	static private final SubLString $str_alt143$Dumping_unrepresented_term_indice = makeString(
			"Dumping unrepresented term indices");

	static private final SubLString $str_alt144$__Unrepresented_term_indexing_wil = makeString(
			"~&Unrepresented term indexing will be swapped in lazily from ~A and ~A~%");

	public static final SubLObject dump_assertion_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject assertion_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$assertion, directory_path,
						UNPROVIDED);
				SubLObject assertion_index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt108$assertion_index,
						directory_path, UNPROVIDED);
				SubLObject filename_var = assertion_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_36 = stream;
						SubLObject filename_var_37 = assertion_index_file;
						SubLObject stream_38 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_38 = compatibility.open_binary(filename_var_37, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_38.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_37);
							}
							{
								SubLObject index_stream = stream_38;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_36);
								{
									SubLObject fvector = create_file_vector(stream_36, index_stream);
									SubLObject idx = assertion_handles.do_assertions_table();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($$$Dumping_assertion_definitions, STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Dumping_assertion_definitions);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
													SubLObject assertion = NIL;
													while (NIL != id) {
														assertion = do_id_index_state_object(idx, $SKIP, id, state_var);
														if (NIL != do_id_index_id_and_object_validP(id, assertion,
																$SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															update_file_vector_index_linear(fvector);
															com.cyc.cycjava.cycl.dumper.dump_assertion_def(assertion,
																	stream_36);
														}
														id = do_id_index_next_id(idx, T, id, state_var);
														state_var = do_id_index_next_state(idx, T, id, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_38.isStream()) {
										close(stream_38, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_37);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_assertion_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$348 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$349 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$348);
			final SubLObject memory_mappedP_$350 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$348);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$348);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$348);
				final SubLObject manager_$349 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$350 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$349);
				final SubLObject memory_mappedP_$351 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$349);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$349);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$349);
					final SubLObject manager_$350 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$351 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$350);
					final SubLObject memory_mappedP_$352 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$350);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$350);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$350);
						final SubLObject manager_$351 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$352 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$351);
						final SubLObject memory_mappedP_$353 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$351);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$351);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$351);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								final SubLObject assertion_file = dumper.kb_dump_file(dumper.$$$assertion,
										directory_path, UNPROVIDED);
								final SubLObject assertion_index_file = dumper
										.kb_dump_file(dumper.$str330$assertion_index, directory_path, UNPROVIDED);
								final SubLObject _prev_bind_0_$360 = StreamsLow.$stream_initial_input_buffer_size$
										.currentBinding(thread);
								final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$
										.currentBinding(thread);
								try {
									StreamsLow.$stream_initial_input_buffer_size$.bind(
											file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread),
											thread);
									StreamsLow.$stream_initial_output_buffer_size$.bind(
											StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread),
											thread);
									final SubLObject filename_var = assertion_file;
									SubLObject stream = NIL;
									try {
										final SubLObject _prev_bind_0_$361 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream = compatibility.open_binary(filename_var, $OUTPUT);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$361, thread);
										}
										if (!stream.isStream()) {
											Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
										}
										SubLObject stream_$362 = stream;
										if ($OUTPUT == $INPUT) {
											stream_$362 = file_utilities.enable_file_stream_memory_mapping(stream_$362);
										}
										try {
											final SubLObject filename_var_$363 = assertion_index_file;
											SubLObject stream_$363 = NIL;
											try {
												final SubLObject _prev_bind_0_$362 = stream_macros.$stream_requires_locking$
														.currentBinding(thread);
												try {
													stream_macros.$stream_requires_locking$.bind(NIL, thread);
													stream_$363 = compatibility.open_binary(filename_var_$363, $OUTPUT);
												} finally {
													stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$362,
															thread);
												}
												if (!stream_$363.isStream()) {
													Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$363);
												}
												SubLObject index_stream = stream_$363;
												if ($OUTPUT == $INPUT) {
													index_stream = file_utilities
															.enable_file_stream_memory_mapping(index_stream);
												}
												try {
													dumper.dump_copyright(stream_$362);
													final SubLObject fvector = file_vector
															.create_file_vector(stream_$362, index_stream);
													final SubLObject idx = assertion_handles.do_assertions_table();
													final SubLObject mess = dumper.$$$Dumping_assertion_definitions;
													final SubLObject total = id_index_count(idx);
													SubLObject sofar = ZERO_INTEGER;
													assert NIL != stringp(mess) : "! stringp(mess) "
															+ ("Types.stringp(mess) "
																	+ "CommonSymbols.NIL != Types.stringp(mess) ")
															+ mess;
													final SubLObject _prev_bind_0_$363 = $last_percent_progress_index$
															.currentBinding(thread);
													final SubLObject _prev_bind_1_$367 = $last_percent_progress_prediction$
															.currentBinding(thread);
													final SubLObject _prev_bind_3 = $within_noting_percent_progress$
															.currentBinding(thread);
													final SubLObject _prev_bind_4 = $percent_progress_start_time$
															.currentBinding(thread);
													try {
														$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
														$last_percent_progress_prediction$.bind(NIL, thread);
														$within_noting_percent_progress$.bind(T, thread);
														$percent_progress_start_time$.bind(get_universal_time(),
																thread);
														try {
															noting_percent_progress_preamble(mess);
															final SubLObject idx_$368 = idx;
															if (NIL == id_index_objects_empty_p(idx_$368, $SKIP)) {
																final SubLObject idx_$369 = idx_$368;
																if (NIL == id_index_dense_objects_empty_p(idx_$369,
																		$SKIP)) {
																	final SubLObject vector_var = id_index_dense_objects(
																			idx_$369);
																	final SubLObject backwardP_var = NIL;
																	SubLObject length;
																	SubLObject v_iteration;
																	SubLObject a_id;
																	SubLObject a_handle;
																	SubLObject assertion;
																	for (length = length(
																			vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																					.numL(length); v_iteration = add(
																							v_iteration, ONE_INTEGER)) {
																		a_id = (NIL != backwardP_var)
																				? subtract(length, v_iteration,
																						ONE_INTEGER)
																				: v_iteration;
																		a_handle = aref(vector_var, a_id);
																		if ((NIL == id_index_tombstone_p(a_handle))
																				|| (NIL == id_index_skip_tombstones_p(
																						$SKIP))) {
																			if (NIL != id_index_tombstone_p(a_handle)) {
																				a_handle = $SKIP;
																			}
																			assertion = assertion_handles
																					.resolve_assertion_id_value_pair(
																							a_id, a_handle);
																			file_vector.update_file_vector_index_linear(
																					fvector);
																			dumper.dump_assertion_def(assertion,
																					stream_$362);
																			sofar = add(sofar, ONE_INTEGER);
																			note_percent_progress(sofar, total);
																		}
																	}
																}
																final SubLObject idx_$370 = idx_$368;
																if ((NIL == id_index_sparse_objects_empty_p(idx_$370))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	final SubLObject sparse = id_index_sparse_objects(
																			idx_$370);
																	SubLObject a_id2 = id_index_sparse_id_threshold(
																			idx_$370);
																	final SubLObject end_id = id_index_next_id(
																			idx_$370);
																	final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																			$SKIP)) ? NIL : $SKIP;
																	while (a_id2.numL(end_id)) {
																		final SubLObject a_handle2 = gethash_without_values(
																				a_id2, sparse, v_default);
																		if ((NIL == id_index_skip_tombstones_p($SKIP))
																				|| (NIL == id_index_tombstone_p(
																						a_handle2))) {
																			final SubLObject assertion2 = assertion_handles
																					.resolve_assertion_id_value_pair(
																							a_id2, a_handle2);
																			file_vector.update_file_vector_index_linear(
																					fvector);
																			dumper.dump_assertion_def(assertion2,
																					stream_$362);
																			sofar = add(sofar, ONE_INTEGER);
																			note_percent_progress(sofar, total);
																		}
																		a_id2 = add(a_id2, ONE_INTEGER);
																	}
																}
															}
														} finally {
															final SubLObject _prev_bind_0_$364 = $is_thread_performing_cleanupP$
																	.currentBinding(thread);
															try {
																$is_thread_performing_cleanupP$.bind(T, thread);
																final SubLObject _values = getValuesAsVector();
																noting_percent_progress_postamble();
																restoreValuesFromVector(_values);
															} finally {
																$is_thread_performing_cleanupP$
																		.rebind(_prev_bind_0_$364, thread);
															}
														}
													} finally {
														$percent_progress_start_time$.rebind(_prev_bind_4, thread);
														$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
														$last_percent_progress_prediction$.rebind(_prev_bind_1_$367,
																thread);
														$last_percent_progress_index$.rebind(_prev_bind_0_$363, thread);
													}
													dumper.possibly_persist_wide_fvector_mark(fvector,
															dumper.$str330$assertion_index, directory_path,
															dumper.$$$assertion_defs);
												} finally {
													final SubLObject _prev_bind_0_$365 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values2 = getValuesAsVector();
														close(index_stream, UNPROVIDED);
														restoreValuesFromVector(_values2);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$365,
																thread);
													}
												}
											} finally {
												final SubLObject _prev_bind_0_$366 = $is_thread_performing_cleanupP$
														.currentBinding(thread);
												try {
													$is_thread_performing_cleanupP$.bind(T, thread);
													final SubLObject _values3 = getValuesAsVector();
													if (stream_$363.isStream()) {
														close(stream_$363, UNPROVIDED);
													}
													restoreValuesFromVector(_values3);
												} finally {
													$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$366, thread);
												}
											}
											dumper.discard_dump_filename(filename_var_$363);
										} finally {
											final SubLObject _prev_bind_0_$367 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values4 = getValuesAsVector();
												close(stream_$362, UNPROVIDED);
												restoreValuesFromVector(_values4);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$367, thread);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$368 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values5 = getValuesAsVector();
											if (stream.isStream()) {
												close(stream, UNPROVIDED);
											}
											restoreValuesFromVector(_values5);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$368, thread);
										}
									}
									dumper.discard_dump_filename(filename_var);
								} finally {
									StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
									StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0_$360, thread);
								}
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values6 = getValuesAsVector();
								if (NIL != maintaining_countsP_$352) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$351);
								}
								if (NIL == memory_mappedP_$353) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$351,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values6);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values7 = getValuesAsVector();
							if (NIL != maintaining_countsP_$351) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$350);
							}
							if (NIL == memory_mappedP_$352) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$350,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values7);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values8 = getValuesAsVector();
						if (NIL != maintaining_countsP_$350) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$349);
						}
						if (NIL == memory_mappedP_$351) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$349,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values8);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values9 = getValuesAsVector();
					if (NIL != maintaining_countsP_$349) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$348);
					}
					if (NIL == memory_mappedP_$350) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$348, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values9);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values10 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values10);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	static private final SubLString $str_alt145$Loading_unrepresented_term_indice = makeString(
			"Loading unrepresented term indices");

	static private final SubLString $str_alt147$assertion_indices = makeString("assertion-indices");

	static private final SubLString $str_alt150$auxiliary_indices = makeString("auxiliary-indices");

	static private final SubLString $str_alt151$Dumping_auxiliary_indices___ = makeString(
			"Dumping auxiliary indices...");

	static private final SubLString $str_alt153$bookkeeping_indices = makeString("bookkeeping-indices");

	static private final SubLString $str_alt156$Loading_bookkeeping_indices___ = makeString(
			"Loading bookkeeping indices...");

	static private final SubLString $str_alt157$rule_set = makeString("rule-set");

	static private final SubLString $str_alt158$Dumping_rule_set___ = makeString("Dumping rule set...");

	static private final SubLString $str_alt160$Loading_rule_set___ = makeString("Loading rule set...");

	static private final SubLString $str_alt161$nart_hl_formula = makeString("nart-hl-formula");

	static private final SubLString $str_alt162$nart_hl_formula_index = makeString("nart-hl-formula-index");

	static private final SubLString $str_alt165$_A = makeString("~A");

	static private final SubLString $str_alt166$__NART_HL_formulas_will_be_swappe = makeString(
			"~&NART HL formulas will be swapped in lazily from ~A and ~A~%");

	static private final SubLString $str_alt167$Loading_nart_hl_formula_definitio = makeString(
			"Loading nart-hl-formula definitions");

	static private final SubLString $str_alt169$Dumping_miscellaneous_stuff___ = makeString(
			"Dumping miscellaneous stuff...");

	static private final SubLString $str_alt170$Loading_miscellaneous_stuff___ = makeString(
			"Loading miscellaneous stuff...");

	static private final SubLString $str_alt171$sbhl_modules = makeString("sbhl-modules");

	static private final SubLString $str_alt172$sbhl_module_graphs = makeString("sbhl-module-graphs");

	static private final SubLString $str_alt173$sbhl_module_graphs_index = makeString("sbhl-module-graphs-index");

	static private final SubLString $str_alt174$Dumping_SBHL_modules_and_graphs__ = makeString(
			"Dumping SBHL modules and graphs...");

	static private final SubLString $str_alt176$Dumping_SBHL_graphs___ = makeString("Dumping SBHL graphs...");

	static private final SubLString $str_alt178$Loading_SBHL_graphs___ = makeString("Loading SBHL graphs...");

	static private final SubLString $str_alt181$Cannot_initialize_SBHL_Time_due_t = makeString(
			"Cannot initialize SBHL Time due to missing KB content.");

	static private final SubLString $str_alt186$Could_not_handle_SBHL_miscellany_ = makeString(
			"Could not handle SBHL miscellany token ~s");

	static private final SubLString $str_alt187$sbhl_cache = makeString("sbhl-cache");

	static private final SubLString $str_alt188$Dumping_SBHL_cache___ = makeString("Dumping SBHL cache...");

	static private final SubLString $str_alt189$Loading_SBHL_cache___ = makeString("Loading SBHL cache...");

	static private final SubLString $str_alt190$cardinality_estimates = makeString("cardinality-estimates");

	static private final SubLString $str_alt191$Dumping_cardinality_estimates___ = makeString(
			"Dumping cardinality estimates...");

	static private final SubLString $str_alt193$Loading_cardinality_estimates___ = makeString(
			"Loading cardinality estimates...");

	static private final SubLList $list_alt194 = list(list(makeSymbol("*COMPUTE-ARG-TYPE-CACHE-ON-DUMP?*"), NIL));

	static private final SubLString $str_alt195$arg_type_cache = makeString("arg-type-cache");

	static private final SubLString $str_alt196$Dumping_arg_type_cache___ = makeString("Dumping arg-type cache...");

	static private final SubLString $str_alt197$Loading_arg_type_cache___ = makeString("Loading arg-type cache...");

	static private final SubLString $str_alt198$Rebuilding_arg_type_cache = makeString("Rebuilding arg-type cache");

	static private final SubLString $str_alt199$defns_cache = makeString("defns-cache");

	static private final SubLString $str_alt200$Dumping_defns_cache___ = makeString("Dumping defns cache...");

	static private final SubLString $str_alt201$Loading_defns_cache___ = makeString("Loading defns cache...");

	static private final SubLString $str_alt202$rule_connectivity_graph = makeString("rule-connectivity-graph");

	static private final SubLString $str_alt203$Dumping_rule_connectivity_graph__ = makeString(
			"Dumping rule connectivity graph...");

	static private final SubLString $str_alt205$Loading_rule_connectivity_graph__ = makeString(
			"Loading rule connectivity graph...");

	static private final SubLString $str_alt206$tva_cache = makeString("tva-cache");

	static private final SubLString $str_alt207$Dumping_TVA_cache___ = makeString("Dumping TVA cache...");

	static private final SubLString $str_alt209$Loading_TVA_cache___ = makeString("Loading TVA cache...");

	static private final SubLString $str_alt210$reformulator_rules = makeString("reformulator-rules");

	static private final SubLString $str_alt211$Dumping_reformulator_rules___ = makeString(
			"Dumping reformulator rules...");

	static private final SubLString $str_alt213$Loading_reformulator_rules___ = makeString(
			"Loading reformulator rules...");

	static private final SubLString $str_alt214$Dumping_English_units_of_measure_ = makeString(
			"Dumping English units of measure...");

	static private final SubLString $str_alt215$english_units_of_measure = makeString("english-units-of-measure");

	static private final SubLString $str_alt217$Loading_English_units_of_measure_ = makeString(
			"Loading English units of measure...");

	static private final SubLString $str_alt218$Dumping_CAE_query_search_tables__ = makeString(
			"Dumping CAE query search tables...");

	static private final SubLString $str_alt219$cae_query_search_tables = makeString("cae-query-search-tables");

	static private final SubLString $str_alt221$Loading_CAE_Query_Search_Tables__ = makeString(
			"Loading CAE Query Search Tables...");

	static private final SubLString $str_alt222$sbhl_time = makeString("sbhl-time");

	static private final SubLString $str_alt223$Dumping_sbhl_time_state___ = makeString("Dumping sbhl time state...");

	static private final SubLString $str_alt225$Loading_SBHL_time_state___ = makeString("Loading SBHL time state...");

	static private final SubLString $str_alt226$_d_bytes_of_unread_sbhl_time_stat = makeString(
			"~d bytes of unread sbhl time state in ~S");

	static private final SubLString $str_alt227$rtp_rules_cache = makeString("rtp-rules-cache");

	static private final SubLString $str_alt228$Dumping_RTP_rules_cache___ = makeString("Dumping RTP rules cache...");

	static private final SubLString $str_alt229$Loading_RTP_rules_cache___ = makeString("Loading RTP rules cache...");

	static private final SubLString $str_alt230$somewhere_cache = makeString("somewhere-cache");

	static private final SubLString $str_alt231$Dumping_somewhere_rules_cache___ = makeString(
			"Dumping somewhere rules cache...");

	static private final SubLString $str_alt232$Loading_somewhere_cache___ = makeString("Loading somewhere cache...");

	static private final SubLString $str_alt233$arity_cache = makeString("arity-cache");

	static private final SubLString $str_alt234$Dumping_arity_cache___ = makeString("Dumping arity cache...");

	static private final SubLString $str_alt235$Loading_arity_cache___ = makeString("Loading arity cache...");

	static private final SubLString $str_alt236$pph_phrase_count = makeString("pph-phrase-count");

	static private final SubLString $str_alt237$pph_phrase_shell = makeString("pph-phrase-shell");

	static private final SubLString $str_alt238$Dumping_pph_phrase_shells = makeString("Dumping pph-phrase shells");

	static private final SubLString $str_alt239$PPH_phrase__A_indexed_incorrectly = makeString(
			"PPH phrase ~A indexed incorrectly.");

	static private final SubLString $str_alt240$Loading_pph_phrase_shells = makeString("Loading pph-phrase shells");

	static private final SubLString $str_alt241$pph_phrase = makeString("pph-phrase");

	static private final SubLString $str_alt242$pph_phrase_index = makeString("pph-phrase-index");

	static private final SubLString $str_alt243$Dumping_pph_phrase_definitions = makeString(
			"Dumping pph-phrase definitions");

	static private final SubLString $str_alt244$Loading_pph_phrase_definitions = makeString(
			"Loading pph-phrase definitions");

	static private final SubLString $str_alt245$pph_phrase_definitions_out_of_syn = makeString(
			"pph-phrase definitions out of sync on load");

	static private final SubLString $str_alt246$gen_template_store = makeString("gen-template-store");

	static private final SubLString $str_alt247$Dumping___genTemplate_store___ = makeString(
			"Dumping #$genTemplate store...");

	static private final SubLString $str_alt248$Loading___genTemplate_store___ = makeString(
			"Loading #$genTemplate store...");

	static private final SubLString $str_alt249$Initializing_minor_paraphrase_Cyc = makeString(
			"Initializing minor paraphrase CycL structures...");

	static private final SubLString $str_alt250$________Performing_other_KB_dump_ = makeString(
			"~&~%;;; Performing other KB dump activities at ~A~%");

	static private final SubLString $str_alt251$________Performing_KB_initializat = makeString(
			"~&~%;;; Performing KB initializations at ~A~%");

	static private final SubLString $str_alt252$Reformulator___A__ = makeString("Reformulator: ~A~%");

	static private final SubLString $str_alt253$Paraphrase___A__ = makeString("Paraphrase: ~A~%");

	static private final SubLString $str_alt254$Cyc_Task_Scheduler___A__ = makeString("Cyc Task Scheduler: ~A~%");

	static private final SubLString $str_alt255$SKSI___A__ = makeString("SKSI: ~A~%");

	static private final SubLString $str_alt256$Quant___A__ = makeString("Quant: ~A~%");

	static private final SubLString $str_alt257$Date___A__ = makeString("Date: ~A~%");

	static private final SubLString $str_alt258$Time___A__ = makeString("Time: ~A~%");

	static private final SubLString $str_alt259$Lexicon___A__ = makeString("Lexicon: ~A~%");

	static private final SubLString $str_alt260$NL___A__ = makeString("NL: ~A~%");

	static private final SubLString $str_alt261$RTP___A__ = makeString("RTP: ~A~%");

	static private final SubLString $str_alt262$RKF___A__ = makeString("RKF: ~A~%");

	static private final SubLString $str_alt263$Thesaurus___A__ = makeString("Thesaurus: ~A~%");

	static private final SubLString $str_alt264$Wordnet___A__ = makeString("Wordnet: ~A~%");

	static private final SubLString $str_alt265$Planner___A__ = makeString("Planner: ~A~%");

	static private final SubLString $str_alt266$Secure___A__ = makeString("Secure: ~A~%");

	static private final SubLString $str_alt267$modification_report_ = makeString("modification-report-");

	static private final SubLString $str_alt268$stale_documentation_ = makeString("stale-documentation-");

	static private final SubLString $str_alt276$_A_is_not_a__A = makeString("~A is not a ~A");

	static private final SubLString $$$continue_anyway = makeString("continue anyway");

	static private final SubLString $str_alt281$_A_is_not_a_valid__sbhl_type_erro = makeString(
			"~A is not a valid *sbhl-type-error-action* value");

	static private final SubLString $str_alt283$attempting_to_bind_direction_link = makeString(
			"attempting to bind direction link variable, to NIL. macro body not executed.");

	static private final SubLString $str_alt284$Node__a_does_not_pass_sbhl_type_t = makeString(
			"Node ~a does not pass sbhl-type-test ~a~%");

	static private final SubLList $list_alt285 = list(reader_make_constant_shell("CharacterString"),
			reader_make_constant_shell("SubLString"));

	static private final SubLString $str_alt287$Finding_stale_documentation_refer = makeString(
			"Finding stale documentation references");

	static private final SubLString $str_alt289$___System__A_KB__S______A________ = makeString(
			";; System ~A KB ~S~%;; ~A~%;;~%;; Stale documentation references");

	static private final SubLString $str_alt290$_____S_stale_assertions_ = makeString("~%~%~S stale assertions:");

	static private final SubLString $str_alt291$___S_on__S_in__S = makeString("~%~S on ~S in ~S");

	static private final SubLString $str_alt292$___S_in__S_ = makeString("~%~S in ~S ");

	static private final SubLString $str_alt296$_____S_recent_renames_ = makeString("~%~%~S recent renames:");

	static private final SubLString $str_alt297$___S____ = makeString("~%~S -> ");

	static private final SubLString $str_alt298$_S = makeString("~S");

	static private final SubLString $str_alt299$NAT__S = makeString("NAT ~S");

	static private final SubLString $str_alt300$_by__S = makeString(" by ~S");

	static private final SubLString $str_alt301$_on__D__2__0D__2__0D = makeString(" on ~D/~2,'0D/~2,'0D");

	public static SubLObject snapshot_assertion_defs(final SubLObject active_dir, final SubLObject directory_path) {
		return dumper.snapshot_managed_object_simple_index(dumper.SNAPSHOT_ASSERTION_DEFS_INTERNAL, dumper.$$$assertion,
				active_dir, directory_path);
	}

	public static SubLObject snapshot_assertion_defs_internal(final SubLObject active_dir,
			final SubLObject directory_path, SubLObject widen_indexP) {
		if (widen_indexP == UNPROVIDED) {
			widen_indexP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject current;
		final SubLObject datum = current = dumper.replicate_fv_dump_files(dumper.$list334, dumper.$list335,
				list(dumper.get_wide_mark_basename_from_index_basename(dumper.$str330$assertion_index)),
				list(widen_indexP), active_dir, directory_path, cconcatenate(
						dumper.$str336$Copying_assertion_definitions_fro, format_nil.format_nil_a_no_copy(active_dir)));
		SubLObject new_afile = NIL;
		SubLObject new_ifile = NIL;
		SubLObject new_widemark = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list337);
		new_afile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list337);
		new_ifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list337);
		new_widemark = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject bufsize = file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject small_bufsize = file_utilities.$default_small_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject fvector = file_vector.open_file_vector_for_rewrite(new_afile, new_ifile, new_widemark,
					bufsize, small_bufsize, UNPROVIDED);
			try {
				dumper.snapshot_deleted_object_tombstones(fvector, assertion_handles.deleted_assertion_id_iterator(),
						dumper.$str338$Tombstoning_deleted_assertion_def);
				compatibility.set_file_position(file_vector.get_file_vector_data_stream(fvector), $END);
				dumper.snapshot_changed_managed_objects(fvector, dumper.$NO_COMPLEX_FVECTOR,
						assertion_manager.new_muted_assertion_content_iterator(), FIND_ASSERTION_BY_ID,
						dumper.SNAPSHOT_ASSERTION_DEF, dumper.$str342$Updating_changed_assertion_defini);
				if (NIL != assertion_handles.has_new_assertionsP()) {
					file_vector.file_vector_change_stream_buffer_sizes(fvector, bufsize, bufsize);
					dumper.snapshot_new_managed_objects(fvector, assertion_handles.new_new_assertions_iterator(),
							assertion_manager.get_file_backed_assertion_id_threshold(), ASSERTION_ID,
							dumper.DUMP_ASSERTION_DEF, dumper.$str345$Appending_new_assertion_definitio, UNPROVIDED);
				}
				dumper.possibly_persist_wide_fvector_mark(fvector, dumper.$str330$assertion_index, directory_path,
						dumper.$$$assertion_defs);
			} finally {
				final SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					file_vector.close_file_vector(fvector);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
				}
			}
		} else {
			cdestructuring_bind_error(datum, dumper.$list337);
		}
		return NIL;
	}

	public static final SubLObject load_assertion_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject assertion_cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$assertion, directory_path,
						UNPROVIDED);
				SubLObject assertion_index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt108$assertion_index,
						directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(assertion_index_file))) {
					format(T, $str_alt110$__Assertion_definitions_will_be_s, assertion_cfasl_file,
							assertion_index_file);
					initialize_assertion_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(assertion_cfasl_file, UNPROVIDED)) {
						{
							SubLObject assertion_file = assertion_cfasl_file;
							SubLObject filename_var = assertion_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_39 = stream;
									SubLObject total = file_length(stream_39);
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_39);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Loading_assertion_definitions);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_39, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_39,
																NIL, UNPROVIDED)) {
													note_percent_progress(compatibility.get_file_position(stream_39),
															total);
													if (dump_id.isInteger()) {
														com.cyc.cycjava.cycl.dumper.load_assertion_def(dump_id,
																stream_39);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_assertion_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject assertion_cfasl_file = dumper.kb_dump_file(dumper.$$$assertion, directory_path, UNPROVIDED);
		final SubLObject assertion_index_file = dumper.kb_dump_file(dumper.$str330$assertion_index, directory_path,
				UNPROVIDED);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(assertion_index_file))) {
			format(T, dumper.$str346$__Assertion_definitions_will_be_s, assertion_cfasl_file, assertion_index_file);
			assertion_manager.initialize_assertion_hl_store_cache();
			if (NIL != assertion_manager.wide_assertion_hl_store_cacheP()) {
				format(T, dumper.$str347$___Assertion_definitions_use_wide);
			}
		} else if ((NIL != dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != dumper.has_deleted_assertion_id_setP(directory_path))) {
			Errors.error(dumper.$str326$Not_yet_implemented_);
		} else if (NIL != dumper.verify_file_existence(assertion_cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var;
			final SubLObject assertion_file = filename_var = assertion_cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$376 = stream;
				if ($INPUT == $INPUT) {
					stream_$376 = file_utilities.enable_file_stream_memory_mapping(stream_$376);
				}
				try {
					final SubLObject total = file_length(stream_$376);
					dumper.load_copyright(stream_$376);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_assertion_definitions);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$376, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$376, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$376), total);
								if (dump_id.isInteger()) {
									dumper.load_assertion_def(dump_id, stream_$376);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$377 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$377, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$376, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		return NIL;
	}

	public static final SubLObject dump_assertion_def_alt(SubLObject assertion, SubLObject stream) {
		cfasl_output(assertions_high.assertion_dump_id(assertion), stream);
		assertions_low.dump_assertion_content(assertion, stream);
		return assertion;
	}

	public static SubLObject dump_assertion_def(final SubLObject assertion, final SubLObject stream) {
		cfasl_output(assertions_high.assertion_dump_id(assertion), stream);
		assertions_low.dump_assertion_content(assertion, stream);
		return assertion;
	}

	public static SubLObject snapshot_assertion_def(final SubLObject assertion, final SubLObject content,
			final SubLObject data_stream, SubLObject complex_fvector) {
		if (complex_fvector == UNPROVIDED) {
			complex_fvector = NIL;
		}
		return dumper.dump_assertion_def(assertion, data_stream);
	}

	public static final SubLObject load_assertion_def_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject assertion = assertions_high.find_assertion_by_dump_id(dump_id);
			assertions_low.load_assertion_content(assertion, stream);
			return assertion;
		}
	}

	public static SubLObject load_assertion_def(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject assertion = assertions_high.find_assertion_by_dump_id(dump_id);
		assertions_low.load_assertion_content(assertion, stream);
		return assertion;
	}

	public static final SubLObject load_assertion_def_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject assertion = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						assertion = com.cyc.cycjava.cycl.dumper.load_assertion_def(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return assertion;
			}
		}
	}

	public static SubLObject load_assertion_def_from_cache(final SubLObject dump_id, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject assertion = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			assertion = dumper.load_assertion_def(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return assertion;
	}

	public static final SubLObject dump_kb_hl_support_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject kb_hl_support_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt113$kb_hl_support,
						directory_path, UNPROVIDED);
				SubLObject kb_hl_support_index_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt114$kb_hl_support_index, directory_path, UNPROVIDED);
				SubLObject filename_var = kb_hl_support_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_40 = stream;
						SubLObject filename_var_41 = kb_hl_support_index_file;
						SubLObject stream_42 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_42 = compatibility.open_binary(filename_var_41, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_42.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_41);
							}
							{
								SubLObject index_stream = stream_42;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_40);
								{
									SubLObject fvector = create_file_vector(stream_40, index_stream);
									SubLObject idx = kb_hl_supports.do_kb_hl_supports_table();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($$$Dumping_KB_HL_support_definitions, STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Dumping_KB_HL_support_definitions);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
													SubLObject kb_hl_support = NIL;
													while (NIL != id) {
														kb_hl_support = do_id_index_state_object(idx, $SKIP, id,
																state_var);
														if (NIL != do_id_index_id_and_object_validP(id, kb_hl_support,
																$SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															update_file_vector_index_linear(fvector);
															com.cyc.cycjava.cycl.dumper
																	.dump_kb_hl_support_def(kb_hl_support, stream_40);
														}
														id = do_id_index_next_id(idx, T, id, state_var);
														state_var = do_id_index_next_state(idx, T, id, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_42.isStream()) {
										close(stream_42, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_41);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_kb_hl_support_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject kb_hl_support_file = dumper.kb_dump_file(dumper.$str170$kb_hl_support, directory_path,
				UNPROVIDED);
		final SubLObject kb_hl_support_index_file = dumper.kb_dump_file(dumper.$str350$kb_hl_support_index,
				directory_path, UNPROVIDED);
		final SubLObject filename_var = kb_hl_support_file;
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$378 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$378 = file_utilities.enable_file_stream_memory_mapping(stream_$378);
			}
			try {
				final SubLObject filename_var_$379 = kb_hl_support_index_file;
				SubLObject stream_$379 = NIL;
				try {
					final SubLObject _prev_bind_2 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream_$379 = compatibility.open_binary(filename_var_$379, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_2, thread);
					}
					if (!stream_$379.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$379);
					}
					SubLObject index_stream = stream_$379;
					if ($OUTPUT == $INPUT) {
						index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
					}
					try {
						dumper.dump_copyright(stream_$378);
						final SubLObject fvector = file_vector.create_file_vector(stream_$378, index_stream);
						final SubLObject idx = kb_hl_support_handles.do_kb_hl_supports_table();
						final SubLObject mess = dumper.$$$Dumping_KB_HL_support_definitions;
						final SubLObject total = id_index_count(idx);
						SubLObject sofar = ZERO_INTEGER;
						assert NIL != stringp(mess) : "! stringp(mess) "
								+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
						final SubLObject _prev_bind_3 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_4 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_5 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble(mess);
								final SubLObject idx_$381 = idx;
								if (NIL == id_index_objects_empty_p(idx_$381, $SKIP)) {
									final SubLObject idx_$382 = idx_$381;
									if (NIL == id_index_dense_objects_empty_p(idx_$382, $SKIP)) {
										final SubLObject vector_var = id_index_dense_objects(idx_$382);
										final SubLObject backwardP_var = NIL;
										SubLObject length;
										SubLObject v_iteration;
										SubLObject s_id;
										SubLObject s_handle;
										SubLObject kb_hl_support;
										for (length = length(
												vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
														.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
											s_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
													: v_iteration;
											s_handle = aref(vector_var, s_id);
											if ((NIL == id_index_tombstone_p(s_handle))
													|| (NIL == id_index_skip_tombstones_p($SKIP))) {
												if (NIL != id_index_tombstone_p(s_handle)) {
													s_handle = $SKIP;
												}
												kb_hl_support = kb_hl_support_handles
														.resolve_kb_hl_support_id_value_pair(s_id, s_handle);
												file_vector.update_file_vector_index_linear(fvector);
												dumper.dump_kb_hl_support_def(kb_hl_support, stream_$378);
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
										}
									}
									final SubLObject idx_$383 = idx_$381;
									if ((NIL == id_index_sparse_objects_empty_p(idx_$383))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										final SubLObject sparse = id_index_sparse_objects(idx_$383);
										SubLObject s_id2 = id_index_sparse_id_threshold(idx_$383);
										final SubLObject end_id = id_index_next_id(idx_$383);
										final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL
												: $SKIP;
										while (s_id2.numL(end_id)) {
											final SubLObject s_handle2 = gethash_without_values(s_id2, sparse,
													v_default);
											if ((NIL == id_index_skip_tombstones_p($SKIP))
													|| (NIL == id_index_tombstone_p(s_handle2))) {
												final SubLObject kb_hl_support2 = kb_hl_support_handles
														.resolve_kb_hl_support_id_value_pair(s_id2, s_handle2);
												file_vector.update_file_vector_index_linear(fvector);
												dumper.dump_kb_hl_support_def(kb_hl_support2, stream_$378);
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
											s_id2 = add(s_id2, ONE_INTEGER);
										}
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$384 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$384, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_6, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_5, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_4, thread);
							$last_percent_progress_index$.rebind(_prev_bind_3, thread);
						}
					} finally {
						final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							close(index_stream, UNPROVIDED);
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (stream_$379.isStream()) {
							close(stream_$379, UNPROVIDED);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
					}
				}
				dumper.discard_dump_filename(filename_var_$379);
			} finally {
				final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					close(stream_$378, UNPROVIDED);
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static SubLObject snapshot_kb_hl_support_defs(final SubLObject active_dir, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject kb_hl_support_file = dumper.kb_dump_file(dumper.$str170$kb_hl_support, directory_path,
				UNPROVIDED);
		final SubLObject kb_hl_support_index_file = dumper.kb_dump_file(dumper.$str350$kb_hl_support_index,
				directory_path, UNPROVIDED);
		final SubLObject filename_var = kb_hl_support_file;
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$385 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$385 = file_utilities.enable_file_stream_memory_mapping(stream_$385);
			}
			try {
				final SubLObject filename_var_$386 = kb_hl_support_index_file;
				SubLObject stream_$386 = NIL;
				try {
					final SubLObject _prev_bind_2 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream_$386 = compatibility.open_binary(filename_var_$386, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_2, thread);
					}
					if (!stream_$386.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$386);
					}
					SubLObject index_stream = stream_$386;
					if ($OUTPUT == $INPUT) {
						index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
					}
					try {
						dumper.dump_copyright(stream_$385);
						final SubLObject fvector = file_vector.create_file_vector(stream_$385, index_stream);
						SubLObject expected_id = ZERO_INTEGER;
						final SubLObject idx = kb_hl_support_handles.do_kb_hl_supports_table();
						final SubLObject mess = dumper.$$$Dumping_KB_HL_support_definitions;
						final SubLObject total = id_index_count(idx);
						SubLObject sofar = ZERO_INTEGER;
						assert NIL != stringp(mess) : "! stringp(mess) "
								+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
						final SubLObject _prev_bind_3 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_4 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_5 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble(mess);
								final SubLObject idx_$388 = idx;
								if (NIL == id_index_objects_empty_p(idx_$388, $SKIP)) {
									final SubLObject idx_$389 = idx_$388;
									if (NIL == id_index_dense_objects_empty_p(idx_$389, $SKIP)) {
										final SubLObject vector_var = id_index_dense_objects(idx_$389);
										final SubLObject backwardP_var = NIL;
										SubLObject length;
										SubLObject v_iteration;
										SubLObject s_id;
										SubLObject s_handle;
										SubLObject kb_hl_support;
										SubLObject curr_id;
										for (length = length(
												vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
														.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
											s_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
													: v_iteration;
											s_handle = aref(vector_var, s_id);
											if ((NIL == id_index_tombstone_p(s_handle))
													|| (NIL == id_index_skip_tombstones_p($SKIP))) {
												if (NIL != id_index_tombstone_p(s_handle)) {
													s_handle = $SKIP;
												}
												kb_hl_support = kb_hl_support_handles
														.resolve_kb_hl_support_id_value_pair(s_id, s_handle);
												for (curr_id = kb_hl_supports_high
														.kb_hl_support_dump_id(kb_hl_support); expected_id.numL(
																curr_id); expected_id = add(expected_id, ONE_INTEGER)) {
													file_vector.place_file_vector_index_tombstone(fvector);
												}
												file_vector.update_file_vector_index_linear(fvector);
												dumper.dump_kb_hl_support_def(kb_hl_support, stream_$385);
												expected_id = add(ONE_INTEGER, curr_id);
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
										}
									}
									final SubLObject idx_$390 = idx_$388;
									if ((NIL == id_index_sparse_objects_empty_p(idx_$390))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										final SubLObject sparse = id_index_sparse_objects(idx_$390);
										SubLObject s_id2 = id_index_sparse_id_threshold(idx_$390);
										final SubLObject end_id = id_index_next_id(idx_$390);
										final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL
												: $SKIP;
										while (s_id2.numL(end_id)) {
											final SubLObject s_handle2 = gethash_without_values(s_id2, sparse,
													v_default);
											if ((NIL == id_index_skip_tombstones_p($SKIP))
													|| (NIL == id_index_tombstone_p(s_handle2))) {
												final SubLObject kb_hl_support2 = kb_hl_support_handles
														.resolve_kb_hl_support_id_value_pair(s_id2, s_handle2);
												SubLObject curr_id2;
												for (curr_id2 = kb_hl_supports_high
														.kb_hl_support_dump_id(kb_hl_support2); expected_id
																.numL(curr_id2); expected_id = add(expected_id,
																		ONE_INTEGER)) {
													file_vector.place_file_vector_index_tombstone(fvector);
												}
												file_vector.update_file_vector_index_linear(fvector);
												dumper.dump_kb_hl_support_def(kb_hl_support2, stream_$385);
												expected_id = add(ONE_INTEGER, curr_id2);
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
											s_id2 = add(s_id2, ONE_INTEGER);
										}
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$391 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$391, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_6, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_5, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_4, thread);
							$last_percent_progress_index$.rebind(_prev_bind_3, thread);
						}
					} finally {
						final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							close(index_stream, UNPROVIDED);
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (stream_$386.isStream()) {
							close(stream_$386, UNPROVIDED);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
					}
				}
				dumper.discard_dump_filename(filename_var_$386);
			} finally {
				final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					close(stream_$385, UNPROVIDED);
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_kb_hl_support_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt113$kb_hl_support,
						directory_path, UNPROVIDED);
				SubLObject index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt114$kb_hl_support_index,
						directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(index_file))) {
					format(T, $str_alt116$__KB_HL_supports_will_be_swapped_, cfasl_file, index_file);
					initialize_kb_hl_support_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
						{
							SubLObject filename_var = cfasl_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_43 = stream;
									SubLObject total = kb_hl_supports.kb_hl_support_count();
									SubLObject sofar = ZERO_INTEGER;
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_43);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Loading_KB_HL_support_definitions);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_43, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_43,
																NIL, UNPROVIDED)) {
													sofar = add(sofar, ONE_INTEGER);
													note_percent_progress(sofar, total);
													if (dump_id.isInteger()) {
														com.cyc.cycjava.cycl.dumper.load_kb_hl_support_def(dump_id,
																stream_43);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_kb_hl_support_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str170$kb_hl_support, directory_path, UNPROVIDED);
		final SubLObject index_file = dumper.kb_dump_file(dumper.$str350$kb_hl_support_index, directory_path,
				UNPROVIDED);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(index_file))) {
			format(T, dumper.$str352$__KB_HL_supports_will_be_swapped_, cfasl_file, index_file);
			kb_hl_support_manager.initialize_kb_hl_support_hl_store_cache();
		} else if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$392 = stream;
				if ($INPUT == $INPUT) {
					stream_$392 = file_utilities.enable_file_stream_memory_mapping(stream_$392);
				}
				try {
					final SubLObject total = kb_hl_support_handles.kb_hl_support_count();
					SubLObject sofar = ZERO_INTEGER;
					dumper.load_copyright(stream_$392);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_KB_HL_support_definitions);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$392, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$392, NIL, UNPROVIDED)) {
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
								if (dump_id.isInteger()) {
									dumper.load_kb_hl_support_def(dump_id, stream_$392);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$393 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$393, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$392, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		return NIL;
	}

	public static final SubLObject dump_kb_hl_support_def_alt(SubLObject kb_hl_support, SubLObject stream) {
		cfasl_output(kb_hl_supports.kb_hl_support_dump_id(kb_hl_support), stream);
		return kb_hl_supports.dump_kb_hl_support_content(kb_hl_support, stream);
	}

	public static SubLObject dump_kb_hl_support_def(final SubLObject kb_hl_support, final SubLObject stream) {
		cfasl_output(kb_hl_supports_high.kb_hl_support_dump_id(kb_hl_support), stream);
		return kb_hl_supports_low.dump_kb_hl_support_content(kb_hl_support, stream);
	}

	public static final SubLObject load_kb_hl_support_def_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject kb_hl_support = kb_hl_supports.find_kb_hl_support_by_dump_id(dump_id);
			kb_hl_supports.load_kb_hl_support_content(kb_hl_support, stream);
			return kb_hl_support;
		}
	}

	public static SubLObject load_kb_hl_support_def(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject kb_hl_support = kb_hl_supports_high.find_kb_hl_support_by_dump_id(dump_id);
		kb_hl_supports_low.load_kb_hl_support_content(kb_hl_support, stream);
		return kb_hl_support;
	}

	public static final SubLObject load_kb_hl_support_def_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject index = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						index = com.cyc.cycjava.cycl.dumper.load_kb_hl_support_def(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return index;
			}
		}
	}

	public static SubLObject load_kb_hl_support_def_from_cache(final SubLObject dump_id, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			index = dumper.load_kb_hl_support_def(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return index;
	}

	public static final SubLObject dump_kb_hl_support_indexing_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt119$kb_hl_support_indexing,
						directory_path, UNPROVIDED);
				{
					SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
					try {
						$noting_progress_start_time$.bind(get_universal_time(), thread);
						noting_progress_preamble($str_alt120$Dumping_KB_HL_support_indexing___);
						kb_hl_supports.dump_kb_hl_support_indexing_int(index_file);
						noting_progress_postamble();
					} finally {
						$noting_progress_start_time$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_kb_hl_support_indexing(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject index_file = dumper.kb_dump_file(dumper.$str355$kb_hl_support_indexing, directory_path,
					UNPROVIDED);
			final SubLObject str = dumper.$str356$Dumping_KB_HL_support_indexing___;
			final SubLObject _prev_bind_0_$394 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_1_$395 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				kb_hl_supports_high.dump_kb_hl_support_indexing_int(index_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_1_$395, thread);
				$progress_start_time$.rebind(_prev_bind_0_$394, thread);
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_kb_hl_support_indexing_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt119$kb_hl_support_indexing,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(index_file, T)) {
					{
						SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
						try {
							$noting_progress_start_time$.bind(get_universal_time(), thread);
							noting_progress_preamble($str_alt121$Loading_KB_HL_support_indexing___);
							kb_hl_supports.load_kb_hl_support_indexing_int(index_file);
							noting_progress_postamble();
						} finally {
							$noting_progress_start_time$.rebind(_prev_bind_0, thread);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_kb_hl_support_indexing(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject index_file = dumper.kb_dump_file(dumper.$str355$kb_hl_support_indexing, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(index_file, T)) {
			final SubLObject str = dumper.$str357$Loading_KB_HL_support_indexing___;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				kb_hl_supports_high.load_kb_hl_support_indexing_int(index_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_bookkeeping_assertions_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt122$bookkeeping_assertions,
						directory_path, UNPROVIDED);
				{
					SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
					try {
						$noting_progress_start_time$.bind(get_universal_time(), thread);
						noting_progress_preamble($str_alt123$Dumping_bookkeeping_assertions___);
						{
							SubLObject filename_var = cfasl_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0_44 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_44, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_45 = stream;
									com.cyc.cycjava.cycl.dumper.dump_copyright(stream_45);
									cfasl_output(dumper_num_top_level_index(), stream_45);
									{
										SubLObject cdolist_list_var = dumper_bookkeeping_binary_gaf_store();
										SubLObject cons = NIL;
										for (cons = cdolist_list_var
												.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
														.rest(), cons = cdolist_list_var.first()) {
											{
												SubLObject datum = cons;
												SubLObject current = datum;
												SubLObject pred = NIL;
												SubLObject subindex = NIL;
												destructuring_bind_must_consp(current, datum, $list_alt124);
												pred = current.first();
												current = current.rest();
												subindex = current;
												com.cyc.cycjava.cycl.dumper.dump_bookkeeping_assertions_for_pred(pred,
														subindex, stream_45);
											}
										}
									}
									cfasl_output(NIL, stream_45);
									cfasl_output(NIL, stream_45);
									cfasl_output(NIL, stream_45);
								}
							} finally {
								{
									SubLObject _prev_bind_0_46 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_46, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
						noting_progress_postamble();
					} finally {
						$noting_progress_start_time$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_bookkeeping_assertions(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str358$bookkeeping_assertions, directory_path,
				UNPROVIDED);
		final SubLObject str = dumper.$str359$Dumping_bookkeeping_assertions___;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$396 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$396, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$397 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$397 = file_utilities.enable_file_stream_memory_mapping(stream_$397);
				}
				try {
					dumper.dump_copyright(stream_$397);
					cfasl_output(bookkeeping_store.dumper_num_top_level_index(), stream_$397);
					SubLObject cdolist_list_var = bookkeeping_store.dumper_bookkeeping_binary_gaf_store();
					SubLObject cons = NIL;
					cons = cdolist_list_var.first();
					while (NIL != cdolist_list_var) {
						SubLObject current;
						final SubLObject datum = current = cons;
						SubLObject pred = NIL;
						SubLObject subindex = NIL;
						destructuring_bind_must_consp(current, datum, dumper.$list360);
						pred = current.first();
						current = subindex = current.rest();
						dumper.dump_bookkeeping_assertions_for_pred(pred, subindex, stream_$397);
						cdolist_list_var = cdolist_list_var.rest();
						cons = cdolist_list_var.first();
					}
					cfasl_output(NIL, stream_$397);
					cfasl_output(NIL, stream_$397);
					cfasl_output(NIL, stream_$397);
				} finally {
					final SubLObject _prev_bind_0_$397 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$397, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$397, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$398 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$398, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_bookkeeping_assertions_for_pred_alt(SubLObject pred, SubLObject subindex,
			SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			cfasl_output(pred, stream);
			cfasl_output(dumper_num_intermediate_index(subindex), stream);
			{
				SubLObject iteration_state = dictionary_contents
						.do_dictionary_contents_state(dictionary.dictionary_contents(subindex));
				while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
					thread.resetMultipleValues();
					{
						SubLObject arg1 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
						SubLObject arg2 = thread.secondMultipleValue();
						thread.resetMultipleValues();
						com.cyc.cycjava.cycl.dumper.dump_bookkeeping_assertion(arg1, arg2, stream);
						iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
					}
				}
				dictionary_contents.do_dictionary_contents_finalize(iteration_state);
			}
			return NIL;
		}
	}

	public static SubLObject dump_bookkeeping_assertions_for_pred(final SubLObject pred, final SubLObject subindex,
			final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		cfasl_output(pred, stream);
		cfasl_output(bookkeeping_store.dumper_num_intermediate_index(subindex), stream);
		SubLObject iteration_state;
		for (iteration_state = dictionary_contents
				.do_dictionary_contents_state(dictionary.dictionary_contents(subindex)); NIL == dictionary_contents
						.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents
								.do_dictionary_contents_next(iteration_state)) {
			thread.resetMultipleValues();
			final SubLObject arg1 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
			final SubLObject arg2 = thread.secondMultipleValue();
			thread.resetMultipleValues();
			dumper.dump_bookkeeping_assertion(arg1, arg2, stream);
		}
		dictionary_contents.do_dictionary_contents_finalize(iteration_state);
		return NIL;
	}

	public static final SubLObject dump_bookkeeping_assertion_alt(SubLObject arg1, SubLObject arg2, SubLObject stream) {
		cfasl_output(arg1, stream);
		cfasl_output(arg2, stream);
		return NIL;
	}

	public static SubLObject dump_bookkeeping_assertion(final SubLObject arg1, final SubLObject arg2,
			final SubLObject stream) {
		cfasl_output(arg1, stream);
		cfasl_output(arg2, stream);
		return NIL;
	}

	public static final SubLObject load_bookkeeping_assertions_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt122$bookkeeping_assertions,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
						try {
							$noting_progress_start_time$.bind(get_universal_time(), thread);
							noting_progress_preamble($str_alt125$Loading_bookkeeping_assertions___);
							{
								SubLObject filename_var = cfasl_file;
								SubLObject stream = NIL;
								try {
									{
										SubLObject _prev_bind_0_47 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream = compatibility.open_binary(filename_var, $INPUT, NIL);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_47, thread);
										}
									}
									if (!stream.isStream()) {
										Errors.error($str_alt65$Unable_to_open__S, filename_var);
									}
									{
										SubLObject stream_48 = stream;
										SubLObject total = file_length(stream_48);
										com.cyc.cycjava.cycl.dumper.load_copyright(stream_48);
										dumper_clear_bookkeeping_binary_gaf_store();
										{
											SubLObject num_bookkeeping_preds = cfasl_input(stream_48, UNPROVIDED,
													UNPROVIDED);
											SubLObject n = NIL;
											for (n = ZERO_INTEGER; n
													.numL(num_bookkeeping_preds); n = add(n, ONE_INTEGER)) {
												com.cyc.cycjava.cycl.dumper
														.load_bookkeeping_assertions_for_pred(stream_48);
											}
										}
										cfasl_input(stream_48, UNPROVIDED, UNPROVIDED);
										cfasl_input(stream_48, UNPROVIDED, UNPROVIDED);
										cfasl_input(stream_48, UNPROVIDED, UNPROVIDED);
										if (cfasl_input(stream_48, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_48)),
													cfasl_file);
										}
									}
								} finally {
									{
										SubLObject _prev_bind_0_49 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											if (stream.isStream()) {
												close(stream, UNPROVIDED);
											}
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_49, thread);
										}
									}
								}
								com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
							}
							noting_progress_postamble();
						} finally {
							$noting_progress_start_time$.rebind(_prev_bind_0, thread);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_bookkeeping_assertions(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str358$bookkeeping_assertions, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject str = dumper.$str361$Loading_bookkeeping_assertions___;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				final SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$400 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $INPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$400, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$401 = stream;
					if ($INPUT == $INPUT) {
						stream_$401 = file_utilities.enable_file_stream_memory_mapping(stream_$401);
					}
					try {
						final SubLObject total = file_length(stream_$401);
						dumper.load_copyright(stream_$401);
						bookkeeping_store.dumper_clear_bookkeeping_binary_gaf_store();
						SubLObject num_bookkeeping_preds;
						SubLObject n;
						for (num_bookkeeping_preds = cfasl_input(stream_$401, UNPROVIDED,
								UNPROVIDED), n = NIL, n = ZERO_INTEGER; n
										.numL(num_bookkeeping_preds); n = add(n, ONE_INTEGER)) {
							dumper.load_bookkeeping_assertions_for_pred(stream_$401);
						}
						cfasl_input(stream_$401, UNPROVIDED, UNPROVIDED);
						cfasl_input(stream_$401, UNPROVIDED, UNPROVIDED);
						cfasl_input(stream_$401, UNPROVIDED, UNPROVIDED);
						if (cfasl_input(stream_$401, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$401)), cfasl_file);
						}
					} finally {
						final SubLObject _prev_bind_0_$401 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$401, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$401, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$402 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$402, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject load_bookkeeping_assertions_for_pred_alt(SubLObject stream) {
		{
			SubLObject pred = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			SubLObject num_assertions = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			SubLObject i = NIL;
			for (i = ZERO_INTEGER; i.numL(num_assertions); i = add(i, ONE_INTEGER)) {
				com.cyc.cycjava.cycl.dumper.load_bookkeeping_assertion(pred, stream);
			}
		}
		return NIL;
	}

	public static SubLObject load_bookkeeping_assertions_for_pred(final SubLObject stream) {
		final SubLObject pred = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		SubLObject num_assertions;
		SubLObject i;
		for (num_assertions = cfasl_input(stream, UNPROVIDED, UNPROVIDED), i = NIL, i = ZERO_INTEGER; i
				.numL(num_assertions); i = add(i, ONE_INTEGER)) {
			dumper.load_bookkeeping_assertion(pred, stream);
		}
		return NIL;
	}

	public static final SubLObject load_bookkeeping_assertion_alt(SubLObject pred, SubLObject stream) {
		{
			SubLObject arg1 = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			SubLObject arg2 = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			dumper_load_bookkeeping_binary_gaf(pred, arg1, arg2);
		}
		return NIL;
	}

	public static SubLObject load_bookkeeping_assertion(final SubLObject pred, final SubLObject stream) {
		final SubLObject arg1 = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		final SubLObject arg2 = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		bookkeeping_store.dumper_load_bookkeeping_binary_gaf(pred, arg1, arg2);
		return NIL;
	}

	/**
	 * Assumes that the already-loaded experience is what we want to dump out.
	 */
	@LispMethod(comment = "Assumes that the already-loaded experience is what we want to dump out.")
	public static final SubLObject dump_experience(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
				try {
					$noting_progress_start_time$.bind(get_universal_time(), thread);
					noting_progress_preamble($str_alt126$Dumping_rule_utility_experience__);
					com.cyc.cycjava.cycl.dumper.dump_rule_utility_experience(directory_path, UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$noting_progress_start_time$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_experience(final SubLObject directory_path, SubLObject internalP) {
		if (internalP == UNPROVIDED) {
			internalP = T;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject str = dumper.$str362$Dumping_rule_utility_experience__;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			dumper.dump_rule_utility_experience(directory_path, internalP);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_rule_utility_experience_alt(SubLObject directory_path, SubLObject internalP) {
		if (internalP == UNPROVIDED) {
			internalP = T;
		}
		{
			SubLObject experience_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt30$rule_utility_experience,
					directory_path, UNPROVIDED);
			inference_analysis.save_transformation_rule_statistics(experience_file, internalP);
		}
		return NIL;
	}

	public static SubLObject dump_rule_utility_experience(final SubLObject directory_path, SubLObject internalP) {
		if (internalP == UNPROVIDED) {
			internalP = T;
		}
		final SubLObject experience_file = dumper.kb_dump_file(dumper.$str41$rule_utility_experience, directory_path,
				UNPROVIDED);
		inference_analysis.save_transformation_rule_statistics(experience_file, internalP);
		return NIL;
	}

	public static final SubLObject load_experience_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
				try {
					$noting_progress_start_time$.bind(get_universal_time(), thread);
					noting_progress_preamble($str_alt127$Loading_rule_utility_experience__);
					com.cyc.cycjava.cycl.dumper.load_rule_utility_experience(directory_path);
					noting_progress_postamble();
				} finally {
					$noting_progress_start_time$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_experience(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject str = dumper.$str363$Loading_rule_utility_experience__;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			dumper.load_rule_utility_experience(directory_path);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_rule_utility_experience_alt(SubLObject directory_path) {
		{
			SubLObject experience_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt30$rule_utility_experience,
					directory_path, UNPROVIDED);
			if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(experience_file, T)) {
				inference_analysis.load_transformation_rule_statistics(experience_file, NIL);
			}
		}
		return NIL;
	}

	public static SubLObject load_rule_utility_experience(final SubLObject directory_path) {
		final SubLObject experience_file = dumper.kb_dump_file(dumper.$str41$rule_utility_experience, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(experience_file, T)) {
			inference_analysis.load_transformation_rule_statistics(experience_file, NIL, UNPROVIDED);
		}
		return NIL;
	}

	/**
	 * Reset experience to the state present in the dump DIRECTORY-PATH
	 */
	@LispMethod(comment = "Reset experience to the state present in the dump DIRECTORY-PATH")
	public static final SubLObject reload_experience_alt(SubLObject directory_path) {
		if (directory_path == UNPROVIDED) {
			directory_path = com.cyc.cycjava.cycl.dumper.kb_dump_directory(kb_loaded(), UNPROVIDED);
		}
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject result = NIL;
				SubLObject common_symbols = com.cyc.cycjava.cycl.dumper.load_special_objects(directory_path);
				{
					SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
					try {
						$cfasl_common_symbols$.bind(NIL, thread);
						cfasl_set_common_symbols(common_symbols);
						{
							SubLObject _prev_bind_0_50 = api_control_vars.$cfasl_constant_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_1 = api_control_vars.$cfasl_nart_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_2 = api_control_vars.$cfasl_assertion_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_3 = api_control_vars.$cfasl_deduction_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_4 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_5 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
									.currentBinding(thread);
							SubLObject _prev_bind_6 = $structure_resourcing_make_static$.currentBinding(thread);
							SubLObject _prev_bind_7 = $cfasl_input_to_static_area$.currentBinding(thread);
							try {
								api_control_vars.$cfasl_constant_handle_lookup_func$.bind(FIND_CONSTANT_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_nart_handle_lookup_func$.bind(FIND_NART_BY_DUMP_ID, thread);
								api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(FIND_ASSERTION_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(FIND_DEDUCTION_BY_DUMP_ID,
										thread);
								api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
										.bind(FIND_KB_HL_SUPPORT_BY_DUMP_ID, thread);
								api_control_vars.$cfasl_clause_struc_handle_lookup_func$
										.bind(FIND_CLAUSE_STRUC_BY_DUMP_ID, thread);
								$structure_resourcing_make_static$.bind(T, thread);
								$cfasl_input_to_static_area$.bind(T, thread);
								result = com.cyc.cycjava.cycl.dumper.load_experience(directory_path);
							} finally {
								$cfasl_input_to_static_area$.rebind(_prev_bind_7, thread);
								$structure_resourcing_make_static$.rebind(_prev_bind_6, thread);
								api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_5, thread);
								api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_4, thread);
								api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_3, thread);
								api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_2, thread);
								api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_1, thread);
								api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_50, thread);
							}
						}
					} finally {
						$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
					}
				}
				return result;
			}
		}
	}

	/**
	 * Reset experience to the state present in the dump DIRECTORY-PATH
	 */
	@LispMethod(comment = "Reset experience to the state present in the dump DIRECTORY-PATH")
	public static SubLObject reload_experience(SubLObject directory_path) {
		if (directory_path == UNPROVIDED) {
			directory_path = dumper.kb_dump_directory(kb_loaded(), UNPROVIDED);
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		final SubLObject common_symbols = dumper.load_special_objects(directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(common_symbols);
			final SubLObject _prev_bind_0_$404 = api_control_vars.$cfasl_constant_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_2 = api_control_vars.$cfasl_nart_handle_lookup_func$.currentBinding(thread);
			final SubLObject _prev_bind_3 = api_control_vars.$cfasl_assertion_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_4 = api_control_vars.$cfasl_deduction_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_5 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_6 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_7 = $structure_resourcing_make_static$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $cfasl_input_to_static_area$.currentBinding(thread);
			try {
				api_control_vars.$cfasl_constant_handle_lookup_func$.bind(dumper.FIND_CONSTANT_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.bind(dumper.FIND_NART_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(dumper.FIND_ASSERTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(dumper.FIND_DEDUCTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.bind(dumper.FIND_KB_HL_SUPPORT_BY_DUMP_ID,
						thread);
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.bind(dumper.FIND_CLAUSE_STRUC_BY_DUMP_ID,
						thread);
				$structure_resourcing_make_static$.bind(T, thread);
				$cfasl_input_to_static_area$.bind(T, thread);
				result = dumper.load_experience(directory_path);
			} finally {
				$cfasl_input_to_static_area$.rebind(_prev_bind_8, thread);
				$structure_resourcing_make_static$.rebind(_prev_bind_7, thread);
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_6, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_5, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_4, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_3, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_2, thread);
				api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_$404, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return result;
	}

	public static SubLObject new_niniveh_index_iterator(final SubLObject filename, final SubLObject dir_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject index_file = dumper.kb_dump_file(filename, dir_path, UNPROVIDED);
		SubLObject stream = NIL;
		if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread)) && (NIL == Filesys.probe_file(index_file))) {
			Errors.error(dumper.$str364$Cannot_locate__A_, index_file);
		}
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			stream = compatibility.open_binary(index_file, $INPUT);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		if ((NIL == Errors.$ignore_mustsP$.getDynamicValue(thread))
				&& (NIL == list_utilities.sublisp_boolean(stream))) {
			Errors.error(dumper.$str365$Cannot_open__A_for_reading___, index_file);
		}
		dumper.load_copyright(stream);
		return iteration.new_iterator(dumper.construct_niniveh_iterator_state(stream),
				dumper.$sym366$NINIVEH_INDEX_ITERATOR_DONE_, dumper.NINIVEH_INDEX_ITERATOR_NEXT,
				dumper.NINIVEH_INDEX_ITERATOR_FINALIZE);
	}

	public static SubLObject construct_niniveh_iterator_state(final SubLObject stream) {
		return list(stream, NIL, cons($STUB, $STUB));
	}

	public static SubLObject niniveh_index_iterator_doneP(final SubLObject state) {
		SubLObject stream = NIL;
		SubLObject doneP = NIL;
		SubLObject cons_cell = NIL;
		destructuring_bind_must_consp(state, state, dumper.$list370);
		stream = state.first();
		SubLObject current = state.rest();
		destructuring_bind_must_consp(current, state, dumper.$list370);
		doneP = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, state, dumper.$list370);
		cons_cell = current.first();
		current = current.rest();
		if (NIL == current) {
			return doneP;
		}
		cdestructuring_bind_error(state, dumper.$list370);
		return NIL;
	}

	public static SubLObject niniveh_index_iterator_next(final SubLObject state) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject stream = NIL;
		SubLObject doneP = NIL;
		SubLObject cons_cell = NIL;
		destructuring_bind_must_consp(state, state, dumper.$list370);
		stream = state.first();
		SubLObject current = state.rest();
		destructuring_bind_must_consp(current, state, dumper.$list370);
		doneP = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, state, dumper.$list370);
		cons_cell = current.first();
		current = current.rest();
		if (NIL == current) {
			SubLObject dump_id = NIL;
			SubLObject valid_dump_idP = NIL;
			SubLObject index = NIL;
			final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
			try {
				$cfasl_common_symbols$.bind(NIL, thread);
				cfasl_set_common_symbols(misc_utilities.get_hl_store_caches_shared_symbols());
				dump_id = cfasl_input(stream, NIL, $EOF);
				valid_dump_idP = makeBoolean(dump_id != $EOF);
				index = (NIL != valid_dump_idP) ? cfasl_input(stream, NIL, $EOF) : NIL;
				rplaca(cons_cell, dump_id);
				rplacd(cons_cell, index);
			} finally {
				$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
			}
			if (NIL == valid_dump_idP) {
				set_nth(ONE_INTEGER, state, T);
				doneP = T;
			}
			return values(cons_cell, state, doneP);
		}
		cdestructuring_bind_error(state, dumper.$list370);
		return NIL;
	}

	public static SubLObject niniveh_index_iterator_finalize(final SubLObject state) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject stream = NIL;
		SubLObject cache_load_fn = NIL;
		SubLObject doneP = NIL;
		destructuring_bind_must_consp(state, state, dumper.$list371);
		stream = state.first();
		SubLObject current = state.rest();
		destructuring_bind_must_consp(current, state, dumper.$list371);
		cache_load_fn = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, state, dumper.$list371);
		doneP = current.first();
		current = current.rest();
		if (NIL == current) {
			if (NIL != open_stream_p(stream)) {
				SubLObject ignore_errors_tag = NIL;
				try {
					thread.throwStack.push(dumper.$IGNORE_ERRORS_TARGET);
					final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
					try {
						Errors.$error_handler$.bind(symbol_function(dumper.IGNORE_ERRORS_HANDLER), thread);
						try {
							close(stream, UNPROVIDED);
						} catch (final Throwable catch_var) {
							Errors.handleThrowable(catch_var, NIL);
						}
					} finally {
						Errors.$error_handler$.rebind(_prev_bind_0, thread);
					}
				} catch (final Throwable ccatch_env_var) {
					ignore_errors_tag = Errors.handleThrowable(ccatch_env_var, dumper.$IGNORE_ERRORS_TARGET);
				} finally {
					thread.throwStack.pop();
				}
			}
			return cache_load_fn;
		}
		cdestructuring_bind_error(state, dumper.$list371);
		return NIL;
	}

	public static final SubLObject dump_kb_indexing_alt(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.dump_constant_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_nart_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_unrepresented_term_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_assertion_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_auxiliary_indices_file(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_bookkeeping_indices_file(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_kb_hl_support_indexing(directory_path);
		return NIL;
	}

	public static SubLObject dump_kb_indexing(final SubLObject directory_path) {
		dumper.dump_constant_indices(directory_path);
		dumper.dump_nart_indices(directory_path);
		dumper.dump_unrepresented_term_indices(directory_path);
		dumper.dump_assertion_indices(directory_path);
		dumper.dump_auxiliary_indices_file(directory_path);
		dumper.dump_bookkeeping_indices_file(directory_path);
		dumper.dump_kb_hl_support_indexing(directory_path);
		return NIL;
	}

	public static SubLObject snapshot_kb_indexing(final SubLObject active_dir, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($CONSTANT_INDEX, thread);
			dumper.snapshot_constant_indices(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($NART_INDEX, thread);
			dumper.snapshot_nart_indices(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind(dumper.$UNREPRESENTED_TERM_INDEX, thread);
			dumper.snapshot_unrepresented_term_indices(active_dir, directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($ASSERTION_INDEX, thread);
			dumper.dump_assertion_indices(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($AUXILIARY_INDEX, thread);
			dumper.dump_auxiliary_indices_file(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($BOOKKEEPPING_INDEX, thread);
			dumper.dump_bookkeeping_indices_file(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind(dumper.$KB_HL_SUPPORT_INDEX, thread);
			dumper.dump_kb_hl_support_indexing(directory_path);
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_kb_indexing_alt(SubLObject directory_path) {
		com.cyc.cycjava.cycl.dumper.load_constant_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		com.cyc.cycjava.cycl.dumper.load_nart_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		com.cyc.cycjava.cycl.dumper.load_unrepresented_term_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		com.cyc.cycjava.cycl.dumper.load_assertion_indices(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		com.cyc.cycjava.cycl.dumper.load_auxiliary_indices_file(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		com.cyc.cycjava.cycl.dumper.load_bookkeeping_indices_file(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		com.cyc.cycjava.cycl.dumper.load_kb_hl_support_indexing(directory_path);
		com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
		return NIL;
	}

	public static SubLObject load_kb_indexing(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		dumper.load_kb_assertion_indexing(directory_path);
		SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($BOOKKEEPPING_INDEX, thread);
			dumper.load_bookkeeping_indices_file(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind(dumper.$KB_HL_SUPPORT_INDEX, thread);
			dumper.load_kb_hl_support_indexing(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject load_kb_assertion_indexing(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject _prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($CONSTANT_INDEX, thread);
			dumper.load_constant_indices(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($NART_INDEX, thread);
			dumper.load_nart_indices(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind(dumper.$UNREPRESENTED_TERM_INDEX, thread);
			dumper.load_unrepresented_term_indices(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($ASSERTION_INDEX, thread);
			dumper.load_assertion_indices(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		_prev_bind_0 = kb_health_statistics.$kb_health_current_sub_context$.currentBinding(thread);
		try {
			kb_health_statistics.$kb_health_current_sub_context$.bind($AUXILIARY_INDEX, thread);
			dumper.load_auxiliary_indices_file(directory_path);
			dumper.kb_load_gc_checkpoint();
		} finally {
			kb_health_statistics.$kb_health_current_sub_context$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject rebuild_kb_indexing_alt() {
		reindex_all_assertions();
		perform_indexing_pre_dump_cleanup();
		reindex_all_bookkeeping_assertions();
		kb_hl_supports.reindex_all_kb_hl_supports();
		return NIL;
	}

	public static SubLObject rebuild_kb_indexing() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$405 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$406 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$405);
			final SubLObject memory_mappedP_$407 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$405);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$405);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$405);
				final SubLObject manager_$406 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$407 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$406);
				final SubLObject memory_mappedP_$408 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$406);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$406);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$406);
					final SubLObject manager_$407 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$408 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$407);
					final SubLObject memory_mappedP_$409 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$407);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$407);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$407);
						final SubLObject manager_$408 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$409 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$408);
						final SubLObject memory_mappedP_$410 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$408);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$408);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$408);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								kb_indexing.reindex_all_assertions();
								kb_indexing.perform_indexing_pre_dump_cleanup();
								bookkeeping_store.reindex_all_bookkeeping_assertions();
								kb_hl_supports_low.reindex_all_kb_hl_supports();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$409) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$408);
								}
								if (NIL == memory_mappedP_$410) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$408,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$408) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$407);
							}
							if (NIL == memory_mappedP_$409) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$407,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$407) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$406);
						}
						if (NIL == memory_mappedP_$408) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$406,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$406) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$405);
					}
					if (NIL == memory_mappedP_$407) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$405, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject test_dump_kb_indexing_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
				try {
					$cfasl_common_symbols$.bind(NIL, thread);
					cfasl_set_common_symbols(com.cyc.cycjava.cycl.dumper.kb_dump_common_symbols());
					com.cyc.cycjava.cycl.dumper.dump_kb_indexing(directory_path);
				} finally {
					$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject test_dump_kb_indexing(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(dumper.kb_dump_common_symbols());
			dumper.dump_kb_indexing(directory_path);
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject test_load_kb_indexing_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
				try {
					$cfasl_common_symbols$.bind(NIL, thread);
					cfasl_set_common_symbols(com.cyc.cycjava.cycl.dumper.kb_dump_common_symbols());
					{
						SubLObject _prev_bind_0_51 = $structure_resourcing_make_static$.currentBinding(thread);
						SubLObject _prev_bind_1 = $cfasl_input_to_static_area$.currentBinding(thread);
						try {
							$structure_resourcing_make_static$.bind(T, thread);
							$cfasl_input_to_static_area$.bind(T, thread);
							com.cyc.cycjava.cycl.dumper.load_kb_indexing(directory_path);
						} finally {
							$cfasl_input_to_static_area$.rebind(_prev_bind_1, thread);
							$structure_resourcing_make_static$.rebind(_prev_bind_0_51, thread);
						}
					}
				} finally {
					$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject test_load_kb_indexing(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(dumper.kb_dump_common_symbols());
			final SubLObject _prev_bind_0_$417 = $structure_resourcing_make_static$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $cfasl_input_to_static_area$.currentBinding(thread);
			try {
				$structure_resourcing_make_static$.bind(T, thread);
				$cfasl_input_to_static_area$.bind(T, thread);
				dumper.load_kb_indexing(directory_path);
			} finally {
				$cfasl_input_to_static_area$.rebind(_prev_bind_2, thread);
				$structure_resourcing_make_static$.rebind(_prev_bind_0_$417, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject index_writer_print_function_trampoline(final SubLObject v_object,
			final SubLObject stream) {
		compatibility.default_struct_print_function(v_object, stream, ZERO_INTEGER);
		return NIL;
	}

	public static SubLObject index_writer_p(final SubLObject v_object) {
		return v_object.getClass() == dumper.$index_writer_native.class ? T : NIL;
	}

	public static SubLObject idxwriter_directory(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField2();
	}

	public static SubLObject idxwriter_fvector(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField3();
	}

	public static SubLObject idxwriter_index_file(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField4();
	}

	public static SubLObject idxwriter_index_label(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField5();
	}

	public static SubLObject idxwriter_complex_fvector(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField6();
	}

	public static SubLObject idxwriter_complex_index_file(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField7();
	}

	public static SubLObject idxwriter_complex_index_label(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField8();
	}

	public static SubLObject idxwriter_dump_fn(final SubLObject v_object) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.getField9();
	}

	public static SubLObject _csetf_idxwriter_directory(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField2(value);
	}

	public static SubLObject _csetf_idxwriter_fvector(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField3(value);
	}

	public static SubLObject _csetf_idxwriter_index_file(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField4(value);
	}

	public static SubLObject _csetf_idxwriter_index_label(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField5(value);
	}

	public static SubLObject _csetf_idxwriter_complex_fvector(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField6(value);
	}

	public static SubLObject _csetf_idxwriter_complex_index_file(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField7(value);
	}

	public static SubLObject _csetf_idxwriter_complex_index_label(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField8(value);
	}

	public static SubLObject _csetf_idxwriter_dump_fn(final SubLObject v_object, final SubLObject value) {
		assert NIL != dumper.index_writer_p(v_object) : "! dumper.index_writer_p(v_object) "
				+ "dumper.index_writer_p error :" + v_object;
		return v_object.setField9(value);
	}

	public static SubLObject make_index_writer(SubLObject arglist) {
		if (arglist == UNPROVIDED) {
			arglist = NIL;
		}
		final SubLObject v_new = new dumper.$index_writer_native();
		SubLObject next;
		SubLObject current_arg;
		SubLObject current_value;
		SubLObject pcase_var;
		for (next = NIL, next = arglist; NIL != next; next = cddr(next)) {
			current_arg = next.first();
			current_value = cadr(next);
			pcase_var = current_arg;
			if (pcase_var.eql($DIRECTORY)) {
				dumper._csetf_idxwriter_directory(v_new, current_value);
			} else if (pcase_var.eql($FVECTOR)) {
				dumper._csetf_idxwriter_fvector(v_new, current_value);
			} else if (pcase_var.eql($INDEX_FILE)) {
				dumper._csetf_idxwriter_index_file(v_new, current_value);
			} else if (pcase_var.eql($INDEX_LABEL)) {
				dumper._csetf_idxwriter_index_label(v_new, current_value);
			} else if (pcase_var.eql($COMPLEX_FVECTOR)) {
				dumper._csetf_idxwriter_complex_fvector(v_new, current_value);
			} else if (pcase_var.eql(dumper.$COMPLEX_INDEX_FILE)) {
				dumper._csetf_idxwriter_complex_index_file(v_new, current_value);
			} else if (pcase_var.eql(dumper.$COMPLEX_INDEX_LABEL)) {
				dumper._csetf_idxwriter_complex_index_label(v_new, current_value);
			} else if (pcase_var.eql($DUMP_FN)) {
				dumper._csetf_idxwriter_dump_fn(v_new, current_value);
			} else {
				Errors.error(dumper.$str411$Invalid_slot__S_for_construction_, current_arg);
			}

		}
		return v_new;
	}

	public static SubLObject visit_defstruct_index_writer(final SubLObject obj, final SubLObject visitor_fn) {
		funcall(visitor_fn, obj, $BEGIN, dumper.MAKE_INDEX_WRITER, EIGHT_INTEGER);
		funcall(visitor_fn, obj, $SLOT, $DIRECTORY, dumper.idxwriter_directory(obj));
		funcall(visitor_fn, obj, $SLOT, $FVECTOR, dumper.idxwriter_fvector(obj));
		funcall(visitor_fn, obj, $SLOT, $INDEX_FILE, dumper.idxwriter_index_file(obj));
		funcall(visitor_fn, obj, $SLOT, $INDEX_LABEL, dumper.idxwriter_index_label(obj));
		funcall(visitor_fn, obj, $SLOT, $COMPLEX_FVECTOR, dumper.idxwriter_complex_fvector(obj));
		funcall(visitor_fn, obj, $SLOT, dumper.$COMPLEX_INDEX_FILE, dumper.idxwriter_complex_index_file(obj));
		funcall(visitor_fn, obj, $SLOT, dumper.$COMPLEX_INDEX_LABEL, dumper.idxwriter_complex_index_label(obj));
		funcall(visitor_fn, obj, $SLOT, $DUMP_FN, dumper.idxwriter_dump_fn(obj));
		funcall(visitor_fn, obj, $END, dumper.MAKE_INDEX_WRITER, EIGHT_INTEGER);
		return obj;
	}

	public static SubLObject visit_defstruct_object_index_writer_method(final SubLObject obj,
			final SubLObject visitor_fn) {
		return dumper.visit_defstruct_index_writer(obj, visitor_fn);
	}

	public static SubLObject new_index_writer(final SubLObject dir_path, final SubLObject data_file,
			final SubLObject index_file, final SubLObject index_label, final SubLObject cdata_file,
			final SubLObject cindex_file, final SubLObject cindex_label, final SubLObject dump_fn) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject fvector = NIL;
		SubLObject complex_fvector = NIL;
		final SubLObject indices_file = dumper.kb_dump_file(data_file, dir_path, UNPROVIDED);
		final SubLObject indices_index_file = dumper.kb_dump_file(index_file, dir_path, UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(cdata_file, dir_path, UNPROVIDED);
		final SubLObject complex_index_file = dumper.kb_dump_file(cindex_file, dir_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject stream = compatibility.open_binary(indices_file, $OUTPUT);
			final SubLObject index_stream = compatibility.open_binary(indices_index_file, $OUTPUT);
			dumper.dump_copyright(stream);
			fvector = file_vector.create_file_vector(stream, index_stream);
			if (NIL != dumper.$separate_file_for_complex_indexingP$.getDynamicValue(thread)) {
				final SubLObject complex_stream = compatibility.open_binary(complex_file, $OUTPUT);
				final SubLObject compinx_stream = compatibility.open_binary(complex_index_file, $OUTPUT);
				complex_fvector = file_vector.create_file_vector(complex_stream, compinx_stream);
				dumper.kb_dump_stamp_file_vector_for_references(complex_fvector);
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return dumper.make_index_writer(list(new SubLObject[] { $DIRECTORY, dir_path, $DUMP_FN, dump_fn, $FVECTOR,
				fvector, $INDEX_FILE, index_file, $INDEX_LABEL, index_label, $COMPLEX_FVECTOR, complex_fvector,
				dumper.$COMPLEX_INDEX_FILE, cindex_file, dumper.$COMPLEX_INDEX_LABEL, cindex_label }));
	}

	public static SubLObject index_writer_put_index_entry(final SubLObject idx_writer, final SubLObject v_term) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject fvector = dumper.idxwriter_fvector(idx_writer);
		final SubLObject complex_fvector = dumper.idxwriter_complex_fvector(idx_writer);
		final SubLObject dump_fn = dumper.idxwriter_dump_fn(idx_writer);
		file_vector.update_file_vector_index_linear(fvector);
		final SubLObject _prev_bind_0 = dumper.$separate_file_for_complex_indexingP$.currentBinding(thread);
		try {
			dumper.$separate_file_for_complex_indexingP$.bind(file_vector.file_vector_p(complex_fvector), thread);
			funcall(dump_fn, v_term, file_vector.get_file_vector_data_stream(fvector), complex_fvector);
		} finally {
			dumper.$separate_file_for_complex_indexingP$.rebind(_prev_bind_0, thread);
		}
		return v_term;
	}

	public static SubLObject close_index_writer(final SubLObject idx_writer) {
		final SubLObject directory_path = dumper.idxwriter_directory(idx_writer);
		final SubLObject fvector = dumper.idxwriter_fvector(idx_writer);
		final SubLObject index_file = dumper.idxwriter_index_file(idx_writer);
		final SubLObject index_label = dumper.idxwriter_index_label(idx_writer);
		dumper.possibly_persist_wide_fvector_mark(fvector, index_file, directory_path, index_label);
		file_vector.close_file_vector(fvector);
		final SubLObject complex_fvector = dumper.idxwriter_complex_fvector(idx_writer);
		if (NIL != file_vector.file_vector_p(complex_fvector)) {
			final SubLObject complex_index_file = dumper.idxwriter_complex_index_file(idx_writer);
			final SubLObject complex_index_label = dumper.idxwriter_complex_index_label(idx_writer);
			dumper.possibly_persist_wide_fvector_mark(complex_fvector, complex_index_file, directory_path,
					complex_index_label);
			file_vector.close_file_vector(complex_fvector);
		}
		return idx_writer;
	}

	public static SubLObject new_constant_indices_writer(final SubLObject directory_path) {
		return dumper.new_index_writer(directory_path, dumper.$$$indices, dumper.$str416$indices_index,
				dumper.$$$constant_indices, dumper.$str418$constant_complex_indices,
				dumper.$str419$constant_complex_indices_index, dumper.$$$constant_complex_indices,
				dumper.DUMP_CONSTANT_INDEX);
	}

	public static final SubLObject dump_constant_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject indices_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$indices, directory_path,
						UNPROVIDED);
				SubLObject indices_index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt130$indices_index,
						directory_path, UNPROVIDED);
				SubLObject filename_var = indices_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_52 = stream;
						SubLObject filename_var_53 = indices_index_file;
						SubLObject stream_54 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_54 = compatibility.open_binary(filename_var_53, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_54.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_53);
							}
							{
								SubLObject index_stream = stream_54;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_52);
								{
									SubLObject fvector = create_file_vector(stream_52, index_stream);
									SubLObject idx = do_constants_table();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($$$Dumping_constant_indices, STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Dumping_constant_indices);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
													SubLObject constant = NIL;
													while (NIL != id) {
														constant = do_id_index_state_object(idx, $SKIP, id, state_var);
														if (NIL != do_id_index_id_and_object_validP(id, constant,
																$SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															update_file_vector_index_linear(fvector);
															com.cyc.cycjava.cycl.dumper.dump_constant_index(constant,
																	stream_52);
														}
														id = do_id_index_next_id(idx, T, id, state_var);
														state_var = do_id_index_next_state(idx, T, id, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_54.isStream()) {
										close(stream_54, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_53);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_constant_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject indices_file = dumper.kb_dump_file(dumper.$$$indices, directory_path, UNPROVIDED);
		final SubLObject indices_index_file = dumper.kb_dump_file(dumper.$str416$indices_index, directory_path,
				UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(dumper.$str418$constant_complex_indices, directory_path,
				UNPROVIDED);
		final SubLObject compinx_file = dumper.kb_dump_file(dumper.$str419$constant_complex_indices_index,
				directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = indices_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$418 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$418, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$419 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$419 = file_utilities.enable_file_stream_memory_mapping(stream_$419);
				}
				try {
					final SubLObject filename_var_$420 = indices_index_file;
					SubLObject stream_$420 = NIL;
					try {
						final SubLObject _prev_bind_0_$419 = stream_macros.$stream_requires_locking$
								.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream_$420 = compatibility.open_binary(filename_var_$420, $OUTPUT);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$419, thread);
						}
						if (!stream_$420.isStream()) {
							Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$420);
						}
						SubLObject index_stream = stream_$420;
						if ($OUTPUT == $INPUT) {
							index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
						}
						try {
							dumper.dump_copyright(stream_$419);
							final SubLObject filename_var_$421 = complex_file;
							SubLObject stream_$421 = NIL;
							try {
								final SubLObject _prev_bind_0_$420 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_$421 = compatibility.open_binary(filename_var_$421, $OUTPUT);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$420, thread);
								}
								if (!stream_$421.isStream()) {
									Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$421);
								}
								SubLObject complex_stream = stream_$421;
								if ($OUTPUT == $INPUT) {
									complex_stream = file_utilities.enable_file_stream_memory_mapping(complex_stream);
								}
								try {
									final SubLObject filename_var_$422 = compinx_file;
									SubLObject stream_$422 = NIL;
									try {
										final SubLObject _prev_bind_0_$421 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream_$422 = compatibility.open_binary(filename_var_$422, $OUTPUT);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$421, thread);
										}
										if (!stream_$422.isStream()) {
											Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$422);
										}
										SubLObject compinx_stream = stream_$422;
										if ($OUTPUT == $INPUT) {
											compinx_stream = file_utilities
													.enable_file_stream_memory_mapping(compinx_stream);
										}
										try {
											final SubLObject fvector = file_vector.create_file_vector(stream_$419,
													index_stream);
											final SubLObject complex_fvector = file_vector
													.create_file_vector(complex_stream, compinx_stream);
											dumper.kb_dump_stamp_file_vector_for_references(complex_fvector);
											final SubLObject idx = do_constants_table();
											final SubLObject mess = dumper.$$$Dumping_constant_indices;
											final SubLObject total = id_index_count(idx);
											SubLObject sofar = ZERO_INTEGER;
											assert NIL != stringp(mess) : "! stringp(mess) " + ("Types.stringp(mess) "
													+ "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
											final SubLObject _prev_bind_0_$422 = $last_percent_progress_index$
													.currentBinding(thread);
											final SubLObject _prev_bind_1_$430 = $last_percent_progress_prediction$
													.currentBinding(thread);
											final SubLObject _prev_bind_3 = $within_noting_percent_progress$
													.currentBinding(thread);
											final SubLObject _prev_bind_4 = $percent_progress_start_time$
													.currentBinding(thread);
											try {
												$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
												$last_percent_progress_prediction$.bind(NIL, thread);
												$within_noting_percent_progress$.bind(T, thread);
												$percent_progress_start_time$.bind(get_universal_time(), thread);
												try {
													noting_percent_progress_preamble(mess);
													final SubLObject idx_$431 = idx;
													if (NIL == id_index_objects_empty_p(idx_$431, $SKIP)) {
														final SubLObject idx_$432 = idx_$431;
														if (NIL == id_index_dense_objects_empty_p(idx_$432, $SKIP)) {
															final SubLObject vector_var = id_index_dense_objects(
																	idx_$432);
															final SubLObject backwardP_var = NIL;
															SubLObject length;
															SubLObject v_iteration;
															SubLObject id;
															SubLObject constant;
															for (length = length(
																	vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																			.numL(length); v_iteration = add(
																					v_iteration, ONE_INTEGER)) {
																id = (NIL != backwardP_var)
																		? subtract(length, v_iteration, ONE_INTEGER)
																		: v_iteration;
																constant = aref(vector_var, id);
																if ((NIL == id_index_tombstone_p(constant))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	if (NIL != id_index_tombstone_p(constant)) {
																		constant = $SKIP;
																	}
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_constant_index(constant, stream_$419,
																			complex_fvector);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
															}
														}
														final SubLObject idx_$433 = idx_$431;
														if ((NIL == id_index_sparse_objects_empty_p(idx_$433))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															final SubLObject sparse = id_index_sparse_objects(idx_$433);
															SubLObject id2 = id_index_sparse_id_threshold(idx_$433);
															final SubLObject end_id = id_index_next_id(idx_$433);
															final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																	$SKIP)) ? NIL : $SKIP;
															while (id2.numL(end_id)) {
																final SubLObject constant2 = gethash_without_values(id2,
																		sparse, v_default);
																if ((NIL == id_index_skip_tombstones_p($SKIP))
																		|| (NIL == id_index_tombstone_p(constant2))) {
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_constant_index(constant2, stream_$419,
																			complex_fvector);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
																id2 = add(id2, ONE_INTEGER);
															}
														}
													}
												} finally {
													final SubLObject _prev_bind_0_$423 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values = getValuesAsVector();
														noting_percent_progress_postamble();
														restoreValuesFromVector(_values);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$423,
																thread);
													}
												}
											} finally {
												$percent_progress_start_time$.rebind(_prev_bind_4, thread);
												$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
												$last_percent_progress_prediction$.rebind(_prev_bind_1_$430, thread);
												$last_percent_progress_index$.rebind(_prev_bind_0_$422, thread);
											}
											dumper.possibly_persist_wide_fvector_mark(fvector,
													dumper.$str416$indices_index, directory_path,
													dumper.$$$constant_indices);
											if (NIL != dumper.$separate_file_for_complex_indexingP$
													.getDynamicValue(thread)) {
												dumper.possibly_persist_wide_fvector_mark(complex_fvector,
														dumper.$str419$constant_complex_indices_index, directory_path,
														dumper.$$$complex_constant_indices);
											}
										} finally {
											final SubLObject _prev_bind_0_$424 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values2 = getValuesAsVector();
												close(compinx_stream, UNPROVIDED);
												restoreValuesFromVector(_values2);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$424, thread);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$425 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values3 = getValuesAsVector();
											if (stream_$422.isStream()) {
												close(stream_$422, UNPROVIDED);
											}
											restoreValuesFromVector(_values3);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$425, thread);
										}
									}
									dumper.discard_dump_filename(filename_var_$422);
								} finally {
									final SubLObject _prev_bind_0_$426 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values4 = getValuesAsVector();
										close(complex_stream, UNPROVIDED);
										restoreValuesFromVector(_values4);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$426, thread);
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$427 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values5 = getValuesAsVector();
									if (stream_$421.isStream()) {
										close(stream_$421, UNPROVIDED);
									}
									restoreValuesFromVector(_values5);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$427, thread);
								}
							}
							dumper.discard_dump_filename(filename_var_$421);
						} finally {
							final SubLObject _prev_bind_0_$428 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values6 = getValuesAsVector();
								close(index_stream, UNPROVIDED);
								restoreValuesFromVector(_values6);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$428, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$429 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values7 = getValuesAsVector();
							if (stream_$420.isStream()) {
								close(stream_$420, UNPROVIDED);
							}
							restoreValuesFromVector(_values7);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$429, thread);
						}
					}
					dumper.discard_dump_filename(filename_var_$420);
				} finally {
					final SubLObject _prev_bind_0_$430 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values8 = getValuesAsVector();
						close(stream_$419, UNPROVIDED);
						restoreValuesFromVector(_values8);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$430, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$431 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values9 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values9);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$431, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		if (NIL == dumper.$separate_file_for_complex_indexingP$.getDynamicValue(thread)) {
			final SubLObject str = dumper.$str424$Cleaning_up_empty_complex_indexin;
			final SubLObject _prev_bind_5 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_9 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_10 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_11 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_12 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				sleep(ONE_INTEGER);
				Filesys.delete_file(complex_file);
				Filesys.delete_file(compinx_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_12, thread);
				$is_noting_progressP$.rebind(_prev_bind_11, thread);
				$progress_count$.rebind(_prev_bind_10, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_9, thread);
				$progress_notification_count$.rebind(_prev_bind_8, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_7, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_6, thread);
				$progress_start_time$.rebind(_prev_bind_5, thread);
			}
		}
		return NIL;
	}

	public static SubLObject snapshot_constant_indices(final SubLObject active_dir, final SubLObject directory_path) {
		return dumper.snapshot_managed_object_simple_complex_index(dumper.SNAPSHOT_CONSTANT_INDICES_INTERNAL,
				dumper.$$$constant, active_dir, directory_path);
	}

	public static SubLObject snapshot_constant_indices_internal(final SubLObject active_dir,
			final SubLObject directory_path, SubLObject widen_fvectorP, SubLObject widen_complexP) {
		if (widen_fvectorP == UNPROVIDED) {
			widen_fvectorP = NIL;
		}
		if (widen_complexP == UNPROVIDED) {
			widen_complexP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject current;
		final SubLObject datum = current = dumper.replicate_fv_dump_files(dumper.$list426, dumper.$list427,
				list(dumper.get_wide_mark_basename_from_index_basename(dumper.$str416$indices_index),
						dumper.get_wide_mark_basename_from_index_basename(
								dumper.$str419$constant_complex_indices_index)),
				list(widen_fvectorP, widen_complexP), active_dir, directory_path,
				cconcatenate(dumper.$$$Copying_constant_indices_from_, format_nil.format_nil_a_no_copy(active_dir)));
		SubLObject new_dfile = NIL;
		SubLObject new_ifile = NIL;
		SubLObject new_iwmark = NIL;
		SubLObject new_cdfile = NIL;
		SubLObject new_cifile = NIL;
		SubLObject new_cwmark = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_dfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_ifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_iwmark = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cdfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cwmark = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject bufsize = file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject small_bufsize = file_utilities.$default_small_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject fvector = file_vector.open_file_vector_for_rewrite(new_dfile, new_ifile, new_iwmark,
					bufsize, small_bufsize, UNPROVIDED);
			final SubLObject complex_fvector = file_vector.open_file_vector_for_append(new_cdfile, new_cifile,
					new_cwmark, bufsize, bufsize, UNPROVIDED);
			try {
				dumper.snapshot_deleted_object_tombstones(fvector, deleted_constant_id_iterator(),
						dumper.$str430$Tombstoning_deleted_constant_indi);
				compatibility.set_file_position(file_vector.get_file_vector_data_stream(fvector), $END);
				dumper.snapshot_changed_managed_objects(fvector, complex_fvector,
						constant_index_manager.new_muted_constant_index_iterator(), dumper.FIND_CONSTANT_BY_SUID,
						dumper.SNAPSHOT_CONSTANT_INDEX, dumper.$$$Updating_changed_constant_indices);
				if (NIL != has_new_constantsP()) {
					file_vector.file_vector_change_stream_buffer_sizes(fvector, bufsize, bufsize);
					dumper.snapshot_new_managed_objects(fvector, new_new_constants_iterator(),
							constant_index_manager.get_file_backed_constant_internal_id_threshold(),
							dumper.CONSTANT_SUID, dumper.DUMP_CONSTANT_INDEX, dumper.$$$Appending_new_constant_indices,
							complex_fvector);
				}
				dumper.possibly_persist_wide_fvector_mark(fvector, dumper.$str416$indices_index, directory_path,
						dumper.$$$constant_indices);
				dumper.possibly_persist_wide_fvector_mark(complex_fvector,
						dumper.$str419$constant_complex_indices_index, directory_path,
						dumper.$$$complex_constant_indices);
			} finally {
				final SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					file_vector.close_file_vector(fvector);
					file_vector.close_file_vector(complex_fvector);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
				}
			}
		} else {
			cdestructuring_bind_error(datum, dumper.$list429);
		}
		return NIL;
	}

	public static SubLObject new_niniveh_constant_indices_iterator(final SubLObject directory_path) {
		return dumper.new_niniveh_index_iterator(dumper.$$$indices, directory_path);
	}

	public static final SubLObject load_constant_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$indices, directory_path,
						UNPROVIDED);
				SubLObject index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt130$indices_index,
						directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(index_file))) {
					format(T, $str_alt132$__Constant_indexing_will_be_swapp, cfasl_file, index_file);
					initialize_constant_index_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
						{
							SubLObject filename_var = cfasl_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_55 = stream;
									SubLObject total = constant_count();
									SubLObject sofar = ZERO_INTEGER;
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_55);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Loading_constant_indices);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_55, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_55,
																NIL, UNPROVIDED)) {
													sofar = add(sofar, ONE_INTEGER);
													note_percent_progress(sofar, total);
													if (dump_id.isInteger()) {
														com.cyc.cycjava.cycl.dumper.load_constant_index(dump_id,
																stream_55);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_constant_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$$$indices, directory_path, UNPROVIDED);
		final SubLObject index_file = dumper.kb_dump_file(dumper.$str416$indices_index, directory_path, UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(dumper.$str418$constant_complex_indices, directory_path,
				UNPROVIDED);
		final SubLObject compinx_file = dumper.kb_dump_file(dumper.$str419$constant_complex_indices_index,
				directory_path, UNPROVIDED);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(complex_file))) {
			format(T, dumper.$str436$__Constant_indexing_will_be_swapp, cfasl_file, index_file);
			format(T, dumper.$str437$__Constant_complex_indexing_will_, complex_file, compinx_file);
			constant_index_manager.initialize_constant_index_hl_store_cache();
			if (NIL != constant_index_manager.wide_constant_index_hl_store_cacheP()) {
				format(T, dumper.$str438$___Constant_indices_use_wide_inde);
			}
			if (NIL != constant_index_manager.wide_constant_complex_index_hl_store_cacheP()) {
				format(T, dumper.$str439$___Constant_complex_indices_use_w);
			}
		} else if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(index_file))) {
			format(T, dumper.$str436$__Constant_indexing_will_be_swapp, cfasl_file, index_file);
			constant_index_manager.initialize_constant_index_hl_store_cache();
			if (NIL != constant_index_manager.wide_constant_index_hl_store_cacheP()) {
				format(T, dumper.$str438$___Constant_indices_use_wide_inde);
			}
		} else if ((NIL != dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != dumper.has_deleted_constant_id_setP(directory_path))) {
			Errors.error(dumper.$str326$Not_yet_implemented_);
		} else if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$443 = stream;
				if ($INPUT == $INPUT) {
					stream_$443 = file_utilities.enable_file_stream_memory_mapping(stream_$443);
				}
				try {
					final SubLObject total = constant_count();
					SubLObject sofar = ZERO_INTEGER;
					dumper.load_copyright(stream_$443);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_constant_indices);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$443, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$443, NIL, UNPROVIDED)) {
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
								if (dump_id.isInteger()) {
									dumper.load_constant_index(dump_id, stream_$443);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$444 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$444, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$443, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		return NIL;
	}

	public static final SubLObject dump_constant_index(SubLObject constant, SubLObject stream) {
		{
			SubLObject index = constants_low.constant_index(constant);
			cfasl_output(constants_high.constant_dump_id(constant), stream);
			cfasl_output(index, stream);
		}
		return NIL;
	}

	public static SubLObject dump_constant_index(final SubLObject constant, final SubLObject stream,
			final SubLObject fvector) {
		final SubLObject index = constants_low.constant_index(constant);
		final SubLObject id = constants_high.constant_dump_id(constant);
		dumper.dump_top_level_index_of_type(constant, id, index, stream, dumper.$$$constant, fvector, $CONSTANT_INDEX);
		return NIL;
	}

	public static SubLObject dump_top_level_index_of_type(final SubLObject v_object, final SubLObject id,
			SubLObject index, final SubLObject stream, final SubLObject type_name, final SubLObject fvector,
			final SubLObject type_code) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if ((NIL != dumper.$separate_file_for_complex_indexingP$.getDynamicValue(thread))
				&& (NIL != complex_index_p(index))) {
			SubLObject problem = NIL;
			try {
				thread.throwStack.push($catch_error_message_target$.getGlobalValue());
				final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
				try {
					Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
					try {
						index = indexing_utilities.dump_entire_swappable_complex_index(index, fvector, type_code);
					} catch (final Throwable catch_var) {
						Errors.handleThrowable(catch_var, NIL);
					}
				} finally {
					Errors.$error_handler$.rebind(_prev_bind_0, thread);
				}
			} catch (final Throwable ccatch_env_var) {
				problem = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
			} finally {
				thread.throwStack.pop();
			}
			if (problem.isString()) {
				Errors.error(dumper.$str441$Could_not_dump_the__A_index_for__,
						new SubLObject[] { type_name, v_object, id, problem });
			}
		}
		cfasl_output(id, stream);
		cfasl_output(index, stream);
		return v_object;
	}

	public static SubLObject snapshot_constant_index(final SubLObject constant, final SubLObject old_index,
			final SubLObject data_stream, final SubLObject complex_fvector) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = old_index;
		if (NIL != complex_index_p(index)) {
			SubLObject problem = NIL;
			try {
				thread.throwStack.push($catch_error_message_target$.getGlobalValue());
				final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
				try {
					Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
					try {
						index = indexing_utilities.dump_changed_swappable_complex_index(index, complex_fvector,
								$CONSTANT_INDEX);
					} catch (final Throwable catch_var) {
						Errors.handleThrowable(catch_var, NIL);
					}
				} finally {
					Errors.$error_handler$.rebind(_prev_bind_0, thread);
				}
			} catch (final Throwable ccatch_env_var) {
				problem = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
			} finally {
				thread.throwStack.pop();
			}
			if (problem.isString()) {
				Errors.error(dumper.$str442$Could_not_dump_the_constant_index, constant, constant_suid(constant),
						problem);
			}
		}
		cfasl_output(constants_high.constant_dump_id(constant), data_stream);
		cfasl_output(index, data_stream);
		return NIL;
	}

	public static final SubLObject load_constant_index_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject constant = constants_high.find_constant_by_dump_id(dump_id);
			return constants_low.reset_constant_index(constant, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		}
	}

	public static SubLObject load_constant_index(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject constant = constants_high.find_constant_by_dump_id(dump_id);
		return constants_low.reset_constant_index(constant, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
	}

	public static final SubLObject load_constant_index_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject index = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						index = com.cyc.cycjava.cycl.dumper.load_constant_index(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return index;
			}
		}
	}

	public static SubLObject load_constant_index_from_cache(final SubLObject dump_id, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			index = dumper.load_constant_index(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return index;
	}

	public static SubLObject new_nart_indices_writer(final SubLObject directory_path) {
		return dumper.new_index_writer(directory_path, dumper.$str444$nat_indices, dumper.$str445$nat_indices_index,
				dumper.$$$NART_indices, dumper.$str447$nat_complex_indices, dumper.$str448$nat_complex_indices_index,
				dumper.$$$complex_NART_indices, dumper.DUMP_NART_INDEX);
	}

	public static final SubLObject dump_nart_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject indices_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt135$nat_indices,
						directory_path, UNPROVIDED);
				SubLObject indices_index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt136$nat_indices_index,
						directory_path, UNPROVIDED);
				SubLObject filename_var = indices_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_56 = stream;
						SubLObject filename_var_57 = indices_index_file;
						SubLObject stream_58 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_58 = compatibility.open_binary(filename_var_57, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_58.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_57);
							}
							{
								SubLObject index_stream = stream_58;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_56);
								{
									SubLObject fvector = create_file_vector(stream_56, index_stream);
									SubLObject idx = nart_handles.do_narts_table();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($$$Dumping_NART_indices, STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Dumping_NART_indices);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
													SubLObject nart = NIL;
													while (NIL != id) {
														nart = do_id_index_state_object(idx, $SKIP, id, state_var);
														if (NIL != do_id_index_id_and_object_validP(id, nart, $SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															update_file_vector_index_linear(fvector);
															com.cyc.cycjava.cycl.dumper.dump_nart_index(nart,
																	stream_56);
														}
														id = do_id_index_next_id(idx, T, id, state_var);
														state_var = do_id_index_next_state(idx, T, id, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_58.isStream()) {
										close(stream_58, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_57);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_nart_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject indices_file = dumper.kb_dump_file(dumper.$str444$nat_indices, directory_path, UNPROVIDED);
		final SubLObject indices_index_file = dumper.kb_dump_file(dumper.$str445$nat_indices_index, directory_path,
				UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(dumper.$str447$nat_complex_indices, directory_path,
				UNPROVIDED);
		final SubLObject compinx_file = dumper.kb_dump_file(dumper.$str448$nat_complex_indices_index, directory_path,
				UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = indices_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$445 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$445, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$446 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$446 = file_utilities.enable_file_stream_memory_mapping(stream_$446);
				}
				try {
					final SubLObject filename_var_$447 = indices_index_file;
					SubLObject stream_$447 = NIL;
					try {
						final SubLObject _prev_bind_0_$446 = stream_macros.$stream_requires_locking$
								.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream_$447 = compatibility.open_binary(filename_var_$447, $OUTPUT);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$446, thread);
						}
						if (!stream_$447.isStream()) {
							Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$447);
						}
						SubLObject index_stream = stream_$447;
						if ($OUTPUT == $INPUT) {
							index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
						}
						try {
							dumper.dump_copyright(stream_$446);
							final SubLObject filename_var_$448 = complex_file;
							SubLObject stream_$448 = NIL;
							try {
								final SubLObject _prev_bind_0_$447 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_$448 = compatibility.open_binary(filename_var_$448, $OUTPUT);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$447, thread);
								}
								if (!stream_$448.isStream()) {
									Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$448);
								}
								SubLObject complex_stream = stream_$448;
								if ($OUTPUT == $INPUT) {
									complex_stream = file_utilities.enable_file_stream_memory_mapping(complex_stream);
								}
								try {
									final SubLObject filename_var_$449 = compinx_file;
									SubLObject stream_$449 = NIL;
									try {
										final SubLObject _prev_bind_0_$448 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream_$449 = compatibility.open_binary(filename_var_$449, $OUTPUT);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$448, thread);
										}
										if (!stream_$449.isStream()) {
											Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$449);
										}
										SubLObject compinx_stream = stream_$449;
										if ($OUTPUT == $INPUT) {
											compinx_stream = file_utilities
													.enable_file_stream_memory_mapping(compinx_stream);
										}
										try {
											dumper.dump_copyright(complex_stream);
											final SubLObject fvector = file_vector.create_file_vector(stream_$446,
													index_stream);
											final SubLObject complex_fvector = file_vector
													.create_file_vector(complex_stream, compinx_stream);
											dumper.kb_dump_stamp_file_vector_for_references(complex_fvector);
											final SubLObject idx = nart_handles.do_narts_table();
											final SubLObject mess = dumper.$$$Dumping_NART_indices;
											final SubLObject total = id_index_count(idx);
											SubLObject sofar = ZERO_INTEGER;
											assert NIL != stringp(mess) : "! stringp(mess) " + ("Types.stringp(mess) "
													+ "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
											final SubLObject _prev_bind_0_$449 = $last_percent_progress_index$
													.currentBinding(thread);
											final SubLObject _prev_bind_1_$457 = $last_percent_progress_prediction$
													.currentBinding(thread);
											final SubLObject _prev_bind_3 = $within_noting_percent_progress$
													.currentBinding(thread);
											final SubLObject _prev_bind_4 = $percent_progress_start_time$
													.currentBinding(thread);
											try {
												$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
												$last_percent_progress_prediction$.bind(NIL, thread);
												$within_noting_percent_progress$.bind(T, thread);
												$percent_progress_start_time$.bind(get_universal_time(), thread);
												try {
													noting_percent_progress_preamble(mess);
													final SubLObject idx_$458 = idx;
													if (NIL == id_index_objects_empty_p(idx_$458, $SKIP)) {
														final SubLObject idx_$459 = idx_$458;
														if (NIL == id_index_dense_objects_empty_p(idx_$459, $SKIP)) {
															final SubLObject vector_var = id_index_dense_objects(
																	idx_$459);
															final SubLObject backwardP_var = NIL;
															SubLObject length;
															SubLObject v_iteration;
															SubLObject id;
															SubLObject nart;
															for (length = length(
																	vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																			.numL(length); v_iteration = add(
																					v_iteration, ONE_INTEGER)) {
																id = (NIL != backwardP_var)
																		? subtract(length, v_iteration, ONE_INTEGER)
																		: v_iteration;
																nart = aref(vector_var, id);
																if ((NIL == id_index_tombstone_p(nart))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	if (NIL != id_index_tombstone_p(nart)) {
																		nart = $SKIP;
																	}
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_nart_index(nart, stream_$446,
																			complex_fvector);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
															}
														}
														final SubLObject idx_$460 = idx_$458;
														if ((NIL == id_index_sparse_objects_empty_p(idx_$460))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															final SubLObject sparse = id_index_sparse_objects(idx_$460);
															SubLObject id2 = id_index_sparse_id_threshold(idx_$460);
															final SubLObject end_id = id_index_next_id(idx_$460);
															final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																	$SKIP)) ? NIL : $SKIP;
															while (id2.numL(end_id)) {
																final SubLObject nart2 = gethash_without_values(id2,
																		sparse, v_default);
																if ((NIL == id_index_skip_tombstones_p($SKIP))
																		|| (NIL == id_index_tombstone_p(nart2))) {
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_nart_index(nart2, stream_$446,
																			complex_fvector);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
																id2 = add(id2, ONE_INTEGER);
															}
														}
													}
												} finally {
													final SubLObject _prev_bind_0_$450 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values = getValuesAsVector();
														noting_percent_progress_postamble();
														restoreValuesFromVector(_values);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$450,
																thread);
													}
												}
											} finally {
												$percent_progress_start_time$.rebind(_prev_bind_4, thread);
												$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
												$last_percent_progress_prediction$.rebind(_prev_bind_1_$457, thread);
												$last_percent_progress_index$.rebind(_prev_bind_0_$449, thread);
											}
											dumper.possibly_persist_wide_fvector_mark(fvector,
													dumper.$str445$nat_indices_index, directory_path,
													dumper.$$$NART_indices);
											if (NIL != dumper.$separate_file_for_complex_indexingP$
													.getDynamicValue(thread)) {
												dumper.possibly_persist_wide_fvector_mark(complex_fvector,
														dumper.$str452$nart_complex_indices_index, directory_path,
														dumper.$$$complex_NART_indices);
											}
										} finally {
											final SubLObject _prev_bind_0_$451 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values2 = getValuesAsVector();
												close(compinx_stream, UNPROVIDED);
												restoreValuesFromVector(_values2);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$451, thread);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$452 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values3 = getValuesAsVector();
											if (stream_$449.isStream()) {
												close(stream_$449, UNPROVIDED);
											}
											restoreValuesFromVector(_values3);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$452, thread);
										}
									}
									dumper.discard_dump_filename(filename_var_$449);
								} finally {
									final SubLObject _prev_bind_0_$453 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values4 = getValuesAsVector();
										close(complex_stream, UNPROVIDED);
										restoreValuesFromVector(_values4);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$453, thread);
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$454 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values5 = getValuesAsVector();
									if (stream_$448.isStream()) {
										close(stream_$448, UNPROVIDED);
									}
									restoreValuesFromVector(_values5);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$454, thread);
								}
							}
							dumper.discard_dump_filename(filename_var_$448);
						} finally {
							final SubLObject _prev_bind_0_$455 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values6 = getValuesAsVector();
								close(index_stream, UNPROVIDED);
								restoreValuesFromVector(_values6);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$455, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$456 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values7 = getValuesAsVector();
							if (stream_$447.isStream()) {
								close(stream_$447, UNPROVIDED);
							}
							restoreValuesFromVector(_values7);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$456, thread);
						}
					}
					dumper.discard_dump_filename(filename_var_$447);
				} finally {
					final SubLObject _prev_bind_0_$457 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values8 = getValuesAsVector();
						close(stream_$446, UNPROVIDED);
						restoreValuesFromVector(_values8);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$457, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$458 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values9 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values9);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$458, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		if (NIL == dumper.$separate_file_for_complex_indexingP$.getDynamicValue(thread)) {
			final SubLObject str = dumper.$str424$Cleaning_up_empty_complex_indexin;
			final SubLObject _prev_bind_5 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_9 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_10 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_11 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_12 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				sleep(ONE_INTEGER);
				Filesys.delete_file(complex_file);
				Filesys.delete_file(compinx_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_12, thread);
				$is_noting_progressP$.rebind(_prev_bind_11, thread);
				$progress_count$.rebind(_prev_bind_10, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_9, thread);
				$progress_notification_count$.rebind(_prev_bind_8, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_7, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_6, thread);
				$progress_start_time$.rebind(_prev_bind_5, thread);
			}
		}
		return NIL;
	}

	public static SubLObject snapshot_nart_indices(final SubLObject active_dir, final SubLObject directory_path) {
		return dumper.snapshot_managed_object_simple_complex_index(dumper.SNAPSHOT_NART_INDICES_INTERNAL, dumper.$$$NAT,
				active_dir, directory_path);
	}

	public static SubLObject snapshot_nart_indices_internal(final SubLObject active_dir,
			final SubLObject directory_path, SubLObject widen_fvectorP, SubLObject widen_complexP) {
		if (widen_fvectorP == UNPROVIDED) {
			widen_fvectorP = NIL;
		}
		if (widen_complexP == UNPROVIDED) {
			widen_complexP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject current;
		final SubLObject datum = current = dumper.replicate_fv_dump_files(dumper.$list455, dumper.$list456,
				list(dumper.get_wide_mark_basename_from_index_basename(dumper.$str445$nat_indices_index),
						dumper.get_wide_mark_basename_from_index_basename(dumper.$str448$nat_complex_indices_index)),
				list(widen_fvectorP, widen_complexP), active_dir, directory_path,
				cconcatenate(dumper.$$$Copying_NAT_indices_from_, format_nil.format_nil_a_no_copy(active_dir)));
		SubLObject new_dfile = NIL;
		SubLObject new_ifile = NIL;
		SubLObject new_iwmark = NIL;
		SubLObject new_cdfile = NIL;
		SubLObject new_cifile = NIL;
		SubLObject new_cwmark = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_dfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_ifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_iwmark = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cdfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cwmark = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject bufsize = file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject small_bufsize = file_utilities.$default_small_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject fvector = file_vector.open_file_vector_for_rewrite(new_dfile, new_ifile, new_iwmark,
					bufsize, small_bufsize, UNPROVIDED);
			final SubLObject complex_fvector = file_vector.open_file_vector_for_append(new_cdfile, new_cifile,
					new_cwmark, bufsize, bufsize, UNPROVIDED);
			try {
				dumper.snapshot_deleted_object_tombstones(fvector, nart_handles.deleted_nart_id_iterator(),
						dumper.$$$Tombstoning_deleted_NAT_indices);
				compatibility.set_file_position(file_vector.get_file_vector_data_stream(fvector), $END);
				dumper.snapshot_changed_managed_objects(fvector, complex_fvector,
						nart_index_manager.new_muted_nart_index_iterator(), dumper.FIND_NART_BY_ID,
						dumper.SNAPSHOT_NART_INDEX, dumper.$$$Updating_changed_NAT_indices);
				if (NIL != nart_handles.has_new_nartsP()) {
					file_vector.file_vector_change_stream_buffer_sizes(fvector, bufsize, bufsize);
					dumper.snapshot_new_managed_objects(fvector, nart_handles.new_new_narts_iterator(),
							nart_handles.get_file_backed_nart_internal_id_threshold(), dumper.NART_ID,
							dumper.DUMP_NART_INDEX, dumper.$$$Appending_new_NAT_indices, complex_fvector);
				}
				dumper.possibly_persist_wide_fvector_mark(fvector, dumper.$str445$nat_indices_index, directory_path,
						dumper.$$$NAT_indices);
				dumper.possibly_persist_wide_fvector_mark(complex_fvector, dumper.$str448$nat_complex_indices_index,
						directory_path, dumper.$$$complex_NAT_indices);
			} finally {
				final SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					file_vector.close_file_vector(fvector);
					file_vector.close_file_vector(complex_fvector);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
				}
			}
		} else {
			cdestructuring_bind_error(datum, dumper.$list429);
		}
		return NIL;
	}

	public static SubLObject new_niniveh_nart_indices_iterator(final SubLObject directory_path) {
		return dumper.new_niniveh_index_iterator(dumper.$str444$nat_indices, directory_path);
	}

	public static final SubLObject load_nart_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt135$nat_indices,
						directory_path, UNPROVIDED);
				SubLObject index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt136$nat_indices_index,
						directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(index_file))) {
					format(T, $str_alt138$__NART_indexing_will_be_swapped_i, cfasl_file, index_file);
					initialize_nart_index_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
						{
							SubLObject filename_var = cfasl_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_59 = stream;
									SubLObject total = nart_handles.nart_count();
									SubLObject sofar = ZERO_INTEGER;
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_59);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble($$$Loading_NART_indices);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_59, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_59,
																NIL, UNPROVIDED)) {
													sofar = add(sofar, ONE_INTEGER);
													note_percent_progress(sofar, total);
													if (dump_id.isInteger()) {
														com.cyc.cycjava.cycl.dumper.load_nart_index(dump_id, stream_59);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_nart_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject indices_file = dumper.kb_dump_file(dumper.$str444$nat_indices, directory_path, UNPROVIDED);
		final SubLObject indices_index_file = dumper.kb_dump_file(dumper.$str445$nat_indices_index, directory_path,
				UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(dumper.$str447$nat_complex_indices, directory_path,
				UNPROVIDED);
		final SubLObject compinx_file = dumper.kb_dump_file(dumper.$str448$nat_complex_indices_index, directory_path,
				UNPROVIDED);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(complex_file))) {
			format(T, dumper.$str466$__NART_indexing_will_be_swapped_i, indices_file, indices_index_file);
			format(T, dumper.$str467$__NART_complex_indexing_will_be_s, complex_file, compinx_file);
			nart_index_manager.initialize_nart_index_hl_store_cache();
			if (NIL != nart_index_manager.wide_nart_index_hl_store_cacheP()) {
				format(T, dumper.$str468$___NART_indices_use_wide_index_en);
			}
			if (NIL != nart_index_manager.wide_nart_complex_index_hl_store_cacheP()) {
				format(T, dumper.$str469$___NART_complex_indices_use_wide_);
			}
		} else if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(indices_index_file))) {
			format(T, dumper.$str466$__NART_indexing_will_be_swapped_i, indices_file, indices_index_file);
			nart_index_manager.initialize_nart_index_hl_store_cache();
			if (NIL != nart_index_manager.wide_nart_index_hl_store_cacheP()) {
				format(T, dumper.$str468$___NART_indices_use_wide_index_en);
			}
		} else if (NIL != dumper.verify_file_existence(indices_file, UNPROVIDED)) {
			final SubLObject filename_var = indices_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$470 = stream;
				if ($INPUT == $INPUT) {
					stream_$470 = file_utilities.enable_file_stream_memory_mapping(stream_$470);
				}
				try {
					final SubLObject total = nart_handles.nart_count();
					SubLObject sofar = ZERO_INTEGER;
					dumper.load_copyright(stream_$470);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_NART_indices);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$470, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$470, NIL, UNPROVIDED)) {
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
								if (dump_id.isInteger()) {
									dumper.load_nart_index(dump_id, stream_$470);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$471 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$471, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$470, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		return NIL;
	}

	public static final SubLObject dump_nart_index(SubLObject nart, SubLObject stream) {
		{
			SubLObject index = narts_low.nart_index(nart);
			cfasl_output(narts_high.nart_dump_id(nart), stream);
			cfasl_output(index, stream);
		}
		return NIL;
	}

	public static SubLObject dump_nart_index(final SubLObject nart, final SubLObject stream, final SubLObject fvector) {
		final SubLObject index = narts_low.nart_index(nart);
		final SubLObject id = narts_high.nart_dump_id(nart);
		dumper.dump_top_level_index_of_type(nart, id, index, stream, dumper.$$$NART, fvector, $NART_INDEX);
		return NIL;
	}

	public static SubLObject snapshot_nart_index(final SubLObject nart, final SubLObject old_index,
			final SubLObject data_stream, final SubLObject complex_fvector) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = old_index;
		if (NIL != complex_index_p(index)) {
			SubLObject problem = NIL;
			try {
				thread.throwStack.push($catch_error_message_target$.getGlobalValue());
				final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
				try {
					Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
					try {
						index = indexing_utilities.dump_changed_swappable_complex_index(index, complex_fvector,
								$NART_INDEX);
					} catch (final Throwable catch_var) {
						Errors.handleThrowable(catch_var, NIL);
					}
				} finally {
					Errors.$error_handler$.rebind(_prev_bind_0, thread);
				}
			} catch (final Throwable ccatch_env_var) {
				problem = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
			} finally {
				thread.throwStack.pop();
			}
			if (problem.isString()) {
				Errors.error(dumper.$str471$Could_not_dump_the_NART_index_for, nart, nart_handles.nart_id(nart),
						problem);
			}
		}
		cfasl_output(narts_high.nart_dump_id(nart), data_stream);
		cfasl_output(index, data_stream);
		return NIL;
	}

	public static final SubLObject load_nart_index_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject nart = narts_high.find_nart_by_dump_id(dump_id);
			return narts_low.reset_nart_index(nart, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		}
	}

	public static SubLObject load_nart_index(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject nart = narts_high.find_nart_by_dump_id(dump_id);
		return narts_low.reset_nart_index(nart, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
	}

	public static final SubLObject load_nart_index_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject index = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						index = com.cyc.cycjava.cycl.dumper.load_nart_index(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return index;
			}
		}
	}

	public static SubLObject load_nart_index_from_cache(final SubLObject dump_id, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			index = dumper.load_nart_index(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return index;
	}

	public static SubLObject new_unrepresented_term_indices_writer(final SubLObject directory_path) {
		return dumper.new_index_writer(directory_path, dumper.$str473$unrepresented_term_indices,
				dumper.$str474$unrepresented_term_indices_index, dumper.$$$unrepresented_term_indices,
				dumper.$str476$unrepresented_term_complex_indice, dumper.$str477$unrepresented_term_complex_indice,
				dumper.$str478$complex_unrepresented_term_indice, dumper.DUMP_UNREPRESENTED_TERM_INDEX);
	}

	public static final SubLObject dump_unrepresented_term_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject indices_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt141$unrepresented_term_indices, directory_path, UNPROVIDED);
				SubLObject indices_index_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt142$unrepresented_term_indices_index, directory_path, UNPROVIDED);
				SubLObject filename_var = indices_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_60 = stream;
						SubLObject filename_var_61 = indices_index_file;
						SubLObject stream_62 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_62 = compatibility.open_binary(filename_var_61, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_62.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_61);
							}
							{
								SubLObject index_stream = stream_62;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_60);
								{
									SubLObject fvector = create_file_vector(stream_60, index_stream);
									SubLObject idx = unrepresented_terms.do_unrepresented_terms_table();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($str_alt143$Dumping_unrepresented_term_indice,
											STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble(
													$str_alt143$Dumping_unrepresented_term_indice);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
													SubLObject unrepresented_term = NIL;
													while (NIL != id) {
														unrepresented_term = do_id_index_state_object(idx, $SKIP, id,
																state_var);
														if (NIL != do_id_index_id_and_object_validP(id,
																unrepresented_term, $SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															update_file_vector_index_linear(fvector);
															com.cyc.cycjava.cycl.dumper.dump_unrepresented_term_index(
																	unrepresented_term, stream_60);
														}
														id = do_id_index_next_id(idx, T, id, state_var);
														state_var = do_id_index_next_state(idx, T, id, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_62.isStream()) {
										close(stream_62, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_61);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_unrepresented_term_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject indices_file = dumper.kb_dump_file(dumper.$str473$unrepresented_term_indices, directory_path,
				UNPROVIDED);
		final SubLObject indices_index_file = dumper.kb_dump_file(dumper.$str474$unrepresented_term_indices_index,
				directory_path, UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(dumper.$str476$unrepresented_term_complex_indice,
				directory_path, UNPROVIDED);
		final SubLObject compinx_file = dumper.kb_dump_file(dumper.$str477$unrepresented_term_complex_indice,
				directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = indices_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$472 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$472, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$473 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$473 = file_utilities.enable_file_stream_memory_mapping(stream_$473);
				}
				try {
					final SubLObject filename_var_$474 = indices_index_file;
					SubLObject stream_$474 = NIL;
					try {
						final SubLObject _prev_bind_0_$473 = stream_macros.$stream_requires_locking$
								.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream_$474 = compatibility.open_binary(filename_var_$474, $OUTPUT);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$473, thread);
						}
						if (!stream_$474.isStream()) {
							Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$474);
						}
						SubLObject index_stream = stream_$474;
						if ($OUTPUT == $INPUT) {
							index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
						}
						try {
							dumper.dump_copyright(stream_$473);
							final SubLObject filename_var_$475 = complex_file;
							SubLObject stream_$475 = NIL;
							try {
								final SubLObject _prev_bind_0_$474 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_$475 = compatibility.open_binary(filename_var_$475, $OUTPUT);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$474, thread);
								}
								if (!stream_$475.isStream()) {
									Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$475);
								}
								SubLObject complex_stream = stream_$475;
								if ($OUTPUT == $INPUT) {
									complex_stream = file_utilities.enable_file_stream_memory_mapping(complex_stream);
								}
								try {
									final SubLObject filename_var_$476 = compinx_file;
									SubLObject stream_$476 = NIL;
									try {
										final SubLObject _prev_bind_0_$475 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream_$476 = compatibility.open_binary(filename_var_$476, $OUTPUT);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$475, thread);
										}
										if (!stream_$476.isStream()) {
											Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$476);
										}
										SubLObject compinx_stream = stream_$476;
										if ($OUTPUT == $INPUT) {
											compinx_stream = file_utilities
													.enable_file_stream_memory_mapping(compinx_stream);
										}
										try {
											dumper.dump_copyright(complex_stream);
											final SubLObject fvector = file_vector.create_file_vector(stream_$473,
													index_stream);
											final SubLObject complex_fvector = file_vector
													.create_file_vector(complex_stream, compinx_stream);
											dumper.kb_dump_stamp_file_vector_for_references(complex_fvector);
											if (NIL != unrepresented_terms.use_unrepresented_term_fhtP()) {
												SubLObject msg = cconcatenate(
														dumper.$str480$Dumping_unrepresented_term_indice,
														dumper.$str292$____Old_Space);
												SubLObject release = NIL;
												try {
													release = seize_lock(
															unrepresented_terms.$unrepresented_term_fht_lock$
																	.getGlobalValue());
													final SubLObject table_var = unrepresented_terms
															.get_unrepresented_term_fht();
													$progress_note$.setDynamicValue(msg, thread);
													$progress_start_time$.setDynamicValue(get_universal_time(), thread);
													$progress_total$.setDynamicValue(
															file_hash_table.file_hash_table_count(table_var), thread);
													$progress_sofar$.setDynamicValue(ZERO_INTEGER, thread);
													final SubLObject _prev_bind_0_$476 = $last_percent_progress_index$
															.currentBinding(thread);
													final SubLObject _prev_bind_1_$484 = $last_percent_progress_prediction$
															.currentBinding(thread);
													final SubLObject _prev_bind_3 = $within_noting_percent_progress$
															.currentBinding(thread);
													final SubLObject _prev_bind_4 = $percent_progress_start_time$
															.currentBinding(thread);
													try {
														$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
														$last_percent_progress_prediction$.bind(NIL, thread);
														$within_noting_percent_progress$.bind(T, thread);
														$percent_progress_start_time$.bind(get_universal_time(),
																thread);
														try {
															noting_percent_progress_preamble(
																	$progress_note$.getDynamicValue(thread));
															SubLObject continuation = NIL;
															SubLObject next;
															for (SubLObject completeP = NIL; NIL == completeP; completeP = sublisp_null(
																	next)) {
																thread.resetMultipleValues();
																final SubLObject the_key = file_hash_table
																		.get_file_hash_table_any(table_var,
																				continuation, NIL);
																final SubLObject the_value = thread
																		.secondMultipleValue();
																next = thread.thirdMultipleValue();
																thread.resetMultipleValues();
																if (NIL != next) {
																	final SubLObject key = the_key;
																	final SubLObject unrepresented_term = the_value;
																	note_percent_progress(
																			$progress_sofar$.getDynamicValue(thread),
																			$progress_total$.getDynamicValue(thread));
																	$progress_sofar$.setDynamicValue(add(
																			$progress_sofar$.getDynamicValue(thread),
																			ONE_INTEGER), thread);
																	if ((NIL == unrepresented_terms
																			.deleted_unrepresented_term_itemP(key))
																			&& (NIL != unrepresented_terms
																					.fht_suid_item_p(key))) {
																		final SubLObject id = unrepresented_terms
																				.get_fht_suid_item_suid(key);
																		file_vector.update_file_vector_index_linear(
																				fvector);
																		dumper.dump_unrepresented_term_index(
																				unrepresented_term, stream_$473,
																				complex_fvector);
																	}
																}
																continuation = next;
															}
														} finally {
															final SubLObject _prev_bind_0_$477 = $is_thread_performing_cleanupP$
																	.currentBinding(thread);
															try {
																$is_thread_performing_cleanupP$.bind(T, thread);
																final SubLObject _values = getValuesAsVector();
																noting_percent_progress_postamble();
																restoreValuesFromVector(_values);
															} finally {
																$is_thread_performing_cleanupP$
																		.rebind(_prev_bind_0_$477, thread);
															}
														}
													} finally {
														$percent_progress_start_time$.rebind(_prev_bind_4, thread);
														$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
														$last_percent_progress_prediction$.rebind(_prev_bind_1_$484,
																thread);
														$last_percent_progress_index$.rebind(_prev_bind_0_$476, thread);
													}
												} finally {
													if (NIL != release) {
														release_lock(unrepresented_terms.$unrepresented_term_fht_lock$
																.getGlobalValue());
													}
												}
												msg = cconcatenate(dumper.$str480$Dumping_unrepresented_term_indice,
														dumper.$str293$____New_Space);
												if (NIL != unrepresented_terms.use_unrepresented_term_fhtP()) {
													final SubLObject list_var = unrepresented_terms
															.get_unrepresented_term_new_space_ascending_suid_keys();
													final SubLObject _prev_bind_0_$478 = $progress_note$
															.currentBinding(thread);
													final SubLObject _prev_bind_1_$485 = $progress_start_time$
															.currentBinding(thread);
													final SubLObject _prev_bind_3 = $progress_total$
															.currentBinding(thread);
													final SubLObject _prev_bind_4 = $progress_sofar$
															.currentBinding(thread);
													final SubLObject _prev_bind_5 = $last_percent_progress_index$
															.currentBinding(thread);
													final SubLObject _prev_bind_6 = $last_percent_progress_prediction$
															.currentBinding(thread);
													final SubLObject _prev_bind_7 = $within_noting_percent_progress$
															.currentBinding(thread);
													final SubLObject _prev_bind_8 = $percent_progress_start_time$
															.currentBinding(thread);
													try {
														$progress_note$.bind(NIL != msg ? msg : dumper.$$$cdolist,
																thread);
														$progress_start_time$.bind(get_universal_time(), thread);
														$progress_total$.bind(length(list_var), thread);
														$progress_sofar$.bind(ZERO_INTEGER, thread);
														$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
														$last_percent_progress_prediction$.bind(NIL, thread);
														$within_noting_percent_progress$.bind(T, thread);
														$percent_progress_start_time$.bind(get_universal_time(),
																thread);
														try {
															noting_percent_progress_preamble(
																	$progress_note$.getDynamicValue(thread));
															SubLObject csome_list_var = list_var;
															SubLObject suid_item = NIL;
															suid_item = csome_list_var.first();
															while (NIL != csome_list_var) {
																final SubLObject id2 = unrepresented_terms
																		.get_fht_suid_item_suid(suid_item);
																final SubLObject unrepresented_term2 = unrepresented_terms
																		.find_unrepresented_term_by_suid(id2);
																file_vector.update_file_vector_index_linear(fvector);
																dumper.dump_unrepresented_term_index(
																		unrepresented_term2, stream_$473,
																		complex_fvector);
																$progress_sofar$.setDynamicValue(
																		add($progress_sofar$.getDynamicValue(thread),
																				ONE_INTEGER),
																		thread);
																note_percent_progress(
																		$progress_sofar$.getDynamicValue(thread),
																		$progress_total$.getDynamicValue(thread));
																csome_list_var = csome_list_var.rest();
																suid_item = csome_list_var.first();
															}
														} finally {
															final SubLObject _prev_bind_0_$479 = $is_thread_performing_cleanupP$
																	.currentBinding(thread);
															try {
																$is_thread_performing_cleanupP$.bind(T, thread);
																final SubLObject _values2 = getValuesAsVector();
																noting_percent_progress_postamble();
																restoreValuesFromVector(_values2);
															} finally {
																$is_thread_performing_cleanupP$
																		.rebind(_prev_bind_0_$479, thread);
															}
														}
													} finally {
														$percent_progress_start_time$.rebind(_prev_bind_8, thread);
														$within_noting_percent_progress$.rebind(_prev_bind_7, thread);
														$last_percent_progress_prediction$.rebind(_prev_bind_6, thread);
														$last_percent_progress_index$.rebind(_prev_bind_5, thread);
														$progress_sofar$.rebind(_prev_bind_4, thread);
														$progress_total$.rebind(_prev_bind_3, thread);
														$progress_start_time$.rebind(_prev_bind_1_$485, thread);
														$progress_note$.rebind(_prev_bind_0_$478, thread);
													}
												} else {
													final SubLObject table_var = unrepresented_terms
															.do_unrepresented_terms_table();
													final SubLObject first_id_var = unrepresented_terms
															.new_unrepresented_term_id_threshold();
													final SubLObject total = subtract(id_index_next_id(table_var),
															first_id_var);
													SubLObject sofar = ZERO_INTEGER;
													final SubLObject _prev_bind_0_$480 = $last_percent_progress_index$
															.currentBinding(thread);
													final SubLObject _prev_bind_1_$486 = $last_percent_progress_prediction$
															.currentBinding(thread);
													final SubLObject _prev_bind_9 = $within_noting_percent_progress$
															.currentBinding(thread);
													final SubLObject _prev_bind_10 = $percent_progress_start_time$
															.currentBinding(thread);
													try {
														$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
														$last_percent_progress_prediction$.bind(NIL, thread);
														$within_noting_percent_progress$.bind(T, thread);
														$percent_progress_start_time$.bind(get_universal_time(),
																thread);
														try {
															noting_percent_progress_preamble(msg);
															SubLObject unrepresented_term;
															SubLObject end_var;
															SubLObject end;
															SubLObject id3;
															SubLObject id_$491;
															for (end = end_var = id_index_next_id(
																	table_var), id3 = NIL, id3 = first_id_var; !id3
																			.numGE(end_var); id3 = number_utilities
																					.f_1X(id3)) {
																unrepresented_term = id_index_lookup(table_var, id3,
																		UNPROVIDED);
																if (NIL != unrepresented_term) {
																	note_percent_progress(sofar, total);
																	sofar = add(sofar, ONE_INTEGER);
																	id_$491 = unrepresented_terms
																			.unrepresented_term_suid(
																					unrepresented_term);
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_unrepresented_term_index(
																			unrepresented_term, stream_$473,
																			complex_fvector);
																}
															}
														} finally {
															final SubLObject _prev_bind_0_$481 = $is_thread_performing_cleanupP$
																	.currentBinding(thread);
															try {
																$is_thread_performing_cleanupP$.bind(T, thread);
																final SubLObject _values3 = getValuesAsVector();
																noting_percent_progress_postamble();
																restoreValuesFromVector(_values3);
															} finally {
																$is_thread_performing_cleanupP$
																		.rebind(_prev_bind_0_$481, thread);
															}
														}
													} finally {
														$percent_progress_start_time$.rebind(_prev_bind_10, thread);
														$within_noting_percent_progress$.rebind(_prev_bind_9, thread);
														$last_percent_progress_prediction$.rebind(_prev_bind_1_$486,
																thread);
														$last_percent_progress_index$.rebind(_prev_bind_0_$480, thread);
													}
												}
											} else {
												final SubLObject idx = unrepresented_terms
														.do_unrepresented_terms_table();
												final SubLObject mess = dumper.$str480$Dumping_unrepresented_term_indice;
												final SubLObject total2 = id_index_count(idx);
												SubLObject sofar2 = ZERO_INTEGER;
												assert NIL != stringp(mess) : "! stringp(mess) "
														+ ("Types.stringp(mess) "
																+ "CommonSymbols.NIL != Types.stringp(mess) ")
														+ mess;
												final SubLObject _prev_bind_0_$482 = $last_percent_progress_index$
														.currentBinding(thread);
												final SubLObject _prev_bind_1_$487 = $last_percent_progress_prediction$
														.currentBinding(thread);
												final SubLObject _prev_bind_11 = $within_noting_percent_progress$
														.currentBinding(thread);
												final SubLObject _prev_bind_12 = $percent_progress_start_time$
														.currentBinding(thread);
												try {
													$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
													$last_percent_progress_prediction$.bind(NIL, thread);
													$within_noting_percent_progress$.bind(T, thread);
													$percent_progress_start_time$.bind(get_universal_time(), thread);
													try {
														noting_percent_progress_preamble(mess);
														final SubLObject idx_$495 = idx;
														if (NIL == id_index_objects_empty_p(idx_$495, $SKIP)) {
															final SubLObject idx_$496 = idx_$495;
															if (NIL == id_index_dense_objects_empty_p(idx_$496,
																	$SKIP)) {
																final SubLObject vector_var = id_index_dense_objects(
																		idx_$496);
																final SubLObject backwardP_var = NIL;
																SubLObject id;
																SubLObject length;
																SubLObject v_iteration;
																SubLObject unrepresented_term3;
																for (length = length(
																		vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																				.numL(length); v_iteration = add(
																						v_iteration, ONE_INTEGER)) {
																	id = (NIL != backwardP_var)
																			? subtract(length, v_iteration, ONE_INTEGER)
																			: v_iteration;
																	unrepresented_term3 = aref(vector_var, id);
																	if ((NIL == id_index_tombstone_p(
																			unrepresented_term3))
																			|| (NIL == id_index_skip_tombstones_p(
																					$SKIP))) {
																		if (NIL != id_index_tombstone_p(
																				unrepresented_term3)) {
																			unrepresented_term3 = $SKIP;
																		}
																		file_vector.update_file_vector_index_linear(
																				fvector);
																		dumper.dump_unrepresented_term_index(
																				unrepresented_term3, stream_$473,
																				complex_fvector);
																		sofar2 = add(sofar2, ONE_INTEGER);
																		note_percent_progress(sofar2, total2);
																	}
																}
															}
															final SubLObject idx_$497 = idx_$495;
															if ((NIL == id_index_sparse_objects_empty_p(idx_$497))
																	|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																final SubLObject sparse = id_index_sparse_objects(
																		idx_$497);
																SubLObject id4 = id_index_sparse_id_threshold(idx_$497);
																final SubLObject end_id = id_index_next_id(idx_$497);
																final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																		$SKIP)) ? NIL : $SKIP;
																while (id4.numL(end_id)) {
																	final SubLObject unrepresented_term2 = gethash_without_values(
																			id4, sparse, v_default);
																	if ((NIL == id_index_skip_tombstones_p($SKIP))
																			|| (NIL == id_index_tombstone_p(
																					unrepresented_term2))) {
																		file_vector.update_file_vector_index_linear(
																				fvector);
																		dumper.dump_unrepresented_term_index(
																				unrepresented_term2, stream_$473,
																				complex_fvector);
																		sofar2 = add(sofar2, ONE_INTEGER);
																		note_percent_progress(sofar2, total2);
																	}
																	id4 = add(id4, ONE_INTEGER);
																}
															}
														}
													} finally {
														final SubLObject _prev_bind_0_$483 = $is_thread_performing_cleanupP$
																.currentBinding(thread);
														try {
															$is_thread_performing_cleanupP$.bind(T, thread);
															final SubLObject _values4 = getValuesAsVector();
															noting_percent_progress_postamble();
															restoreValuesFromVector(_values4);
														} finally {
															$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$483,
																	thread);
														}
													}
												} finally {
													$percent_progress_start_time$.rebind(_prev_bind_12, thread);
													$within_noting_percent_progress$.rebind(_prev_bind_11, thread);
													$last_percent_progress_prediction$.rebind(_prev_bind_1_$487,
															thread);
													$last_percent_progress_index$.rebind(_prev_bind_0_$482, thread);
												}
											}
											dumper.possibly_persist_wide_fvector_mark(fvector,
													dumper.$str474$unrepresented_term_indices_index, directory_path,
													dumper.$$$unrepresented_term_indices);
											if (NIL != dumper.$separate_file_for_complex_indexingP$
													.getDynamicValue(thread)) {
												dumper.possibly_persist_wide_fvector_mark(complex_fvector,
														dumper.$str477$unrepresented_term_complex_indice,
														directory_path,
														dumper.$str478$complex_unrepresented_term_indice);
											}
										} finally {
											final SubLObject _prev_bind_0_$484 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values5 = getValuesAsVector();
												close(compinx_stream, UNPROVIDED);
												restoreValuesFromVector(_values5);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$484, thread);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$485 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values6 = getValuesAsVector();
											if (stream_$476.isStream()) {
												close(stream_$476, UNPROVIDED);
											}
											restoreValuesFromVector(_values6);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$485, thread);
										}
									}
									dumper.discard_dump_filename(filename_var_$476);
								} finally {
									final SubLObject _prev_bind_0_$486 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values7 = getValuesAsVector();
										close(complex_stream, UNPROVIDED);
										restoreValuesFromVector(_values7);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$486, thread);
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$487 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values8 = getValuesAsVector();
									if (stream_$475.isStream()) {
										close(stream_$475, UNPROVIDED);
									}
									restoreValuesFromVector(_values8);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$487, thread);
								}
							}
							dumper.discard_dump_filename(filename_var_$475);
						} finally {
							final SubLObject _prev_bind_0_$488 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values9 = getValuesAsVector();
								close(index_stream, UNPROVIDED);
								restoreValuesFromVector(_values9);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$488, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$489 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values10 = getValuesAsVector();
							if (stream_$474.isStream()) {
								close(stream_$474, UNPROVIDED);
							}
							restoreValuesFromVector(_values10);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$489, thread);
						}
					}
					dumper.discard_dump_filename(filename_var_$474);
				} finally {
					final SubLObject _prev_bind_0_$490 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values11 = getValuesAsVector();
						close(stream_$473, UNPROVIDED);
						restoreValuesFromVector(_values11);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$490, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$491 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values12 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values12);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$491, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		if (NIL == dumper.$separate_file_for_complex_indexingP$.getDynamicValue(thread)) {
			final SubLObject str = dumper.$str424$Cleaning_up_empty_complex_indexin;
			final SubLObject _prev_bind_13 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_14 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_15 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_16 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_17 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_18 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_19 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_20 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				sleep(ONE_INTEGER);
				Filesys.delete_file(complex_file);
				Filesys.delete_file(compinx_file);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_20, thread);
				$is_noting_progressP$.rebind(_prev_bind_19, thread);
				$progress_count$.rebind(_prev_bind_18, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_17, thread);
				$progress_notification_count$.rebind(_prev_bind_16, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_15, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_14, thread);
				$progress_start_time$.rebind(_prev_bind_13, thread);
			}
		}
		return NIL;
	}

	public static SubLObject snapshot_unrepresented_term_indices(final SubLObject active_dir,
			final SubLObject directory_path) {
		return dumper.snapshot_managed_object_simple_complex_index(dumper.SNAPSHOT_UNREPRESENTED_TERM_INDICES_INTERNAL,
				dumper.$$$unrepresented_term, active_dir, directory_path);
	}

	public static SubLObject snapshot_unrepresented_term_indices_internal(final SubLObject active_dir,
			final SubLObject directory_path, SubLObject widen_fvectorP, SubLObject widen_complexP) {
		if (widen_fvectorP == UNPROVIDED) {
			widen_fvectorP = NIL;
		}
		if (widen_complexP == UNPROVIDED) {
			widen_complexP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject current;
		final SubLObject datum = current = dumper.replicate_fv_dump_files(dumper.$list483, dumper.$list484,
				list(dumper.get_wide_mark_basename_from_index_basename(dumper.$str474$unrepresented_term_indices_index),
						dumper.get_wide_mark_basename_from_index_basename(
								dumper.$str477$unrepresented_term_complex_indice)),
				list(widen_fvectorP, widen_complexP), active_dir, directory_path, cconcatenate(
						dumper.$str485$Copying_unrepresented_term_indice, format_nil.format_nil_a_no_copy(active_dir)));
		SubLObject new_dfile = NIL;
		SubLObject new_ifile = NIL;
		SubLObject new_iwmark = NIL;
		SubLObject new_cdfile = NIL;
		SubLObject new_cifile = NIL;
		SubLObject new_cwmark = NIL;
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_dfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_ifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_iwmark = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cdfile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cifile = current.first();
		current = current.rest();
		destructuring_bind_must_consp(current, datum, dumper.$list429);
		new_cwmark = current.first();
		current = current.rest();
		if (NIL == current) {
			final SubLObject bufsize = file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject small_bufsize = file_utilities.$default_small_stream_buffer_size$.getDynamicValue(thread);
			final SubLObject fvector = file_vector.open_file_vector_for_rewrite(new_dfile, new_ifile, new_iwmark,
					bufsize, small_bufsize, UNPROVIDED);
			final SubLObject complex_fvector = file_vector.open_file_vector_for_append(new_cdfile, new_cifile,
					new_cwmark, bufsize, bufsize, UNPROVIDED);
			try {
				dumper.snapshot_deleted_object_tombstones(fvector,
						unrepresented_terms.deleted_unrepresented_term_id_iterator(),
						dumper.$str486$Tombstoning_deleted_unrepresented);
				compatibility.set_file_position(file_vector.get_file_vector_data_stream(fvector), $END);
				dumper.snapshot_changed_managed_objects(fvector, complex_fvector,
						unrepresented_term_index_manager.new_muted_unrepresented_term_index_iterator(),
						dumper.FIND_UNREPRESENTED_TERM_BY_SUID, dumper.SNAPSHOT_UNREPRESENTED_TERM_INDEX,
						dumper.$str488$Updating_changed_unrepresented_te);
				if (NIL != unrepresented_terms.has_new_unrepresented_termsP()) {
					file_vector.file_vector_change_stream_buffer_sizes(fvector, bufsize, bufsize);
					dumper.snapshot_new_managed_objects(fvector,
							unrepresented_terms.new_new_unrepresented_terms_iterator(),
							unrepresented_term_index_manager.get_file_backed_unrepresented_term_internal_id_threshold(),
							dumper.UNREPRESENTED_TERM_SUID, dumper.DUMP_UNREPRESENTED_TERM_INDEX,
							dumper.$str490$Appending_new_unrepresented_term_, complex_fvector);
				}
				dumper.possibly_persist_wide_fvector_mark(fvector, dumper.$str474$unrepresented_term_indices_index,
						directory_path, dumper.$$$unrepresented_term_indices);
				dumper.possibly_persist_wide_fvector_mark(complex_fvector,
						dumper.$str477$unrepresented_term_complex_indice, directory_path,
						dumper.$str478$complex_unrepresented_term_indice);
			} finally {
				final SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					file_vector.close_file_vector(fvector);
					file_vector.close_file_vector(complex_fvector);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
				}
			}
		} else {
			cdestructuring_bind_error(datum, dumper.$list429);
		}
		return NIL;
	}

	public static SubLObject new_niniveh_unrepresented_term_indices_iterator(final SubLObject directory_path) {
		return dumper.new_niniveh_index_iterator(dumper.$str473$unrepresented_term_indices, directory_path);
	}

	public static final SubLObject load_unrepresented_term_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt141$unrepresented_term_indices,
						directory_path, UNPROVIDED);
				SubLObject index_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt142$unrepresented_term_indices_index, directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(index_file))) {
					format(T, $str_alt144$__Unrepresented_term_indexing_wil, cfasl_file, index_file);
					initialize_unrepresented_term_index_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
						{
							SubLObject filename_var = cfasl_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_63 = stream;
									SubLObject total = unrepresented_terms.kb_unrepresented_term_count();
									SubLObject sofar = ZERO_INTEGER;
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_63);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble(
													$str_alt145$Loading_unrepresented_term_indice);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_63, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_63,
																NIL, UNPROVIDED)) {
													sofar = add(sofar, ONE_INTEGER);
													note_percent_progress(sofar, total);
													if (dump_id.isInteger()) {
														com.cyc.cycjava.cycl.dumper
																.load_unrepresented_term_index(dump_id, stream_63);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_unrepresented_term_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str473$unrepresented_term_indices, directory_path,
				UNPROVIDED);
		final SubLObject index_file = dumper.kb_dump_file(dumper.$str474$unrepresented_term_indices_index,
				directory_path, UNPROVIDED);
		final SubLObject complex_file = dumper.kb_dump_file(dumper.$str476$unrepresented_term_complex_indice,
				directory_path, UNPROVIDED);
		final SubLObject compinx_file = dumper.kb_dump_file(dumper.$str477$unrepresented_term_complex_indice,
				directory_path, UNPROVIDED);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(complex_file))) {
			format(T, dumper.$str491$__Unrepresented_term_indexing_wil, cfasl_file, index_file);
			format(T, dumper.$str492$__Unrepresented_complex_term_inde, complex_file, compinx_file);
			unrepresented_term_index_manager.initialize_unrepresented_term_index_hl_store_cache();
			if (NIL != unrepresented_term_index_manager.wide_unrepresented_term_index_hl_store_cacheP()) {
				format(T, dumper.$str493$___Unrepresented_term_indices_use);
			}
			if (NIL != unrepresented_term_index_manager.wide_unrepresented_term_complex_index_hl_store_cacheP()) {
				format(T, dumper.$str494$___Unrepresented_term_complex_ind);
			}
		} else if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(index_file))) {
			format(T, dumper.$str491$__Unrepresented_term_indexing_wil, cfasl_file, index_file);
			unrepresented_term_index_manager.initialize_unrepresented_term_index_hl_store_cache();
			if (NIL != unrepresented_term_index_manager.wide_unrepresented_term_index_hl_store_cacheP()) {
				format(T, dumper.$str493$___Unrepresented_term_indices_use);
			}
		} else if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$507 = stream;
				if ($INPUT == $INPUT) {
					stream_$507 = file_utilities.enable_file_stream_memory_mapping(stream_$507);
				}
				try {
					final SubLObject total = unrepresented_terms.kb_unrepresented_term_count();
					SubLObject sofar = ZERO_INTEGER;
					dumper.load_copyright(stream_$507);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$str495$Loading_unrepresented_term_indice);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$507, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$507, NIL, UNPROVIDED)) {
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
								if (dump_id.isInteger()) {
									dumper.load_unrepresented_term_index(dump_id, stream_$507);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$508 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$508, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$507, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		return NIL;
	}

	public static final SubLObject dump_unrepresented_term_index(SubLObject unrepresented_term, SubLObject stream) {
		{
			SubLObject index = unrepresented_terms.unrepresented_term_index(unrepresented_term);
			cfasl_output(unrepresented_terms.unrepresented_term_dump_id(unrepresented_term), stream);
			cfasl_output(index, stream);
		}
		return NIL;
	}

	public static SubLObject dump_unrepresented_term_index(final SubLObject unrepresented_term, final SubLObject stream,
			final SubLObject fvector) {
		final SubLObject index = unrepresented_terms.unrepresented_term_index(unrepresented_term);
		final SubLObject id = unrepresented_terms.unrepresented_term_dump_id(unrepresented_term);
		dumper.dump_top_level_index_of_type(unrepresented_term, id, index, stream, dumper.$$$unrepresented_term,
				fvector, dumper.$UNREPRESENTED_TERM_INDEX);
		return NIL;
	}

	public static SubLObject snapshot_unrepresented_term_index(final SubLObject unrepresented_term,
			final SubLObject old_index, final SubLObject data_stream, final SubLObject complex_fvector) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = old_index;
		final SubLObject id = unrepresented_terms.unrepresented_term_dump_id(unrepresented_term);
		if (NIL != complex_index_p(index)) {
			SubLObject problem = NIL;
			try {
				thread.throwStack.push($catch_error_message_target$.getGlobalValue());
				final SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
				try {
					Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
					try {
						index = indexing_utilities.dump_changed_swappable_complex_index(index, complex_fvector,
								dumper.$UNREPRESENTED_TERM_INDEX);
					} catch (final Throwable catch_var) {
						Errors.handleThrowable(catch_var, NIL);
					}
				} finally {
					Errors.$error_handler$.rebind(_prev_bind_0, thread);
				}
			} catch (final Throwable ccatch_env_var) {
				problem = Errors.handleThrowable(ccatch_env_var, $catch_error_message_target$.getGlobalValue());
			} finally {
				thread.throwStack.pop();
			}
			if (problem.isString()) {
				Errors.error(dumper.$str496$Could_not_dump_the_unrepresented_, unrepresented_term, id, problem);
			}
		}
		cfasl_output(id, data_stream);
		cfasl_output(index, data_stream);
		return NIL;
	}

	public static final SubLObject load_unrepresented_term_index_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject unrepresented_term = unrepresented_terms.find_unrepresented_term_by_dump_id(dump_id);
			return unrepresented_terms.reset_unrepresented_term_index(unrepresented_term,
					cfasl_input(stream, UNPROVIDED, UNPROVIDED), UNPROVIDED);
		}
	}

	public static SubLObject load_unrepresented_term_index(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject unrepresented_term = unrepresented_terms.find_unrepresented_term_by_dump_id(dump_id);
		return unrepresented_terms.reset_unrepresented_term_index(unrepresented_term,
				cfasl_input(stream, UNPROVIDED, UNPROVIDED), UNPROVIDED);
	}

	public static final SubLObject load_unrepresented_term_index_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject index = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						index = com.cyc.cycjava.cycl.dumper.load_unrepresented_term_index(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return index;
			}
		}
	}

	public static SubLObject load_unrepresented_term_index_from_cache(final SubLObject dump_id,
			final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject index = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			index = dumper.load_unrepresented_term_index(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return index;
	}

	public static final SubLObject dump_assertion_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject indices_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt147$assertion_indices,
						directory_path, UNPROVIDED);
				SubLObject filename_var = indices_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_64 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_64);
						{
							SubLObject idx = assertion_handles.do_assertions_table();
							SubLObject total = id_index_count(idx);
							SubLObject sofar = ZERO_INTEGER;
							SubLTrampolineFile.checkType($$$Dumping_assertion_indices, STRINGP);
							{
								SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($$$Dumping_assertion_indices);
									if (NIL == do_id_index_empty_p(idx, $SKIP)) {
										{
											SubLObject id = do_id_index_next_id(idx, T, NIL, NIL);
											SubLObject state_var = do_id_index_next_state(idx, T, id, NIL);
											SubLObject assertion = NIL;
											while (NIL != id) {
												assertion = do_id_index_state_object(idx, $SKIP, id, state_var);
												if (NIL != do_id_index_id_and_object_validP(id, assertion, $SKIP)) {
													note_percent_progress(sofar, total);
													sofar = add(sofar, ONE_INTEGER);
													if (NIL != assertion_utilities
															.assertion_has_meta_assertionsP(assertion)) {
														com.cyc.cycjava.cycl.dumper.dump_assertion_index(assertion,
																stream_64);
													}
												}
												id = do_id_index_next_id(idx, T, id, state_var);
												state_var = do_id_index_next_state(idx, T, id, state_var);
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0, thread);
								}
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_assertion_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject indices_file = dumper.kb_dump_file(dumper.$str498$assertion_indices, directory_path,
				UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = indices_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$509 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$509, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$510 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$510 = file_utilities.enable_file_stream_memory_mapping(stream_$510);
				}
				try {
					dumper.dump_copyright(stream_$510);
					final SubLObject idx = assertion_handles.do_assertions_table();
					final SubLObject mess = dumper.$$$Dumping_assertion_indices;
					final SubLObject total = id_index_count(idx);
					SubLObject sofar = ZERO_INTEGER;
					assert NIL != stringp(mess) : "! stringp(mess) "
							+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
					final SubLObject _prev_bind_0_$510 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_1_$512 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(mess);
							final SubLObject idx_$513 = idx;
							if (NIL == id_index_objects_empty_p(idx_$513, $SKIP)) {
								final SubLObject idx_$514 = idx_$513;
								if (NIL == id_index_dense_objects_empty_p(idx_$514, $SKIP)) {
									final SubLObject vector_var = id_index_dense_objects(idx_$514);
									final SubLObject backwardP_var = NIL;
									SubLObject length;
									SubLObject v_iteration;
									SubLObject a_id;
									SubLObject a_handle;
									SubLObject assertion;
									for (length = length(
											vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
													.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
										a_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
												: v_iteration;
										a_handle = aref(vector_var, a_id);
										if ((NIL == id_index_tombstone_p(a_handle))
												|| (NIL == id_index_skip_tombstones_p($SKIP))) {
											if (NIL != id_index_tombstone_p(a_handle)) {
												a_handle = $SKIP;
											}
											assertion = assertion_handles.resolve_assertion_id_value_pair(a_id,
													a_handle);
											if (NIL != assertion_utilities.assertion_has_meta_assertionsP(assertion)) {
												dumper.dump_assertion_index(assertion, stream_$510);
											}
											sofar = add(sofar, ONE_INTEGER);
											note_percent_progress(sofar, total);
										}
									}
								}
								final SubLObject idx_$515 = idx_$513;
								if ((NIL == id_index_sparse_objects_empty_p(idx_$515))
										|| (NIL == id_index_skip_tombstones_p($SKIP))) {
									final SubLObject sparse = id_index_sparse_objects(idx_$515);
									SubLObject a_id2 = id_index_sparse_id_threshold(idx_$515);
									final SubLObject end_id = id_index_next_id(idx_$515);
									final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL
											: $SKIP;
									while (a_id2.numL(end_id)) {
										final SubLObject a_handle2 = gethash_without_values(a_id2, sparse, v_default);
										if ((NIL == id_index_skip_tombstones_p($SKIP))
												|| (NIL == id_index_tombstone_p(a_handle2))) {
											final SubLObject assertion2 = assertion_handles
													.resolve_assertion_id_value_pair(a_id2, a_handle2);
											if (NIL != assertion_utilities.assertion_has_meta_assertionsP(assertion2)) {
												dumper.dump_assertion_index(assertion2, stream_$510);
											}
											sofar = add(sofar, ONE_INTEGER);
											note_percent_progress(sofar, total);
										}
										a_id2 = add(a_id2, ONE_INTEGER);
									}
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$511 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$511, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_4, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_1_$512, thread);
						$last_percent_progress_index$.rebind(_prev_bind_0_$510, thread);
					}
				} finally {
					final SubLObject _prev_bind_0_$512 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$510, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$512, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$513 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$513, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_assertion_indices_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt147$assertion_indices,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_65 = stream;
								SubLObject total = file_length(stream_65);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_65);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($$$Loading_assertion_indices);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_65, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_65, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_65),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_assertion_index(dump_id,
															stream_65);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_assertion_indices(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str498$assertion_indices, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$519 = stream;
				if ($INPUT == $INPUT) {
					stream_$519 = file_utilities.enable_file_stream_memory_mapping(stream_$519);
				}
				try {
					final SubLObject total = file_length(stream_$519);
					dumper.load_copyright(stream_$519);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$$$Loading_assertion_indices);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$519, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$519, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$519), total);
								if (dump_id.isInteger()) {
									dumper.load_assertion_index(dump_id, stream_$519);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$520 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$520, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$519, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static SubLObject replicate_meta_assertion_indexing(final SubLObject part_directory) {
		final SubLObject src_misc_file = dumper.kb_dump_file(dumper.$str498$assertion_indices, part_directory,
				UNPROVIDED);
		final SubLObject trg_misc_file = dumper.kb_dump_file(dumper.$str498$assertion_indices,
				misc_utilities.generic_caches_directory(), UNPROVIDED);
		file_utilities.copy_file_checked(src_misc_file, trg_misc_file);
		return part_directory;
	}

	public static final SubLObject dump_assertion_index_alt(SubLObject assertion, SubLObject stream) {
		{
			SubLObject index = assertions_low.assertion_index(assertion);
			cfasl_output(assertions_high.assertion_dump_id(assertion), stream);
			cfasl_output(index, stream);
		}
		return NIL;
	}

	public static SubLObject dump_assertion_index(final SubLObject assertion, final SubLObject stream) {
		final SubLObject index = assertions_low.assertion_index(assertion);
		cfasl_output(assertions_high.assertion_dump_id(assertion), stream);
		cfasl_output(index, stream);
		return NIL;
	}

	public static final SubLObject load_assertion_index_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject assertion = assertions_high.find_assertion_by_dump_id(dump_id);
			return assertions_low.reset_assertion_index(assertion, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		}
	}

	public static SubLObject load_assertion_index(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject assertion = assertions_high.find_assertion_by_dump_id(dump_id);
		return assertions_low.reset_assertion_index(assertion, cfasl_input(stream, UNPROVIDED, UNPROVIDED));
	}

	public static final SubLObject dump_auxiliary_indices_file_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject misc_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt150$auxiliary_indices,
						directory_path, UNPROVIDED);
				SubLObject filename_var = misc_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_66 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_66);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt151$Dumping_auxiliary_indices___);
								auxiliary_indexing.dump_auxiliary_indices(stream_66);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_auxiliary_indices_file(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject misc_file = dumper.kb_dump_file(dumper.$str501$auxiliary_indices, directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = misc_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$521 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$521, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$522 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$522 = file_utilities.enable_file_stream_memory_mapping(stream_$522);
				}
				try {
					dumper.dump_copyright(stream_$522);
					final SubLObject str = dumper.$str502$Dumping_auxiliary_indices____;
					final SubLObject _prev_bind_0_$522 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_1_$524 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						auxiliary_indexing.dump_auxiliary_indices(stream_$522);
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_8, thread);
						$is_noting_progressP$.rebind(_prev_bind_7, thread);
						$progress_count$.rebind(_prev_bind_6, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
						$progress_notification_count$.rebind(_prev_bind_4, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_1_$524, thread);
						$progress_start_time$.rebind(_prev_bind_0_$522, thread);
					}
				} finally {
					final SubLObject _prev_bind_0_$523 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$522, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$523, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$524 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$524, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_auxiliary_indices_file_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt150$auxiliary_indices,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_67 = stream;
								SubLObject total = file_length(stream_67);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_67);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($$$Loading_auxiliary_indices);
										auxiliary_indexing.load_auxiliary_indices(stream_67);
										if (cfasl_input(stream_67, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_67)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_auxiliary_indices_file(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str501$auxiliary_indices, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$527 = stream;
				if ($INPUT == $INPUT) {
					stream_$527 = file_utilities.enable_file_stream_memory_mapping(stream_$527);
				}
				try {
					final SubLObject total = file_length(stream_$527);
					dumper.load_copyright(stream_$527);
					final SubLObject str = dumper.$$$Loading_auxiliary_indices;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						auxiliary_indexing.load_auxiliary_indices(stream_$527);
						if (cfasl_input(stream_$527, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$527)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$527, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static SubLObject replicate_auxiliary_assertion_indexing(final SubLObject part_directory) {
		final SubLObject src_misc_file = dumper.kb_dump_file(dumper.$str501$auxiliary_indices, part_directory,
				UNPROVIDED);
		final SubLObject trg_misc_file = dumper.kb_dump_file(dumper.$str501$auxiliary_indices,
				misc_utilities.generic_caches_directory(), UNPROVIDED);
		file_utilities.copy_file_checked(src_misc_file, trg_misc_file);
		return part_directory;
	}

	public static final SubLObject dump_bookkeeping_indices_file_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject misc_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt153$bookkeeping_indices,
						directory_path, UNPROVIDED);
				SubLObject filename_var = misc_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_68 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_68);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($$$Dumping_bookkeeping_indices);
								com.cyc.cycjava.cycl.dumper.dump_bookkeeping_indices(stream_68);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_bookkeeping_indices_file(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject misc_file = dumper.kb_dump_file(dumper.$str504$bookkeeping_indices, directory_path,
				UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = misc_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$528 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$528, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$529 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$529 = file_utilities.enable_file_stream_memory_mapping(stream_$529);
				}
				try {
					dumper.dump_copyright(stream_$529);
					final SubLObject str = dumper.$$$Dumping_bookkeeping_indices;
					final SubLObject _prev_bind_0_$529 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_1_$531 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						dumper.dump_bookkeeping_indices(stream_$529);
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_8, thread);
						$is_noting_progressP$.rebind(_prev_bind_7, thread);
						$progress_count$.rebind(_prev_bind_6, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
						$progress_notification_count$.rebind(_prev_bind_4, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_1_$531, thread);
						$progress_start_time$.rebind(_prev_bind_0_$529, thread);
					}
				} finally {
					final SubLObject _prev_bind_0_$530 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$529, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$530, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$531 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$531, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_bookkeeping_indices_file_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_unit_file(directory_path, $str_alt153$bookkeeping_indices,
				LOAD_BOOKKEEPING_INDICES, $str_alt156$Loading_bookkeeping_indices___);
	}

	public static SubLObject load_bookkeeping_indices_file(final SubLObject directory_path) {
		return dumper.load_unit_file(directory_path, dumper.$str504$bookkeeping_indices,
				dumper.LOAD_BOOKKEEPING_INDICES, dumper.$str507$Loading_bookkeeping_indices____);
	}

	public static final SubLObject dump_bookkeeping_indices_alt(SubLObject stream) {
		cfasl_output(dumper_dumpable_bookkeeping_index(), stream);
		return NIL;
	}

	public static SubLObject dump_bookkeeping_indices(final SubLObject stream) {
		cfasl_output(bookkeeping_store.dumper_dumpable_bookkeeping_index(), stream);
		return NIL;
	}

	public static final SubLObject load_bookkeeping_indices_alt(SubLObject stream) {
		{
			SubLObject index = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			dumper_load_bookkeeping_index(index);
		}
		return NIL;
	}

	public static SubLObject load_bookkeeping_indices(final SubLObject stream) {
		final SubLObject index = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		bookkeeping_store.dumper_load_bookkeeping_index(index);
		return NIL;
	}

	public static final SubLObject dump_rule_set_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject indices_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt157$rule_set, directory_path,
						UNPROVIDED);
				{
					SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
					try {
						$noting_progress_start_time$.bind(get_universal_time(), thread);
						noting_progress_preamble($str_alt158$Dumping_rule_set___);
						{
							SubLObject filename_var = indices_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0_69 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_69, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_70 = stream;
									com.cyc.cycjava.cycl.dumper.dump_copyright(stream_70);
									assertions_low.dump_rule_set_to_stream(stream_70);
								}
							} finally {
								{
									SubLObject _prev_bind_0_71 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_71, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
						noting_progress_postamble();
					} finally {
						$noting_progress_start_time$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_rule_set(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject indices_file = dumper.kb_dump_file(dumper.$str508$rule_set, directory_path, UNPROVIDED);
			final SubLObject str = dumper.$str509$Dumping_rule_set____;
			final SubLObject _prev_bind_0_$534 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_1_$535 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				final SubLObject filename_var = indices_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$535 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$535, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$537 = stream;
					if ($OUTPUT == $INPUT) {
						stream_$537 = file_utilities.enable_file_stream_memory_mapping(stream_$537);
					}
					try {
						dumper.dump_copyright(stream_$537);
						assertions_low.dump_rule_set_to_stream(stream_$537);
					} finally {
						final SubLObject _prev_bind_0_$536 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$537, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$536, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$537 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$537, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_1_$535, thread);
				$progress_start_time$.rebind(_prev_bind_0_$534, thread);
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_rule_set_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_unit_file(directory_path, $str_alt157$rule_set,
				LOAD_RULE_SET_FROM_STREAM, $str_alt160$Loading_rule_set___);
	}

	public static SubLObject load_rule_set(final SubLObject directory_path) {
		return dumper.load_unit_file(directory_path, dumper.$str508$rule_set, dumper.LOAD_RULE_SET_FROM_STREAM,
				dumper.$str511$Loading_rule_set____);
	}

	public static SubLObject dump_non_true_assertion_tv_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject indices_file = dumper.kb_dump_file(dumper.$str512$non_true_assertion_tv_cache,
					directory_path, UNPROVIDED);
			final SubLObject str = dumper.$str513$Dumping_non_true_assertion_tv_cac;
			final SubLObject _prev_bind_0_$540 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_1_$541 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				final SubLObject filename_var = indices_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$541 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$541, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$543 = stream;
					if ($OUTPUT == $INPUT) {
						stream_$543 = file_utilities.enable_file_stream_memory_mapping(stream_$543);
					}
					try {
						dumper.dump_copyright(stream_$543);
						assertions_low.dump_non_true_assertion_tv_cache_to_stream(stream_$543);
					} finally {
						final SubLObject _prev_bind_0_$542 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$543, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$542, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$543 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$543, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_1_$541, thread);
				$progress_start_time$.rebind(_prev_bind_0_$540, thread);
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject load_non_true_assertion_tv_cache(final SubLObject directory_path) {
		return dumper.load_unit_file(directory_path, dumper.$str512$non_true_assertion_tv_cache,
				dumper.LOAD_NON_TRUE_ASSERTION_TV_CACHE_FROM_STREAM, dumper.$str515$Loading_non_true_assertion_tv_cac);
	}

	public static final SubLObject dump_nart_hl_formulas_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject nart_hl_formula_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt161$nart_hl_formula,
						directory_path, UNPROVIDED);
				SubLObject nart_hl_formula_index_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt162$nart_hl_formula_index, directory_path, UNPROVIDED);
				SubLObject filename_var = nart_hl_formula_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_72 = stream;
						SubLObject filename_var_73 = nart_hl_formula_index_file;
						SubLObject stream_74 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_74 = compatibility.open_binary(filename_var_73, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_74.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_73);
							}
							{
								SubLObject index_stream = stream_74;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_72);
								{
									SubLObject fvector = create_file_vector(stream_72, index_stream);
									SubLObject message_var = NIL;
									try {
										{
											SubLObject _prev_bind_0 = Errors.$error_handler$.currentBinding(thread);
											try {
												Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
												try {
													{
														SubLObject idx = nart_handles.do_narts_table();
														SubLObject total = id_index_count(idx);
														SubLObject sofar = ZERO_INTEGER;
														SubLTrampolineFile.checkType($$$Dumping_NART_HL_formulas,
																STRINGP);
														{
															SubLObject _prev_bind_0_75 = $last_percent_progress_index$
																	.currentBinding(thread);
															SubLObject _prev_bind_1 = $last_percent_progress_prediction$
																	.currentBinding(thread);
															SubLObject _prev_bind_2 = $within_noting_percent_progress$
																	.currentBinding(thread);
															SubLObject _prev_bind_3 = $percent_progress_start_time$
																	.currentBinding(thread);
															try {
																$last_percent_progress_index$.bind(ZERO_INTEGER,
																		thread);
																$last_percent_progress_prediction$.bind(NIL, thread);
																$within_noting_percent_progress$.bind(T, thread);
																$percent_progress_start_time$.bind(get_universal_time(),
																		thread);
																noting_percent_progress_preamble(
																		$$$Dumping_NART_HL_formulas);
																if (NIL == do_id_index_empty_p(idx, $SKIP)) {
																	{
																		SubLObject id = do_id_index_next_id(idx, T, NIL,
																				NIL);
																		SubLObject state_var = do_id_index_next_state(
																				idx, T, id, NIL);
																		SubLObject nart = NIL;
																		while (NIL != id) {
																			nart = do_id_index_state_object(idx, $SKIP,
																					id, state_var);
																			if (NIL != do_id_index_id_and_object_validP(
																					id, nart, $SKIP)) {
																				note_percent_progress(sofar, total);
																				sofar = add(sofar, ONE_INTEGER);
																				{
																					SubLObject nart_hl_formula = narts_high
																							.nart_hl_formula(nart);
																					update_file_vector_index_linear(
																							fvector);
																					com.cyc.cycjava.cycl.dumper
																							.dump_nart_hl_formula(nart,
																									nart_hl_formula,
																									stream_72);
																				}
																			}
																			id = do_id_index_next_id(idx, T, id,
																					state_var);
																			state_var = do_id_index_next_state(idx, T,
																					id, state_var);
																		}
																	}
																}
																noting_percent_progress_postamble();
															} finally {
																$percent_progress_start_time$.rebind(_prev_bind_3,
																		thread);
																$within_noting_percent_progress$.rebind(_prev_bind_2,
																		thread);
																$last_percent_progress_prediction$.rebind(_prev_bind_1,
																		thread);
																$last_percent_progress_index$.rebind(_prev_bind_0_75,
																		thread);
															}
														}
													}
												} catch (Throwable catch_var) {
													Errors.handleThrowable(catch_var, NIL);
												}
											} finally {
												Errors.$error_handler$.rebind(_prev_bind_0, thread);
											}
										}
									} catch (Throwable ccatch_env_var) {
										message_var = Errors.handleThrowable(ccatch_env_var,
												$catch_error_message_target$.getGlobalValue());
									}
									if (message_var.isString()) {
										Errors.warn($str_alt165$_A, message_var);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_74.isStream()) {
										close(stream_74, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_73);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_nart_hl_formulas(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject nart_hl_formula_file = dumper.kb_dump_file(dumper.$str171$nart_hl_formula, directory_path,
				UNPROVIDED);
		final SubLObject nart_hl_formula_index_file = dumper.kb_dump_file(dumper.$str516$nart_hl_formula_index,
				directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = nart_hl_formula_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$546 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$546, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$547 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$547 = file_utilities.enable_file_stream_memory_mapping(stream_$547);
				}
				try {
					final SubLObject filename_var_$548 = nart_hl_formula_index_file;
					SubLObject stream_$548 = NIL;
					try {
						final SubLObject _prev_bind_0_$547 = stream_macros.$stream_requires_locking$
								.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream_$548 = compatibility.open_binary(filename_var_$548, $OUTPUT);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$547, thread);
						}
						if (!stream_$548.isStream()) {
							Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$548);
						}
						SubLObject index_stream = stream_$548;
						if ($OUTPUT == $INPUT) {
							index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
						}
						try {
							dumper.dump_copyright(stream_$547);
							final SubLObject fvector = file_vector.create_file_vector(stream_$547, index_stream);
							SubLObject message_var = NIL;
							final SubLObject was_appendingP = eval(dumper.$append_stack_traces_to_error_messagesP$);
							eval(dumper.$list518);
							try {
								try {
									thread.throwStack.push($catch_error_message_target$.getGlobalValue());
									final SubLObject _prev_bind_0_$548 = Errors.$error_handler$.currentBinding(thread);
									try {
										Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
										try {
											final SubLObject idx = nart_handles.do_narts_table();
											final SubLObject mess = dumper.$$$Dumping_NART_HL_formulas;
											final SubLObject total = id_index_count(idx);
											SubLObject sofar = ZERO_INTEGER;
											assert NIL != stringp(mess) : "! stringp(mess) " + ("Types.stringp(mess) "
													+ "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
											final SubLObject _prev_bind_0_$549 = $last_percent_progress_index$
													.currentBinding(thread);
											final SubLObject _prev_bind_1_$553 = $last_percent_progress_prediction$
													.currentBinding(thread);
											final SubLObject _prev_bind_3 = $within_noting_percent_progress$
													.currentBinding(thread);
											final SubLObject _prev_bind_4 = $percent_progress_start_time$
													.currentBinding(thread);
											try {
												$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
												$last_percent_progress_prediction$.bind(NIL, thread);
												$within_noting_percent_progress$.bind(T, thread);
												$percent_progress_start_time$.bind(get_universal_time(), thread);
												try {
													noting_percent_progress_preamble(mess);
													final SubLObject idx_$554 = idx;
													if (NIL == id_index_objects_empty_p(idx_$554, $SKIP)) {
														final SubLObject idx_$555 = idx_$554;
														if (NIL == id_index_dense_objects_empty_p(idx_$555, $SKIP)) {
															final SubLObject vector_var = id_index_dense_objects(
																	idx_$555);
															final SubLObject backwardP_var = NIL;
															SubLObject length;
															SubLObject v_iteration;
															SubLObject id;
															SubLObject nart;
															SubLObject nart_hl_formula;
															for (length = length(
																	vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																			.numL(length); v_iteration = add(
																					v_iteration, ONE_INTEGER)) {
																id = (NIL != backwardP_var)
																		? subtract(length, v_iteration, ONE_INTEGER)
																		: v_iteration;
																nart = aref(vector_var, id);
																if ((NIL == id_index_tombstone_p(nart))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	if (NIL != id_index_tombstone_p(nart)) {
																		nart = $SKIP;
																	}
																	nart_hl_formula = narts_high.nart_hl_formula(nart);
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_nart_hl_formula(nart, nart_hl_formula,
																			stream_$547);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
															}
														}
														final SubLObject idx_$556 = idx_$554;
														if ((NIL == id_index_sparse_objects_empty_p(idx_$556))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															final SubLObject sparse = id_index_sparse_objects(idx_$556);
															SubLObject id2 = id_index_sparse_id_threshold(idx_$556);
															final SubLObject end_id = id_index_next_id(idx_$556);
															final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																	$SKIP)) ? NIL : $SKIP;
															while (id2.numL(end_id)) {
																final SubLObject nart2 = gethash_without_values(id2,
																		sparse, v_default);
																if ((NIL == id_index_skip_tombstones_p($SKIP))
																		|| (NIL == id_index_tombstone_p(nart2))) {
																	final SubLObject nart_hl_formula2 = narts_high
																			.nart_hl_formula(nart2);
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_nart_hl_formula(nart2, nart_hl_formula2,
																			stream_$547);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
																id2 = add(id2, ONE_INTEGER);
															}
														}
													}
												} finally {
													final SubLObject _prev_bind_0_$550 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values = getValuesAsVector();
														noting_percent_progress_postamble();
														restoreValuesFromVector(_values);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$550,
																thread);
													}
												}
											} finally {
												$percent_progress_start_time$.rebind(_prev_bind_4, thread);
												$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
												$last_percent_progress_prediction$.rebind(_prev_bind_1_$553, thread);
												$last_percent_progress_index$.rebind(_prev_bind_0_$549, thread);
											}
										} catch (final Throwable catch_var) {
											Errors.handleThrowable(catch_var, NIL);
										}
									} finally {
										Errors.$error_handler$.rebind(_prev_bind_0_$548, thread);
									}
								} catch (final Throwable ccatch_env_var) {
									message_var = Errors.handleThrowable(ccatch_env_var,
											$catch_error_message_target$.getGlobalValue());
								} finally {
									thread.throwStack.pop();
								}
							} finally {
								final SubLObject _prev_bind_0_$551 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values2 = getValuesAsVector();
									eval(list(CSETQ, dumper.$append_stack_traces_to_error_messagesP$, was_appendingP));
									restoreValuesFromVector(_values2);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$551, thread);
								}
							}
							if (message_var.isString()) {
								Errors.warn(dumper.$str520$_A, message_var);
							}
						} finally {
							final SubLObject _prev_bind_0_$552 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values3 = getValuesAsVector();
								close(index_stream, UNPROVIDED);
								restoreValuesFromVector(_values3);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$552, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$553 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values4 = getValuesAsVector();
							if (stream_$548.isStream()) {
								close(stream_$548, UNPROVIDED);
							}
							restoreValuesFromVector(_values4);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$553, thread);
						}
					}
					dumper.discard_dump_filename(filename_var_$548);
				} finally {
					final SubLObject _prev_bind_0_$554 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values5 = getValuesAsVector();
						close(stream_$547, UNPROVIDED);
						restoreValuesFromVector(_values5);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$554, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$555 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values6 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values6);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$555, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject snapshot_nart_hl_formulas(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject nart_hl_formula_file = dumper.kb_dump_file(dumper.$str171$nart_hl_formula, directory_path,
				UNPROVIDED);
		final SubLObject nart_hl_formula_index_file = dumper.kb_dump_file(dumper.$str516$nart_hl_formula_index,
				directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = nart_hl_formula_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$563 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$563, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$564 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$564 = file_utilities.enable_file_stream_memory_mapping(stream_$564);
				}
				try {
					final SubLObject filename_var_$565 = nart_hl_formula_index_file;
					SubLObject stream_$565 = NIL;
					try {
						final SubLObject _prev_bind_0_$564 = stream_macros.$stream_requires_locking$
								.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream_$565 = compatibility.open_binary(filename_var_$565, $OUTPUT);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$564, thread);
						}
						if (!stream_$565.isStream()) {
							Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$565);
						}
						SubLObject index_stream = stream_$565;
						if ($OUTPUT == $INPUT) {
							index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
						}
						try {
							dumper.dump_copyright(stream_$564);
							final SubLObject fvector = file_vector.create_file_vector(stream_$564, index_stream);
							SubLObject expected_id = ZERO_INTEGER;
							SubLObject message_var = NIL;
							final SubLObject was_appendingP = eval(dumper.$append_stack_traces_to_error_messagesP$);
							eval(dumper.$list518);
							try {
								try {
									thread.throwStack.push($catch_error_message_target$.getGlobalValue());
									final SubLObject _prev_bind_0_$565 = Errors.$error_handler$.currentBinding(thread);
									try {
										Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
										try {
											final SubLObject idx = nart_handles.do_narts_table();
											final SubLObject mess = dumper.$$$Dumping_NART_HL_formulas;
											final SubLObject total = id_index_count(idx);
											SubLObject sofar = ZERO_INTEGER;
											assert NIL != stringp(mess) : "! stringp(mess) " + ("Types.stringp(mess) "
													+ "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
											final SubLObject _prev_bind_0_$566 = $last_percent_progress_index$
													.currentBinding(thread);
											final SubLObject _prev_bind_1_$570 = $last_percent_progress_prediction$
													.currentBinding(thread);
											final SubLObject _prev_bind_3 = $within_noting_percent_progress$
													.currentBinding(thread);
											final SubLObject _prev_bind_4 = $percent_progress_start_time$
													.currentBinding(thread);
											try {
												$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
												$last_percent_progress_prediction$.bind(NIL, thread);
												$within_noting_percent_progress$.bind(T, thread);
												$percent_progress_start_time$.bind(get_universal_time(), thread);
												try {
													noting_percent_progress_preamble(mess);
													final SubLObject idx_$571 = idx;
													if (NIL == id_index_objects_empty_p(idx_$571, $SKIP)) {
														final SubLObject idx_$572 = idx_$571;
														if (NIL == id_index_dense_objects_empty_p(idx_$572, $SKIP)) {
															final SubLObject vector_var = id_index_dense_objects(
																	idx_$572);
															final SubLObject backwardP_var = NIL;
															SubLObject length;
															SubLObject v_iteration;
															SubLObject id;
															SubLObject nart;
															SubLObject nart_hl_formula;
															SubLObject curr_id;
															for (length = length(
																	vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																			.numL(length); v_iteration = add(
																					v_iteration, ONE_INTEGER)) {
																id = (NIL != backwardP_var)
																		? subtract(length, v_iteration, ONE_INTEGER)
																		: v_iteration;
																nart = aref(vector_var, id);
																if ((NIL == id_index_tombstone_p(nart))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	if (NIL != id_index_tombstone_p(nart)) {
																		nart = $SKIP;
																	}
																	nart_hl_formula = narts_high.nart_hl_formula(nart);
																	for (curr_id = nart_handles
																			.nart_id(nart); expected_id
																					.numL(curr_id); expected_id = add(
																							expected_id, ONE_INTEGER)) {
																		file_vector.place_file_vector_index_tombstone(
																				fvector);
																	}
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_nart_hl_formula(nart, nart_hl_formula,
																			stream_$564);
																	expected_id = add(ONE_INTEGER, curr_id);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
															}
														}
														final SubLObject idx_$573 = idx_$571;
														if ((NIL == id_index_sparse_objects_empty_p(idx_$573))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															final SubLObject sparse = id_index_sparse_objects(idx_$573);
															SubLObject id2 = id_index_sparse_id_threshold(idx_$573);
															final SubLObject end_id = id_index_next_id(idx_$573);
															final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																	$SKIP)) ? NIL : $SKIP;
															while (id2.numL(end_id)) {
																final SubLObject nart2 = gethash_without_values(id2,
																		sparse, v_default);
																if ((NIL == id_index_skip_tombstones_p($SKIP))
																		|| (NIL == id_index_tombstone_p(nart2))) {
																	final SubLObject nart_hl_formula2 = narts_high
																			.nart_hl_formula(nart2);
																	SubLObject curr_id2;
																	for (curr_id2 = nart_handles
																			.nart_id(nart2); expected_id
																					.numL(curr_id2); expected_id = add(
																							expected_id, ONE_INTEGER)) {
																		file_vector.place_file_vector_index_tombstone(
																				fvector);
																	}
																	file_vector
																			.update_file_vector_index_linear(fvector);
																	dumper.dump_nart_hl_formula(nart2, nart_hl_formula2,
																			stream_$564);
																	expected_id = add(ONE_INTEGER, curr_id2);
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
																id2 = add(id2, ONE_INTEGER);
															}
														}
													}
												} finally {
													final SubLObject _prev_bind_0_$567 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values = getValuesAsVector();
														noting_percent_progress_postamble();
														restoreValuesFromVector(_values);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$567,
																thread);
													}
												}
											} finally {
												$percent_progress_start_time$.rebind(_prev_bind_4, thread);
												$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
												$last_percent_progress_prediction$.rebind(_prev_bind_1_$570, thread);
												$last_percent_progress_index$.rebind(_prev_bind_0_$566, thread);
											}
										} catch (final Throwable catch_var) {
											Errors.handleThrowable(catch_var, NIL);
										}
									} finally {
										Errors.$error_handler$.rebind(_prev_bind_0_$565, thread);
									}
								} catch (final Throwable ccatch_env_var) {
									message_var = Errors.handleThrowable(ccatch_env_var,
											$catch_error_message_target$.getGlobalValue());
								} finally {
									thread.throwStack.pop();
								}
							} finally {
								final SubLObject _prev_bind_0_$568 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values2 = getValuesAsVector();
									eval(list(CSETQ, dumper.$append_stack_traces_to_error_messagesP$, was_appendingP));
									restoreValuesFromVector(_values2);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$568, thread);
								}
							}
							if (message_var.isString()) {
								Errors.warn(dumper.$str520$_A, message_var);
							}
						} finally {
							final SubLObject _prev_bind_0_$569 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values3 = getValuesAsVector();
								close(index_stream, UNPROVIDED);
								restoreValuesFromVector(_values3);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$569, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$570 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values4 = getValuesAsVector();
							if (stream_$565.isStream()) {
								close(stream_$565, UNPROVIDED);
							}
							restoreValuesFromVector(_values4);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$570, thread);
						}
					}
					dumper.discard_dump_filename(filename_var_$565);
				} finally {
					final SubLObject _prev_bind_0_$571 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values5 = getValuesAsVector();
						close(stream_$564, UNPROVIDED);
						restoreValuesFromVector(_values5);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$571, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$572 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values6 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values6);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$572, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_nart_hl_formulas_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject nart_hl_formula_cfasl_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt161$nart_hl_formula, directory_path, UNPROVIDED);
				SubLObject nart_hl_formula_index_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt162$nart_hl_formula_index, directory_path, UNPROVIDED);
				if ((NIL == $force_monolithic_kb_assumption$.getGlobalValue())
						&& (NIL != Filesys.probe_file(nart_hl_formula_index_file))) {
					format(T, $str_alt166$__NART_HL_formulas_will_be_swappe, nart_hl_formula_cfasl_file,
							nart_hl_formula_index_file);
					nart_hl_formula_manager.initialize_nart_hl_formula_hl_store_cache();
				} else {
					if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(nart_hl_formula_cfasl_file, T)) {
						{
							SubLObject nart_hl_formula_file = nart_hl_formula_cfasl_file;
							SubLObject filename_var = nart_hl_formula_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $INPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_76 = stream;
									SubLObject total = file_length(stream_76);
									com.cyc.cycjava.cycl.dumper.load_copyright(stream_76);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble(
													$str_alt167$Loading_nart_hl_formula_definitio);
											{
												SubLObject dump_id = NIL;
												for (dump_id = cfasl_input(stream_76, NIL,
														UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_76,
																NIL, UNPROVIDED)) {
													note_percent_progress(compatibility.get_file_position(stream_76),
															total);
													if (dump_id.isInteger()) {
														com.cyc.cycjava.cycl.dumper.load_nart_hl_formula(dump_id,
																stream_76);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_nart_hl_formulas(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject nart_hl_formula_cfasl_file = dumper.kb_dump_file(dumper.$str171$nart_hl_formula,
				directory_path, UNPROVIDED);
		final SubLObject nart_hl_formula_index_file = dumper.kb_dump_file(dumper.$str516$nart_hl_formula_index,
				directory_path, UNPROVIDED);
		if ((NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue())
				&& (NIL != Filesys.probe_file(nart_hl_formula_index_file))) {
			format(T, dumper.$str521$__NART_HL_formulas_will_be_swappe, nart_hl_formula_cfasl_file,
					nart_hl_formula_index_file);
			nart_hl_formula_manager.initialize_nart_hl_formula_hl_store_cache();
		} else if (NIL != dumper.verify_file_existence(nart_hl_formula_cfasl_file, T)) {
			final SubLObject filename_var;
			final SubLObject nart_hl_formula_file = filename_var = nart_hl_formula_cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$580 = stream;
				if ($INPUT == $INPUT) {
					stream_$580 = file_utilities.enable_file_stream_memory_mapping(stream_$580);
				}
				try {
					final SubLObject total = file_length(stream_$580);
					dumper.load_copyright(stream_$580);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$str522$Loading_nart_hl_formula_definitio);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$580, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$580, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$580), total);
								if (dump_id.isInteger()) {
									dumper.load_nart_hl_formula(dump_id, stream_$580);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$581 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$581, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$580, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}

		return NIL;
	}

	public static final SubLObject dump_nart_hl_formula_alt(SubLObject nart, SubLObject nart_hl_formula,
			SubLObject stream) {
		cfasl_output(narts_high.nart_dump_id(nart), stream);
		cfasl_output(nart_hl_formula, stream);
		return nart;
	}

	public static SubLObject dump_nart_hl_formula(final SubLObject nart, final SubLObject nart_hl_formula,
			final SubLObject stream) {
		cfasl_output(narts_high.nart_dump_id(nart), stream);
		cfasl_output(nart_hl_formula, stream);
		return nart;
	}

	public static final SubLObject load_nart_hl_formula_alt(SubLObject dump_id, SubLObject stream) {
		{
			SubLObject nart_hl_formula = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			narts_low.register_nart_hl_formula_for_kb_load(dump_id, nart_hl_formula);
			return nart_hl_formula;
		}
	}

	public static SubLObject load_nart_hl_formula(final SubLObject dump_id, final SubLObject stream) {
		final SubLObject nart_hl_formula = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
		narts_low.register_nart_hl_formula_for_kb_load(dump_id, nart_hl_formula);
		return nart_hl_formula;
	}

	public static final SubLObject load_nart_hl_formula_from_cache_alt(SubLObject dump_id, SubLObject stream) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject nart_hl_formula = NIL;
				{
					SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
					try {
						$within_cfasl_externalization$.bind(NIL, thread);
						nart_hl_formula = com.cyc.cycjava.cycl.dumper.load_nart_hl_formula(dump_id, stream);
					} finally {
						$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
					}
				}
				return nart_hl_formula;
			}
		}
	}

	public static SubLObject load_nart_hl_formula_from_cache(final SubLObject dump_id, final SubLObject stream) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject nart_hl_formula = NIL;
		final SubLObject _prev_bind_0 = $within_cfasl_externalization$.currentBinding(thread);
		try {
			$within_cfasl_externalization$.bind(NIL, thread);
			nart_hl_formula = dumper.load_nart_hl_formula(dump_id, stream);
		} finally {
			$within_cfasl_externalization$.rebind(_prev_bind_0, thread);
		}
		return nart_hl_formula;
	}

	public static final SubLObject dump_miscellaneous_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject misc_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$misc, directory_path, UNPROVIDED);
				SubLObject filename_var = misc_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_77 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_77);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt169$Dumping_miscellaneous_stuff___);
								cfasl_output(NIL, stream_77);
								cfasl_output(czer_vars.$skolem_axiom_table$.getGlobalValue(), stream_77);
								cfasl_output(NIL, stream_77);
								cfasl_output(add(kb_loaded(), ONE_INTEGER), stream_77);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_miscellaneous(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject misc_file = filename_var = dumper.kb_dump_file(dumper.$$$misc, directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$582 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$582 = file_utilities.enable_file_stream_memory_mapping(stream_$582);
			}
			try {
				dumper.dump_copyright(stream_$582);
				final SubLObject str = dumper.$str524$Dumping_miscellaneous_stuff____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					cfasl_output(NIL, stream_$582);
					cfasl_output(czer_vars.$skolem_axiom_table$.getGlobalValue(), stream_$582);
					cfasl_output(NIL, stream_$582);
					final SubLObject kb_number = (NIL != dumper.$auto_increment_kb_number_on_dumpP$
							.getDynamicValue(thread)) ? add(kb_loaded(), ONE_INTEGER) : kb_loaded();
					cfasl_output(kb_number, stream_$582);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$582, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_miscellaneous_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$misc, directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_78 = stream;
								SubLObject total = file_length(stream_78);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_78);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt170$Loading_miscellaneous_stuff___);
										cfasl_input(stream_78, UNPROVIDED, UNPROVIDED);
										czer_vars.$skolem_axiom_table$
												.setGlobalValue(cfasl_input(stream_78, UNPROVIDED, UNPROVIDED));
										cfasl_input(stream_78, UNPROVIDED, UNPROVIDED);
										set_build_kb_loaded(cfasl_input(stream_78, UNPROVIDED, UNPROVIDED));
										if (cfasl_input(stream_78, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_78)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_miscellaneous(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$$$misc, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$583 = stream;
				if ($INPUT == $INPUT) {
					stream_$583 = file_utilities.enable_file_stream_memory_mapping(stream_$583);
				}
				try {
					final SubLObject total = file_length(stream_$583);
					dumper.load_copyright(stream_$583);
					final SubLObject str = dumper.$str525$Loading_miscellaneous_stuff____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						cfasl_input(stream_$583, UNPROVIDED, UNPROVIDED);
						czer_vars.$skolem_axiom_table$.setGlobalValue(cfasl_input(stream_$583, UNPROVIDED, UNPROVIDED));
						cfasl_input(stream_$583, UNPROVIDED, UNPROVIDED);
						set_build_kb_loaded(cfasl_input(stream_$583, UNPROVIDED, UNPROVIDED));
						if (cfasl_input(stream_$583, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$583)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$583, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	/**
	 * Write out the SBHL data in such a form that it becomes swappable
	 */
	@LispMethod(comment = "Write out the SBHL data in such a form that it becomes swappable")
	public static final SubLObject dump_sbhl_data_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject sbhl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt171$sbhl_modules,
						directory_path, UNPROVIDED);
				SubLObject filename_var = sbhl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_79 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_79);
						{
							SubLObject data_file = com.cyc.cycjava.cycl.dumper
									.kb_dump_file($str_alt172$sbhl_module_graphs, directory_path, UNPROVIDED);
							SubLObject index_file = com.cyc.cycjava.cycl.dumper
									.kb_dump_file($str_alt173$sbhl_module_graphs_index, directory_path, UNPROVIDED);
							SubLObject fvector = NIL;
							try {
								fvector = new_file_vector(data_file, index_file, $OUTPUT);
								{
									SubLObject data_stream = get_file_vector_data_stream(fvector);
									com.cyc.cycjava.cycl.dumper.dump_copyright(data_stream);
									{
										SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
										try {
											$noting_progress_start_time$.bind(get_universal_time(), thread);
											noting_progress_preamble($str_alt174$Dumping_SBHL_modules_and_graphs__);
											{
												SubLObject sbhl_modules = sbhl_module_vars.get_sbhl_module_list();
												cfasl_output(length(sbhl_modules), stream_79);
												{
													SubLObject cdolist_list_var = sbhl_modules;
													SubLObject module = NIL;
													for (module = cdolist_list_var
															.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var
																	.rest(), module = cdolist_list_var.first()) {
														sbhl_graphs.swap_in_all_graph_links(module);
														{
															SubLObject new_map = create_file_vector_backed_map_from_map(
																	sbhl_module_vars.get_sbhl_module_graph(module),
																	fvector, $SWAPPED_OUT);
															cfasl_output(
																	sbhl_module_vars.get_sbhl_module_link_pred(module),
																	stream_79);
															cfasl_output(new_map, stream_79);
														}
														sbhl_graphs.swap_out_all_pristine_graph_links(module);
													}
												}
											}
											noting_progress_postamble();
										} finally {
											$noting_progress_start_time$.rebind(_prev_bind_0, thread);
										}
									}
								}
							} finally {
								{
									SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (NIL != file_vector_p(fvector)) {
											close_file_vector(fvector);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(index_file);
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(data_file);
						}
						com.cyc.cycjava.cycl.dumper.dump_sbhl_miscellany(stream_79);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			com.cyc.cycjava.cycl.dumper.dump_sbhl_time_state(directory_path);
			return NIL;
		}
	}

	/**
	 * Write out the SBHL data in such a form that it becomes swappable
	 */
	@LispMethod(comment = "Write out the SBHL data in such a form that it becomes swappable")
	public static SubLObject dump_sbhl_data(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject sbhl_file = dumper.kb_dump_file(dumper.$str526$sbhl_modules, directory_path, UNPROVIDED);
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var = sbhl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$584 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$584, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$585 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$585 = file_utilities.enable_file_stream_memory_mapping(stream_$585);
				}
				try {
					dumper.dump_copyright(stream_$585);
					final SubLObject data_file = dumper.kb_dump_file(dumper.$str527$sbhl_module_graphs, directory_path,
							UNPROVIDED);
					final SubLObject index_file = dumper.kb_dump_file(dumper.$str528$sbhl_module_graphs_index,
							directory_path, UNPROVIDED);
					SubLObject fvector = NIL;
					try {
						fvector = file_vector.new_file_vector(data_file, index_file, $OUTPUT,
								file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread),
								file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), UNPROVIDED);
						dumper.kb_dump_stamp_file_vector_for_references(fvector);
						final SubLObject str = dumper.$str529$Dumping_SBHL_modules_and_graphs__;
						final SubLObject _prev_bind_0_$585 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_1_$587 = $progress_last_pacification_time$.currentBinding(thread);
						final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$
								.currentBinding(thread);
						final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
						final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
						final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
						final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
						try {
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread),
									thread);
							$progress_elapsed_seconds_for_notification$
									.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
							$progress_notification_count$.bind(ZERO_INTEGER, thread);
							$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
							$progress_count$.bind(ZERO_INTEGER, thread);
							$is_noting_progressP$.bind(T, thread);
							$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T,
									thread);
							noting_progress_preamble(str);
							final SubLObject sbhl_modules = get_sbhl_module_list();
							cfasl_output(length(sbhl_modules), stream_$585);
							SubLObject cdolist_list_var = sbhl_modules;
							SubLObject module = NIL;
							module = cdolist_list_var.first();
							while (NIL != cdolist_list_var) {
								swap_in_all_graph_links(module);
								final SubLObject new_map = file_vector_utilities.create_file_vector_backed_map_from_map(
										get_sbhl_module_graph(module), fvector, $SWAPPED_OUT, $COMPACT);
								cfasl_output(get_sbhl_module_link_pred(module), stream_$585);
								cfasl_output(new_map, stream_$585);
								swap_out_all_pristine_graph_links(module);
								cdolist_list_var = cdolist_list_var.rest();
								module = cdolist_list_var.first();
							}
							noting_progress_postamble();
						} finally {
							$silent_progressP$.rebind(_prev_bind_8, thread);
							$is_noting_progressP$.rebind(_prev_bind_7, thread);
							$progress_count$.rebind(_prev_bind_6, thread);
							$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
							$progress_notification_count$.rebind(_prev_bind_4, thread);
							$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
							$progress_last_pacification_time$.rebind(_prev_bind_1_$587, thread);
							$progress_start_time$.rebind(_prev_bind_0_$585, thread);
						}
					} finally {
						final SubLObject _prev_bind_0_$586 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							if (NIL != file_vector.file_vector_p(fvector)) {
								file_vector.close_file_vector(fvector);
							}
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$586, thread);
						}
					}
					dumper.discard_dump_filename(index_file);
					dumper.discard_dump_filename(data_file);
					dumper.dump_sbhl_miscellany(stream_$585);
				} finally {
					final SubLObject _prev_bind_0_$587 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$585, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$587, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$588 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$588, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		dumper.dump_sbhl_time_state(directory_path);
		return NIL;
	}

	public static final SubLObject load_sbhl_data_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt171$sbhl_modules,
						directory_path, UNPROVIDED);
				SubLObject data_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt172$sbhl_module_graphs,
						directory_path, UNPROVIDED);
				SubLObject index_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt173$sbhl_module_graphs_index,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					if ((NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(data_file, $WARN_ONLY))
							&& (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(index_file, $WARN_ONLY))) {
						sbhl_graphs.initialize_sbhl_graph_caches_during_load_kb(data_file, index_file);
					}
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_81 = stream;
								SubLObject total = file_length(stream_81);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_81);
								sbhl_time_utilities.initialize_hl_endpoint_tables();
								{
									SubLObject graph_count = cfasl_input(stream_81, UNPROVIDED, UNPROVIDED);
									{
										SubLObject _prev_bind_0 = $cfasl_stream_extensions_enabled$
												.currentBinding(thread);
										SubLObject _prev_bind_1 = $cfasl_unread_byte$.currentBinding(thread);
										SubLObject _prev_bind_2 = $noting_progress_start_time$.currentBinding(thread);
										try {
											$cfasl_stream_extensions_enabled$.bind(T, thread);
											$cfasl_unread_byte$.bind(NIL, thread);
											$noting_progress_start_time$.bind(get_universal_time(), thread);
											noting_progress_preamble($str_alt178$Loading_SBHL_graphs___);
											sbhl_module_declarations.initialize_sbhl_modules(T);
											{
												SubLObject n = NIL;
												for (n = ZERO_INTEGER; n.numL(graph_count); n = add(n, ONE_INTEGER)) {
													if (cfasl_opcode_peek(stream_81, UNPROVIDED,
															UNPROVIDED) == $int$30) {
														{
															SubLObject predicate = cfasl_input(stream_81, UNPROVIDED,
																	UNPROVIDED);
															SubLObject v_graph = cfasl_input(stream_81, UNPROVIDED,
																	UNPROVIDED);
															SubLObject module = sbhl_module_vars
																	.get_sbhl_module(predicate);
															if (((NIL != valid_constantP(predicate, UNPROVIDED))
																	&& v_graph.isHashtable())
																	&& (NIL != sbhl_module_vars
																			.sbhl_module_p(module))) {
																sbhl_module_vars.set_sbhl_module_property(module,
																		$GRAPH, v_graph);
															}
														}
													}
												}
											}
											if (NIL != sbhl_module_vars.get_sbhl_modules()) {
												sbhl_module_declarations.note_sbhl_modules_initialized();
											}
											com.cyc.cycjava.cycl.dumper.load_sbhl_miscellany(stream_81);
											if (cfasl_input(stream_81, NIL, $EOF) != $EOF) {
												Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
														subtract(total, compatibility.get_file_position(stream_81)),
														cfasl_file);
											}
											noting_progress_postamble();
										} finally {
											$noting_progress_start_time$.rebind(_prev_bind_2, thread);
											$cfasl_unread_byte$.rebind(_prev_bind_1, thread);
											$cfasl_stream_extensions_enabled$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			com.cyc.cycjava.cycl.dumper.load_sbhl_time_state(directory_path);
			return NIL;
		}
	}

	public static SubLObject load_sbhl_data(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str526$sbhl_modules, directory_path, UNPROVIDED);
		final SubLObject data_file = dumper.kb_dump_file(dumper.$str527$sbhl_module_graphs, directory_path, UNPROVIDED);
		final SubLObject index_file = dumper.kb_dump_file(dumper.$str528$sbhl_module_graphs_index, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			if ((NIL != dumper.verify_file_existence(data_file, $WARN_ONLY))
					&& (NIL != dumper.verify_file_existence(index_file, $WARN_ONLY))) {
				initialize_sbhl_graph_caches_during_load_kb(data_file, index_file);
			}
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$591 = stream;
				if ($INPUT == $INPUT) {
					stream_$591 = file_utilities.enable_file_stream_memory_mapping(stream_$591);
				}
				try {
					final SubLObject total = file_length(stream_$591);
					dumper.load_copyright(stream_$591);
					initialize_hl_endpoint_tables();
					final SubLObject graph_count = cfasl_input(stream_$591, UNPROVIDED, UNPROVIDED);
					final SubLObject _prev_bind_2 = $cfasl_stream_extensions_enabled$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $cfasl_unread_byte$.currentBinding(thread);
					try {
						$cfasl_stream_extensions_enabled$.bind(T, thread);
						$cfasl_unread_byte$.bind(NIL, thread);
						final SubLObject str = dumper.$str533$Loading_SBHL_graphs____;
						final SubLObject _prev_bind_0_$592 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_1_$593 = $progress_last_pacification_time$.currentBinding(thread);
						final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$
								.currentBinding(thread);
						final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
						final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
						final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
						final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
						try {
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread),
									thread);
							$progress_elapsed_seconds_for_notification$
									.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
							$progress_notification_count$.bind(ZERO_INTEGER, thread);
							$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
							$progress_count$.bind(ZERO_INTEGER, thread);
							$is_noting_progressP$.bind(T, thread);
							$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T,
									thread);
							noting_progress_preamble(str);
							initialize_sbhl_modules(T);
							SubLObject n;
							SubLObject predicate;
							SubLObject v_graph;
							SubLObject module;
							for (n = NIL, n = ZERO_INTEGER; n.numL(graph_count); n = add(n, ONE_INTEGER)) {
								if (cfasl_opcode_peek(stream_$591, UNPROVIDED, UNPROVIDED).eql(dumper.$int$30)) {
									predicate = cfasl_input(stream_$591, UNPROVIDED, UNPROVIDED);
									v_graph = cfasl_input(stream_$591, UNPROVIDED, UNPROVIDED);
									module = get_sbhl_module(predicate);
									if (((NIL != valid_constantP(predicate, UNPROVIDED)) && v_graph.isHashtable())
											&& (NIL != sbhl_module_p(module))) {
										set_sbhl_module_property(module, $GRAPH, v_graph);
									}
								}
							}
							if (NIL != get_sbhl_modules()) {
								note_sbhl_modules_initialized();
							}
							dumper.load_sbhl_miscellany(stream_$591);
							if (cfasl_input(stream_$591, NIL, $EOF) != $EOF) {
								Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
										subtract(total, compatibility.get_file_position(stream_$591)), cfasl_file);
							}
							noting_progress_postamble();
						} finally {
							$silent_progressP$.rebind(_prev_bind_9, thread);
							$is_noting_progressP$.rebind(_prev_bind_8, thread);
							$progress_count$.rebind(_prev_bind_7, thread);
							$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
							$progress_notification_count$.rebind(_prev_bind_5, thread);
							$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
							$progress_last_pacification_time$.rebind(_prev_bind_1_$593, thread);
							$progress_start_time$.rebind(_prev_bind_0_$592, thread);
						}
					} finally {
						$cfasl_unread_byte$.rebind(_prev_bind_3, thread);
						$cfasl_stream_extensions_enabled$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$591, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		dumper.load_sbhl_time_state(directory_path);
		return NIL;
	}

	public static final SubLObject rebuild_sbhl_data_alt() {
		sbhl_link_methods.make_all_sbhl_links();
		if (NIL != kb_control_vars.time_kb_loaded_p()) {
			com.cyc.cycjava.cycl.dumper.rebuild_sbhl_time_data();
			sbhl_time_modules.initialize_sbhl_time_modules();
		} else {
			Errors.warn($str_alt181$Cannot_initialize_SBHL_Time_due_t);
		}
		return NIL;
	}

	public static SubLObject rebuild_sbhl_data() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$594 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$595 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$594);
			final SubLObject memory_mappedP_$596 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$594);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$594);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$594);
				final SubLObject manager_$595 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$596 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$595);
				final SubLObject memory_mappedP_$597 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$595);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$595);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$595);
					final SubLObject manager_$596 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$597 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$596);
					final SubLObject memory_mappedP_$598 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$596);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$596);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$596);
						final SubLObject manager_$597 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$598 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$597);
						final SubLObject memory_mappedP_$599 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$597);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$597);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$597);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								make_all_sbhl_links();
								if (NIL != kb_control_vars.time_kb_loaded_p()) {
									cleanly_initialize_sbhl_time_modules();
									dumper.rebuild_sbhl_time_data();
								} else {
									Errors.warn(dumper.$str536$Cannot_initialize_SBHL_Time_due_t);
								}
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$598) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$597);
								}
								if (NIL == memory_mappedP_$599) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$597,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$597) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$596);
							}
							if (NIL == memory_mappedP_$598) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$596,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$596) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$595);
						}
						if (NIL == memory_mappedP_$597) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$595,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$595) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$594);
					}
					if (NIL == memory_mappedP_$596) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$594, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static SubLObject recompute_missing_sbhl_graphs() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
		final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
		try {
			mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
			mt_relevance_macros.$mt$.bind(dumper.$$EverythingPSC, thread);
			SubLObject cdolist_list_var = get_sbhl_modules();
			SubLObject cons = NIL;
			cons = cdolist_list_var.first();
			while (NIL != cdolist_list_var) {
				SubLObject current;
				final SubLObject datum = current = cons;
				SubLObject key = NIL;
				SubLObject module = NIL;
				destructuring_bind_must_consp(current, datum, dumper.$list539);
				key = current.first();
				current = module = current.rest();
				final SubLObject v_graph = get_sbhl_graph(module);
				if ((!v_graph.isHashtable())
						|| ((NIL != hash_table_utilities.hash_table_empty_p(v_graph)) && ((!kb_indexing
								.num_predicate_extent_index(get_sbhl_module_link_pred(module), UNPROVIDED).isZero())
								|| (NIL != genl_predicates.all_proper_spec_predicates_and_inverses(
										get_sbhl_module_link_pred(module), UNPROVIDED, UNPROVIDED))))) {
					make_sbhl_links_for_module(module);
				}
				cdolist_list_var = cdolist_list_var.rest();
				cons = cdolist_list_var.first();
			}
		} finally {
			mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
			mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_sbhl_miscellany_alt(SubLObject stream) {
		com.cyc.cycjava.cycl.dumper.dump_isa_arg2_naut_table(stream);
		com.cyc.cycjava.cycl.dumper.dump_non_fort_isa_table(stream);
		com.cyc.cycjava.cycl.dumper.dump_non_fort_instance_table(stream);
		cfasl_output($END, stream);
		return NIL;
	}

	public static SubLObject dump_sbhl_miscellany(final SubLObject stream) {
		dumper.dump_isa_arg2_naut_table(stream);
		dumper.dump_non_fort_isa_table(stream);
		dumper.dump_non_fort_instance_table(stream);
		cfasl_output($END, stream);
		return NIL;
	}

	public static final SubLObject dump_isa_arg2_naut_table_alt(SubLObject stream) {
		cfasl_output($ISA_ARG2_NAUT_TABLE, stream);
		cfasl_output(sbhl_link_methods.$isa_arg2_naut_table$.getGlobalValue(), stream);
		return NIL;
	}

	public static SubLObject dump_isa_arg2_naut_table(final SubLObject stream) {
		cfasl_output(dumper.$ISA_ARG2_NAUT_TABLE, stream);
		cfasl_output($isa_arg2_naut_table$.getGlobalValue(), stream);
		return NIL;
	}

	public static final SubLObject dump_non_fort_isa_table_alt(SubLObject stream) {
		cfasl_output($NON_FORT_ISA_TABLE, stream);
		cfasl_output(sbhl_link_methods.non_fort_isa_table(), stream);
		return NIL;
	}

	public static SubLObject dump_non_fort_isa_table(final SubLObject stream) {
		cfasl_output(dumper.$NON_FORT_ISA_TABLE, stream);
		cfasl_output(non_fort_isa_table(), stream);
		return NIL;
	}

	public static final SubLObject dump_non_fort_instance_table_alt(SubLObject stream) {
		cfasl_output($NON_FORT_INSTANCE_TABLE, stream);
		cfasl_output(sbhl_link_methods.non_fort_instance_table(), stream);
		return NIL;
	}

	public static SubLObject dump_non_fort_instance_table(final SubLObject stream) {
		cfasl_output(dumper.$NON_FORT_INSTANCE_TABLE, stream);
		cfasl_output(non_fort_instance_table(), stream);
		return NIL;
	}

	public static final SubLObject load_sbhl_miscellany_alt(SubLObject stream) {
		{
			SubLObject token = NIL;
			while ($END != token) {
				token = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
				if (token.isHashtable()) {
					sbhl_link_methods.$isa_arg2_naut_table$.setGlobalValue(token);
					sbhl_link_methods.rebuild_non_fort_isa_tables();
					token = $END;
				} else {
					{
						SubLObject pcase_var = token;
						if (pcase_var.eql($ISA_ARG2_NAUT_TABLE)) {
							com.cyc.cycjava.cycl.dumper.load_isa_arg2_naut_table(stream);
						} else {
							if (pcase_var.eql($NON_FORT_ISA_TABLE)) {
								com.cyc.cycjava.cycl.dumper.load_non_fort_isa_table(stream);
							} else {
								if (pcase_var.eql($NON_FORT_INSTANCE_TABLE)) {
									com.cyc.cycjava.cycl.dumper.load_non_fort_instance_table(stream);
								} else {
									if (pcase_var.eql($END)) {
									} else {
										Errors.warn($str_alt186$Could_not_handle_SBHL_miscellany_, token);
									}
								}
							}
						}
					}
				}
			}
		}
		return NIL;
	}

	public static SubLObject load_sbhl_miscellany(final SubLObject stream) {
		SubLObject token = NIL;
		while ($END != token) {
			token = cfasl_input(stream, UNPROVIDED, UNPROVIDED);
			if (token.isHashtable()) {
				$isa_arg2_naut_table$.setGlobalValue(token);
				rebuild_non_fort_isa_tables();
				token = $END;
			} else {
				final SubLObject pcase_var = token;
				if (pcase_var.eql(dumper.$ISA_ARG2_NAUT_TABLE)) {
					dumper.load_isa_arg2_naut_table(stream);
				} else if (pcase_var.eql(dumper.$NON_FORT_ISA_TABLE)) {
					dumper.load_non_fort_isa_table(stream);
				} else if (pcase_var.eql(dumper.$NON_FORT_INSTANCE_TABLE)) {
					dumper.load_non_fort_instance_table(stream);
				} else {
					if (pcase_var.eql($END)) {
						continue;
					}
					Errors.warn(dumper.$str543$Could_not_handle_SBHL_miscellany_, token);
				}

			}
		}
		return NIL;
	}

	public static final SubLObject load_isa_arg2_naut_table_alt(SubLObject stream) {
		sbhl_link_methods.$isa_arg2_naut_table$.setGlobalValue(cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return NIL;
	}

	public static SubLObject load_isa_arg2_naut_table(final SubLObject stream) {
		$isa_arg2_naut_table$.setGlobalValue(cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return NIL;
	}

	public static final SubLObject load_non_fort_isa_table_alt(SubLObject stream) {
		sbhl_link_methods.set_non_fort_isa_table(cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return NIL;
	}

	public static SubLObject load_non_fort_isa_table(final SubLObject stream) {
		set_non_fort_isa_table(cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return NIL;
	}

	public static final SubLObject load_non_fort_instance_table_alt(SubLObject stream) {
		sbhl_link_methods.set_non_fort_instance_table(cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return NIL;
	}

	public static SubLObject load_non_fort_instance_table(final SubLObject stream) {
		set_non_fort_instance_table(cfasl_input(stream, UNPROVIDED, UNPROVIDED));
		return NIL;
	}

	public static final SubLObject dump_sbhl_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject sbhl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt187$sbhl_cache, directory_path,
						UNPROVIDED);
				SubLObject filename_var = sbhl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_82 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_82);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt188$Dumping_SBHL_cache___);
								cfasl_output(sbhl_cache.$isa_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$all_mts_isa_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$genls_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$all_mts_genls_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$genl_predicate_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$genl_inverse_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$all_mts_genl_predicate_cache$.getGlobalValue(), stream_82);
								cfasl_output(sbhl_cache.$all_mts_genl_inverse_cache$.getGlobalValue(), stream_82);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_sbhl_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject sbhl_file = filename_var = dumper.kb_dump_file(dumper.$str544$sbhl_cache, directory_path,
				UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$606 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$606 = file_utilities.enable_file_stream_memory_mapping(stream_$606);
			}
			try {
				dumper.dump_copyright(stream_$606);
				final SubLObject str = dumper.$str545$Dumping_SBHL_cache____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					cfasl_output($isa_cache$.getGlobalValue(), stream_$606);
					cfasl_output($all_mts_isa_cache$.getGlobalValue(), stream_$606);
					cfasl_output($genls_cache$.getGlobalValue(), stream_$606);
					cfasl_output($all_mts_genls_cache$.getGlobalValue(), stream_$606);
					cfasl_output($genl_predicate_cache$.getGlobalValue(), stream_$606);
					cfasl_output($genl_inverse_cache$.getGlobalValue(), stream_$606);
					cfasl_output($all_mts_genl_predicate_cache$.getGlobalValue(), stream_$606);
					cfasl_output($all_mts_genl_inverse_cache$.getGlobalValue(), stream_$606);
					if ((NIL != dictionary.dictionary_p($quoted_isa_cache$.getGlobalValue()))
							&& (NIL != dictionary.dictionary_p($all_mts_quoted_isa_cache$.getGlobalValue()))) {
						cfasl_output($quoted_isa_cache$.getGlobalValue(), stream_$606);
						cfasl_output($all_mts_quoted_isa_cache$.getGlobalValue(), stream_$606);
					}
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$606, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_sbhl_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt187$sbhl_cache, directory_path,
						UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_83 = stream;
								SubLObject total = file_length(stream_83);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_83);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt189$Loading_SBHL_cache___);
										sbhl_cache.$isa_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$all_mts_isa_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$genls_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$all_mts_genls_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$genl_predicate_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$genl_inverse_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$all_mts_genl_predicate_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.$all_mts_genl_inverse_cache$
												.setGlobalValue(cfasl_input(stream_83, UNPROVIDED, UNPROVIDED));
										sbhl_cache.note_sbhl_caches_initialized();
										if (cfasl_input(stream_83, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_83)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_sbhl_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str544$sbhl_cache, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$607 = stream;
				if ($INPUT == $INPUT) {
					stream_$607 = file_utilities.enable_file_stream_memory_mapping(stream_$607);
				}
				try {
					final SubLObject total = file_length(stream_$607);
					dumper.load_copyright(stream_$607);
					final SubLObject str = dumper.$str546$Loading_SBHL_cache____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						$isa_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$all_mts_isa_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$genls_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$all_mts_genls_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$genl_predicate_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$genl_inverse_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$all_mts_genl_predicate_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						$all_mts_genl_inverse_cache$.setGlobalValue(cfasl_input(stream_$607, UNPROVIDED, UNPROVIDED));
						SubLObject next_cache = cfasl_input(stream_$607, NIL, NIL);
						if (NIL != next_cache) {
							$quoted_isa_cache$.setGlobalValue(next_cache);
						}
						next_cache = cfasl_input(stream_$607, NIL, NIL);
						if (NIL != next_cache) {
							$all_mts_quoted_isa_cache$.setGlobalValue(next_cache);
						}
						note_sbhl_caches_initialized();
						if (cfasl_input(stream_$607, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$607)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$607, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject rebuild_sbhl_cache_alt() {
		sbhl_cache.initialize_all_sbhl_caching();
		return NIL;
	}

	public static SubLObject rebuild_sbhl_cache() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$608 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$609 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$608);
			final SubLObject memory_mappedP_$610 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$608);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$608);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$608);
				final SubLObject manager_$609 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$610 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$609);
				final SubLObject memory_mappedP_$611 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$609);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$609);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$609);
					final SubLObject manager_$610 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$611 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$610);
					final SubLObject memory_mappedP_$612 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$610);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$610);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$610);
						final SubLObject manager_$611 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$612 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$611);
						final SubLObject memory_mappedP_$613 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$611);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$611);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$611);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								initialize_all_sbhl_caching();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$612) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$611);
								}
								if (NIL == memory_mappedP_$613) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$611,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$611) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$610);
							}
							if (NIL == memory_mappedP_$612) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$610,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$610) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$609);
						}
						if (NIL == memory_mappedP_$611) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$609,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$609) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$608);
					}
					if (NIL == memory_mappedP_$610) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$608, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_cardinality_estimates_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject filename = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt190$cardinality_estimates,
						directory_path, UNPROVIDED);
				SubLObject filename_var = filename;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_84 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_84);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt191$Dumping_cardinality_estimates___);
								cardinality_estimates.dump_cardinality_estimates_to_stream(stream_84);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_cardinality_estimates(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject filename = filename_var = dumper.kb_dump_file(dumper.$str547$cardinality_estimates,
				directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$620 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$620 = file_utilities.enable_file_stream_memory_mapping(stream_$620);
			}
			try {
				dumper.dump_copyright(stream_$620);
				final SubLObject str = dumper.$str548$Dumping_cardinality_estimates____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					cardinality_estimates.dump_cardinality_estimates_to_stream(stream_$620);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$620, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_cardinality_estimates_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_unit_file(directory_path, $str_alt190$cardinality_estimates,
				LOAD_CARDINALITY_ESTIMATES_FROM_STREAM, $str_alt193$Loading_cardinality_estimates___);
	}

	public static SubLObject load_cardinality_estimates(final SubLObject directory_path) {
		return dumper.load_unit_file(directory_path, dumper.$str547$cardinality_estimates,
				dumper.LOAD_CARDINALITY_ESTIMATES_FROM_STREAM, dumper.$str550$Loading_cardinality_estimates____);
	}

	/**
	 * Keeps the current arg-type-cache during the dump
	 */
	@LispMethod(comment = "Keeps the current arg-type-cache during the dump")
	public static final SubLObject not_computing_arg_type_cache_alt(SubLObject macroform, SubLObject environment) {
		{
			SubLObject datum = macroform.rest();
			SubLObject current = datum;
			SubLObject body = current;
			return listS(CLET, $list_alt194, append(body, NIL));
		}
	}

	/**
	 * Keeps the current arg-type-cache during the dump
	 */
	@LispMethod(comment = "Keeps the current arg-type-cache during the dump")
	public static SubLObject not_computing_arg_type_cache(final SubLObject macroform, final SubLObject environment) {
		final SubLObject datum = macroform.rest();
		final SubLObject body;
		final SubLObject current = body = datum;
		return listS(CLET, dumper.$list551, append(body, NIL));
	}

	public static final SubLObject dump_arg_type_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $compute_arg_type_cache_on_dumpP$.getDynamicValue(thread)) {
				com.cyc.cycjava.cycl.dumper.rebuild_arg_type_cache();
			}
			{
				SubLObject at_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt195$arg_type_cache,
						directory_path, UNPROVIDED);
				SubLObject filename_var = at_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_85 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_85);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt196$Dumping_arg_type_cache___);
								cfasl_output(at_cache.$arg_type_cache$.getGlobalValue(), stream_85);
								cfasl_output(NIL, stream_85);
								cfasl_output(NIL, stream_85);
								cfasl_output(NIL, stream_85);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_arg_type_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$compute_arg_type_cache_on_dumpP$.getDynamicValue(thread)) {
			dumper.rebuild_arg_type_cache();
		}
		final SubLObject filename_var;
		final SubLObject at_file = filename_var = dumper.kb_dump_file(dumper.$str552$arg_type_cache, directory_path,
				UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$621 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$621 = file_utilities.enable_file_stream_memory_mapping(stream_$621);
			}
			try {
				dumper.dump_copyright(stream_$621);
				final SubLObject str = dumper.$str553$Dumping_arg_type_cache____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					cfasl_output(at_cache.$arg_type_cache$.getGlobalValue(), stream_$621);
					cfasl_output(NIL, stream_$621);
					cfasl_output(NIL, stream_$621);
					cfasl_output(NIL, stream_$621);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$621, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_arg_type_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt195$arg_type_cache,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_86 = stream;
								SubLObject total = file_length(stream_86);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_86);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt197$Loading_arg_type_cache___);
										{
											SubLObject dummy = NIL;
											at_cache.$arg_type_cache$
													.setGlobalValue(cfasl_input(stream_86, UNPROVIDED, UNPROVIDED));
											dummy = cfasl_input(stream_86, UNPROVIDED, UNPROVIDED);
											dummy = cfasl_input(stream_86, UNPROVIDED, UNPROVIDED);
											dummy = cfasl_input(stream_86, UNPROVIDED, UNPROVIDED);
										}
										at_cache.note_at_cache_initialized();
										if (cfasl_input(stream_86, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_86)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_arg_type_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str552$arg_type_cache, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$622 = stream;
				if ($INPUT == $INPUT) {
					stream_$622 = file_utilities.enable_file_stream_memory_mapping(stream_$622);
				}
				try {
					final SubLObject total = file_length(stream_$622);
					dumper.load_copyright(stream_$622);
					final SubLObject str = dumper.$str554$Loading_arg_type_cache____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						SubLObject dummy = NIL;
						at_cache.$arg_type_cache$.setGlobalValue(cfasl_input(stream_$622, UNPROVIDED, UNPROVIDED));
						dummy = cfasl_input(stream_$622, UNPROVIDED, UNPROVIDED);
						dummy = cfasl_input(stream_$622, UNPROVIDED, UNPROVIDED);
						dummy = cfasl_input(stream_$622, UNPROVIDED, UNPROVIDED);
						at_cache.note_at_cache_initialized();
						if (cfasl_input(stream_$622, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$622)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$622, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject rebuild_arg_type_cache_alt() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
				try {
					$noting_progress_start_time$.bind(get_universal_time(), thread);
					noting_progress_preamble($str_alt198$Rebuilding_arg_type_cache);
					at_cache.initialize_at_cache();
					noting_progress_postamble();
				} finally {
					$noting_progress_start_time$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject rebuild_arg_type_cache() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$623 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$624 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$623);
			final SubLObject memory_mappedP_$625 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$623);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$623);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$623);
				final SubLObject manager_$624 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$625 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$624);
				final SubLObject memory_mappedP_$626 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$624);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$624);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$624);
					final SubLObject manager_$625 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$626 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$625);
					final SubLObject memory_mappedP_$627 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$625);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$625);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$625);
						final SubLObject manager_$626 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$627 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$626);
						final SubLObject memory_mappedP_$628 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$626);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$626);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$626);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								final SubLObject str = dumper.$str555$Rebuilding_arg_type_cache;
								final SubLObject _prev_bind_0_$635 = $progress_start_time$.currentBinding(thread);
								final SubLObject _prev_bind_2 = $progress_last_pacification_time$
										.currentBinding(thread);
								final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$
										.currentBinding(thread);
								final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
								final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$
										.currentBinding(thread);
								final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
								final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
								final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
								try {
									$progress_start_time$.bind(get_universal_time(), thread);
									$progress_last_pacification_time$
											.bind($progress_start_time$.getDynamicValue(thread), thread);
									$progress_elapsed_seconds_for_notification$.bind(
											$suppress_all_progress_faster_than_seconds$.getDynamicValue(thread),
											thread);
									$progress_notification_count$.bind(ZERO_INTEGER, thread);
									$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
									$progress_count$.bind(ZERO_INTEGER, thread);
									$is_noting_progressP$.bind(T, thread);
									$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T,
											thread);
									noting_progress_preamble(str);
									at_cache.initialize_at_cache();
									noting_progress_postamble();
								} finally {
									$silent_progressP$.rebind(_prev_bind_8, thread);
									$is_noting_progressP$.rebind(_prev_bind_7, thread);
									$progress_count$.rebind(_prev_bind_6, thread);
									$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
									$progress_notification_count$.rebind(_prev_bind_4, thread);
									$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
									$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
									$progress_start_time$.rebind(_prev_bind_0_$635, thread);
								}
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$627) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$626);
								}
								if (NIL == memory_mappedP_$628) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$626,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$626) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$625);
							}
							if (NIL == memory_mappedP_$627) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$625,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$625) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$624);
						}
						if (NIL == memory_mappedP_$626) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$624,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_12 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$624) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$623);
					}
					if (NIL == memory_mappedP_$625) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$623, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_12, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_13 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_13, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_defns_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt199$defns_cache,
						directory_path, UNPROVIDED);
				SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_87 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_87);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt200$Dumping_defns_cache___);
								defns.dump_defns_cache_to_stream(stream_87);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_defns_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL == dumper.$cyc_alexandria_defns_dump_load_supportedP$.getGlobalValue()) {
			final SubLObject filename_var;
			final SubLObject cfasl_file = filename_var = dumper.kb_dump_file(dumper.$str557$defns_cache, directory_path,
					UNPROVIDED);
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$636 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$636 = file_utilities.enable_file_stream_memory_mapping(stream_$636);
				}
				try {
					dumper.dump_copyright(stream_$636);
					final SubLObject str = dumper.$str558$Dumping_defns_cache____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						defns.dump_defns_cache_to_stream(stream_$636);
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$636, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject load_defns_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt199$defns_cache,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_88 = stream;
								SubLObject total = file_length(stream_88);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_88);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt201$Loading_defns_cache___);
										defns.load_defns_cache_from_stream(stream_88);
										if (cfasl_input(stream_88, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_88)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_defns_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL == dumper.$cyc_alexandria_defns_dump_load_supportedP$.getGlobalValue()) {
			final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str557$defns_cache, directory_path, UNPROVIDED);
			if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
				final SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $INPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$637 = stream;
					if ($INPUT == $INPUT) {
						stream_$637 = file_utilities.enable_file_stream_memory_mapping(stream_$637);
					}
					try {
						final SubLObject total = file_length(stream_$637);
						dumper.load_copyright(stream_$637);
						final SubLObject str = dumper.$str559$Loading_defns_cache____;
						final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
						final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$
								.currentBinding(thread);
						final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
						final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
						final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
						final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
						try {
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread),
									thread);
							$progress_elapsed_seconds_for_notification$
									.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
							$progress_notification_count$.bind(ZERO_INTEGER, thread);
							$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
							$progress_count$.bind(ZERO_INTEGER, thread);
							$is_noting_progressP$.bind(T, thread);
							$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T,
									thread);
							noting_progress_preamble(str);
							defns.load_defns_cache_from_stream(stream_$637);
							if (cfasl_input(stream_$637, NIL, $EOF) != $EOF) {
								Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
										subtract(total, compatibility.get_file_position(stream_$637)), cfasl_file);
							}
							noting_progress_postamble();
						} finally {
							$silent_progressP$.rebind(_prev_bind_9, thread);
							$is_noting_progressP$.rebind(_prev_bind_8, thread);
							$progress_count$.rebind(_prev_bind_7, thread);
							$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
							$progress_notification_count$.rebind(_prev_bind_5, thread);
							$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
							$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
							$progress_start_time$.rebind(_prev_bind_2, thread);
						}
					} finally {
						final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$637, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_rule_connectivity_graph_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject filename = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt202$rule_connectivity_graph,
						directory_path, UNPROVIDED);
				SubLObject filename_var = filename;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_89 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_89);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt203$Dumping_rule_connectivity_graph__);
								predicate_suggestor.dump_rule_connectivity_graph_to_stream(stream_89);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_rule_connectivity_graph(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject filename = filename_var = dumper.kb_dump_file(dumper.$str560$rule_connectivity_graph,
				directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$638 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$638 = file_utilities.enable_file_stream_memory_mapping(stream_$638);
			}
			try {
				dumper.dump_copyright(stream_$638);
				final SubLObject str = dumper.$str561$Dumping_rule_connectivity_graph__;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					predicate_suggestor.dump_rule_connectivity_graph_to_stream(stream_$638);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$638, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_rule_connectivity_graph_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_unit_file(directory_path, $str_alt202$rule_connectivity_graph,
				LOAD_RULE_CONNECTIVITY_GRAPH_FROM_STREAM, $str_alt205$Loading_rule_connectivity_graph__);
	}

	public static SubLObject load_rule_connectivity_graph(final SubLObject directory_path) {
		return dumper.load_unit_file(directory_path, dumper.$str560$rule_connectivity_graph,
				dumper.LOAD_RULE_CONNECTIVITY_GRAPH_FROM_STREAM, dumper.$str563$Loading_rule_connectivity_graph__);
	}

	public static final SubLObject dump_tva_cache_alt(SubLObject dump_directory) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject tva_cache_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt206$tva_cache,
						dump_directory, UNPROVIDED);
				SubLObject tvac_data_file = tva_cache.get_tva_cache_contents_data_file(dump_directory);
				SubLObject tvac_index_file = tva_cache.get_tva_cache_contents_index_file(dump_directory);
				SubLObject fvector = NIL;
				try {
					fvector = new_file_vector(tvac_data_file, tvac_index_file, $OUTPUT);
					{
						SubLObject filename_var = tva_cache_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_90 = stream;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_90);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt207$Dumping_TVA_cache___);
										tva_cache.dump_swappable_tva_cache_to_stream(stream_90, fvector);
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (NIL != file_vector_p(fvector)) {
								close_file_vector(fvector);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_tva_cache(final SubLObject dump_directory) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject tva_cache_file = dumper.kb_dump_file(dumper.$str564$tva_cache, dump_directory, UNPROVIDED);
			final SubLObject tvac_data_file = tva_cache.get_tva_cache_contents_data_file(dump_directory);
			final SubLObject tvac_index_file = tva_cache.get_tva_cache_contents_index_file(dump_directory);
			SubLObject fvector = NIL;
			try {
				fvector = file_vector.new_file_vector(tvac_data_file, tvac_index_file, $OUTPUT,
						file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread),
						file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), UNPROVIDED);
				final SubLObject filename_var = tva_cache_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$639 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$639, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$640 = stream;
					if ($OUTPUT == $INPUT) {
						stream_$640 = file_utilities.enable_file_stream_memory_mapping(stream_$640);
					}
					try {
						dumper.dump_copyright(stream_$640);
						final SubLObject str = dumper.$str565$Dumping_TVA_cache____;
						final SubLObject _prev_bind_0_$640 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_1_$642 = $progress_last_pacification_time$.currentBinding(thread);
						final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$
								.currentBinding(thread);
						final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
						final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
						final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
						final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
						try {
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread),
									thread);
							$progress_elapsed_seconds_for_notification$
									.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
							$progress_notification_count$.bind(ZERO_INTEGER, thread);
							$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
							$progress_count$.bind(ZERO_INTEGER, thread);
							$is_noting_progressP$.bind(T, thread);
							$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T,
									thread);
							noting_progress_preamble(str);
							tva_cache.dump_swappable_tva_cache_to_stream(stream_$640, fvector);
							noting_progress_postamble();
						} finally {
							$silent_progressP$.rebind(_prev_bind_8, thread);
							$is_noting_progressP$.rebind(_prev_bind_7, thread);
							$progress_count$.rebind(_prev_bind_6, thread);
							$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
							$progress_notification_count$.rebind(_prev_bind_4, thread);
							$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
							$progress_last_pacification_time$.rebind(_prev_bind_1_$642, thread);
							$progress_start_time$.rebind(_prev_bind_0_$640, thread);
						}
					} finally {
						final SubLObject _prev_bind_0_$641 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$640, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$641, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$642 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$642, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
			} finally {
				final SubLObject _prev_bind_0_$643 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (NIL != file_vector.file_vector_p(fvector)) {
						file_vector.close_file_vector(fvector);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$643, thread);
				}
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_tva_cache_alt(SubLObject dump_directory) {
		{
			SubLObject result = com.cyc.cycjava.cycl.dumper.load_unit_file(dump_directory, $str_alt206$tva_cache,
					LOAD_TVA_CACHE_FROM_STREAM, $str_alt209$Loading_TVA_cache___);
			tva_cache.reconnect_tva_cache_registry(dump_directory, cfasl_current_common_symbols());
			return result;
		}
	}

	public static SubLObject load_tva_cache(final SubLObject dump_directory) {
		final SubLObject result = dumper.load_unit_file(dump_directory, dumper.$str564$tva_cache,
				dumper.LOAD_TVA_CACHE_FROM_STREAM, dumper.$str567$Loading_TVA_cache____);
		tva_cache.reconnect_tva_cache_registry(dump_directory, cfasl_current_common_symbols());
		return result;
	}

	public static final SubLObject dump_reformulator_rules_alt(SubLObject dump_directory) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject reformulator_rules_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt210$reformulator_rules, dump_directory, UNPROVIDED);
				SubLObject filename_var = reformulator_rules_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_91 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_91);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt211$Dumping_reformulator_rules___);
								reformulator_rule_unifier_datastructures.dump_reformulator_rules_to_stream(stream_91);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_reformulator_rules(final SubLObject dump_directory) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject reformulator_rules_file = filename_var = dumper.kb_dump_file(dumper.$str568$reformulator_rules,
				dump_directory, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$646 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$646 = file_utilities.enable_file_stream_memory_mapping(stream_$646);
			}
			try {
				dumper.dump_copyright(stream_$646);
				final SubLObject str = dumper.$str569$Dumping_reformulator_rules____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					reformulator_rule_unifier_datastructures.dump_reformulator_rules_to_stream(stream_$646);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$646, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_reformulator_rules_alt(SubLObject dump_directory) {
		return com.cyc.cycjava.cycl.dumper.load_unit_file(dump_directory, $str_alt210$reformulator_rules,
				LOAD_REFORMULATOR_RULES_FROM_STREAM, $str_alt213$Loading_reformulator_rules___);
	}

	public static SubLObject load_reformulator_rules(final SubLObject dump_directory) {
		return dumper.load_unit_file(dump_directory, dumper.$str568$reformulator_rules,
				dumper.LOAD_REFORMULATOR_RULES_FROM_STREAM, dumper.$str571$Loading_reformulator_rules____);
	}

	public static final SubLObject dump_english_units_of_measure_alt(SubLObject dump_directory) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
				try {
					$noting_progress_start_time$.bind(get_universal_time(), thread);
					noting_progress_preamble($str_alt214$Dumping_English_units_of_measure_);
					english_quantity_parser.ensure_english_units_of_measure_initialization();
					{
						SubLObject english_units_of_measure_file = com.cyc.cycjava.cycl.dumper
								.kb_dump_file($str_alt215$english_units_of_measure, dump_directory, UNPROVIDED);
						SubLObject filename_var = english_units_of_measure_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0_92 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_92, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_93 = stream;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_93);
								english_quantity_parser.dump_english_units_of_measure_to_stream(stream_93);
							}
						} finally {
							{
								SubLObject _prev_bind_0_94 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_94, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
					noting_progress_postamble();
				} finally {
					$noting_progress_start_time$.rebind(_prev_bind_0, thread);
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_english_units_of_measure(final SubLObject dump_directory) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject str = dumper.$str572$Dumping_English_units_of_measure_;
		final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
		final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
		final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
		final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			english_quantity_parser.ensure_english_units_of_measure_initialization();
			final SubLObject filename_var;
			final SubLObject english_units_of_measure_file = filename_var = dumper
					.kb_dump_file(dumper.$str573$english_units_of_measure, dump_directory, UNPROVIDED);
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$647 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$647, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$648 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$648 = file_utilities.enable_file_stream_memory_mapping(stream_$648);
				}
				try {
					dumper.dump_copyright(stream_$648);
					english_quantity_parser.dump_english_units_of_measure_to_stream(stream_$648);
				} finally {
					final SubLObject _prev_bind_0_$648 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$648, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$648, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$649 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$649, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_8, thread);
			$is_noting_progressP$.rebind(_prev_bind_7, thread);
			$progress_count$.rebind(_prev_bind_6, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
			$progress_notification_count$.rebind(_prev_bind_4, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
			$progress_start_time$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_english_units_of_measure_alt(SubLObject dump_directory) {
		return com.cyc.cycjava.cycl.dumper.load_unit_file(dump_directory, $str_alt215$english_units_of_measure,
				LOAD_ENGLISH_UNITS_OF_MEASURE_FROM_STREAM, $str_alt217$Loading_English_units_of_measure_);
	}

	public static SubLObject load_english_units_of_measure(final SubLObject dump_directory) {
		return dumper.load_unit_file(dump_directory, dumper.$str573$english_units_of_measure,
				dumper.LOAD_ENGLISH_UNITS_OF_MEASURE_FROM_STREAM, dumper.$str575$Loading_English_units_of_measure_);
	}

	public static final SubLObject dump_cae_query_search_tables_alt(SubLObject dump_directory) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != non_tiny_kb_loadedP()) {
				{
					SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
					try {
						$noting_progress_start_time$.bind(get_universal_time(), thread);
						noting_progress_preamble($str_alt218$Dumping_CAE_query_search_tables__);
						cae_query_search.ensure_cae_query_search_tables_initialization();
						{
							SubLObject cae_query_search_tables_file = com.cyc.cycjava.cycl.dumper
									.kb_dump_file($str_alt219$cae_query_search_tables, dump_directory, UNPROVIDED);
							SubLObject filename_var = cae_query_search_tables_file;
							SubLObject stream = NIL;
							try {
								{
									SubLObject _prev_bind_0_95 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_95, thread);
									}
								}
								if (!stream.isStream()) {
									Errors.error($str_alt65$Unable_to_open__S, filename_var);
								}
								{
									SubLObject stream_96 = stream;
									com.cyc.cycjava.cycl.dumper.dump_copyright(stream_96);
									cae_query_search.dump_cae_query_search_tables_to_stream(stream_96);
								}
							} finally {
								{
									SubLObject _prev_bind_0_97 = $is_thread_performing_cleanupP$.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_97, thread);
									}
								}
							}
							com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
						}
						noting_progress_postamble();
					} finally {
						$noting_progress_start_time$.rebind(_prev_bind_0, thread);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject dump_cae_query_search_tables(final SubLObject dump_directory) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != non_tiny_kb_loadedP()) {
			final SubLObject str = dumper.$str576$Dumping_CAE_query_search_tables__;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				cae_query_search.ensure_cae_query_search_tables_initialization();
				final SubLObject filename_var;
				final SubLObject cae_query_search_tables_file = filename_var = dumper
						.kb_dump_file(dumper.$str577$cae_query_search_tables, dump_directory, UNPROVIDED);
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$651 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$651, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$652 = stream;
					if ($OUTPUT == $INPUT) {
						stream_$652 = file_utilities.enable_file_stream_memory_mapping(stream_$652);
					}
					try {
						dumper.dump_copyright(stream_$652);
						cae_query_search.dump_cae_query_search_tables_to_stream(stream_$652);
					} finally {
						final SubLObject _prev_bind_0_$652 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$652, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$652, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$653 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$653, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject load_cae_query_search_tables_alt(SubLObject dump_directory) {
		if (NIL != Filesys.probe_file(com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt219$cae_query_search_tables,
				dump_directory, UNPROVIDED))) {
			return com.cyc.cycjava.cycl.dumper.load_unit_file(dump_directory, $str_alt219$cae_query_search_tables,
					LOAD_CAE_QUERY_SEARCH_TABLES_FROM_STREAM, $str_alt221$Loading_CAE_Query_Search_Tables__);
		}
		return T;
	}

	public static SubLObject load_cae_query_search_tables(final SubLObject dump_directory) {
		if (NIL != Filesys
				.probe_file(dumper.kb_dump_file(dumper.$str577$cae_query_search_tables, dump_directory, UNPROVIDED))) {
			return dumper.load_unit_file(dump_directory, dumper.$str577$cae_query_search_tables,
					dumper.LOAD_CAE_QUERY_SEARCH_TABLES_FROM_STREAM, dumper.$str579$Loading_CAE_Query_Search_Tables__);
		}
		return T;
	}

	public static final SubLObject dump_sbhl_time_state_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject sbhl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt222$sbhl_time, directory_path,
						UNPROVIDED);
				SubLObject filename_var = sbhl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_98 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_98);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt223$Dumping_sbhl_time_state___);
								cfasl_output(sbhl_time_vars.$sbhl_temporal_link_support_table$.getGlobalValue(),
										stream_98);
								cfasl_output(
										sbhl_time_vars.$sbhl_temporal_link_disjunction_support_table$.getGlobalValue(),
										stream_98);
								cfasl_output(
										sbhl_time_vars.$sbhl_temporal_link_disjunction_term_table$.getGlobalValue(),
										stream_98);
								cfasl_output(sbhl_time_vars.$sbhl_extended_universal_date_list$.getGlobalValue(),
										stream_98);
								cfasl_output(sbhl_time_dates.$sbhl_time_date_graph$.getGlobalValue(), stream_98);
								cfasl_output(sbhl_time_dates.$sbhl_time_date_object_predicate_links$.getGlobalValue(),
										stream_98);
								cfasl_output(sbhl_time_dates.$sbhl_time_date_object_inverse_links$.getGlobalValue(),
										stream_98);
								cfasl_output(sbhl_time_dates.$sbhl_time_object_date_predicate_links$.getGlobalValue(),
										stream_98);
								cfasl_output(sbhl_time_dates.$sbhl_time_object_date_inverse_links$.getGlobalValue(),
										stream_98);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_sbhl_time_state(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject filename_var;
			final SubLObject sbhl_file = filename_var = dumper.kb_dump_file(dumper.$str580$sbhl_time, directory_path,
					UNPROVIDED);
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0_$655 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $OUTPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$655, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$656 = stream;
				if ($OUTPUT == $INPUT) {
					stream_$656 = file_utilities.enable_file_stream_memory_mapping(stream_$656);
				}
				try {
					dumper.dump_copyright(stream_$656);
					final SubLObject str = dumper.$str581$Dumping_sbhl_time_state____;
					final SubLObject _prev_bind_0_$656 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_1_$658 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						cfasl_output($sbhl_temporal_link_support_table$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_temporal_link_disjunction_support_table$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_temporal_link_disjunction_term_table$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_extended_universal_date_list$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_time_date_graph$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_time_date_object_predicate_links$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_time_date_object_inverse_links$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_time_object_date_predicate_links$.getGlobalValue(), stream_$656);
						cfasl_output($sbhl_time_object_date_inverse_links$.getGlobalValue(), stream_$656);
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_8, thread);
						$is_noting_progressP$.rebind(_prev_bind_7, thread);
						$progress_count$.rebind(_prev_bind_6, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
						$progress_notification_count$.rebind(_prev_bind_4, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_1_$658, thread);
						$progress_start_time$.rebind(_prev_bind_0_$656, thread);
					}
				} finally {
					final SubLObject _prev_bind_0_$657 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$656, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$657, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$658 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$658, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject load_sbhl_time_state_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt222$sbhl_time, directory_path,
						UNPROVIDED);
				if (NIL == Filesys.probe_file(cfasl_file)) {
					cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($$$sbhl, directory_path, UNPROVIDED);
				}
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_99 = stream;
								SubLObject total = file_length(stream_99);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_99);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt225$Loading_SBHL_time_state___);
										sbhl_time_vars.$sbhl_temporal_link_support_table$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_vars.$sbhl_temporal_link_disjunction_support_table$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_vars.$sbhl_temporal_link_disjunction_term_table$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_vars.$sbhl_extended_universal_date_list$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_dates.$sbhl_time_date_graph$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_dates.$sbhl_time_date_object_predicate_links$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_dates.$sbhl_time_date_object_inverse_links$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_dates.$sbhl_time_object_date_predicate_links$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										sbhl_time_dates.$sbhl_time_object_date_inverse_links$
												.setGlobalValue(cfasl_input(stream_99, UNPROVIDED, UNPROVIDED));
										if (cfasl_input(stream_99, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt226$_d_bytes_of_unread_sbhl_time_stat,
													subtract(total, compatibility.get_file_position(stream_99)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_sbhl_time_state(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str580$sbhl_time, directory_path, UNPROVIDED);
		if (NIL == Filesys.probe_file(cfasl_file)) {
			cfasl_file = dumper.kb_dump_file(dumper.$$$sbhl, directory_path, UNPROVIDED);
		}
		if (NIL != dumper.verify_file_existence(cfasl_file, UNPROVIDED)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$661 = stream;
				if ($INPUT == $INPUT) {
					stream_$661 = file_utilities.enable_file_stream_memory_mapping(stream_$661);
				}
				try {
					final SubLObject total = file_length(stream_$661);
					dumper.load_copyright(stream_$661);
					final SubLObject str = dumper.$str583$Loading_SBHL_time_state____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						$sbhl_temporal_link_support_table$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_temporal_link_disjunction_support_table$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_temporal_link_disjunction_term_table$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_extended_universal_date_list$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_time_date_graph$.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_time_date_object_predicate_links$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_time_date_object_inverse_links$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_time_object_date_predicate_links$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						$sbhl_time_object_date_inverse_links$
								.setGlobalValue(cfasl_input(stream_$661, UNPROVIDED, UNPROVIDED));
						if (cfasl_input(stream_$661, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str584$_d_bytes_of_unread_sbhl_time_stat,
									subtract(total, compatibility.get_file_position(stream_$661)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$661, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject rebuild_sbhl_time_data_alt() {
		sbhl_link_methods.make_all_sbhl_time_links();
		return NIL;
	}

	public static SubLObject rebuild_sbhl_time_data() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$662 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$663 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$662);
			final SubLObject memory_mappedP_$664 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$662);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$662);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$662);
				final SubLObject manager_$663 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$664 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$663);
				final SubLObject memory_mappedP_$665 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$663);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$663);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$663);
					final SubLObject manager_$664 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$665 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$664);
					final SubLObject memory_mappedP_$666 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$664);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$664);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$664);
						final SubLObject manager_$665 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$666 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$665);
						final SubLObject memory_mappedP_$667 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$665);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$665);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$665);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								make_all_sbhl_time_links();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$666) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$665);
								}
								if (NIL == memory_mappedP_$667) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$665,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$665) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$664);
							}
							if (NIL == memory_mappedP_$666) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$664,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$664) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$663);
						}
						if (NIL == memory_mappedP_$665) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$663,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$663) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$662);
					}
					if (NIL == memory_mappedP_$664) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$662, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject dump_rtp_rules_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt227$rtp_rules_cache,
						directory_path, UNPROVIDED);
				SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_100 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_100);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt228$Dumping_RTP_rules_cache___);
								rtp_datastructures.dump_rtp_rules_cache_to_stream(stream_100);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_rtp_rules_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject cfasl_file = filename_var = dumper.kb_dump_file(dumper.$str585$rtp_rules_cache, directory_path,
				UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$674 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$674 = file_utilities.enable_file_stream_memory_mapping(stream_$674);
			}
			try {
				dumper.dump_copyright(stream_$674);
				final SubLObject str = dumper.$str586$Dumping_RTP_rules_cache____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					rtp_datastructures.dump_rtp_rules_cache_to_stream(stream_$674);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$674, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_rtp_rules_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt227$rtp_rules_cache,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_101 = stream;
								SubLObject total = file_length(stream_101);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_101);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt229$Loading_RTP_rules_cache___);
										rtp_datastructures.load_rtp_rules_cache_from_stream(stream_101);
										if (cfasl_input(stream_101, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_101)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_rtp_rules_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = StreamsLow.$stream_initial_input_buffer_size$.currentBinding(thread);
		final SubLObject _prev_bind_2 = StreamsLow.$stream_initial_output_buffer_size$.currentBinding(thread);
		try {
			StreamsLow.$stream_initial_input_buffer_size$
					.bind(file_utilities.$default_big_stream_buffer_size$.getDynamicValue(thread), thread);
			StreamsLow.$stream_initial_output_buffer_size$
					.bind(StreamsLow.$stream_initial_input_buffer_size$.getDynamicValue(thread), thread);
			final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str585$rtp_rules_cache, directory_path,
					UNPROVIDED);
			if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
				final SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					final SubLObject _prev_bind_0_$675 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream = compatibility.open_binary(filename_var, $INPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$675, thread);
					}
					if (!stream.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
					}
					SubLObject stream_$676 = stream;
					if ($INPUT == $INPUT) {
						stream_$676 = file_utilities.enable_file_stream_memory_mapping(stream_$676);
					}
					try {
						final SubLObject total = file_length(stream_$676);
						dumper.load_copyright(stream_$676);
						final SubLObject str = dumper.$str587$Loading_RTP_rules_cache____;
						final SubLObject _prev_bind_0_$676 = $progress_start_time$.currentBinding(thread);
						final SubLObject _prev_bind_1_$678 = $progress_last_pacification_time$.currentBinding(thread);
						final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$
								.currentBinding(thread);
						final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
						final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
						final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
						final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
						try {
							$progress_start_time$.bind(get_universal_time(), thread);
							$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread),
									thread);
							$progress_elapsed_seconds_for_notification$
									.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
							$progress_notification_count$.bind(ZERO_INTEGER, thread);
							$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
							$progress_count$.bind(ZERO_INTEGER, thread);
							$is_noting_progressP$.bind(T, thread);
							$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T,
									thread);
							noting_progress_preamble(str);
							rtp_datastructures.load_rtp_rules_cache_from_stream(stream_$676);
							if (cfasl_input(stream_$676, NIL, $EOF) != $EOF) {
								Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
										subtract(total, compatibility.get_file_position(stream_$676)), cfasl_file);
							}
							noting_progress_postamble();
						} finally {
							$silent_progressP$.rebind(_prev_bind_8, thread);
							$is_noting_progressP$.rebind(_prev_bind_7, thread);
							$progress_count$.rebind(_prev_bind_6, thread);
							$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
							$progress_notification_count$.rebind(_prev_bind_4, thread);
							$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
							$progress_last_pacification_time$.rebind(_prev_bind_1_$678, thread);
							$progress_start_time$.rebind(_prev_bind_0_$676, thread);
						}
					} finally {
						final SubLObject _prev_bind_0_$677 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							close(stream_$676, UNPROVIDED);
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$677, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_0_$678 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (stream.isStream()) {
							close(stream, UNPROVIDED);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$678, thread);
					}
				}
				dumper.discard_dump_filename(filename_var);
			}
		} finally {
			StreamsLow.$stream_initial_output_buffer_size$.rebind(_prev_bind_2, thread);
			StreamsLow.$stream_initial_input_buffer_size$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject dump_somewhere_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt230$somewhere_cache,
						directory_path, UNPROVIDED);
				SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_102 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_102);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt231$Dumping_somewhere_rules_cache___);
								dump_somewhere_cache_to_stream(stream_102);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_somewhere_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject cfasl_file = filename_var = dumper.kb_dump_file(dumper.$str588$somewhere_cache, directory_path,
				UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$681 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$681 = file_utilities.enable_file_stream_memory_mapping(stream_$681);
			}
			try {
				dumper.dump_copyright(stream_$681);
				final SubLObject str = dumper.$str589$Dumping_somewhere_rules_cache____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					somewhere_cache.dump_somewhere_cache_to_stream(stream_$681);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$681, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_somewhere_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt230$somewhere_cache,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_103 = stream;
								SubLObject total = file_length(stream_103);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_103);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt232$Loading_somewhere_cache___);
										load_somewhere_cache_from_stream(stream_103);
										if (cfasl_input(stream_103, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_103)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_somewhere_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str588$somewhere_cache, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$682 = stream;
				if ($INPUT == $INPUT) {
					stream_$682 = file_utilities.enable_file_stream_memory_mapping(stream_$682);
				}
				try {
					final SubLObject total = file_length(stream_$682);
					dumper.load_copyright(stream_$682);
					final SubLObject str = dumper.$str590$Loading_somewhere_cache____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						somewhere_cache.load_somewhere_cache_from_stream(stream_$682);
						if (cfasl_input(stream_$682, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$682)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$682, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject dump_arity_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt233$arity_cache,
						directory_path, UNPROVIDED);
				SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_104 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_104);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt234$Dumping_arity_cache___);
								arity.dump_arity_cache_to_stream(stream_104);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_arity_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject cfasl_file = filename_var = dumper.kb_dump_file(dumper.$str591$arity_cache, directory_path,
				UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$683 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$683 = file_utilities.enable_file_stream_memory_mapping(stream_$683);
			}
			try {
				dumper.dump_copyright(stream_$683);
				final SubLObject str = dumper.$str592$Dumping_arity_cache____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					arity.dump_arity_cache_to_stream(stream_$683);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$683, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_arity_cache_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt233$arity_cache,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_105 = stream;
								SubLObject total = file_length(stream_105);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_105);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt235$Loading_arity_cache___);
										arity.load_arity_cache_from_stream(stream_105);
										if (cfasl_input(stream_105, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_105)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_arity_cache(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str591$arity_cache, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$684 = stream;
				if ($INPUT == $INPUT) {
					stream_$684 = file_utilities.enable_file_stream_memory_mapping(stream_$684);
				}
				try {
					final SubLObject total = file_length(stream_$684);
					dumper.load_copyright(stream_$684);
					final SubLObject str = dumper.$str593$Loading_arity_cache____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						arity.load_arity_cache_from_stream(stream_$684);
						if (cfasl_input(stream_$684, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$684)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$684, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject dump_pph_phrase_shells_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			com.cyc.cycjava.cycl.dumper.dump_kb_object_count(directory_path, $str_alt236$pph_phrase_count,
					pph_data_structures.pph_phrase_count());
			{
				SubLObject pph_phrase_shell_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt237$pph_phrase_shell, directory_path, UNPROVIDED);
				SubLObject filename_var = pph_phrase_shell_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_106 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_106);
						{
							SubLObject idx = pph_data_structures.pph_phrase_id_index();
							SubLObject total = id_index_count(idx);
							SubLObject sofar = ZERO_INTEGER;
							SubLTrampolineFile.checkType($str_alt238$Dumping_pph_phrase_shells, STRINGP);
							{
								SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
								SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
								SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
								SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
								try {
									$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
									$last_percent_progress_prediction$.bind(NIL, thread);
									$within_noting_percent_progress$.bind(T, thread);
									$percent_progress_start_time$.bind(get_universal_time(), thread);
									noting_percent_progress_preamble($str_alt238$Dumping_pph_phrase_shells);
									if (NIL == do_id_index_empty_p(idx, $SKIP)) {
										{
											SubLObject suid = do_id_index_next_id(idx, NIL, NIL, NIL);
											SubLObject state_var = do_id_index_next_state(idx, NIL, suid, NIL);
											SubLObject v_pph_phrase = NIL;
											while (NIL != suid) {
												v_pph_phrase = do_id_index_state_object(idx, $SKIP, suid, state_var);
												if (NIL != do_id_index_id_and_object_validP(suid, v_pph_phrase,
														$SKIP)) {
													note_percent_progress(sofar, total);
													sofar = add(sofar, ONE_INTEGER);
													if (!suid.equal(pph_phrase.pph_phrase_suid(v_pph_phrase))) {
														Errors.warn($str_alt239$PPH_phrase__A_indexed_incorrectly,
																v_pph_phrase);
													} else {
														com.cyc.cycjava.cycl.dumper.dump_pph_phrase_shell(v_pph_phrase,
																stream_106);
													}
												}
												suid = do_id_index_next_id(idx, NIL, suid, state_var);
												state_var = do_id_index_next_state(idx, NIL, suid, state_var);
											}
										}
									}
									noting_percent_progress_postamble();
								} finally {
									$percent_progress_start_time$.rebind(_prev_bind_3, thread);
									$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
									$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
									$last_percent_progress_index$.rebind(_prev_bind_0, thread);
								}
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_pph_phrase_shells(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		dumper.dump_kb_object_count(directory_path, dumper.$str594$pph_phrase_count,
				pph_data_structures.pph_phrase_count());
		final SubLObject filename_var;
		final SubLObject pph_phrase_shell_file = filename_var = dumper.kb_dump_file(dumper.$str595$pph_phrase_shell,
				directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$685 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$685 = file_utilities.enable_file_stream_memory_mapping(stream_$685);
			}
			try {
				dumper.dump_copyright(stream_$685);
				final SubLObject idx = pph_data_structures.pph_phrase_id_index();
				final SubLObject mess = dumper.$str596$Dumping_pph_phrase_shells;
				final SubLObject total = id_index_count(idx);
				SubLObject sofar = ZERO_INTEGER;
				assert NIL != stringp(mess) : "! stringp(mess) "
						+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
				final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
				try {
					$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
					$last_percent_progress_prediction$.bind(NIL, thread);
					$within_noting_percent_progress$.bind(T, thread);
					$percent_progress_start_time$.bind(get_universal_time(), thread);
					try {
						noting_percent_progress_preamble(mess);
						final SubLObject idx_$686 = idx;
						if (NIL == id_index_objects_empty_p(idx_$686, $SKIP)) {
							final SubLObject idx_$687 = idx_$686;
							if (NIL == id_index_dense_objects_empty_p(idx_$687, $SKIP)) {
								final SubLObject vector_var = id_index_dense_objects(idx_$687);
								final SubLObject backwardP_var = NIL;
								SubLObject length;
								SubLObject v_iteration;
								SubLObject suid;
								SubLObject v_pph_phrase;
								for (length = length(
										vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
												.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
									suid = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
											: v_iteration;
									v_pph_phrase = aref(vector_var, suid);
									if ((NIL == id_index_tombstone_p(v_pph_phrase))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										if (NIL != id_index_tombstone_p(v_pph_phrase)) {
											v_pph_phrase = $SKIP;
										}
										if (!suid.equal(pph_phrase.pph_phrase_suid(v_pph_phrase))) {
											Errors.warn(dumper.$str597$PPH_phrase__A_indexed_incorrectly, v_pph_phrase);
										} else {
											dumper.dump_pph_phrase_shell(v_pph_phrase, stream_$685);
										}
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
								}
							}
							final SubLObject idx_$688 = idx_$686;
							if (NIL == id_index_sparse_objects_empty_p(idx_$688)) {
								final SubLObject cdohash_table = id_index_sparse_objects(idx_$688);
								SubLObject suid2 = NIL;
								SubLObject v_pph_phrase2 = NIL;
								final Iterator cdohash_iterator = getEntrySetIterator(cdohash_table);
								try {
									while (iteratorHasNext(cdohash_iterator)) {
										final Map.Entry cdohash_entry = iteratorNextEntry(cdohash_iterator);
										suid2 = getEntryKey(cdohash_entry);
										v_pph_phrase2 = getEntryValue(cdohash_entry);
										if (!suid2.equal(pph_phrase.pph_phrase_suid(v_pph_phrase2))) {
											Errors.warn(dumper.$str597$PPH_phrase__A_indexed_incorrectly,
													v_pph_phrase2);
										} else {
											dumper.dump_pph_phrase_shell(v_pph_phrase2, stream_$685);
										}
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
								} finally {
									releaseEntrySetIterator(cdohash_iterator);
								}
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$689 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							noting_percent_progress_postamble();
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$689, thread);
						}
					}
				} finally {
					$percent_progress_start_time$.rebind(_prev_bind_5, thread);
					$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
					$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
					$last_percent_progress_index$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					close(stream_$685, UNPROVIDED);
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values3 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values3);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_pph_phrase_shells_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt237$pph_phrase_shell,
						directory_path, UNPROVIDED);
				SubLObject pph_phrase_count = com.cyc.cycjava.cycl.dumper.load_pph_phrase_count(directory_path);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					pph_data_structures.clear_pph_phrase_id_index(
							NIL != pph_phrase_count ? ((SubLObject) (pph_phrase_count)) : ZERO_INTEGER);
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_107 = stream;
								SubLObject total = file_length(stream_107);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_107);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($str_alt240$Loading_pph_phrase_shells);
										{
											SubLObject dump_id = NIL;
											for (dump_id = cfasl_input(stream_107, NIL,
													UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_107, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_107),
														total);
												if (dump_id.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_pph_phrase_shell(dump_id,
															stream_107);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_pph_phrase_shells(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str595$pph_phrase_shell, directory_path, UNPROVIDED);
		final SubLObject pph_phrase_count = dumper.load_pph_phrase_count(directory_path);
		if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			pph_data_structures.clear_pph_phrase_id_index(NIL != pph_phrase_count ? pph_phrase_count : ZERO_INTEGER);
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$690 = stream;
				if ($INPUT == $INPUT) {
					stream_$690 = file_utilities.enable_file_stream_memory_mapping(stream_$690);
				}
				try {
					final SubLObject total = file_length(stream_$690);
					dumper.load_copyright(stream_$690);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$str598$Loading_pph_phrase_shells);
							SubLObject dump_id;
							for (dump_id = NIL, dump_id = cfasl_input(stream_$690, NIL,
									UNPROVIDED); dump_id != $EOF; dump_id = cfasl_input(stream_$690, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$690), total);
								if (dump_id.isInteger()) {
									dumper.load_pph_phrase_shell(dump_id, stream_$690);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$691 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$691, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$690, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject load_pph_phrase_count_alt(SubLObject directory_path) {
		return com.cyc.cycjava.cycl.dumper.load_kb_object_count(directory_path, $str_alt236$pph_phrase_count);
	}

	public static SubLObject load_pph_phrase_count(final SubLObject directory_path) {
		return dumper.load_kb_object_count(directory_path, dumper.$str594$pph_phrase_count);
	}

	public static final SubLObject dump_pph_phrase_shell_alt(SubLObject v_pph_phrase, SubLObject stream) {
		cfasl_output(pph_phrase.pph_phrase_suid(v_pph_phrase), stream);
		return v_pph_phrase;
	}

	public static SubLObject dump_pph_phrase_shell(final SubLObject v_pph_phrase, final SubLObject stream) {
		cfasl_output(pph_phrase.pph_phrase_suid(v_pph_phrase), stream);
		return v_pph_phrase;
	}

	public static final SubLObject load_pph_phrase_shell_alt(SubLObject dump_id, SubLObject stream) {
		return pph_data_structures.make_pph_phrase_shell(dump_id);
	}

	public static SubLObject load_pph_phrase_shell(final SubLObject dump_id, final SubLObject stream) {
		return pph_data_structures.make_pph_phrase_shell(dump_id);
	}

	public static final SubLObject dump_pph_phrase_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject pph_phrase_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt241$pph_phrase,
						directory_path, UNPROVIDED);
				SubLObject pph_phrase_index_file = com.cyc.cycjava.cycl.dumper
						.kb_dump_file($str_alt242$pph_phrase_index, directory_path, UNPROVIDED);
				SubLObject filename_var = pph_phrase_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_108 = stream;
						SubLObject filename_var_109 = pph_phrase_index_file;
						SubLObject stream_110 = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream_110 = compatibility.open_binary(filename_var_109, $OUTPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream_110.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var_109);
							}
							{
								SubLObject index_stream = stream_110;
								com.cyc.cycjava.cycl.dumper.dump_copyright(stream_108);
								{
									SubLObject fvector = create_file_vector(stream_108, index_stream);
									SubLObject idx = pph_data_structures.pph_phrase_id_index();
									SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									SubLTrampolineFile.checkType($str_alt243$Dumping_pph_phrase_definitions, STRINGP);
									{
										SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
										SubLObject _prev_bind_1 = $last_percent_progress_prediction$
												.currentBinding(thread);
										SubLObject _prev_bind_2 = $within_noting_percent_progress$
												.currentBinding(thread);
										SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											noting_percent_progress_preamble(
													$str_alt243$Dumping_pph_phrase_definitions);
											if (NIL == do_id_index_empty_p(idx, $SKIP)) {
												{
													SubLObject suid = do_id_index_next_id(idx, NIL, NIL, NIL);
													SubLObject state_var = do_id_index_next_state(idx, NIL, suid, NIL);
													SubLObject v_pph_phrase = NIL;
													while (NIL != suid) {
														v_pph_phrase = do_id_index_state_object(idx, $SKIP, suid,
																state_var);
														if (NIL != do_id_index_id_and_object_validP(suid, v_pph_phrase,
																$SKIP)) {
															note_percent_progress(sofar, total);
															sofar = add(sofar, ONE_INTEGER);
															if (!suid.equal(pph_phrase.pph_phrase_suid(v_pph_phrase))) {
																Errors.warn(
																		$str_alt239$PPH_phrase__A_indexed_incorrectly,
																		v_pph_phrase);
															} else {
																update_file_vector_index_linear(fvector);
																com.cyc.cycjava.cycl.dumper
																		.dump_pph_phrase_def(v_pph_phrase, stream_108);
															}
														}
														suid = do_id_index_next_id(idx, NIL, suid, state_var);
														state_var = do_id_index_next_state(idx, NIL, suid, state_var);
													}
												}
											}
											noting_percent_progress_postamble();
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0, thread);
										}
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream_110.isStream()) {
										close(stream_110, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var_109);
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_pph_phrase_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject pph_phrase_file = dumper.kb_dump_file(dumper.$str599$pph_phrase, directory_path, UNPROVIDED);
		final SubLObject pph_phrase_index_file = dumper.kb_dump_file(dumper.$str600$pph_phrase_index, directory_path,
				UNPROVIDED);
		final SubLObject filename_var = pph_phrase_file;
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$692 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$692 = file_utilities.enable_file_stream_memory_mapping(stream_$692);
			}
			try {
				final SubLObject filename_var_$693 = pph_phrase_index_file;
				SubLObject stream_$693 = NIL;
				try {
					final SubLObject _prev_bind_2 = stream_macros.$stream_requires_locking$.currentBinding(thread);
					try {
						stream_macros.$stream_requires_locking$.bind(NIL, thread);
						stream_$693 = compatibility.open_binary(filename_var_$693, $OUTPUT);
					} finally {
						stream_macros.$stream_requires_locking$.rebind(_prev_bind_2, thread);
					}
					if (!stream_$693.isStream()) {
						Errors.error(dumper.$str152$Unable_to_open__S, filename_var_$693);
					}
					SubLObject index_stream = stream_$693;
					if ($OUTPUT == $INPUT) {
						index_stream = file_utilities.enable_file_stream_memory_mapping(index_stream);
					}
					try {
						dumper.dump_copyright(stream_$692);
						final SubLObject fvector = file_vector.create_file_vector(stream_$692, index_stream);
						final SubLObject idx = pph_data_structures.pph_phrase_id_index();
						final SubLObject mess = dumper.$str601$Dumping_pph_phrase_definitions;
						final SubLObject total = id_index_count(idx);
						SubLObject sofar = ZERO_INTEGER;
						assert NIL != stringp(mess) : "! stringp(mess) "
								+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
						final SubLObject _prev_bind_3 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_4 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_5 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_6 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble(mess);
								final SubLObject idx_$695 = idx;
								if (NIL == id_index_objects_empty_p(idx_$695, $SKIP)) {
									final SubLObject idx_$696 = idx_$695;
									if (NIL == id_index_dense_objects_empty_p(idx_$696, $SKIP)) {
										final SubLObject vector_var = id_index_dense_objects(idx_$696);
										final SubLObject backwardP_var = NIL;
										SubLObject length;
										SubLObject v_iteration;
										SubLObject suid;
										SubLObject v_pph_phrase;
										for (length = length(
												vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
														.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
											suid = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
													: v_iteration;
											v_pph_phrase = aref(vector_var, suid);
											if ((NIL == id_index_tombstone_p(v_pph_phrase))
													|| (NIL == id_index_skip_tombstones_p($SKIP))) {
												if (NIL != id_index_tombstone_p(v_pph_phrase)) {
													v_pph_phrase = $SKIP;
												}
												if (!suid.equal(pph_phrase.pph_phrase_suid(v_pph_phrase))) {
													Errors.warn(dumper.$str597$PPH_phrase__A_indexed_incorrectly,
															v_pph_phrase);
												} else {
													file_vector.update_file_vector_index_linear(fvector);
													dumper.dump_pph_phrase_def(v_pph_phrase, stream_$692);
												}
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
										}
									}
									final SubLObject idx_$697 = idx_$695;
									if (NIL == id_index_sparse_objects_empty_p(idx_$697)) {
										final SubLObject cdohash_table = id_index_sparse_objects(idx_$697);
										SubLObject suid2 = NIL;
										SubLObject v_pph_phrase2 = NIL;
										final Iterator cdohash_iterator = getEntrySetIterator(cdohash_table);
										try {
											while (iteratorHasNext(cdohash_iterator)) {
												final Map.Entry cdohash_entry = iteratorNextEntry(cdohash_iterator);
												suid2 = getEntryKey(cdohash_entry);
												v_pph_phrase2 = getEntryValue(cdohash_entry);
												if (!suid2.equal(pph_phrase.pph_phrase_suid(v_pph_phrase2))) {
													Errors.warn(dumper.$str597$PPH_phrase__A_indexed_incorrectly,
															v_pph_phrase2);
												} else {
													file_vector.update_file_vector_index_linear(fvector);
													dumper.dump_pph_phrase_def(v_pph_phrase2, stream_$692);
												}
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
										} finally {
											releaseEntrySetIterator(cdohash_iterator);
										}
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$698 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$698, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_6, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_5, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_4, thread);
							$last_percent_progress_index$.rebind(_prev_bind_3, thread);
						}
					} finally {
						final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							close(index_stream, UNPROVIDED);
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (stream_$693.isStream()) {
							close(stream_$693, UNPROVIDED);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
					}
				}
				dumper.discard_dump_filename(filename_var_$693);
			} finally {
				final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					close(stream_$692, UNPROVIDED);
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_pph_phrase_defs_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject pph_phrase_cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt241$pph_phrase,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(pph_phrase_cfasl_file, T)) {
					{
						SubLObject pph_phrase_file = pph_phrase_cfasl_file;
						SubLObject filename_var = pph_phrase_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_111 = stream;
								SubLObject total = file_length(stream_111);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_111);
								{
									SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
									SubLObject _prev_bind_1 = $last_percent_progress_prediction$.currentBinding(thread);
									SubLObject _prev_bind_2 = $within_noting_percent_progress$.currentBinding(thread);
									SubLObject _prev_bind_3 = $percent_progress_start_time$.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										noting_percent_progress_preamble($str_alt244$Loading_pph_phrase_definitions);
										{
											SubLObject suid = NIL;
											for (suid = cfasl_input(stream_111, NIL,
													UNPROVIDED); suid != $EOF; suid = cfasl_input(stream_111, NIL,
															UNPROVIDED)) {
												note_percent_progress(compatibility.get_file_position(stream_111),
														total);
												if (suid.isInteger()) {
													com.cyc.cycjava.cycl.dumper.load_pph_phrase_def(suid, stream_111);
												} else {
													Errors.warn($str_alt245$pph_phrase_definitions_out_of_syn);
												}
											}
										}
										noting_percent_progress_postamble();
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_pph_phrase_defs(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject pph_phrase_cfasl_file = dumper.kb_dump_file(dumper.$str599$pph_phrase, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(pph_phrase_cfasl_file, T)) {
			final SubLObject filename_var;
			final SubLObject pph_phrase_file = filename_var = pph_phrase_cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$699 = stream;
				if ($INPUT == $INPUT) {
					stream_$699 = file_utilities.enable_file_stream_memory_mapping(stream_$699);
				}
				try {
					final SubLObject total = file_length(stream_$699);
					dumper.load_copyright(stream_$699);
					final SubLObject _prev_bind_2 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(dumper.$str602$Loading_pph_phrase_definitions);
							SubLObject suid;
							for (suid = NIL, suid = cfasl_input(stream_$699, NIL,
									UNPROVIDED); suid != $EOF; suid = cfasl_input(stream_$699, NIL, UNPROVIDED)) {
								note_percent_progress(compatibility.get_file_position(stream_$699), total);
								if (suid.isInteger()) {
									dumper.load_pph_phrase_def(suid, stream_$699);
								} else {
									Errors.warn(dumper.$str603$pph_phrase_definitions_out_of_syn);
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$700 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$700, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_5, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_4, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_3, thread);
						$last_percent_progress_index$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						close(stream_$699, UNPROVIDED);
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static final SubLObject dump_pph_phrase_def_alt(SubLObject v_pph_phrase, SubLObject stream) {
		cfasl_output(pph_phrase.pph_phrase_suid(v_pph_phrase), stream);
		pph_data_structures.dump_pph_phrase_content(v_pph_phrase, stream);
		return v_pph_phrase;
	}

	public static SubLObject dump_pph_phrase_def(final SubLObject v_pph_phrase, final SubLObject stream) {
		cfasl_output(pph_phrase.pph_phrase_suid(v_pph_phrase), stream);
		pph_data_structures.dump_pph_phrase_content(v_pph_phrase, stream);
		return v_pph_phrase;
	}

	public static final SubLObject load_pph_phrase_def_alt(SubLObject suid, SubLObject stream) {
		{
			SubLObject v_pph_phrase = pph_data_structures.find_pph_phrase_by_id(suid);
			pph_data_structures.load_pph_phrase_content(v_pph_phrase, stream);
			return v_pph_phrase;
		}
	}

	public static SubLObject load_pph_phrase_def(final SubLObject suid, final SubLObject stream) {
		final SubLObject v_pph_phrase = pph_data_structures.find_pph_phrase_by_id(suid);
		pph_data_structures.load_pph_phrase_content(v_pph_phrase, stream);
		return v_pph_phrase;
	}

	public static final SubLObject dump_gen_template_store_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt246$gen_template_store,
						directory_path, UNPROVIDED);
				SubLObject filename_var = cfasl_file;
				SubLObject stream = NIL;
				try {
					{
						SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
						try {
							stream_macros.$stream_requires_locking$.bind(NIL, thread);
							stream = compatibility.open_binary(filename_var, $OUTPUT, NIL);
						} finally {
							stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
						}
					}
					if (!stream.isStream()) {
						Errors.error($str_alt65$Unable_to_open__S, filename_var);
					}
					{
						SubLObject stream_112 = stream;
						com.cyc.cycjava.cycl.dumper.dump_copyright(stream_112);
						{
							SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
							try {
								$noting_progress_start_time$.bind(get_universal_time(), thread);
								noting_progress_preamble($str_alt247$Dumping___genTemplate_store___);
								pph_data_structures.dump_gen_template_store_to_stream(stream_112);
								noting_progress_postamble();
							} finally {
								$noting_progress_start_time$.rebind(_prev_bind_0, thread);
							}
						}
					}
				} finally {
					{
						SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							if (stream.isStream()) {
								close(stream, UNPROVIDED);
							}
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
						}
					}
				}
				com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
			}
			return NIL;
		}
	}

	public static SubLObject dump_gen_template_store(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject filename_var;
		final SubLObject cfasl_file = filename_var = dumper.kb_dump_file(dumper.$str604$gen_template_store,
				directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$701 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$701 = file_utilities.enable_file_stream_memory_mapping(stream_$701);
			}
			try {
				dumper.dump_copyright(stream_$701);
				final SubLObject str = dumper.$str605$Dumping___genTemplate_store____;
				final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					pph_data_structures.dump_gen_template_store_to_stream(stream_$701);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_9, thread);
					$is_noting_progressP$.rebind(_prev_bind_8, thread);
					$progress_count$.rebind(_prev_bind_7, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
					$progress_notification_count$.rebind(_prev_bind_5, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
					$progress_start_time$.rebind(_prev_bind_2, thread);
				}
			} finally {
				final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$701, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return NIL;
	}

	public static final SubLObject load_gen_template_store_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			{
				SubLObject cfasl_file = com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt246$gen_template_store,
						directory_path, UNPROVIDED);
				if (NIL != com.cyc.cycjava.cycl.dumper.verify_file_existence(cfasl_file, T)) {
					{
						SubLObject filename_var = cfasl_file;
						SubLObject stream = NIL;
						try {
							{
								SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$
										.currentBinding(thread);
								try {
									stream_macros.$stream_requires_locking$.bind(NIL, thread);
									stream = compatibility.open_binary(filename_var, $INPUT, NIL);
								} finally {
									stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
								}
							}
							if (!stream.isStream()) {
								Errors.error($str_alt65$Unable_to_open__S, filename_var);
							}
							{
								SubLObject stream_113 = stream;
								SubLObject total = file_length(stream_113);
								com.cyc.cycjava.cycl.dumper.load_copyright(stream_113);
								{
									SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
									try {
										$noting_progress_start_time$.bind(get_universal_time(), thread);
										noting_progress_preamble($str_alt248$Loading___genTemplate_store___);
										pph_data_structures.load_gen_template_store_from_stream(stream_113);
										if (cfasl_input(stream_113, NIL, $EOF) != $EOF) {
											Errors.warn($str_alt67$_d_bytes_of_unread_stuff_in__S,
													subtract(total, compatibility.get_file_position(stream_113)),
													cfasl_file);
										}
										noting_progress_postamble();
									} finally {
										$noting_progress_start_time$.rebind(_prev_bind_0, thread);
									}
								}
							}
						} finally {
							{
								SubLObject _prev_bind_0 = $is_thread_performing_cleanupP$.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									if (stream.isStream()) {
										close(stream, UNPROVIDED);
									}
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0, thread);
								}
							}
						}
						com.cyc.cycjava.cycl.dumper.discard_dump_filename(filename_var);
					}
				}
			}
			return NIL;
		}
	}

	public static SubLObject load_gen_template_store(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject cfasl_file = dumper.kb_dump_file(dumper.$str604$gen_template_store, directory_path,
				UNPROVIDED);
		if (NIL != dumper.verify_file_existence(cfasl_file, T)) {
			final SubLObject filename_var = cfasl_file;
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$702 = stream;
				if ($INPUT == $INPUT) {
					stream_$702 = file_utilities.enable_file_stream_memory_mapping(stream_$702);
				}
				try {
					final SubLObject total = file_length(stream_$702);
					dumper.load_copyright(stream_$702);
					final SubLObject str = dumper.$str606$Loading___genTemplate_store____;
					final SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
					final SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
					final SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
					final SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
					final SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
					final SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
					try {
						$progress_start_time$.bind(get_universal_time(), thread);
						$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
						$progress_elapsed_seconds_for_notification$
								.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
						$progress_notification_count$.bind(ZERO_INTEGER, thread);
						$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
						$progress_count$.bind(ZERO_INTEGER, thread);
						$is_noting_progressP$.bind(T, thread);
						$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
						noting_progress_preamble(str);
						pph_data_structures.load_gen_template_store_from_stream(stream_$702);
						if (cfasl_input(stream_$702, NIL, $EOF) != $EOF) {
							Errors.warn(dumper.$str227$_d_bytes_of_unread_stuff_in__S,
									subtract(total, compatibility.get_file_position(stream_$702)), cfasl_file);
						}
						noting_progress_postamble();
					} finally {
						$silent_progressP$.rebind(_prev_bind_9, thread);
						$is_noting_progressP$.rebind(_prev_bind_8, thread);
						$progress_count$.rebind(_prev_bind_7, thread);
						$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
						$progress_notification_count$.rebind(_prev_bind_5, thread);
						$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
						$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
						$progress_start_time$.rebind(_prev_bind_2, thread);
					}
				} finally {
					final SubLObject _prev_bind_10 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$702, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_10, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_11 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_11, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		}
		return NIL;
	}

	public static SubLObject dump_pph_name_string_preds(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject preds = pph_methods.pph_name_string_preds(UNPROVIDED);
		final SubLObject filename_var = dumper.kb_dump_file(dumper.$str607$pph_name_string_preds, directory_path,
				UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$703 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$703 = file_utilities.enable_file_stream_memory_mapping(stream_$703);
			}
			try {
				dumper.dump_copyright(stream_$703);
				cfasl_output(preds, stream_$703);
			} finally {
				final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$703, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return $DUMPED;
	}

	public static SubLObject dump_pph_phrase_fns(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL == pph_functions.pph_phrase_fns_initializedP()) {
			pph_functions.initialize_pph_phrase_fns();
		}
		final SubLObject filename_var = dumper.kb_dump_file(dumper.$str609$pph_phrase_fns, directory_path, UNPROVIDED);
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_binary(filename_var, $OUTPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
			}
			SubLObject stream_$704 = stream;
			if ($OUTPUT == $INPUT) {
				stream_$704 = file_utilities.enable_file_stream_memory_mapping(stream_$704);
			}
			try {
				dumper.dump_copyright(stream_$704);
				cfasl_output(pph_vars.$pph_phrase_fns$.getDynamicValue(thread), stream_$704);
			} finally {
				final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					close(stream_$704, UNPROVIDED);
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
			}
		}
		dumper.discard_dump_filename(filename_var);
		return $DUMPED;
	}

	public static SubLObject load_pph_phrase_fns(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject file_name = dumper.kb_dump_file(dumper.$str609$pph_phrase_fns, directory_path, UNPROVIDED);
		if (NIL != dumper.verify_file_existence(file_name, T)) {
			final SubLObject filename_var = dumper.kb_dump_file(dumper.$str609$pph_phrase_fns, directory_path,
					UNPROVIDED);
			SubLObject stream = NIL;
			try {
				final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
				try {
					stream_macros.$stream_requires_locking$.bind(NIL, thread);
					stream = compatibility.open_binary(filename_var, $INPUT);
				} finally {
					stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
				}
				if (!stream.isStream()) {
					Errors.error(dumper.$str152$Unable_to_open__S, filename_var);
				}
				SubLObject stream_$705 = stream;
				if ($INPUT == $INPUT) {
					stream_$705 = file_utilities.enable_file_stream_memory_mapping(stream_$705);
				}
				try {
					dumper.load_copyright(stream_$705);
					pph_vars.$pph_phrase_fns$.setDynamicValue(cfasl_input(stream_$705, UNPROVIDED, UNPROVIDED), thread);
				} finally {
					final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(stream_$705, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (stream.isStream()) {
						close(stream, UNPROVIDED);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
				}
			}
			dumper.discard_dump_filename(filename_var);
		} else {
			pph_functions.initialize_pph_phrase_fns();
		}
		return $LOADED;
	}

	public static final SubLObject dump_paraphrase_cycl_caches_alt(SubLObject directory_path) {
		pph_data_structures.optimize_pph_phrase_id_index(T);
		com.cyc.cycjava.cycl.dumper.dump_pph_phrase_shells(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_pph_phrase_defs(directory_path);
		com.cyc.cycjava.cycl.dumper.dump_gen_template_store(directory_path);
		return NIL;
	}

	public static SubLObject dump_paraphrase_cycl_caches(final SubLObject directory_path) {
		pph_main.ensure_pph_initialized();
		pph_data_structures.optimize_pph_phrase_id_index(T);
		dumper.dump_pph_phrase_shells(directory_path);
		dumper.dump_pph_phrase_defs(directory_path);
		dumper.dump_gen_template_store(directory_path);
		dumper.dump_pph_phrase_fns(directory_path);
		dumper.dump_pph_name_string_preds(directory_path);
		return NIL;
	}

	public static final SubLObject rebuild_pph_phrases_alt() {
		pph_data_structures.clear_gen_template_store();
		return pph_templates.initialize_gen_template_store();
	}

	public static SubLObject rebuild_pph_phrases() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$706 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$707 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$706);
			final SubLObject memory_mappedP_$708 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$706);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$706);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$706);
				final SubLObject manager_$707 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$708 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$707);
				final SubLObject memory_mappedP_$709 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$707);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$707);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$707);
					final SubLObject manager_$708 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$709 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$708);
					final SubLObject memory_mappedP_$710 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$708);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$708);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$708);
						final SubLObject manager_$709 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$710 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$709);
						final SubLObject memory_mappedP_$711 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$709);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$709);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$709);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								pph_data_structures.clear_gen_template_store();
								pph_templates.initialize_gen_template_store();
							} finally {
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								if (NIL != maintaining_countsP_$710) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$709);
								}
								if (NIL == memory_mappedP_$711) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$709,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$709) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$708);
							}
							if (NIL == memory_mappedP_$710) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$708,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$708) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$707);
						}
						if (NIL == memory_mappedP_$709) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$707,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$707) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$706);
					}
					if (NIL == memory_mappedP_$708) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$706, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return NIL;
	}

	public static final SubLObject load_paraphrase_cycl_caches_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if ((((NIL != Filesys.probe_file(
					com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt237$pph_phrase_shell, directory_path, UNPROVIDED)))
					&& (NIL != Filesys.probe_file(com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt242$pph_phrase_index,
							directory_path, UNPROVIDED))))
					&& (NIL != Filesys.probe_file(com.cyc.cycjava.cycl.dumper.kb_dump_file($str_alt241$pph_phrase,
							directory_path, UNPROVIDED))))
					&& (NIL != Filesys.probe_file(com.cyc.cycjava.cycl.dumper
							.kb_dump_file($str_alt246$gen_template_store, directory_path, UNPROVIDED)))) {
				{
					SubLObject _prev_bind_0 = $noting_progress_start_time$.currentBinding(thread);
					try {
						$noting_progress_start_time$.bind(get_universal_time(), thread);
						noting_progress_preamble($str_alt249$Initializing_minor_paraphrase_Cyc);
						initialize_pph_vars();
						pph_utilities.initialize_pph_constant_key_ids();
						init_pph_name_string_preds();
						pph_data_structures.clear_gen_template_store();
						pph_types.initialize_pph_phrase_fns();
						noting_progress_postamble();
					} finally {
						$noting_progress_start_time$.rebind(_prev_bind_0, thread);
					}
				}
				com.cyc.cycjava.cycl.dumper.load_pph_phrase_shells(directory_path);
				com.cyc.cycjava.cycl.dumper.load_pph_phrase_defs(directory_path);
				com.cyc.cycjava.cycl.dumper.load_gen_template_store(directory_path);
				pph_main.clear_paraphrase_caches(UNPROVIDED, UNPROVIDED);
				pph_data_structures.note_gen_template_store_initialized();
				if (NIL == com.cyc.cycjava.cycl.dumper.load_pph_phrase_count(directory_path)) {
					pph_data_structures.optimize_pph_phrase_id_index(NIL);
				}
				pph_main.set_pph_initialized();
			}
			return NIL;
		}
	}

	public static SubLObject load_paraphrase_cycl_caches(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if ((((NIL != Filesys
				.probe_file(dumper.kb_dump_file(dumper.$str595$pph_phrase_shell, directory_path, UNPROVIDED)))
				&& (NIL != Filesys
						.probe_file(dumper.kb_dump_file(dumper.$str600$pph_phrase_index, directory_path, UNPROVIDED))))
				&& (NIL != Filesys
						.probe_file(dumper.kb_dump_file(dumper.$str599$pph_phrase, directory_path, UNPROVIDED))))
				&& (NIL != Filesys.probe_file(
						dumper.kb_dump_file(dumper.$str604$gen_template_store, directory_path, UNPROVIDED)))) {
			final SubLObject str = dumper.$str611$Initializing_minor_paraphrase_Cyc;
			final SubLObject _prev_bind_0 = $progress_start_time$.currentBinding(thread);
			final SubLObject _prev_bind_2 = $progress_last_pacification_time$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
			final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
			final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
			final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
			final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
			final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
			try {
				$progress_start_time$.bind(get_universal_time(), thread);
				$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
				$progress_elapsed_seconds_for_notification$
						.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
				$progress_notification_count$.bind(ZERO_INTEGER, thread);
				$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
				$progress_count$.bind(ZERO_INTEGER, thread);
				$is_noting_progressP$.bind(T, thread);
				$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
				noting_progress_preamble(str);
				pph_vars.initialize_pph_vars();
				pph_data_structures.clear_gen_template_store();
				noting_progress_postamble();
			} finally {
				$silent_progressP$.rebind(_prev_bind_8, thread);
				$is_noting_progressP$.rebind(_prev_bind_7, thread);
				$progress_count$.rebind(_prev_bind_6, thread);
				$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
				$progress_notification_count$.rebind(_prev_bind_4, thread);
				$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
				$progress_last_pacification_time$.rebind(_prev_bind_2, thread);
				$progress_start_time$.rebind(_prev_bind_0, thread);
			}
			dumper.load_pph_phrase_fns(directory_path);
			dumper.load_pph_phrase_shells(directory_path);
			dumper.load_pph_phrase_defs(directory_path);
			dumper.load_gen_template_store(directory_path);
			pph_main.clear_paraphrase_caches(UNPROVIDED, UNPROVIDED);
			pph_data_structures.note_gen_template_store_initialized();
			if (NIL == dumper.load_pph_phrase_count(directory_path)) {
				pph_data_structures.optimize_pph_phrase_id_index(NIL);
			}
			pph_main.set_pph_initialized();
		}
		return NIL;
	}

	public static final SubLObject dump_kb_activities_alt(SubLObject directory_path) {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(T, $str_alt250$________Performing_other_KB_dump_, numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			com.cyc.cycjava.cycl.dumper.generate_constant_shell_file(directory_path);
			return NIL;
		}
	}

	public static SubLObject dump_kb_activities(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(T, dumper.$str612$________Performing_other_KB_dump_, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		dumper.generate_constant_shell_file(directory_path);
		return NIL;
	}

	/**
	 * Initializations which should be run whenever the KB is loaded. Note that the
	 * definition of initialization has stretched to include the building of huge
	 * structures. Large structures must be loaded and dumped like other large
	 * structure. Initialization need to be FAST to support starting up a Cyc image
	 * without a world from units.
	 */
	@LispMethod(comment = "Initializations which should be run whenever the KB is loaded.  Note that the definition of initialization has stretched to include the building of huge structures.  Large structures must be loaded and dumped like other large structure.  Initialization need to be FAST to support starting up a Cyc image without a world from units.")
	public static final SubLObject load_kb_initializations_alt() {
		{
			final SubLThread thread = SubLProcess.currentSubLThread();
			if (NIL != $dump_verbose$.getDynamicValue(thread)) {
				format(StreamsLow.$standard_output$.getDynamicValue(thread),
						$str_alt251$________Performing_KB_initializat, numeric_date_utilities.timestring(UNPROVIDED));
				force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
			}
			sbhl_module_vars.clean_sbhl_modules();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			constant_completion.compute_bogus_constant_names_in_code();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			initialize_kb_state_hashes();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			ke.initialize_old_constant_names();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			initialize_kb_variables();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			if (NIL != kb_control_vars.reformulator_kb_loaded_p()) {
				if (NIL == reformulator_datastructures.reformulator_variables_initializedP()) {
					reformulator_datastructures.initialize_reformulator_variables();
				}
				if (NIL == reformulator_datastructures.reformulator_rules_initializedP()) {
					reformulator_rule_unifier_datastructures.rebuild_reformulator_rules();
				}
			}
			if (NIL != kb_control_vars.lexicon_kb_loaded_p()) {
				lexicon_cache.initialize_lexicon_modules();
				com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			}
			open_cyc_inference_api.initialize_open_cyc_inference_api_vars();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			com.cyc.cycjava.cycl.dumper.rebuild_computable_but_not_dumpable_yet();
			com.cyc.cycjava.cycl.dumper.kb_load_gc_checkpoint();
			if (NIL == non_tiny_kb_loadedP()) {
				system_parameters.$allow_guest_to_editP$.setDynamicValue(T, thread);
			}
			return NIL;
		}
	}

	/**
	 * Initializations which should be run whenever the KB is loaded. Note that the
	 * definition of initialization has stretched to include the building of huge
	 * structures. Large structures must be loaded and dumped like other large
	 * structure. Initialization need to be FAST to support starting up a Cyc image
	 * without a world from units.
	 */
	@LispMethod(comment = "Initializations which should be run whenever the KB is loaded.  Note that the definition of initialization has stretched to include the building of huge structures.  Large structures must be loaded and dumped like other large structure.  Initialization need to be FAST to support starting up a Cyc image without a world from units.")
	public static SubLObject load_kb_initializations() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str613$________Performing_KB_initializat, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		clean_sbhl_modules();
		dumper.kb_load_gc_checkpoint();
		constant_completion.compute_bogus_constant_names_in_code();
		dumper.kb_load_gc_checkpoint();
		kb_utilities.initialize_kb_state_hashes();
		dumper.kb_load_gc_checkpoint();
		ke.initialize_old_constant_names();
		dumper.kb_load_gc_checkpoint();
		initialize_kb_variables();
		dumper.kb_load_gc_checkpoint();
		if (NIL != kb_control_vars.reformulator_kb_loaded_p()) {
			if (NIL == reformulator_datastructures.reformulator_variables_initializedP()) {
				reformulator_datastructures.initialize_reformulator_variables();
			}
			if (NIL == reformulator_datastructures.reformulator_rules_initializedP()) {
				reformulator_rule_unifier_datastructures.rebuild_reformulator_rules();
			}
		}
		if (NIL != kb_control_vars.lexicon_kb_loaded_p()) {
			lexicon_cache.initialize_lexicon_modules();
			dumper.kb_load_gc_checkpoint();
		}
		open_cyc_inference_api.initialize_open_cyc_inference_api_vars();
		dumper.kb_load_gc_checkpoint();
		dumper.rebuild_computable_but_not_dumpable_yet();
		dumper.kb_load_gc_checkpoint();
		if (NIL == non_tiny_kb_loadedP()) {
			system_parameters.$allow_guest_to_editP$.setDynamicValue(T, thread);
		}
		return NIL;
	}

	/**
	 * If the code is missing, assume the relevant portion of the KB is also
	 * missing, because it won't matter if it's there.
	 */
	@LispMethod(comment = "If the code is missing, assume the relevant portion of the KB is also missing,\r\nbecause it won\'t matter if it\'s there.\nIf the code is missing, assume the relevant portion of the KB is also missing,\nbecause it won\'t matter if it\'s there.")
	public static final SubLObject initialize_kb_features_alt() {
		reformulator_datastructures.initialize_reformulator_kb_feature();
		pph_utilities.initialize_paraphrase_kb_feature();
		task_scheduler.initialize_cyc_task_scheduler_kb_feature();
		sksi_infrastructure_utilities.initialize_sksi_kb_feature();
		quantities.initialize_quant_kb_feature();
		date_utilities.initialize_date_kb_feature();
		sbhl_time_utilities.initialize_time_kb_feature();
		if (NIL == kb_control_vars.time_kb_loaded_p()) {
			hlmt.disable_hlmts();
		}
		lexicon_cache.initialize_lexicon_kb_feature();
		parsing_vars.initialize_nl_kb_feature();
		rtp_initialize.initialize_rtp_kb_feature();
		rkf_tools.initialize_rkf_kb_feature();
		tm_control_vars.initialize_thesaurus_kb_feature();
		wordnet.initialize_wordnet_kb_feature();
		shop_main.initialize_planner_kb_feature();
		// infrastructure_vars.initialize_cyc_secure_kb_feature();
		kct_utils.initialize_kct_kb_feature();
		return NIL;
	}

	/**
	 * If the code is missing, assume the relevant portion of the KB is also
	 * missing, because it won't matter if it's there.
	 */
	@LispMethod(comment = "If the code is missing, assume the relevant portion of the KB is also missing,\r\nbecause it won\'t matter if it\'s there.\nIf the code is missing, assume the relevant portion of the KB is also missing,\nbecause it won\'t matter if it\'s there.")
	public static SubLObject initialize_kb_features() {
		reformulator_datastructures.initialize_reformulator_kb_feature();
		pph_utilities.initialize_paraphrase_kb_feature();
		sksi_infrastructure_utilities.initialize_sksi_kb_feature();
		quantities.initialize_quant_kb_feature();
		date_utilities.initialize_date_kb_feature();
		extended_numbers.initialize_fraction_kb_feature();
		initialize_time_kb_feature();
		if (NIL == kb_control_vars.time_kb_loaded_p()) {
			hlmt.disable_hlmts();
		}
		lexicon_cache.initialize_lexicon_kb_feature();
		parsing_vars.initialize_nl_kb_feature();
		wordnet_import.initialize_wordnet_import_kb_feature();
		rtp_initialize.initialize_rtp_kb_feature();
		rkf_tools.initialize_rkf_kb_feature();
		wordnet.initialize_wordnet_kb_feature();
		shop_main.initialize_planner_kb_feature();
		kct_utils.initialize_kct_kb_feature();
		return NIL;
	}

	public static final SubLObject show_kb_features_alt() {
		format(T, $str_alt252$Reformulator___A__, kb_control_vars.reformulator_kb_loaded_p());
		format(T, $str_alt253$Paraphrase___A__, kb_control_vars.paraphrase_kb_loaded_p());
		format(T, $str_alt254$Cyc_Task_Scheduler___A__, kb_control_vars.cyc_task_scheduler_kb_loaded_p());
		format(T, $str_alt255$SKSI___A__, kb_control_vars.sksi_kb_loaded_p());
		format(T, $str_alt256$Quant___A__, kb_control_vars.quant_kb_loaded_p());
		format(T, $str_alt257$Date___A__, kb_control_vars.date_kb_loaded_p());
		format(T, $str_alt258$Time___A__, kb_control_vars.time_kb_loaded_p());
		format(T, $str_alt259$Lexicon___A__, kb_control_vars.lexicon_kb_loaded_p());
		format(T, $str_alt260$NL___A__, kb_control_vars.nl_kb_loaded_p());
		format(T, $str_alt261$RTP___A__, kb_control_vars.rtp_kb_loaded_p());
		format(T, $str_alt262$RKF___A__, kb_control_vars.rkf_kb_loaded_p());
		format(T, $str_alt263$Thesaurus___A__, kb_control_vars.thesaurus_kb_loaded_p());
		format(T, $str_alt264$Wordnet___A__, kb_control_vars.wordnet_kb_loaded_p());
		format(T, $str_alt265$Planner___A__, kb_control_vars.planner_kb_loaded_p());
		format(T, $str_alt266$Secure___A__, kb_control_vars.cyc_secure_kb_loaded_p());
		force_output(T);
		return NIL;
	}

	public static SubLObject show_kb_features() {
		format(T, dumper.$str614$Reformulator___A__, kb_control_vars.reformulator_kb_loaded_p());
		format(T, dumper.$str615$Paraphrase___A__, kb_control_vars.paraphrase_kb_loaded_p());
		format(T, dumper.$str616$Cyc_Task_Scheduler___A__, kb_control_vars.cyc_task_scheduler_kb_loaded_p());
		format(T, dumper.$str617$SKSI___A__, kb_control_vars.sksi_kb_loaded_p());
		format(T, dumper.$str618$Quant___A__, kb_control_vars.quant_kb_loaded_p());
		format(T, dumper.$str619$Date___A__, kb_control_vars.date_kb_loaded_p());
		format(T, dumper.$str620$Time___A__, kb_control_vars.time_kb_loaded_p());
		format(T, dumper.$str621$Lexicon___A__, kb_control_vars.lexicon_kb_loaded_p());
		format(T, dumper.$str622$NL___A__, kb_control_vars.nl_kb_loaded_p());
		format(T, dumper.$str623$RTP___A__, kb_control_vars.rtp_kb_loaded_p());
		format(T, dumper.$str624$RKF___A__, kb_control_vars.rkf_kb_loaded_p());
		format(T, dumper.$str625$Thesaurus___A__, kb_control_vars.thesaurus_kb_loaded_p());
		format(T, dumper.$str626$Wordnet___A__, kb_control_vars.wordnet_kb_loaded_p());
		format(T, dumper.$str627$Planner___A__, kb_control_vars.planner_kb_loaded_p());
		format(T, dumper.$str628$Secure___A__, kb_control_vars.cyc_secure_kb_loaded_p());
		force_output(T);
		return NIL;
	}

	public static SubLObject dump_essential_kb_evaluatable(SubLObject output_dir) {
		if (output_dir == UNPROVIDED) {
			output_dir = dumper.$str629$_scratch_;
		}
		$save_asked_queriesP$.setDynamicValue(NIL);
		dumper.dump_essential_kb_constants_evaluatable(
				cconcatenate(output_dir, dumper.$str630$load_all_constants_lisp));
		dumper.dump_essential_kb_narts_evaluatable(cconcatenate(output_dir, dumper.$str631$load_all_narts_lisp));
		dumper.dump_essential_kb_assertions_evaluatable(
				cconcatenate(output_dir, dumper.$str632$load_all_assertions_lisp));
		dumper.dump_essential_kb_kb_hl_supports_evaluatable(
				cconcatenate(output_dir, dumper.$str633$load_all_kb_hl_supports_lisp),
				cconcatenate(output_dir, dumper.$str634$load_all_kb_hl_supports_just_lisp));
		dumper.dump_essential_kb_deductions_evaluatable(
				cconcatenate(output_dir, dumper.$str635$load_all_deductions_lisp), UNPROVIDED, UNPROVIDED);
		dumper.dump_essential_kb_bookkeeping_gafs_evaluatable(
				cconcatenate(output_dir, dumper.$str636$load_all_bookkeeping_gafs_lisp));
		dumper.dump_experience(output_dir, NIL);
		dumper.dump_special_objects(output_dir);
		dump_active_kb_sbhl_caching_policies(output_dir, T);
		return NIL;
	}

	public static SubLObject load_essential_kb_evaluatable_file(final SubLObject directory_path,
			final SubLObject file_name, final SubLObject file_type, final SubLObject first_file_type,
			final SubLObject finish_after_loading_specified_file_typeP, final SubLObject ops_per_transaction,
			final SubLObject start_operation, final SubLObject stop_operation, final SubLObject checkpoint_dir) {
		return NIL;
	}

	public static SubLObject load_essential_kb_evaluatable(final SubLObject directory_path, SubLObject files,
			SubLObject finish_after_loading_specified_typeP, SubLObject ops_per_transaction, SubLObject start_operation,
			SubLObject stop_operation, SubLObject checkpoint_dir, SubLObject database_dir) {
		if (files == UNPROVIDED) {
			files = $ALL;
		}
		if (finish_after_loading_specified_typeP == UNPROVIDED) {
			finish_after_loading_specified_typeP = NIL;
		}
		if (ops_per_transaction == UNPROVIDED) {
			ops_per_transaction = dumper.$int$250;
		}
		if (start_operation == UNPROVIDED) {
			start_operation = ZERO_INTEGER;
		}
		if (stop_operation == UNPROVIDED) {
			stop_operation = NIL;
		}
		if (checkpoint_dir == UNPROVIDED) {
			checkpoint_dir = NIL;
		}
		if (database_dir == UNPROVIDED) {
			database_dir = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		$save_asked_queriesP$.setDynamicValue(NIL, thread);
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str641$________Loading_evaluatable_essen, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		final SubLObject _prev_bind_0 = $bootstrapping_kbP$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $save_asked_queriesP$.currentBinding(thread);
		try {
			$bootstrapping_kbP$.bind(T, thread);
			$save_asked_queriesP$.bind(NIL, thread);
			core.core_kb_start_bootstrapping();
			initialize_non_fort_isa_tables();
			system_parameters.load_system_parameters();
			final SubLObject _prev_bind_0_$718 = dumper.$bootstrapping_constantsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_constantsP$.bind(T, thread);
				final SubLObject str = dumper.$$$Loading_constants;
				final SubLObject _prev_bind_0_$719 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$720 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str630$load_all_constants_lisp), ops_per_transaction,
							start_operation, stop_operation);
					synchronize_constants_with_hl_store();
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$720, thread);
					$progress_start_time$.rebind(_prev_bind_0_$719, thread);
				}
			} finally {
				dumper.$bootstrapping_constantsP$.rebind(_prev_bind_0_$718, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$720 = dumper.$bootstrapping_nartsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_nartsP$.bind(T, thread);
				final SubLObject str = dumper.$$$Loading_narts;
				final SubLObject _prev_bind_0_$721 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$721 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str631$load_all_narts_lisp), UNPROVIDED, UNPROVIDED,
							UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$721, thread);
					$progress_start_time$.rebind(_prev_bind_0_$721, thread);
				}
			} finally {
				dumper.$bootstrapping_nartsP$.rebind(_prev_bind_0_$720, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$722 = dumper.$bootstrapping_assertionsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_assertionsP$.bind(T, thread);
				final SubLObject str = dumper.$$$Loading_assertions;
				final SubLObject _prev_bind_0_$723 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$722 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str632$load_all_assertions_lisp), UNPROVIDED,
							UNPROVIDED, UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$722, thread);
					$progress_start_time$.rebind(_prev_bind_0_$723, thread);
				}
			} finally {
				dumper.$bootstrapping_assertionsP$.rebind(_prev_bind_0_$722, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$724 = dumper.$bootstrapping_kb_hl_supportsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_kb_hl_supportsP$.bind(T, thread);
				final SubLObject str = dumper.$str645$Loading_definitions_for_KB_HL_sup;
				final SubLObject _prev_bind_0_$725 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$723 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str633$load_all_kb_hl_supports_lisp), UNPROVIDED,
							UNPROVIDED, UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$723, thread);
					$progress_start_time$.rebind(_prev_bind_0_$725, thread);
				}
			} finally {
				dumper.$bootstrapping_kb_hl_supportsP$.rebind(_prev_bind_0_$724, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$726 = dumper.$bootstrapping_kb_hl_supportsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_kb_hl_supportsP$.bind(T, thread);
				final SubLObject str = dumper.$str646$Loading_justifications_for_KB_HL_;
				final SubLObject _prev_bind_0_$727 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$724 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str634$load_all_kb_hl_supports_just_lisp), UNPROVIDED,
							UNPROVIDED, UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$724, thread);
					$progress_start_time$.rebind(_prev_bind_0_$727, thread);
				}
			} finally {
				dumper.$bootstrapping_kb_hl_supportsP$.rebind(_prev_bind_0_$726, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$728 = dumper.$bootstrapping_deductionsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_deductionsP$.bind(T, thread);
				final SubLObject str = dumper.$$$Loading_deductions;
				final SubLObject _prev_bind_0_$729 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$725 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str635$load_all_deductions_lisp), UNPROVIDED,
							UNPROVIDED, UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$725, thread);
					$progress_start_time$.rebind(_prev_bind_0_$729, thread);
				}
			} finally {
				dumper.$bootstrapping_deductionsP$.rebind(_prev_bind_0_$728, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			final SubLObject _prev_bind_0_$730 = dumper.$bootstrapping_bookkeeping_gafsP$.currentBinding(thread);
			try {
				dumper.$bootstrapping_bookkeeping_gafsP$.bind(T, thread);
				final SubLObject str = dumper.$$$Loading_bookkeeping_data;
				final SubLObject _prev_bind_0_$731 = $progress_start_time$.currentBinding(thread);
				final SubLObject _prev_bind_1_$726 = $progress_last_pacification_time$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
				final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
				final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
				final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
				final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
				try {
					$progress_start_time$.bind(get_universal_time(), thread);
					$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
					$progress_elapsed_seconds_for_notification$
							.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
					$progress_notification_count$.bind(ZERO_INTEGER, thread);
					$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
					$progress_count$.bind(ZERO_INTEGER, thread);
					$is_noting_progressP$.bind(T, thread);
					$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
					noting_progress_preamble(str);
					dumper.read_and_eval_evaluatable_dump_file(
							cconcatenate(directory_path, dumper.$str636$load_all_bookkeeping_gafs_lisp), UNPROVIDED,
							UNPROVIDED, UNPROVIDED);
					noting_progress_postamble();
				} finally {
					$silent_progressP$.rebind(_prev_bind_8, thread);
					$is_noting_progressP$.rebind(_prev_bind_7, thread);
					$progress_count$.rebind(_prev_bind_6, thread);
					$progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
					$progress_notification_count$.rebind(_prev_bind_4, thread);
					$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
					$progress_last_pacification_time$.rebind(_prev_bind_1_$726, thread);
					$progress_start_time$.rebind(_prev_bind_0_$731, thread);
				}
			} finally {
				dumper.$bootstrapping_bookkeeping_gafsP$.rebind(_prev_bind_0_$730, thread);
			}
			alexandria_iterators.clear_alexandria_caches();
			dumper.$kb_dump_common_symbols$.setDynamicValue(dumper.load_special_objects(directory_path, NIL), thread);
			dumper.load_experience(directory_path);
			dumper.load_essential_kb_initializations();
			wff_vars.$wff_mode$.setDynamicValue($STRICT, thread);
			forward.perform_forward_inference();
			return NIL;
		} finally {
			$save_asked_queriesP$.rebind(_prev_bind_2, thread);
			$bootstrapping_kbP$.rebind(_prev_bind_0, thread);
		}
	}

	public static SubLObject rebuild_alexandria_computable_kb() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		misc_utilities.system_code_initializations(UNPROVIDED);
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str651$________Rebuilding_Computable_KB_, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		$save_asked_queriesP$.setDynamicValue(NIL, thread);
		dumper.load_essential_kb_initializations();
		wff_vars.$wff_mode$.setDynamicValue($STRICT, thread);
		forward.perform_forward_inference();
		synchronize_constants_with_hl_store();
		final SubLObject _prev_bind_0 = dumper.$compute_arg_type_cache_on_dumpP$.currentBinding(thread);
		try {
			dumper.$compute_arg_type_cache_on_dumpP$.bind(NIL, thread);
			cardinality_estimates.setup_cardinality_tables(constant_count());
			dumper.load_essential_kb_initializations();
			misc_utilities.system_code_hl_initializations();
			misc_utilities.system_kb_initializations();
			dumper.rebuild_computable_content_dumpable(T);
			wff_utilities.set_check_wff_semantics();
			$bootstrapping_kbP$.setDynamicValue(NIL, thread);
			wff_vars.$wff_mode$.setDynamicValue($ASSERTIVE, thread);
			czer_vars.$simplify_non_wff_literalP$.setDynamicValue(T, thread);
		} finally {
			dumper.$compute_arg_type_cache_on_dumpP$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject load_alexandria_computable_kb_from_directory(final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject _prev_bind_0 = $structure_resourcing_make_static$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $cfasl_input_to_static_area$.currentBinding(thread);
		try {
			$structure_resourcing_make_static$.bind(T, thread);
			$cfasl_input_to_static_area$.bind(T, thread);
			dumper.load_experience(directory_path);
		} finally {
			$cfasl_input_to_static_area$.rebind(_prev_bind_2, thread);
			$structure_resourcing_make_static$.rebind(_prev_bind_0, thread);
		}
		$save_asked_queriesP$.setDynamicValue(NIL, thread);
		dumper.load_essential_kb_initializations();
		wff_vars.$wff_mode$.setDynamicValue($STRICT, thread);
		forward.perform_forward_inference();
		synchronize_constants_with_hl_store();
		dumper.$kb_dump_common_symbols$.setDynamicValue(dumper.load_special_objects(directory_path, UNPROVIDED),
				thread);
		final SubLObject common_symbols = dumper.$kb_dump_common_symbols$.getDynamicValue(thread);
		if (NIL == dumper.$force_monolithic_kb_assumption$.getGlobalValue()) {
			misc_utilities.initialize_hl_store_cache_directory_and_shared_symbols(directory_path, common_symbols);
			dumper.kb_load_gc_checkpoint();
		}
		dumper.kb_possibly_load_manifest_from_directory(directory_path);
		final SubLObject _prev_bind_3 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(common_symbols);
			final SubLObject _prev_bind_0_$739 = api_control_vars.$cfasl_constant_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_4 = api_control_vars.$cfasl_nart_handle_lookup_func$.currentBinding(thread);
			final SubLObject _prev_bind_5 = api_control_vars.$cfasl_assertion_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_6 = api_control_vars.$cfasl_deduction_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_7 = api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$
					.currentBinding(thread);
			final SubLObject _prev_bind_8 = api_control_vars.$cfasl_clause_struc_handle_lookup_func$
					.currentBinding(thread);
			try {
				api_control_vars.$cfasl_constant_handle_lookup_func$.bind(dumper.FIND_CONSTANT_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.bind(dumper.FIND_NART_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.bind(dumper.FIND_ASSERTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.bind(dumper.FIND_DEDUCTION_BY_DUMP_ID, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.bind(dumper.FIND_KB_HL_SUPPORT_BY_DUMP_ID,
						thread);
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.bind(dumper.FIND_CLAUSE_STRUC_BY_DUMP_ID,
						thread);
				dumper.load_computable_content(directory_path);
			} finally {
				api_control_vars.$cfasl_clause_struc_handle_lookup_func$.rebind(_prev_bind_8, thread);
				api_control_vars.$cfasl_kb_hl_support_handle_lookup_func$.rebind(_prev_bind_7, thread);
				api_control_vars.$cfasl_deduction_handle_lookup_func$.rebind(_prev_bind_6, thread);
				api_control_vars.$cfasl_assertion_handle_lookup_func$.rebind(_prev_bind_5, thread);
				api_control_vars.$cfasl_nart_handle_lookup_func$.rebind(_prev_bind_4, thread);
				api_control_vars.$cfasl_constant_handle_lookup_func$.rebind(_prev_bind_0_$739, thread);
			}
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_3, thread);
		}
		return NIL;
	}

	public static SubLObject dump_alexandria_units(final SubLObject kb_loaded,
			final SubLObject essential_evaluatable_directory_path, final SubLObject directory_path) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (NIL != dumper.$dump_verbose$.getDynamicValue(thread)) {
			format(StreamsLow.$standard_output$.getDynamicValue(thread),
					dumper.$str653$________Dumping_Computable_KB_at_, numeric_date_utilities.timestring(UNPROVIDED));
			force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		}
		$save_asked_queriesP$.setDynamicValue(NIL, thread);
		dumper.$compute_arg_type_cache_on_dumpP$.setDynamicValue(NIL, thread);
		set_kb_loaded(kb_loaded);
		final SubLObject _prev_bind_0 = $cfasl_common_symbols$.currentBinding(thread);
		try {
			$cfasl_common_symbols$.bind(NIL, thread);
			cfasl_set_common_symbols(dumper.kb_dump_common_symbols());
			dumper.dump_computable_remaining_hl(directory_path, T);
		} finally {
			$cfasl_common_symbols$.rebind(_prev_bind_0, thread);
		}
		SubLObject str = dumper.$$$Dumping_rule_utility_experience;
		SubLObject _prev_bind_2 = $progress_start_time$.currentBinding(thread);
		SubLObject _prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
		SubLObject _prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		SubLObject _prev_bind_5 = $progress_notification_count$.currentBinding(thread);
		SubLObject _prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		SubLObject _prev_bind_7 = $progress_count$.currentBinding(thread);
		SubLObject _prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
		SubLObject _prev_bind_9 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			file_utilities.copy_file_checked(
					cconcatenate(essential_evaluatable_directory_path, dumper.$str655$rule_utility_experience_cfasl),
					cconcatenate(directory_path, dumper.$str655$rule_utility_experience_cfasl));
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_9, thread);
			$is_noting_progressP$.rebind(_prev_bind_8, thread);
			$progress_count$.rebind(_prev_bind_7, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
			$progress_notification_count$.rebind(_prev_bind_5, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
			$progress_start_time$.rebind(_prev_bind_2, thread);
		}
		str = dumper.$$$Dumping_sbhl_caching_policies;
		_prev_bind_2 = $progress_start_time$.currentBinding(thread);
		_prev_bind_3 = $progress_last_pacification_time$.currentBinding(thread);
		_prev_bind_4 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
		_prev_bind_5 = $progress_notification_count$.currentBinding(thread);
		_prev_bind_6 = $progress_pacifications_since_last_nl$.currentBinding(thread);
		_prev_bind_7 = $progress_count$.currentBinding(thread);
		_prev_bind_8 = $is_noting_progressP$.currentBinding(thread);
		_prev_bind_9 = $silent_progressP$.currentBinding(thread);
		try {
			$progress_start_time$.bind(get_universal_time(), thread);
			$progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
			$progress_elapsed_seconds_for_notification$
					.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
			$progress_notification_count$.bind(ZERO_INTEGER, thread);
			$progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
			$progress_count$.bind(ZERO_INTEGER, thread);
			$is_noting_progressP$.bind(T, thread);
			$silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
			noting_progress_preamble(str);
			file_utilities.copy_file_checked(
					cconcatenate(essential_evaluatable_directory_path,
							dumper.$str657$standard_kb_sbhl_caching_policies),
					cconcatenate(directory_path, dumper.$str657$standard_kb_sbhl_caching_policies));
			noting_progress_postamble();
		} finally {
			$silent_progressP$.rebind(_prev_bind_9, thread);
			$is_noting_progressP$.rebind(_prev_bind_8, thread);
			$progress_count$.rebind(_prev_bind_7, thread);
			$progress_pacifications_since_last_nl$.rebind(_prev_bind_6, thread);
			$progress_notification_count$.rebind(_prev_bind_5, thread);
			$progress_elapsed_seconds_for_notification$.rebind(_prev_bind_4, thread);
			$progress_last_pacification_time$.rebind(_prev_bind_3, thread);
			$progress_start_time$.rebind(_prev_bind_2, thread);
		}
		return NIL;
	}

	public static SubLObject load_rebuild_and_dump_alexandria_computable_kb(final SubLObject kb_loaded,
			final SubLObject essential_evaluatable_directory_path, final SubLObject directory_path) {
		dumper.load_essential_kb_evaluatable(essential_evaluatable_directory_path, UNPROVIDED, UNPROVIDED, UNPROVIDED,
				UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
		dumper.rebuild_alexandria_computable_kb();
		dumper.dump_alexandria_units(kb_loaded, essential_evaluatable_directory_path, directory_path);
		return NIL;
	}

	public static SubLObject rebuild_and_dump_alexandria_computable_kb(final SubLObject kb_loaded,
			final SubLObject essential_evaluatable_directory_path, final SubLObject directory_path) {
		dumper.rebuild_alexandria_computable_kb();
		dumper.dump_alexandria_units(kb_loaded, essential_evaluatable_directory_path, directory_path);
		return NIL;
	}

	public static SubLObject count_forms_in_file(final SubLObject file_name) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject forms = ZERO_INTEGER;
		SubLObject stream = NIL;
		try {
			stream = compatibility.open_text(file_name, $INPUT);
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, file_name);
			}
			final SubLObject bad_stream = stream;
			final SubLObject infile = file_utilities.change_file_stream_buffer_size(bad_stream, dumper.$int$4000000);
			try {
				if (infile.isStream()) {
					final SubLObject _prev_bind_0 = $read_suppress$.currentBinding(thread);
					try {
						$read_suppress$.bind(NIL, thread);
						SubLObject var;
						for (var = NIL, var = read(infile, NIL, $EOF, UNPROVIDED); $EOF != var; var = read(infile, NIL,
								$EOF, UNPROVIDED)) {
							forms = add(forms, ONE_INTEGER);
						}
					} finally {
						$read_suppress$.rebind(_prev_bind_0, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_2 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					if (infile.isStream()) {
						close(infile, UNPROVIDED);
					}
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_2, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
			}
		}
		return forms;
	}

	public static SubLObject read_and_eval_evaluatable_dump_file(final SubLObject file_name,
			SubLObject operations_per_transaction, SubLObject min_op, SubLObject max_op) {
		if (operations_per_transaction == UNPROVIDED) {
			operations_per_transaction = TEN_INTEGER;
		}
		if (min_op == UNPROVIDED) {
			min_op = ZERO_INTEGER;
		}
		if (max_op == UNPROVIDED) {
			max_op = dumper.$int$15000000;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		if (min_op == NIL) {
			min_op = ZERO_INTEGER;
		}
		if (max_op == NIL) {
			max_op = dumper.$int$2000000000;
		}
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_text(file_name, $INPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, file_name);
			}
			final SubLObject bad_stream = stream;
			final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream, dumper.$int$32000000);
			SubLObject total_op_count = MINUS_ONE_INTEGER;
			SubLObject processed_op_count = ZERO_INTEGER;
			final SubLObject _prev_bind_2 = kb_control_vars.$forward_inference_enabledP$.currentBinding(thread);
			final SubLObject _prev_bind_3 = $bootstrapping_kbP$.currentBinding(thread);
			try {
				kb_control_vars.$forward_inference_enabledP$.bind(NIL, thread);
				$bootstrapping_kbP$.bind(T, thread);
				try {
					SubLObject operation = NIL;
					SubLObject cur_op_count = ZERO_INTEGER;
					SubLObject mem_clear_count = ZERO_INTEGER;
					kb_store_utils.avoid_using_simple_indexing(T);
					while ($EOF != operation) {
						while (($EOF != operation) && cur_op_count.numL(operations_per_transaction)) {
							cur_op_count = add(cur_op_count, ONE_INTEGER);
							total_op_count = add(total_op_count, ONE_INTEGER);
							note_progress();
							if (total_op_count.numGE(min_op)) {
								operation = read(s, NIL, $EOF, UNPROVIDED);
							} else {
								final SubLObject _prev_bind_0_$740 = $read_suppress$.currentBinding(thread);
								try {
									$read_suppress$.bind(T, thread);
									operation = read(s, NIL, $EOF, UNPROVIDED);
								} finally {
									$read_suppress$.rebind(_prev_bind_0_$740, thread);
								}
							}
							if (total_op_count.numGE(min_op)) {
								if (total_op_count.numG(max_op)) {
									operation = $EOF;
								}
								if ($EOF == operation) {
									continue;
								}
								processed_op_count = add(processed_op_count, ONE_INTEGER);
								mem_clear_count = add(mem_clear_count, ONE_INTEGER);
								if (mem_clear_count.numG(dumper.$int$20000)) {
									mem_clear_count = ZERO_INTEGER;
									alexandria_iterators.clear_alexandria_caches();
								}
								SubLObject error_message = NIL;
								try {
									thread.throwStack.push($catch_error_message_target$.getGlobalValue());
									final SubLObject _prev_bind_0_$741 = Errors.$error_handler$.currentBinding(thread);
									try {
										Errors.$error_handler$.bind(CATCH_ERROR_MESSAGE_HANDLER, thread);
										try {
											eval(operation);
										} catch (final Throwable catch_var) {
											Errors.handleThrowable(catch_var, NIL);
										}
									} finally {
										Errors.$error_handler$.rebind(_prev_bind_0_$741, thread);
									}
								} catch (final Throwable ccatch_env_var) {
									error_message = Errors.handleThrowable(ccatch_env_var,
											$catch_error_message_target$.getGlobalValue());
								} finally {
									thread.throwStack.pop();
								}
								if (!error_message.isString()) {
									continue;
								}
								Errors.warn(dumper.$str663$__Error_with_operation___A___A__, operation, error_message);
							}
						}
						cur_op_count = ZERO_INTEGER;
					}
				} finally {
					final SubLObject _prev_bind_0_$742 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						kb_store_utils.avoid_using_simple_indexing(NIL);
						kb_store_utils.possibly_commit_kb_store_transaction(T);
						close(s, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$742, thread);
					}
				}
				format(T, dumper.$str664$Processed___A__A_operations_from_,
						new SubLObject[] { processed_op_count, total_op_count, file_name });
				force_output(T);
			} finally {
				$bootstrapping_kbP$.rebind(_prev_bind_3, thread);
				kb_control_vars.$forward_inference_enabledP$.rebind(_prev_bind_2, thread);
			}
		} finally {
			final SubLObject _prev_bind_4 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_4, thread);
			}
		}
		return NIL;
	}

	public static SubLObject eval_test_operation(final SubLObject op) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		format(T, dumper.$str665$Operation__S__, op);
		force_output(StreamsLow.$standard_output$.getDynamicValue(thread));
		final SubLObject operation_type = op.first();
		final SubLObject function_name = second(op);
		final SubLObject function_args = third(op);
		final SubLObject function_expected_results = fourth(op);
		final SubLObject function_call = cons(function_name, Mapping.mapcar(dumper.QUOTIFY, function_args));
		final SubLObject result = eval(function_call);
		if ((operation_type == $ACCESSOR) && (!result.equal(function_expected_results.first()))) {
			Errors.error(dumper.$str668$Failed_operation___S__Got___S__, op, result);
		}
		return NIL;
	}

	public static SubLObject read_and_eval_test_file(final SubLObject file_name,
			SubLObject operations_per_transaction) {
		if (operations_per_transaction == UNPROVIDED) {
			operations_per_transaction = TEN_INTEGER;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject stream = NIL;
		try {
			final SubLObject _prev_bind_0 = stream_macros.$stream_requires_locking$.currentBinding(thread);
			try {
				stream_macros.$stream_requires_locking$.bind(NIL, thread);
				stream = compatibility.open_text(file_name, $INPUT);
			} finally {
				stream_macros.$stream_requires_locking$.rebind(_prev_bind_0, thread);
			}
			if (!stream.isStream()) {
				Errors.error(dumper.$str152$Unable_to_open__S, file_name);
			}
			final SubLObject bad_stream = stream;
			final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream, dumper.$int$8000000);
			final SubLObject _prev_bind_2 = $bootstrapping_kbP$.currentBinding(thread);
			try {
				$bootstrapping_kbP$.bind(T, thread);
				try {
					SubLObject operation = NIL;
					SubLObject cur_op_count = ZERO_INTEGER;
					while ($EOF != operation) {
						while (($EOF != operation) && cur_op_count.numL(operations_per_transaction)) {
							cur_op_count = add(cur_op_count, ONE_INTEGER);
							operation = cfasl_input(s, NIL, $EOF);
							if ($EOF != operation) {
								dumper.eval_test_operation(operation);
							}
						}
						cur_op_count = ZERO_INTEGER;
					}
				} finally {
					final SubLObject _prev_bind_0_$743 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values = getValuesAsVector();
						close(s, UNPROVIDED);
						restoreValuesFromVector(_values);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$743, thread);
					}
				}
			} finally {
				$bootstrapping_kbP$.rebind(_prev_bind_2, thread);
			}
		} finally {
			final SubLObject _prev_bind_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values2 = getValuesAsVector();
				if (stream.isStream()) {
					close(stream, UNPROVIDED);
				}
				restoreValuesFromVector(_values2);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_3, thread);
			}
		}
		return NIL;
	}

	public static SubLObject dump_essential_kb_constants_evaluatable(final SubLObject filename) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		set.clear_set(dumper.$dump_invalid_constants$.getGlobalValue());
		$save_asked_queriesP$.setDynamicValue(NIL, thread);
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$744 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$745 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$744);
			final SubLObject memory_mappedP_$746 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$744);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$744);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$744);
				final SubLObject manager_$745 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$746 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$745);
				final SubLObject memory_mappedP_$747 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$745);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$745);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$745);
					final SubLObject manager_$746 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$747 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$746);
					final SubLObject memory_mappedP_$748 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$746);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$746);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$746);
						final SubLObject manager_$747 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$748 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$747);
						final SubLObject memory_mappedP_$749 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$747);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$747);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$747);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							final SubLObject _prev_bind_2 = $print_pretty$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $print_length$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $print_level$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								$print_pretty$.bind(NIL, thread);
								$print_length$.bind(NIL, thread);
								$print_level$.bind(NIL, thread);
								SubLObject stream = NIL;
								try {
									final SubLObject _prev_bind_0_$756 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_text(filename, $OUTPUT);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$756, thread);
									}
									if (!stream.isStream()) {
										Errors.error(dumper.$str152$Unable_to_open__S, filename);
									}
									final SubLObject bad_stream = stream;
									final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream,
											dumper.$int$8000000);
									SubLObject name = NIL;
									SubLObject guid = NIL;
									SubLObject invalid = NIL;
									final SubLObject idx = do_constants_table();
									final SubLObject mess = dumper.$str676$Dumping_forms_to_create_all_const;
									final SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									assert NIL != stringp(mess) : "! stringp(mess) "
											+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ")
											+ mess;
									final SubLObject _prev_bind_0_$757 = $last_percent_progress_index$
											.currentBinding(thread);
									final SubLObject _prev_bind_1_$758 = $last_percent_progress_prediction$
											.currentBinding(thread);
									final SubLObject _prev_bind_2_$759 = $within_noting_percent_progress$
											.currentBinding(thread);
									final SubLObject _prev_bind_3_$760 = $percent_progress_start_time$
											.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										try {
											noting_percent_progress_preamble(mess);
											final SubLObject idx_$761 = idx;
											if (NIL == id_index_objects_empty_p(idx_$761, $SKIP)) {
												final SubLObject idx_$762 = idx_$761;
												if (NIL == id_index_dense_objects_empty_p(idx_$762, $SKIP)) {
													final SubLObject vector_var = id_index_dense_objects(idx_$762);
													final SubLObject backwardP_var = NIL;
													SubLObject length;
													SubLObject v_iteration;
													SubLObject id;
													SubLObject constant;
													for (length = length(
															vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																	.numL(length); v_iteration = add(v_iteration,
																			ONE_INTEGER)) {
														id = (NIL != backwardP_var)
																? subtract(length, v_iteration, ONE_INTEGER)
																: v_iteration;
														constant = aref(vector_var, id);
														if ((NIL == id_index_tombstone_p(constant))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															if (NIL != id_index_tombstone_p(constant)) {
																constant = $SKIP;
															}
															invalid = NIL;
															name = kb_utilities.hl_object_to_evaluatable_string(
																	constants_high.constant_name(constant), UNPROVIDED);
															if ((NIL == invalid) && (NIL == name)) {
																invalid = T;
															}
															guid = kb_utilities.hl_object_to_evaluatable_string(
																	constants_high.constant_guid(constant), UNPROVIDED);
															if ((NIL == invalid) && (NIL == guid)) {
																invalid = T;
															}
															if ((NIL == invalid) && (NIL == constants_high
																	.find_constant(eval(read_from_string(name,
																			UNPROVIDED, UNPROVIDED, UNPROVIDED,
																			UNPROVIDED, UNPROVIDED))))) {
																invalid = T;
															}
															if ((NIL == invalid) && (NIL == constants_high
																	.find_constant_by_guid(eval(read_from_string(guid,
																			UNPROVIDED, UNPROVIDED, UNPROVIDED,
																			UNPROVIDED, UNPROVIDED))))) {
																invalid = T;
															}
															if (NIL != invalid) {
																format(T,
																		dumper.$str677$Found_unfindable_constant___A_wit,
																		constant, constant_suid(constant));
																set.set_add(constant, dumper.$dump_invalid_constants$
																		.getGlobalValue());
															} else {
																format(s, dumper.$str678$_kb_create_constant__A__A___,
																		name, guid);
															}
															sofar = add(sofar, ONE_INTEGER);
															note_percent_progress(sofar, total);
														}
													}
												}
												final SubLObject idx_$763 = idx_$761;
												if ((NIL == id_index_sparse_objects_empty_p(idx_$763))
														|| (NIL == id_index_skip_tombstones_p($SKIP))) {
													final SubLObject sparse = id_index_sparse_objects(idx_$763);
													SubLObject id2 = id_index_sparse_id_threshold(idx_$763);
													final SubLObject end_id = id_index_next_id(idx_$763);
													final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
															$SKIP)) ? NIL : $SKIP;
													while (id2.numL(end_id)) {
														final SubLObject constant2 = gethash_without_values(id2, sparse,
																v_default);
														if ((NIL == id_index_skip_tombstones_p($SKIP))
																|| (NIL == id_index_tombstone_p(constant2))) {
															invalid = NIL;
															name = kb_utilities.hl_object_to_evaluatable_string(
																	constants_high.constant_name(constant2),
																	UNPROVIDED);
															if ((NIL == invalid) && (NIL == name)) {
																invalid = T;
															}
															guid = kb_utilities.hl_object_to_evaluatable_string(
																	constants_high.constant_guid(constant2),
																	UNPROVIDED);
															if ((NIL == invalid) && (NIL == guid)) {
																invalid = T;
															}
															if ((NIL == invalid) && (NIL == constants_high
																	.find_constant(eval(read_from_string(name,
																			UNPROVIDED, UNPROVIDED, UNPROVIDED,
																			UNPROVIDED, UNPROVIDED))))) {
																invalid = T;
															}
															if ((NIL == invalid) && (NIL == constants_high
																	.find_constant_by_guid(eval(read_from_string(guid,
																			UNPROVIDED, UNPROVIDED, UNPROVIDED,
																			UNPROVIDED, UNPROVIDED))))) {
																invalid = T;
															}
															if (NIL != invalid) {
																format(T,
																		dumper.$str677$Found_unfindable_constant___A_wit,
																		constant2, constant_suid(constant2));
																set.set_add(constant2, dumper.$dump_invalid_constants$
																		.getGlobalValue());
															} else {
																format(s, dumper.$str678$_kb_create_constant__A__A___,
																		name, guid);
															}
															sofar = add(sofar, ONE_INTEGER);
															note_percent_progress(sofar, total);
														}
														id2 = add(id2, ONE_INTEGER);
													}
												}
											}
										} finally {
											final SubLObject _prev_bind_0_$758 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values = getValuesAsVector();
												noting_percent_progress_postamble();
												restoreValuesFromVector(_values);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$758, thread);
											}
										}
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3_$760, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2_$759, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1_$758, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0_$757, thread);
									}
									close(s, UNPROVIDED);
								} finally {
									final SubLObject _prev_bind_0_$759 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values2 = getValuesAsVector();
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
										restoreValuesFromVector(_values2);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$759, thread);
									}
								}
							} finally {
								$print_level$.rebind(_prev_bind_4, thread);
								$print_length$.rebind(_prev_bind_3, thread);
								$print_pretty$.rebind(_prev_bind_2, thread);
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values3 = getValuesAsVector();
								if (NIL != maintaining_countsP_$748) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$747);
								}
								if (NIL == memory_mappedP_$749) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$747,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values3);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values4 = getValuesAsVector();
							if (NIL != maintaining_countsP_$747) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$746);
							}
							if (NIL == memory_mappedP_$748) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$746,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values4);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values5 = getValuesAsVector();
						if (NIL != maintaining_countsP_$746) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$745);
						}
						if (NIL == memory_mappedP_$747) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$745,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values5);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values6 = getValuesAsVector();
					if (NIL != maintaining_countsP_$745) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$744);
					}
					if (NIL == memory_mappedP_$746) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$744, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values6);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values7 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values7);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject dump_essential_kb_narts_evaluatable(final SubLObject filename) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		set.clear_set(dumper.$dump_invalid_narts$.getGlobalValue());
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$766 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$767 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$766);
			final SubLObject memory_mappedP_$768 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$766);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$766);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$766);
				final SubLObject manager_$767 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$768 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$767);
				final SubLObject memory_mappedP_$769 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$767);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$767);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$767);
					final SubLObject manager_$768 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$769 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$768);
					final SubLObject memory_mappedP_$770 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$768);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$768);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$768);
						final SubLObject manager_$769 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$770 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$769);
						final SubLObject memory_mappedP_$771 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$769);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$769);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$769);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							final SubLObject _prev_bind_2 = $print_pretty$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $print_length$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $print_level$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								$print_pretty$.bind(NIL, thread);
								$print_length$.bind(NIL, thread);
								$print_level$.bind(NIL, thread);
								SubLObject stream = NIL;
								try {
									final SubLObject _prev_bind_0_$778 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_text(filename, $OUTPUT);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$778, thread);
									}
									if (!stream.isStream()) {
										Errors.error(dumper.$str152$Unable_to_open__S, filename);
									}
									final SubLObject bad_stream = stream;
									final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream,
											dumper.$int$8000000);
									SubLObject nart_hl_formula = NIL;
									SubLObject invalid = NIL;
									final SubLObject unprocessed_narts = set.new_set(EQL, dumper.$int$150000);
									final SubLObject idx = nart_handles.do_narts_table();
									final SubLObject mess = dumper.$str680$Dumping_forms_to_create_all_narts;
									final SubLObject total = id_index_count(idx);
									SubLObject sofar = ZERO_INTEGER;
									assert NIL != stringp(mess) : "! stringp(mess) "
											+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ")
											+ mess;
									final SubLObject _prev_bind_0_$779 = $last_percent_progress_index$
											.currentBinding(thread);
									final SubLObject _prev_bind_1_$780 = $last_percent_progress_prediction$
											.currentBinding(thread);
									final SubLObject _prev_bind_2_$781 = $within_noting_percent_progress$
											.currentBinding(thread);
									final SubLObject _prev_bind_3_$782 = $percent_progress_start_time$
											.currentBinding(thread);
									try {
										$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
										$last_percent_progress_prediction$.bind(NIL, thread);
										$within_noting_percent_progress$.bind(T, thread);
										$percent_progress_start_time$.bind(get_universal_time(), thread);
										try {
											noting_percent_progress_preamble(mess);
											final SubLObject idx_$783 = idx;
											if (NIL == id_index_objects_empty_p(idx_$783, $SKIP)) {
												final SubLObject idx_$784 = idx_$783;
												if (NIL == id_index_dense_objects_empty_p(idx_$784, $SKIP)) {
													final SubLObject vector_var = id_index_dense_objects(idx_$784);
													final SubLObject backwardP_var = NIL;
													SubLObject length;
													SubLObject v_iteration;
													SubLObject id;
													SubLObject nart;
													for (length = length(
															vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																	.numL(length); v_iteration = add(v_iteration,
																			ONE_INTEGER)) {
														id = (NIL != backwardP_var)
																? subtract(length, v_iteration, ONE_INTEGER)
																: v_iteration;
														nart = aref(vector_var, id);
														if ((NIL == id_index_tombstone_p(nart))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															if (NIL != id_index_tombstone_p(nart)) {
																nart = $SKIP;
															}
															if (ZERO_INTEGER.numE(dumper.nart_depth(nart))) {
																invalid = narts_high.invalid_nart_robustP(nart);
																nart_hl_formula = kb_utilities
																		.hl_object_to_evaluatable_string(
																				narts_high.nart_hl_formula(nart),
																				UNPROVIDED);
																if (NIL == nart_hl_formula) {
																	invalid = T;
																}
																if ((NIL == invalid)
																		&& (NIL == cycl_grammar.cycl_formula_p(
																				narts_high.nart_el_formula(nart)))) {
																	invalid = T;
																}
																if ((NIL == invalid) && (NIL == narts_high.find_nart(
																		eval(read_from_string(nart_hl_formula,
																				UNPROVIDED, UNPROVIDED, UNPROVIDED,
																				UNPROVIDED, UNPROVIDED))))) {
																	invalid = T;
																}
																if (NIL != invalid) {
																	format(T,
																			dumper.$str681$Found_unfindable_nart___A_with_id,
																			nart, nart_handles.nart_id(nart));
																	set.set_add(nart, dumper.$dump_invalid_narts$
																			.getGlobalValue());
																} else {
																	format(s, dumper.$str682$_kb_create_nart__A___,
																			nart_hl_formula);
																}
															} else {
																set.set_add(nart, unprocessed_narts);
															}
															sofar = add(sofar, ONE_INTEGER);
															note_percent_progress(sofar, total);
														}
													}
												}
												final SubLObject idx_$785 = idx_$783;
												if ((NIL == id_index_sparse_objects_empty_p(idx_$785))
														|| (NIL == id_index_skip_tombstones_p($SKIP))) {
													final SubLObject sparse = id_index_sparse_objects(idx_$785);
													SubLObject id2 = id_index_sparse_id_threshold(idx_$785);
													final SubLObject end_id = id_index_next_id(idx_$785);
													final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
															$SKIP)) ? NIL : $SKIP;
													while (id2.numL(end_id)) {
														final SubLObject nart2 = gethash_without_values(id2, sparse,
																v_default);
														if ((NIL == id_index_skip_tombstones_p($SKIP))
																|| (NIL == id_index_tombstone_p(nart2))) {
															if (ZERO_INTEGER.numE(dumper.nart_depth(nart2))) {
																invalid = narts_high.invalid_nart_robustP(nart2);
																nart_hl_formula = kb_utilities
																		.hl_object_to_evaluatable_string(
																				narts_high.nart_hl_formula(nart2),
																				UNPROVIDED);
																if (NIL == nart_hl_formula) {
																	invalid = T;
																}
																if ((NIL == invalid)
																		&& (NIL == cycl_grammar.cycl_formula_p(
																				narts_high.nart_el_formula(nart2)))) {
																	invalid = T;
																}
																if ((NIL == invalid) && (NIL == narts_high.find_nart(
																		eval(read_from_string(nart_hl_formula,
																				UNPROVIDED, UNPROVIDED, UNPROVIDED,
																				UNPROVIDED, UNPROVIDED))))) {
																	invalid = T;
																}
																if (NIL != invalid) {
																	format(T,
																			dumper.$str681$Found_unfindable_nart___A_with_id,
																			nart2, nart_handles.nart_id(nart2));
																	set.set_add(nart2, dumper.$dump_invalid_narts$
																			.getGlobalValue());
																} else {
																	format(s, dumper.$str682$_kb_create_nart__A___,
																			nart_hl_formula);
																}
															} else {
																set.set_add(nart2, unprocessed_narts);
															}
															sofar = add(sofar, ONE_INTEGER);
															note_percent_progress(sofar, total);
														}
														id2 = add(id2, ONE_INTEGER);
													}
												}
											}
										} finally {
											final SubLObject _prev_bind_0_$780 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values = getValuesAsVector();
												noting_percent_progress_postamble();
												restoreValuesFromVector(_values);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$780, thread);
											}
										}
									} finally {
										$percent_progress_start_time$.rebind(_prev_bind_3_$782, thread);
										$within_noting_percent_progress$.rebind(_prev_bind_2_$781, thread);
										$last_percent_progress_prediction$.rebind(_prev_bind_1_$780, thread);
										$last_percent_progress_index$.rebind(_prev_bind_0_$779, thread);
									}
									SubLObject current_depth = ONE_INTEGER;
									while (set.set_size(unprocessed_narts).numG(ZERO_INTEGER)) {
										SubLObject cdolist_list_var = set.set_element_list(unprocessed_narts);
										SubLObject nart3 = NIL;
										nart3 = cdolist_list_var.first();
										while (NIL != cdolist_list_var) {
											if (current_depth.numE(dumper.nart_depth(nart3))) {
												invalid = NIL;
												nart_hl_formula = kb_utilities.hl_object_to_evaluatable_string(
														narts_high.nart_hl_formula(nart3), UNPROVIDED);
												if (NIL == nart_hl_formula) {
													invalid = T;
												}
												if ((NIL == invalid) && (NIL == cycl_grammar
														.cycl_formula_p(narts_high.nart_el_formula(nart3)))) {
													invalid = T;
												}
												if ((NIL == invalid) && (NIL == narts_high
														.find_nart(eval(read_from_string(nart_hl_formula, UNPROVIDED,
																UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED))))) {
													invalid = T;
												}
												if (NIL != invalid) {
													format(T, dumper.$str681$Found_unfindable_nart___A_with_id, nart3,
															nart_handles.nart_id(nart3));
													set.set_add(nart3, dumper.$dump_invalid_narts$.getGlobalValue());
												} else {
													format(s, dumper.$str682$_kb_create_nart__A___, nart_hl_formula);
												}
												set.set_remove(nart3, unprocessed_narts);
											}
											cdolist_list_var = cdolist_list_var.rest();
											nart3 = cdolist_list_var.first();
										}
										current_depth = add(current_depth, ONE_INTEGER);
									}
									close(s, UNPROVIDED);
								} finally {
									final SubLObject _prev_bind_0_$781 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values2 = getValuesAsVector();
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
										restoreValuesFromVector(_values2);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$781, thread);
									}
								}
							} finally {
								$print_level$.rebind(_prev_bind_4, thread);
								$print_length$.rebind(_prev_bind_3, thread);
								$print_pretty$.rebind(_prev_bind_2, thread);
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values3 = getValuesAsVector();
								if (NIL != maintaining_countsP_$770) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$769);
								}
								if (NIL == memory_mappedP_$771) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$769,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values3);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values4 = getValuesAsVector();
							if (NIL != maintaining_countsP_$769) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$768);
							}
							if (NIL == memory_mappedP_$770) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$768,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values4);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values5 = getValuesAsVector();
						if (NIL != maintaining_countsP_$768) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$767);
						}
						if (NIL == memory_mappedP_$769) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$767,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values5);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values6 = getValuesAsVector();
					if (NIL != maintaining_countsP_$767) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$766);
					}
					if (NIL == memory_mappedP_$768) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$766, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values6);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values7 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values7);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject exportable_assertionP(final SubLObject assertion,
			SubLObject return_cnf_and_mt_evaluatable_stringsP) {
		if (return_cnf_and_mt_evaluatable_stringsP == UNPROVIDED) {
			return_cnf_and_mt_evaluatable_stringsP = NIL;
		}
		if (((NIL == assertion_handles.assertion_p(assertion))
				|| (NIL == cycl_grammar.cycl_sentence_p(uncanonicalizer.assertion_el_formula(assertion))))
				|| (NIL == dumper.exportable_mtP(assertions_high.assertion_mt(assertion)))) {
			return NIL;
		}
		SubLObject assertion_cnf = NIL;
		SubLObject assertion_mt = NIL;
		assertion_cnf = kb_utilities.hl_object_to_evaluatable_string(assertions_high.assertion_cnf(assertion),
				UNPROVIDED);
		if (NIL == assertion_cnf) {
			return NIL;
		}
		assertion_mt = kb_utilities.hl_object_to_evaluatable_string(assertions_high.assertion_mt(assertion),
				UNPROVIDED);
		if (((NIL == assertion_mt) || (NIL != assertions_high.invalid_assertion_robustP(assertion)))
				|| (NIL == kb_indexing.find_assertion(
						eval(read_from_string(assertion_cnf, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED,
								UNPROVIDED)),
						eval(read_from_string(assertion_mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED,
								UNPROVIDED))))) {
			return NIL;
		}
		if (NIL != return_cnf_and_mt_evaluatable_stringsP) {
			return list(assertion_cnf, assertion_mt);
		}
		return T;
	}

	public static SubLObject clear_exportable_mtP() {
		final SubLObject cs = dumper.$exportable_mtP_caching_state$.getGlobalValue();
		if (NIL != cs) {
			memoization_state.caching_state_clear(cs);
		}
		return NIL;
	}

	public static SubLObject remove_exportable_mtP(final SubLObject mt) {
		return memoization_state.caching_state_remove_function_results_with_args(
				dumper.$exportable_mtP_caching_state$.getGlobalValue(), list(mt), UNPROVIDED, UNPROVIDED);
	}

	public static SubLObject exportable_mtP_internal(final SubLObject mt) {
		return hlmt.hlmtP(mt);
	}

	public static SubLObject exportable_mtP(final SubLObject mt) {
		SubLObject caching_state = dumper.$exportable_mtP_caching_state$.getGlobalValue();
		if (NIL == caching_state) {
			caching_state = memoization_state.create_global_caching_state_for_name(dumper.$sym683$EXPORTABLE_MT_,
					dumper.$sym684$_EXPORTABLE_MT__CACHING_STATE_, NIL, EQUAL, ONE_INTEGER, dumper.$int$16000);
		}
		SubLObject results = memoization_state.caching_state_lookup(caching_state, mt,
				memoization_state.$memoized_item_not_found$.getGlobalValue());
		if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
			results = arg2(resetMultipleValues(), multiple_value_list(dumper.exportable_mtP_internal(mt)));
			memoization_state.caching_state_put(caching_state, mt, results, UNPROVIDED);
		}
		return memoization_state.caching_results(results);
	}

	public static SubLObject exportable_deduction_supportsP(final SubLObject supports) {
		SubLObject result = NIL;
		SubLObject cdolist_list_var = supports;
		SubLObject support = NIL;
		support = cdolist_list_var.first();
		while (NIL != cdolist_list_var) {
			if (NIL != dumper.exportable_deduction_supportP(support)) {
				result = cons(support, result);
			}
			cdolist_list_var = cdolist_list_var.rest();
			support = cdolist_list_var.first();
		}
		return nreverse(result);
	}

	public static SubLObject clear_exportable_deduction_supportP() {
		final SubLObject cs = dumper.$exportable_deduction_supportP_caching_state$.getGlobalValue();
		if (NIL != cs) {
			memoization_state.caching_state_clear(cs);
		}
		return NIL;
	}

	public static SubLObject remove_exportable_deduction_supportP(final SubLObject support) {
		return memoization_state.caching_state_remove_function_results_with_args(
				dumper.$exportable_deduction_supportP_caching_state$.getGlobalValue(), list(support), UNPROVIDED,
				UNPROVIDED);
	}

	public static SubLObject exportable_deduction_supportP_internal(final SubLObject support) {
		if (NIL != assertion_handles.assertion_p(support)) {
			return dumper.exportable_assertionP(support, UNPROVIDED);
		}
		if (NIL != kb_hl_support_handles.kb_hl_support_p(support)) {
			return dumper.exportable_kb_hl_supportP(support);
		}
		if (NIL != arguments.hl_support_p(support)) {
			return dumper.exportable_hl_supportP(support);
		}
		return NIL;
	}

	public static SubLObject exportable_deduction_supportP(final SubLObject support) {
		SubLObject caching_state = dumper.$exportable_deduction_supportP_caching_state$.getGlobalValue();
		if (NIL == caching_state) {
			caching_state = memoization_state.create_global_caching_state_for_name(
					dumper.$sym686$EXPORTABLE_DEDUCTION_SUPPORT_,
					dumper.$sym687$_EXPORTABLE_DEDUCTION_SUPPORT__CACHING_STATE_, NIL, EQUAL, ONE_INTEGER,
					dumper.$int$300000);
		}
		SubLObject results = memoization_state.caching_state_lookup(caching_state, support,
				memoization_state.$memoized_item_not_found$.getGlobalValue());
		if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
			results = arg2(resetMultipleValues(),
					multiple_value_list(dumper.exportable_deduction_supportP_internal(support)));
			memoization_state.caching_state_put(caching_state, support, results, UNPROVIDED);
		}
		return memoization_state.caching_results(results);
	}

	public static SubLObject clear_exportable_deduction_supported_objectP() {
		final SubLObject cs = dumper.$exportable_deduction_supported_objectP_caching_state$.getGlobalValue();
		if (NIL != cs) {
			memoization_state.caching_state_clear(cs);
		}
		return NIL;
	}

	public static SubLObject remove_exportable_deduction_supported_objectP(final SubLObject supported_object) {
		return memoization_state.caching_state_remove_function_results_with_args(
				dumper.$exportable_deduction_supported_objectP_caching_state$.getGlobalValue(), list(supported_object),
				UNPROVIDED, UNPROVIDED);
	}

	public static SubLObject exportable_deduction_supported_objectP_internal(final SubLObject supported_object) {
		if (NIL == supported_object) {
			return NIL;
		}
		if (NIL != assertion_handles.assertion_p(supported_object)) {
			return dumper.exportable_assertionP(supported_object, UNPROVIDED);
		}
		if (NIL != kb_hl_support_handles.kb_hl_support_p(supported_object)) {
			return dumper.exportable_kb_hl_supportP(supported_object);
		}
		if (NIL != arguments.hl_support_p(supported_object)) {
			return dumper.exportable_hl_supportP(supported_object);
		}
		return T;
	}

	public static SubLObject exportable_deduction_supported_objectP(final SubLObject supported_object) {
		SubLObject caching_state = dumper.$exportable_deduction_supported_objectP_caching_state$.getGlobalValue();
		if (NIL == caching_state) {
			caching_state = memoization_state.create_global_caching_state_for_name(
					dumper.$sym689$EXPORTABLE_DEDUCTION_SUPPORTED_OBJECT_,
					dumper.$sym690$_EXPORTABLE_DEDUCTION_SUPPORTED_OBJECT__CACHING_STATE_, NIL, EQUAL, ONE_INTEGER,
					dumper.$int$300000);
		}
		SubLObject results = memoization_state.caching_state_lookup(caching_state, supported_object,
				memoization_state.$memoized_item_not_found$.getGlobalValue());
		if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
			results = arg2(resetMultipleValues(),
					multiple_value_list(dumper.exportable_deduction_supported_objectP_internal(supported_object)));
			memoization_state.caching_state_put(caching_state, supported_object, results, UNPROVIDED);
		}
		return memoization_state.caching_results(results);
	}

	public static SubLObject exportable_deductionP(final SubLObject ded) {
		if (NIL == ded) {
			return NIL;
		}
		if (NIL == dumper.exportable_deduction_supported_objectP(deductions_high.deduction_supported_object(ded))) {
			return NIL;
		}
		if (NIL == dumper.exportable_deduction_supportsP(deductions_high.deduction_supports(ded))) {
			return NIL;
		}
		return T;
	}

	public static SubLObject exportable_kb_hl_supportP(final SubLObject kb_hl_support) {
		if (NIL == dumper.exportable_hl_supportP(kb_hl_supports_high.kb_hl_support_hl_support(kb_hl_support))) {
			return NIL;
		}
		if (NIL == dumper
				.exportable_deduction_supportsP(kb_hl_supports_high.kb_hl_support_justification(kb_hl_support))) {
			return NIL;
		}
		return T;
	}

	public static SubLObject exportable_hl_supportP(final SubLObject hl_support) {
		if (NIL == dumper.exportable_mtP(arguments.hl_support_mt(hl_support))) {
			return NIL;
		}
		if (NIL == cycl_grammar.cycl_sentence_p(arguments.hl_support_sentence(hl_support))) {
			return NIL;
		}
		return T;
	}

	public static SubLObject clear_evaluatable_export_caches() {
		dumper.clear_exportable_deduction_supported_objectP();
		dumper.clear_exportable_deduction_supportP();
		dumper.clear_exportable_mtP();
		return NIL;
	}

	public static SubLObject dump_essential_kb_assertions_evaluatable(final SubLObject filename) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		set.clear_set(dumper.$dump_invalid_assertions$.getGlobalValue());
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$788 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$789 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$788);
			final SubLObject memory_mappedP_$790 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$788);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$788);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$788);
				final SubLObject manager_$789 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$790 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$789);
				final SubLObject memory_mappedP_$791 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$789);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$789);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$789);
					final SubLObject manager_$790 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$791 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$790);
					final SubLObject memory_mappedP_$792 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$790);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$790);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$790);
						final SubLObject manager_$791 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$792 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$791);
						final SubLObject memory_mappedP_$793 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$791);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$791);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$791);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							final SubLObject _prev_bind_2 = $print_pretty$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $print_length$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $print_level$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								$print_pretty$.bind(NIL, thread);
								$print_length$.bind(NIL, thread);
								$print_level$.bind(NIL, thread);
								SubLObject stream = NIL;
								try {
									final SubLObject _prev_bind_0_$800 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_text(filename, $OUTPUT);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$800, thread);
									}
									if (!stream.isStream()) {
										Errors.error(dumper.$str152$Unable_to_open__S, filename);
									}
									final SubLObject bad_stream = stream;
									final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream,
											dumper.$int$8000000);
									try {
										SubLObject assertion_cnf = NIL;
										SubLObject assertion_mt = NIL;
										SubLObject invalid = NIL;
										SubLObject exportableP = NIL;
										final SubLObject unprocessed_assertions = set.new_set(EQL, dumper.$int$350000);
										final SubLObject idx = assertion_handles.do_assertions_table();
										final SubLObject mess = dumper.$str692$Dumping_forms_to_create_all_asser;
										final SubLObject total = id_index_count(idx);
										SubLObject sofar = ZERO_INTEGER;
										assert NIL != stringp(mess) : "! stringp(mess) "
												+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ")
												+ mess;
										final SubLObject _prev_bind_0_$801 = $last_percent_progress_index$
												.currentBinding(thread);
										final SubLObject _prev_bind_1_$802 = $last_percent_progress_prediction$
												.currentBinding(thread);
										final SubLObject _prev_bind_2_$803 = $within_noting_percent_progress$
												.currentBinding(thread);
										final SubLObject _prev_bind_3_$804 = $percent_progress_start_time$
												.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											try {
												noting_percent_progress_preamble(mess);
												final SubLObject idx_$805 = idx;
												if (NIL == id_index_objects_empty_p(idx_$805, $SKIP)) {
													final SubLObject idx_$806 = idx_$805;
													if (NIL == id_index_dense_objects_empty_p(idx_$806, $SKIP)) {
														final SubLObject vector_var = id_index_dense_objects(idx_$806);
														final SubLObject backwardP_var = NIL;
														SubLObject length;
														SubLObject v_iteration;
														SubLObject a_id;
														SubLObject a_handle;
														SubLObject assertion;
														SubLObject who;
														SubLObject when;
														SubLObject why;
														SubLObject second;
														for (length = length(
																vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																		.numL(length); v_iteration = add(v_iteration,
																				ONE_INTEGER)) {
															a_id = (NIL != backwardP_var)
																	? subtract(length, v_iteration, ONE_INTEGER)
																	: v_iteration;
															a_handle = aref(vector_var, a_id);
															if ((NIL == id_index_tombstone_p(a_handle))
																	|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																if (NIL != id_index_tombstone_p(a_handle)) {
																	a_handle = $SKIP;
																}
																assertion = assertion_handles
																		.resolve_assertion_id_value_pair(a_id,
																				a_handle);
																if (ONE_INTEGER
																		.numE(kb_utilities.term_order(assertion))) {
																	exportableP = dumper
																			.exportable_assertionP(assertion, T);
																	invalid = sublisp_null(exportableP);
																	assertion_cnf = exportableP.first();
																	assertion_mt = second(exportableP);
																	who = assertions_high.asserted_by(assertion);
																	when = assertions_high.asserted_when(assertion);
																	why = assertions_high.asserted_why(assertion);
																	second = assertions_high.asserted_second(assertion);
																	if (NIL != invalid) {
																		format(T,
																				dumper.$str693$Found_unfindable_assertion___A_wi,
																				assertion, assertion_handles
																						.assertion_id(assertion));
																		set.set_add(assertion,
																				dumper.$dump_invalid_assertions$
																						.getGlobalValue());
																	} else {
																		if ((((NIL != who) || (NIL != when))
																				|| (NIL != why)) || (NIL != second)) {
																			format(s, dumper.$str694$_progn__);
																		}
																		format(s,
																				dumper.$str695$_csetq__last_assertion___kb_creat,
																				new SubLObject[] { assertion_cnf,
																						assertion_mt,
																						assertions_high
																								.assertion_variable_names(
																										assertion),
																						assertions_high
																								.assertion_direction(
																										assertion),
																						assertions_high.assertion_truth(
																								assertion),
																						assertions_high
																								.assertion_strength(
																										assertion),
																						assertions_high
																								.get_asserted_argument(
																										assertion) });
																		if ((((NIL != who) || (NIL != when))
																				|| (NIL != why)) || (NIL != second)) {
																			format(s,
																					dumper.$str696$_kb_timestamp_asserted_assertion_,
																					new SubLObject[] { kb_utilities
																							.hl_object_to_evaluatable_string(
																									who, UNPROVIDED),
																							when,
																							kb_utilities
																									.hl_object_to_evaluatable_string(
																											why,
																											UNPROVIDED),
																							second });
																		}
																	}
																} else {
																	set.set_add(assertion, unprocessed_assertions);
																}
																sofar = add(sofar, ONE_INTEGER);
																note_percent_progress(sofar, total);
															}
														}
													}
													final SubLObject idx_$807 = idx_$805;
													if ((NIL == id_index_sparse_objects_empty_p(idx_$807))
															|| (NIL == id_index_skip_tombstones_p($SKIP))) {
														final SubLObject sparse = id_index_sparse_objects(idx_$807);
														SubLObject a_id2 = id_index_sparse_id_threshold(idx_$807);
														final SubLObject end_id = id_index_next_id(idx_$807);
														final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																$SKIP)) ? NIL : $SKIP;
														while (a_id2.numL(end_id)) {
															final SubLObject a_handle2 = gethash_without_values(a_id2,
																	sparse, v_default);
															if ((NIL == id_index_skip_tombstones_p($SKIP))
																	|| (NIL == id_index_tombstone_p(a_handle2))) {
																final SubLObject assertion2 = assertion_handles
																		.resolve_assertion_id_value_pair(a_id2,
																				a_handle2);
																if (ONE_INTEGER
																		.numE(kb_utilities.term_order(assertion2))) {
																	exportableP = dumper
																			.exportable_assertionP(assertion2, T);
																	invalid = sublisp_null(exportableP);
																	assertion_cnf = exportableP.first();
																	assertion_mt = second(exportableP);
																	final SubLObject who2 = assertions_high
																			.asserted_by(assertion2);
																	final SubLObject when2 = assertions_high
																			.asserted_when(assertion2);
																	final SubLObject why2 = assertions_high
																			.asserted_why(assertion2);
																	final SubLObject second2 = assertions_high
																			.asserted_second(assertion2);
																	if (NIL != invalid) {
																		format(T,
																				dumper.$str693$Found_unfindable_assertion___A_wi,
																				assertion2, assertion_handles
																						.assertion_id(assertion2));
																		set.set_add(assertion2,
																				dumper.$dump_invalid_assertions$
																						.getGlobalValue());
																	} else {
																		if ((((NIL != who2) || (NIL != when2))
																				|| (NIL != why2)) || (NIL != second2)) {
																			format(s, dumper.$str694$_progn__);
																		}
																		format(s,
																				dumper.$str695$_csetq__last_assertion___kb_creat,
																				new SubLObject[] { assertion_cnf,
																						assertion_mt,
																						assertions_high
																								.assertion_variable_names(
																										assertion2),
																						assertions_high
																								.assertion_direction(
																										assertion2),
																						assertions_high.assertion_truth(
																								assertion2),
																						assertions_high
																								.assertion_strength(
																										assertion2),
																						assertions_high
																								.get_asserted_argument(
																										assertion2) });
																		if ((((NIL != who2) || (NIL != when2))
																				|| (NIL != why2)) || (NIL != second2)) {
																			format(s,
																					dumper.$str696$_kb_timestamp_asserted_assertion_,
																					new SubLObject[] { kb_utilities
																							.hl_object_to_evaluatable_string(
																									who2, UNPROVIDED),
																							when2,
																							kb_utilities
																									.hl_object_to_evaluatable_string(
																											why2,
																											UNPROVIDED),
																							second2 });
																		}
																	}
																} else {
																	set.set_add(assertion2, unprocessed_assertions);
																}
																sofar = add(sofar, ONE_INTEGER);
																note_percent_progress(sofar, total);
															}
															a_id2 = add(a_id2, ONE_INTEGER);
														}
													}
												}
											} finally {
												final SubLObject _prev_bind_0_$802 = $is_thread_performing_cleanupP$
														.currentBinding(thread);
												try {
													$is_thread_performing_cleanupP$.bind(T, thread);
													final SubLObject _values = getValuesAsVector();
													noting_percent_progress_postamble();
													restoreValuesFromVector(_values);
												} finally {
													$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$802, thread);
												}
											}
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3_$804, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2_$803, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1_$802, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0_$801, thread);
										}
										SubLObject current_depth = ONE_INTEGER;
										while (set.set_size(unprocessed_assertions).numG(ZERO_INTEGER)) {
											SubLObject cdolist_list_var = set.set_element_list(unprocessed_assertions);
											SubLObject assertion3 = NIL;
											assertion3 = cdolist_list_var.first();
											while (NIL != cdolist_list_var) {
												if (current_depth.numE(kb_utilities.term_order(assertion3))) {
													exportableP = dumper.exportable_assertionP(assertion3, T);
													invalid = sublisp_null(exportableP);
													assertion_cnf = exportableP.first();
													assertion_mt = second(exportableP);
													final SubLObject who3 = assertions_high.asserted_by(assertion3);
													final SubLObject when3 = assertions_high.asserted_when(assertion3);
													final SubLObject why3 = assertions_high.asserted_why(assertion3);
													final SubLObject second3 = assertions_high
															.asserted_second(assertion3);
													if (NIL != invalid) {
														format(T, dumper.$str697$Found_unfindable_assertion2___A_w,
																assertion3, assertion_handles.assertion_id(assertion3));
														set.set_add(assertion3,
																dumper.$dump_invalid_assertions$.getGlobalValue());
													} else {
														if ((((NIL != who3) || (NIL != when3)) || (NIL != why3))
																|| (NIL != second3)) {
															format(s, dumper.$str694$_progn__);
														}
														format(s, dumper.$str695$_csetq__last_assertion___kb_creat,
																new SubLObject[] { assertion_cnf, assertion_mt,
																		assertions_high
																				.assertion_variable_names(assertion3),
																		assertions_high.assertion_direction(assertion3),
																		assertions_high.assertion_truth(assertion3),
																		assertions_high.assertion_strength(assertion3),
																		assertions_high
																				.get_asserted_argument(assertion3) });
														if ((((NIL != who3) || (NIL != when3)) || (NIL != why3))
																|| (NIL != second3)) {
															format(s, dumper.$str696$_kb_timestamp_asserted_assertion_,
																	new SubLObject[] {
																			kb_utilities
																					.hl_object_to_evaluatable_string(
																							who3, UNPROVIDED),
																			when3,
																			kb_utilities
																					.hl_object_to_evaluatable_string(
																							why3, UNPROVIDED),
																			second3 });
														}
													}
													set.set_remove(assertion3, unprocessed_assertions);
												}
												cdolist_list_var = cdolist_list_var.rest();
												assertion3 = cdolist_list_var.first();
											}
											current_depth = add(current_depth, ONE_INTEGER);
										}
									} finally {
										final SubLObject _prev_bind_0_$803 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values2 = getValuesAsVector();
											force_output(s);
											close(s, UNPROVIDED);
											restoreValuesFromVector(_values2);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$803, thread);
										}
									}
								} finally {
									final SubLObject _prev_bind_0_$804 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values3 = getValuesAsVector();
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
										restoreValuesFromVector(_values3);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$804, thread);
									}
								}
							} finally {
								$print_level$.rebind(_prev_bind_4, thread);
								$print_length$.rebind(_prev_bind_3, thread);
								$print_pretty$.rebind(_prev_bind_2, thread);
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values4 = getValuesAsVector();
								if (NIL != maintaining_countsP_$792) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$791);
								}
								if (NIL == memory_mappedP_$793) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$791,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values4);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values5 = getValuesAsVector();
							if (NIL != maintaining_countsP_$791) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$790);
							}
							if (NIL == memory_mappedP_$792) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$790,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values5);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values6 = getValuesAsVector();
						if (NIL != maintaining_countsP_$790) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$789);
						}
						if (NIL == memory_mappedP_$791) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$789,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values6);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values7 = getValuesAsVector();
					if (NIL != maintaining_countsP_$789) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$788);
					}
					if (NIL == memory_mappedP_$790) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$788, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values7);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values8 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values8);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject dump_essential_kb_kb_hl_supports_evaluatable(final SubLObject base_filename,
			final SubLObject just_filename) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		set.clear_set(dumper.$dump_invalid_kb_hl_supports$.getGlobalValue());
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$811 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$812 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$811);
			final SubLObject memory_mappedP_$813 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$811);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$811);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$811);
				final SubLObject manager_$812 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$813 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$812);
				final SubLObject memory_mappedP_$814 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$812);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$812);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$812);
					final SubLObject manager_$813 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$814 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$813);
					final SubLObject memory_mappedP_$815 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$813);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$813);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$813);
						final SubLObject manager_$814 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$815 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$814);
						final SubLObject memory_mappedP_$816 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$814);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$814);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$814);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							final SubLObject _prev_bind_2 = $print_pretty$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $print_length$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $print_level$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								$print_pretty$.bind(NIL, thread);
								$print_length$.bind(NIL, thread);
								$print_level$.bind(NIL, thread);
								SubLObject stream = NIL;
								try {
									final SubLObject _prev_bind_0_$823 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_text(base_filename, $OUTPUT);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$823, thread);
									}
									if (!stream.isStream()) {
										Errors.error(dumper.$str152$Unable_to_open__S, base_filename);
									}
									final SubLObject bad_base_stream = stream;
									SubLObject stream_$824 = NIL;
									try {
										final SubLObject _prev_bind_0_$824 = stream_macros.$stream_requires_locking$
												.currentBinding(thread);
										try {
											stream_macros.$stream_requires_locking$.bind(NIL, thread);
											stream_$824 = compatibility.open_text(just_filename, $OUTPUT);
										} finally {
											stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$824, thread);
										}
										if (!stream_$824.isStream()) {
											Errors.error(dumper.$str152$Unable_to_open__S, just_filename);
										}
										final SubLObject bad_just_stream = stream_$824;
										final SubLObject s = file_utilities
												.change_file_stream_buffer_size(bad_base_stream, dumper.$int$8000000);
										final SubLObject u = file_utilities
												.change_file_stream_buffer_size(bad_just_stream, dumper.$int$8000000);
										try {
											SubLObject hl_support = NIL;
											SubLObject just = NIL;
											SubLObject invalid = NIL;
											final SubLObject idx = kb_hl_support_handles.do_kb_hl_supports_table();
											final SubLObject mess = dumper.$str698$Dumping_forms_to_create_all_KB_HL;
											final SubLObject total = id_index_count(idx);
											SubLObject sofar = ZERO_INTEGER;
											assert NIL != stringp(mess) : "! stringp(mess) " + ("Types.stringp(mess) "
													+ "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
											final SubLObject _prev_bind_0_$825 = $last_percent_progress_index$
													.currentBinding(thread);
											final SubLObject _prev_bind_1_$827 = $last_percent_progress_prediction$
													.currentBinding(thread);
											final SubLObject _prev_bind_2_$828 = $within_noting_percent_progress$
													.currentBinding(thread);
											final SubLObject _prev_bind_3_$829 = $percent_progress_start_time$
													.currentBinding(thread);
											try {
												$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
												$last_percent_progress_prediction$.bind(NIL, thread);
												$within_noting_percent_progress$.bind(T, thread);
												$percent_progress_start_time$.bind(get_universal_time(), thread);
												try {
													noting_percent_progress_preamble(mess);
													final SubLObject idx_$830 = idx;
													if (NIL == id_index_objects_empty_p(idx_$830, $SKIP)) {
														final SubLObject idx_$831 = idx_$830;
														if (NIL == id_index_dense_objects_empty_p(idx_$831, $SKIP)) {
															final SubLObject vector_var = id_index_dense_objects(
																	idx_$831);
															final SubLObject backwardP_var = NIL;
															SubLObject length;
															SubLObject v_iteration;
															SubLObject s_id;
															SubLObject s_handle;
															SubLObject kb_hl_support;
															for (length = length(
																	vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																			.numL(length); v_iteration = add(
																					v_iteration, ONE_INTEGER)) {
																s_id = (NIL != backwardP_var)
																		? subtract(length, v_iteration, ONE_INTEGER)
																		: v_iteration;
																s_handle = aref(vector_var, s_id);
																if ((NIL == id_index_tombstone_p(s_handle))
																		|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																	if (NIL != id_index_tombstone_p(s_handle)) {
																		s_handle = $SKIP;
																	}
																	kb_hl_support = kb_hl_support_handles
																			.resolve_kb_hl_support_id_value_pair(s_id,
																					s_handle);
																	invalid = makeBoolean(NIL == dumper
																			.exportable_kb_hl_supportP(kb_hl_support));
																	if (NIL == invalid) {
																		hl_support = kb_utilities
																				.hl_object_to_evaluatable_string(
																						kb_hl_supports_high
																								.kb_hl_support_hl_support(
																										kb_hl_support),
																						UNPROVIDED);
																	}
																	if (NIL == hl_support) {
																		invalid = T;
																	}
																	if (NIL == invalid) {
																		just = kb_utilities
																				.hl_object_to_evaluatable_string(
																						kb_hl_supports_high
																								.kb_hl_support_justification(
																										kb_hl_support),
																						UNPROVIDED);
																	}
																	if ((NIL == invalid) && (NIL == just)) {
																		invalid = T;
																	}
																	if ((NIL == invalid) && (NIL == kb_hl_supports_high
																			.find_kb_hl_support(eval(read_from_string(
																					hl_support, UNPROVIDED, UNPROVIDED,
																					UNPROVIDED, UNPROVIDED,
																					UNPROVIDED))))) {
																		invalid = T;
																	}
																	if (NIL != invalid) {
																		format(T,
																				dumper.$str699$Found_unfindable_kb_hl_support__A,
																				kb_hl_support,
																				kb_hl_support_handles.kb_hl_support_id(
																						kb_hl_support));
																		set.set_add(kb_hl_support,
																				dumper.$dump_invalid_kb_hl_supports$
																						.getGlobalValue());
																	} else {
																		format(s,
																				dumper.$str700$_create_kb_hl_support__A_NIL___,
																				hl_support);
																		format(u,
																				dumper.$str701$_kb_hl_support_reset_justificatio,
																				hl_support, just);
																	}
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
															}
														}
														final SubLObject idx_$832 = idx_$830;
														if ((NIL == id_index_sparse_objects_empty_p(idx_$832))
																|| (NIL == id_index_skip_tombstones_p($SKIP))) {
															final SubLObject sparse = id_index_sparse_objects(idx_$832);
															SubLObject s_id2 = id_index_sparse_id_threshold(idx_$832);
															final SubLObject end_id = id_index_next_id(idx_$832);
															final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																	$SKIP)) ? NIL : $SKIP;
															while (s_id2.numL(end_id)) {
																final SubLObject s_handle2 = gethash_without_values(
																		s_id2, sparse, v_default);
																if ((NIL == id_index_skip_tombstones_p($SKIP))
																		|| (NIL == id_index_tombstone_p(s_handle2))) {
																	final SubLObject kb_hl_support2 = kb_hl_support_handles
																			.resolve_kb_hl_support_id_value_pair(s_id2,
																					s_handle2);
																	invalid = makeBoolean(NIL == dumper
																			.exportable_kb_hl_supportP(kb_hl_support2));
																	if (NIL == invalid) {
																		hl_support = kb_utilities
																				.hl_object_to_evaluatable_string(
																						kb_hl_supports_high
																								.kb_hl_support_hl_support(
																										kb_hl_support2),
																						UNPROVIDED);
																	}
																	if (NIL == hl_support) {
																		invalid = T;
																	}
																	if (NIL == invalid) {
																		just = kb_utilities
																				.hl_object_to_evaluatable_string(
																						kb_hl_supports_high
																								.kb_hl_support_justification(
																										kb_hl_support2),
																						UNPROVIDED);
																	}
																	if ((NIL == invalid) && (NIL == just)) {
																		invalid = T;
																	}
																	if ((NIL == invalid) && (NIL == kb_hl_supports_high
																			.find_kb_hl_support(eval(read_from_string(
																					hl_support, UNPROVIDED, UNPROVIDED,
																					UNPROVIDED, UNPROVIDED,
																					UNPROVIDED))))) {
																		invalid = T;
																	}
																	if (NIL != invalid) {
																		format(T,
																				dumper.$str699$Found_unfindable_kb_hl_support__A,
																				kb_hl_support2,
																				kb_hl_support_handles.kb_hl_support_id(
																						kb_hl_support2));
																		set.set_add(kb_hl_support2,
																				dumper.$dump_invalid_kb_hl_supports$
																						.getGlobalValue());
																	} else {
																		format(s,
																				dumper.$str700$_create_kb_hl_support__A_NIL___,
																				hl_support);
																		format(u,
																				dumper.$str701$_kb_hl_support_reset_justificatio,
																				hl_support, just);
																	}
																	sofar = add(sofar, ONE_INTEGER);
																	note_percent_progress(sofar, total);
																}
																s_id2 = add(s_id2, ONE_INTEGER);
															}
														}
													}
												} finally {
													final SubLObject _prev_bind_0_$826 = $is_thread_performing_cleanupP$
															.currentBinding(thread);
													try {
														$is_thread_performing_cleanupP$.bind(T, thread);
														final SubLObject _values = getValuesAsVector();
														noting_percent_progress_postamble();
														restoreValuesFromVector(_values);
													} finally {
														$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$826,
																thread);
													}
												}
											} finally {
												$percent_progress_start_time$.rebind(_prev_bind_3_$829, thread);
												$within_noting_percent_progress$.rebind(_prev_bind_2_$828, thread);
												$last_percent_progress_prediction$.rebind(_prev_bind_1_$827, thread);
												$last_percent_progress_index$.rebind(_prev_bind_0_$825, thread);
											}
										} finally {
											final SubLObject _prev_bind_0_$827 = $is_thread_performing_cleanupP$
													.currentBinding(thread);
											try {
												$is_thread_performing_cleanupP$.bind(T, thread);
												final SubLObject _values2 = getValuesAsVector();
												close(s, UNPROVIDED);
												close(u, UNPROVIDED);
												restoreValuesFromVector(_values2);
											} finally {
												$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$827, thread);
											}
										}
									} finally {
										final SubLObject _prev_bind_0_$828 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values3 = getValuesAsVector();
											if (stream_$824.isStream()) {
												close(stream_$824, UNPROVIDED);
											}
											restoreValuesFromVector(_values3);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$828, thread);
										}
									}
								} finally {
									final SubLObject _prev_bind_0_$829 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values4 = getValuesAsVector();
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
										restoreValuesFromVector(_values4);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$829, thread);
									}
								}
							} finally {
								$print_level$.rebind(_prev_bind_4, thread);
								$print_length$.rebind(_prev_bind_3, thread);
								$print_pretty$.rebind(_prev_bind_2, thread);
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values5 = getValuesAsVector();
								if (NIL != maintaining_countsP_$815) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$814);
								}
								if (NIL == memory_mappedP_$816) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$814,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values5);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values6 = getValuesAsVector();
							if (NIL != maintaining_countsP_$814) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$813);
							}
							if (NIL == memory_mappedP_$815) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$813,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values6);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values7 = getValuesAsVector();
						if (NIL != maintaining_countsP_$813) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$812);
						}
						if (NIL == memory_mappedP_$814) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$812,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values7);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values8 = getValuesAsVector();
					if (NIL != maintaining_countsP_$812) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$811);
					}
					if (NIL == memory_mappedP_$813) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$811, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values8);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values9 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values9);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject dump_essential_kb_deductions_evaluatable_in_parts(final SubLObject filename,
			final SubLObject part_num, final SubLObject total_number_of_parts) {
		final SubLObject deductions_per_part = floor(divide(deduction_handles.deduction_count(), total_number_of_parts),
				UNPROVIDED);
		final SubLObject new_file_name = cconcatenate(filename,
				new SubLObject[] { dumper.$str702$_, string_utilities.to_string(part_num) });
		final SubLObject min = multiply(subtract(part_num, ONE_INTEGER), deductions_per_part);
		final SubLObject max = (part_num.numGE(total_number_of_parts)) ? deduction_handles.deduction_count()
				: add(min, deductions_per_part);
		return dumper.dump_essential_kb_deductions_evaluatable(new_file_name, min, max);
	}

	public static SubLObject dump_essential_kb_deductions_evaluatable(final SubLObject filename, SubLObject min,
			SubLObject max) {
		if (min == UNPROVIDED) {
			min = ZERO_INTEGER;
		}
		if (max == UNPROVIDED) {
			max = deduction_handles.deduction_count();
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		set.clear_set(dumper.$dump_invalid_deductions$.getGlobalValue());
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$837 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$838 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$837);
			final SubLObject memory_mappedP_$839 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$837);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$837);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$837);
				final SubLObject manager_$838 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$839 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$838);
				final SubLObject memory_mappedP_$840 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$838);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$838);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$838);
					final SubLObject manager_$839 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$840 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$839);
					final SubLObject memory_mappedP_$841 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$839);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$839);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$839);
						final SubLObject manager_$840 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$841 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$840);
						final SubLObject memory_mappedP_$842 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$840);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$840);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$840);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							final SubLObject _prev_bind_2 = $print_pretty$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $print_length$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $print_level$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								$print_pretty$.bind(NIL, thread);
								$print_length$.bind(NIL, thread);
								$print_level$.bind(NIL, thread);
								SubLObject stream = NIL;
								try {
									final SubLObject _prev_bind_0_$849 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_text(filename, $OUTPUT);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$849, thread);
									}
									if (!stream.isStream()) {
										Errors.error(dumper.$str152$Unable_to_open__S, filename);
									}
									final SubLObject bad_stream = stream;
									final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream,
											dumper.$int$8000000);
									try {
										SubLObject supported_object = NIL;
										SubLObject supports = NIL;
										SubLObject truth = NIL;
										SubLObject i = ZERO_INTEGER;
										SubLObject invalid = NIL;
										final SubLObject idx = deduction_handles.do_deductions_table();
										final SubLObject mess = dumper.$str703$Dumping_forms_to_create_all_deduc;
										final SubLObject total = id_index_count(idx);
										SubLObject sofar = ZERO_INTEGER;
										assert NIL != stringp(mess) : "! stringp(mess) "
												+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ")
												+ mess;
										final SubLObject _prev_bind_0_$850 = $last_percent_progress_index$
												.currentBinding(thread);
										final SubLObject _prev_bind_1_$851 = $last_percent_progress_prediction$
												.currentBinding(thread);
										final SubLObject _prev_bind_2_$852 = $within_noting_percent_progress$
												.currentBinding(thread);
										final SubLObject _prev_bind_3_$853 = $percent_progress_start_time$
												.currentBinding(thread);
										try {
											$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
											$last_percent_progress_prediction$.bind(NIL, thread);
											$within_noting_percent_progress$.bind(T, thread);
											$percent_progress_start_time$.bind(get_universal_time(), thread);
											try {
												noting_percent_progress_preamble(mess);
												final SubLObject idx_$854 = idx;
												if (NIL == id_index_objects_empty_p(idx_$854, $SKIP)) {
													final SubLObject idx_$855 = idx_$854;
													if (NIL == id_index_dense_objects_empty_p(idx_$855, $SKIP)) {
														final SubLObject vector_var = id_index_dense_objects(idx_$855);
														final SubLObject backwardP_var = NIL;
														SubLObject length;
														SubLObject v_iteration;
														SubLObject d_id;
														SubLObject d_handle;
														SubLObject deduction;
														for (length = length(
																vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
																		.numL(length); v_iteration = add(v_iteration,
																				ONE_INTEGER)) {
															d_id = (NIL != backwardP_var)
																	? subtract(length, v_iteration, ONE_INTEGER)
																	: v_iteration;
															d_handle = aref(vector_var, d_id);
															if ((NIL == id_index_tombstone_p(d_handle))
																	|| (NIL == id_index_skip_tombstones_p($SKIP))) {
																if (NIL != id_index_tombstone_p(d_handle)) {
																	d_handle = $SKIP;
																}
																deduction = deduction_handles
																		.resolve_deduction_id_value_pair(d_id,
																				d_handle);
																if (i.numGE(max)) {
																	return NIL;
																}
																if (i.numGE(min)) {
																	invalid = makeBoolean(NIL == dumper
																			.exportable_deductionP(deduction));
																	if (NIL == invalid) {
																		supported_object = kb_utilities
																				.hl_object_to_evaluatable_string(
																						deductions_high
																								.deduction_supported_object(
																										deduction),
																						UNPROVIDED);
																	}
																	if (NIL == supported_object) {
																		invalid = T;
																	}
																	if (NIL == invalid) {
																		supports = kb_utilities
																				.hl_object_to_evaluatable_string(dumper
																						.exportable_deduction_supportsP(
																								deductions_high
																										.deduction_supports(
																												deduction)),
																						UNPROVIDED);
																	}
																	if ((NIL == invalid) && (NIL == supports)) {
																		invalid = T;
																	}
																	truth = kb_utilities
																			.hl_object_to_evaluatable_string(
																					deductions_high.deduction_truth(
																							deduction),
																					UNPROVIDED);
																	if ((NIL == invalid) && (NIL == truth)) {
																		invalid = T;
																	}
																	if (NIL != invalid) {
																		format(T,
																				dumper.$str704$Found_unfindable_deduction__A_wit,
																				deduction, deduction_handles
																						.deduction_id(deduction));
																		set.set_add(deduction,
																				dumper.$dump_invalid_deductions$
																						.getGlobalValue());
																	} else {
																		format(s,
																				dumper.$str705$_kb_create_deduction__A__A__A__A_,
																				new SubLObject[] { supported_object,
																						supports, truth,
																						kb_utilities
																								.hl_object_to_evaluatable_string(
																										deductions_high
																												.deduction_strength(
																														deduction),
																										UNPROVIDED) });
																	}
																}
																i = add(i, ONE_INTEGER);
																sofar = add(sofar, ONE_INTEGER);
																note_percent_progress(sofar, total);
															}
														}
													}
													final SubLObject idx_$856 = idx_$854;
													if ((NIL == id_index_sparse_objects_empty_p(idx_$856))
															|| (NIL == id_index_skip_tombstones_p($SKIP))) {
														final SubLObject sparse = id_index_sparse_objects(idx_$856);
														SubLObject d_id2 = id_index_sparse_id_threshold(idx_$856);
														final SubLObject end_id = id_index_next_id(idx_$856);
														final SubLObject v_default = (NIL != id_index_skip_tombstones_p(
																$SKIP)) ? NIL : $SKIP;
														while (d_id2.numL(end_id)) {
															final SubLObject d_handle2 = gethash_without_values(d_id2,
																	sparse, v_default);
															if ((NIL == id_index_skip_tombstones_p($SKIP))
																	|| (NIL == id_index_tombstone_p(d_handle2))) {
																final SubLObject deduction2 = deduction_handles
																		.resolve_deduction_id_value_pair(d_id2,
																				d_handle2);
																if (i.numGE(max)) {
																	return NIL;
																}
																if (i.numGE(min)) {
																	invalid = makeBoolean(NIL == dumper
																			.exportable_deductionP(deduction2));
																	if (NIL == invalid) {
																		supported_object = kb_utilities
																				.hl_object_to_evaluatable_string(
																						deductions_high
																								.deduction_supported_object(
																										deduction2),
																						UNPROVIDED);
																	}
																	if (NIL == supported_object) {
																		invalid = T;
																	}
																	if (NIL == invalid) {
																		supports = kb_utilities
																				.hl_object_to_evaluatable_string(dumper
																						.exportable_deduction_supportsP(
																								deductions_high
																										.deduction_supports(
																												deduction2)),
																						UNPROVIDED);
																	}
																	if ((NIL == invalid) && (NIL == supports)) {
																		invalid = T;
																	}
																	truth = kb_utilities
																			.hl_object_to_evaluatable_string(
																					deductions_high.deduction_truth(
																							deduction2),
																					UNPROVIDED);
																	if ((NIL == invalid) && (NIL == truth)) {
																		invalid = T;
																	}
																	if (NIL != invalid) {
																		format(T,
																				dumper.$str704$Found_unfindable_deduction__A_wit,
																				deduction2, deduction_handles
																						.deduction_id(deduction2));
																		set.set_add(deduction2,
																				dumper.$dump_invalid_deductions$
																						.getGlobalValue());
																	} else {
																		format(s,
																				dumper.$str705$_kb_create_deduction__A__A__A__A_,
																				new SubLObject[] { supported_object,
																						supports, truth,
																						kb_utilities
																								.hl_object_to_evaluatable_string(
																										deductions_high
																												.deduction_strength(
																														deduction2),
																										UNPROVIDED) });
																	}
																}
																i = add(i, ONE_INTEGER);
																sofar = add(sofar, ONE_INTEGER);
																note_percent_progress(sofar, total);
															}
															d_id2 = add(d_id2, ONE_INTEGER);
														}
													}
												}
											} finally {
												final SubLObject _prev_bind_0_$851 = $is_thread_performing_cleanupP$
														.currentBinding(thread);
												try {
													$is_thread_performing_cleanupP$.bind(T, thread);
													final SubLObject _values = getValuesAsVector();
													noting_percent_progress_postamble();
													restoreValuesFromVector(_values);
												} finally {
													$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$851, thread);
												}
											}
										} finally {
											$percent_progress_start_time$.rebind(_prev_bind_3_$853, thread);
											$within_noting_percent_progress$.rebind(_prev_bind_2_$852, thread);
											$last_percent_progress_prediction$.rebind(_prev_bind_1_$851, thread);
											$last_percent_progress_index$.rebind(_prev_bind_0_$850, thread);
										}
									} finally {
										final SubLObject _prev_bind_0_$852 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values2 = getValuesAsVector();
											close(s, UNPROVIDED);
											restoreValuesFromVector(_values2);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$852, thread);
										}
									}
								} finally {
									final SubLObject _prev_bind_0_$853 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values3 = getValuesAsVector();
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
										restoreValuesFromVector(_values3);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$853, thread);
									}
								}
							} finally {
								$print_level$.rebind(_prev_bind_4, thread);
								$print_length$.rebind(_prev_bind_3, thread);
								$print_pretty$.rebind(_prev_bind_2, thread);
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values4 = getValuesAsVector();
								if (NIL != maintaining_countsP_$841) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$840);
								}
								if (NIL == memory_mappedP_$842) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$840,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values4);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values5 = getValuesAsVector();
							if (NIL != maintaining_countsP_$840) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$839);
							}
							if (NIL == memory_mappedP_$841) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$839,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values5);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values6 = getValuesAsVector();
						if (NIL != maintaining_countsP_$839) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$838);
						}
						if (NIL == memory_mappedP_$840) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$838,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values6);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values7 = getValuesAsVector();
					if (NIL != maintaining_countsP_$838) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$837);
					}
					if (NIL == memory_mappedP_$839) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$837, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values7);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values8 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values8);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject dump_essential_kb_bookkeeping_gafs_evaluatable(final SubLObject filename) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		set.clear_set(dumper.$dump_invalid_bookkeeping_gafs$.getGlobalValue());
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$860 = deduction_manager.$deduction_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$861 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$860);
			final SubLObject memory_mappedP_$862 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$860);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$860);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$860);
				final SubLObject manager_$861 = kb_hl_support_manager.$kb_hl_support_content_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$862 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$861);
				final SubLObject memory_mappedP_$863 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$861);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$861);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$861);
					final SubLObject manager_$862 = nart_index_manager.$nart_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$863 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$862);
					final SubLObject memory_mappedP_$864 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$862);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$862);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$862);
						final SubLObject manager_$863 = constant_index_manager.$constant_index_manager$
								.getGlobalValue();
						final SubLObject maintaining_countsP_$864 = kb_object_manager
								.kb_object_usage_counts_enabledP(manager_$863);
						final SubLObject memory_mappedP_$865 = kb_object_manager
								.kb_object_manager_memory_mappedP(manager_$863);
						try {
							kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$863);
							kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$863);
							final SubLObject _prev_bind_0 = $save_asked_queriesP$.currentBinding(thread);
							final SubLObject _prev_bind_2 = $print_pretty$.currentBinding(thread);
							final SubLObject _prev_bind_3 = $print_length$.currentBinding(thread);
							final SubLObject _prev_bind_4 = $print_level$.currentBinding(thread);
							try {
								$save_asked_queriesP$.bind(NIL, thread);
								$print_pretty$.bind(NIL, thread);
								$print_length$.bind(NIL, thread);
								$print_level$.bind(NIL, thread);
								SubLObject stream = NIL;
								try {
									final SubLObject _prev_bind_0_$872 = stream_macros.$stream_requires_locking$
											.currentBinding(thread);
									try {
										stream_macros.$stream_requires_locking$.bind(NIL, thread);
										stream = compatibility.open_text(filename, $OUTPUT);
									} finally {
										stream_macros.$stream_requires_locking$.rebind(_prev_bind_0_$872, thread);
									}
									if (!stream.isStream()) {
										Errors.error(dumper.$str152$Unable_to_open__S, filename);
									}
									final SubLObject bad_stream = stream;
									final SubLObject s = file_utilities.change_file_stream_buffer_size(bad_stream,
											dumper.$int$8000000);
									try {
										SubLObject count = ZERO_INTEGER;
										SubLObject cdolist_list_var = bookkeeping_store.bookkeeping_binary_gaf_store();
										SubLObject cons = NIL;
										cons = cdolist_list_var.first();
										while (NIL != cdolist_list_var) {
											SubLObject current;
											final SubLObject datum = current = cons;
											SubLObject pred = NIL;
											SubLObject subindex = NIL;
											destructuring_bind_must_consp(current, datum, dumper.$list706);
											pred = current.first();
											current = subindex = current.rest();
											SubLObject iteration_state;
											for (iteration_state = dictionary_contents
													.do_dictionary_contents_state(dictionary
															.dictionary_contents(subindex)); NIL == dictionary_contents
																	.do_dictionary_contents_doneP(
																			iteration_state); iteration_state = dictionary_contents
																					.do_dictionary_contents_next(
																							iteration_state)) {
												thread.resetMultipleValues();
												final SubLObject arg1 = dictionary_contents
														.do_dictionary_contents_key_value(iteration_state);
												final SubLObject arg2 = thread.secondMultipleValue();
												thread.resetMultipleValues();
												SubLObject should_warn = NIL;
												if ((NIL != forts.fort_p(pred)) && (NIL == forts.valid_fortP(pred))) {
													should_warn = T;
												}
												if ((NIL != forts.fort_p(arg1)) && (NIL == forts.valid_fortP(arg1))) {
													should_warn = T;
												}
												if ((NIL != forts.fort_p(arg2)) && (NIL == forts.valid_fortP(arg2))) {
													should_warn = T;
												}
												if (NIL != should_warn) {
													count = add(count, ONE_INTEGER);
													set.set_add(list(pred, arg1, arg2),
															dumper.$dump_invalid_bookkeeping_gafs$.getGlobalValue());
													Errors.warn(dumper.$str707$Got_bad_bookkeeping_gaf__S____S__,
															new SubLObject[] { count, pred, arg1, arg2 });
												} else {
													format(s, dumper.$str708$_hl_assert_bookkeeping_binary_gaf,
															new SubLObject[] {
																	kb_utilities.hl_object_to_evaluatable_string(pred,
																			UNPROVIDED),
																	kb_utilities.hl_object_to_evaluatable_string(arg1,
																			UNPROVIDED),
																	kb_utilities.hl_object_to_evaluatable_string(arg2,
																			UNPROVIDED),
																	dumper.$$BookkeepingMt });
												}
											}
											dictionary_contents.do_dictionary_contents_finalize(iteration_state);
											cdolist_list_var = cdolist_list_var.rest();
											cons = cdolist_list_var.first();
										}
									} finally {
										final SubLObject _prev_bind_0_$873 = $is_thread_performing_cleanupP$
												.currentBinding(thread);
										try {
											$is_thread_performing_cleanupP$.bind(T, thread);
											final SubLObject _values = getValuesAsVector();
											close(s, UNPROVIDED);
											restoreValuesFromVector(_values);
										} finally {
											$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$873, thread);
										}
									}
								} finally {
									final SubLObject _prev_bind_0_$874 = $is_thread_performing_cleanupP$
											.currentBinding(thread);
									try {
										$is_thread_performing_cleanupP$.bind(T, thread);
										final SubLObject _values2 = getValuesAsVector();
										if (stream.isStream()) {
											close(stream, UNPROVIDED);
										}
										restoreValuesFromVector(_values2);
									} finally {
										$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$874, thread);
									}
								}
							} finally {
								$print_level$.rebind(_prev_bind_4, thread);
								$print_length$.rebind(_prev_bind_3, thread);
								$print_pretty$.rebind(_prev_bind_2, thread);
								$save_asked_queriesP$.rebind(_prev_bind_0, thread);
							}
						} finally {
							final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values3 = getValuesAsVector();
								if (NIL != maintaining_countsP_$864) {
									kb_object_manager.maintain_kb_object_usage_counts(manager_$863);
								}
								if (NIL == memory_mappedP_$865) {
									kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$863,
											dumper.$int$2048, $int$256);
								}
								restoreValuesFromVector(_values3);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
							}
						}
					} finally {
						final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values4 = getValuesAsVector();
							if (NIL != maintaining_countsP_$863) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$862);
							}
							if (NIL == memory_mappedP_$864) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$862,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values4);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values5 = getValuesAsVector();
						if (NIL != maintaining_countsP_$862) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$861);
						}
						if (NIL == memory_mappedP_$863) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$861,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values5);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values6 = getValuesAsVector();
					if (NIL != maintaining_countsP_$861) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$860);
					}
					if (NIL == memory_mappedP_$862) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$860, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values6);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_9 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values7 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values7);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_9, thread);
			}
		}
		return NIL;
	}

	public static SubLObject nart_depth_internal(final SubLObject nart, SubLObject depth) {
		if (depth == UNPROVIDED) {
			depth = ZERO_INTEGER;
		}
		final SubLObject formula = narts_high.nart_hl_formula(nart);
		final SubLObject narts = list_utilities.tree_gather(formula, NART_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
		SubLObject max_depth = depth;
		SubLObject cdolist_list_var = narts;
		SubLObject sub_nart = NIL;
		sub_nart = cdolist_list_var.first();
		while (NIL != cdolist_list_var) {
			max_depth = max(max_depth, dumper.nart_depth_internal(sub_nart, add(depth, ONE_INTEGER)));
			cdolist_list_var = cdolist_list_var.rest();
			sub_nart = cdolist_list_var.first();
		}
		return max_depth;
	}

	public static SubLObject nart_depth(final SubLObject nart) {
		return dumper.nart_depth_internal(nart, ZERO_INTEGER);
	}

	public static SubLObject kb_hl_support_depth_internal(final SubLObject kb_hl_support, SubLObject depth) {
		if (depth == UNPROVIDED) {
			depth = ZERO_INTEGER;
		}
		SubLObject max_depth = depth;
		SubLObject cdolist_list_var = kb_hl_supports_high.kb_hl_support_justification(kb_hl_support);
		SubLObject cur_just = NIL;
		cur_just = cdolist_list_var.first();
		while (NIL != cdolist_list_var) {
			if (NIL != kb_hl_support_handles.kb_hl_support_p(cur_just)) {
				max_depth = max(dumper.kb_hl_support_depth_internal(cur_just, add(depth, ONE_INTEGER)),
						EMPTY_SUBL_OBJECT_ARRAY);
			}
			cdolist_list_var = cdolist_list_var.rest();
			cur_just = cdolist_list_var.first();
		}
		return max_depth;
	}

	public static SubLObject kb_hl_support_depth(final SubLObject kb_hl_support) {
		return dumper.kb_hl_support_depth_internal(kb_hl_support, ZERO_INTEGER);
	}

	public static SubLObject test_that_all_narts_are_findable(SubLObject enable_bootstrappingP) {
		if (enable_bootstrappingP == UNPROVIDED) {
			enable_bootstrappingP = NIL;
		}
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		final SubLObject manager = constant_index_manager.$constant_index_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$875 = nart_index_manager.$nart_index_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$876 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$875);
			final SubLObject memory_mappedP_$877 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$875);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$875);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$875);
				final SubLObject idx = nart_handles.do_narts_table();
				final SubLObject mess = dumper.$str711$Testing_that_narts_are_findable__;
				final SubLObject total = id_index_count(idx);
				SubLObject sofar = ZERO_INTEGER;
				assert NIL != stringp(mess) : "! stringp(mess) "
						+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
				final SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
				final SubLObject _prev_bind_2 = $last_percent_progress_prediction$.currentBinding(thread);
				final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
				final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
				try {
					$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
					$last_percent_progress_prediction$.bind(NIL, thread);
					$within_noting_percent_progress$.bind(T, thread);
					$percent_progress_start_time$.bind(get_universal_time(), thread);
					try {
						noting_percent_progress_preamble(mess);
						final SubLObject idx_$878 = idx;
						if (NIL == id_index_objects_empty_p(idx_$878, $SKIP)) {
							final SubLObject idx_$879 = idx_$878;
							if (NIL == id_index_dense_objects_empty_p(idx_$879, $SKIP)) {
								final SubLObject vector_var = id_index_dense_objects(idx_$879);
								final SubLObject backwardP_var = NIL;
								SubLObject length;
								SubLObject v_iteration;
								SubLObject id;
								SubLObject nart;
								SubLObject _prev_bind_0_$880;
								for (length = length(
										vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
												.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
									id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
											: v_iteration;
									nart = aref(vector_var, id);
									if ((NIL == id_index_tombstone_p(nart))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										if (NIL != id_index_tombstone_p(nart)) {
											nart = $SKIP;
										}
										_prev_bind_0_$880 = $bootstrapping_kbP$.currentBinding(thread);
										try {
											$bootstrapping_kbP$.bind(NIL != enable_bootstrappingP ? T : NIL, thread);
											if (NIL == narts_high.find_nart(narts_high.nart_hl_formula(nart))) {
												result = cons(nart, result);
												Errors.warn(dumper.$str712$Unfindable_nart__S___S,
														nart_handles.nart_id(nart), nart);
											}
										} finally {
											$bootstrapping_kbP$.rebind(_prev_bind_0_$880, thread);
										}
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
								}
							}
							final SubLObject idx_$880 = idx_$878;
							if ((NIL == id_index_sparse_objects_empty_p(idx_$880))
									|| (NIL == id_index_skip_tombstones_p($SKIP))) {
								final SubLObject sparse = id_index_sparse_objects(idx_$880);
								SubLObject id2 = id_index_sparse_id_threshold(idx_$880);
								final SubLObject end_id = id_index_next_id(idx_$880);
								final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL : $SKIP;
								while (id2.numL(end_id)) {
									final SubLObject nart2 = gethash_without_values(id2, sparse, v_default);
									if ((NIL == id_index_skip_tombstones_p($SKIP))
											|| (NIL == id_index_tombstone_p(nart2))) {
										final SubLObject _prev_bind_0_$881 = $bootstrapping_kbP$.currentBinding(thread);
										try {
											$bootstrapping_kbP$.bind(NIL != enable_bootstrappingP ? T : NIL, thread);
											if (NIL == narts_high.find_nart(narts_high.nart_hl_formula(nart2))) {
												result = cons(nart2, result);
												Errors.warn(dumper.$str712$Unfindable_nart__S___S,
														nart_handles.nart_id(nart2), nart2);
											}
										} finally {
											$bootstrapping_kbP$.rebind(_prev_bind_0_$881, thread);
										}
										sofar = add(sofar, ONE_INTEGER);
										note_percent_progress(sofar, total);
									}
									id2 = add(id2, ONE_INTEGER);
								}
							}
						}
					} finally {
						final SubLObject _prev_bind_0_$882 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values = getValuesAsVector();
							noting_percent_progress_postamble();
							restoreValuesFromVector(_values);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$882, thread);
						}
					}
				} finally {
					$percent_progress_start_time$.rebind(_prev_bind_4, thread);
					$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
					$last_percent_progress_prediction$.rebind(_prev_bind_2, thread);
					$last_percent_progress_index$.rebind(_prev_bind_0, thread);
				}
			} finally {
				final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values2 = getValuesAsVector();
					if (NIL != maintaining_countsP_$876) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$875);
					}
					if (NIL == memory_mappedP_$877) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$875, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values2);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values3 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values3);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
			}
		}
		return result;
	}

	public static SubLObject test_that_all_assertions_are_findable() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		final SubLObject manager = assertion_manager.$assertion_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$884 = nart_index_manager.$nart_index_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$885 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$884);
			final SubLObject memory_mappedP_$886 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$884);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$884);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$884);
				final SubLObject manager_$885 = constant_index_manager.$constant_index_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$886 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$885);
				final SubLObject memory_mappedP_$887 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$885);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$885);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$885);
					SubLObject count = ZERO_INTEGER;
					final SubLObject idx = assertion_handles.do_assertions_table();
					final SubLObject mess = dumper.$str713$Testing_that_assertions_are_finda;
					final SubLObject total = id_index_count(idx);
					SubLObject sofar = ZERO_INTEGER;
					assert NIL != stringp(mess) : "! stringp(mess) "
							+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
					final SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
					final SubLObject _prev_bind_2 = $last_percent_progress_prediction$.currentBinding(thread);
					final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
					final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
					try {
						$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
						$last_percent_progress_prediction$.bind(NIL, thread);
						$within_noting_percent_progress$.bind(T, thread);
						$percent_progress_start_time$.bind(get_universal_time(), thread);
						try {
							noting_percent_progress_preamble(mess);
							final SubLObject idx_$890 = idx;
							if (NIL == id_index_objects_empty_p(idx_$890, $SKIP)) {
								final SubLObject idx_$891 = idx_$890;
								if (NIL == id_index_dense_objects_empty_p(idx_$891, $SKIP)) {
									final SubLObject vector_var = id_index_dense_objects(idx_$891);
									final SubLObject backwardP_var = NIL;
									SubLObject length;
									SubLObject v_iteration;
									SubLObject a_id;
									SubLObject a_handle;
									SubLObject assertion;
									SubLObject _prev_bind_0_$892;
									for (length = length(
											vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
													.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
										a_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
												: v_iteration;
										a_handle = aref(vector_var, a_id);
										if ((NIL == id_index_tombstone_p(a_handle))
												|| (NIL == id_index_skip_tombstones_p($SKIP))) {
											if (NIL != id_index_tombstone_p(a_handle)) {
												a_handle = $SKIP;
											}
											assertion = assertion_handles.resolve_assertion_id_value_pair(a_id,
													a_handle);
											_prev_bind_0_$892 = dumper.$current_dump_assertion$.currentBinding(thread);
											try {
												dumper.$current_dump_assertion$.bind(assertion, thread);
												kb_utilities.hl_object_to_evaluatable_string(
														assertions_high.assertion_cnf(assertion), T);
												if (NIL != dumper.$last_invalid_assertion$.getDynamicValue(thread)) {
													result = cons(assertion, result);
												} else if (NIL == kb_indexing.find_assertion(
														assertions_high.assertion_cnf(assertion),
														assertions_high.assertion_mt(assertion))) {
													count = add(count, ONE_INTEGER);
													result = cons(assertion, result);
													Errors.warn(dumper.$str714$__S__Unfindable_assertion_id__S__, count,
															assertion_handles.assertion_id(assertion), assertion);
												}

											} finally {
												dumper.$current_dump_assertion$.rebind(_prev_bind_0_$892, thread);
											}
											sofar = add(sofar, ONE_INTEGER);
											note_percent_progress(sofar, total);
										}
									}
								}
								final SubLObject idx_$892 = idx_$890;
								if ((NIL == id_index_sparse_objects_empty_p(idx_$892))
										|| (NIL == id_index_skip_tombstones_p($SKIP))) {
									final SubLObject sparse = id_index_sparse_objects(idx_$892);
									SubLObject a_id2 = id_index_sparse_id_threshold(idx_$892);
									final SubLObject end_id = id_index_next_id(idx_$892);
									final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL
											: $SKIP;
									while (a_id2.numL(end_id)) {
										final SubLObject a_handle2 = gethash_without_values(a_id2, sparse, v_default);
										if ((NIL == id_index_skip_tombstones_p($SKIP))
												|| (NIL == id_index_tombstone_p(a_handle2))) {
											final SubLObject assertion2 = assertion_handles
													.resolve_assertion_id_value_pair(a_id2, a_handle2);
											final SubLObject _prev_bind_0_$893 = dumper.$current_dump_assertion$
													.currentBinding(thread);
											try {
												dumper.$current_dump_assertion$.bind(assertion2, thread);
												kb_utilities.hl_object_to_evaluatable_string(
														assertions_high.assertion_cnf(assertion2), T);
												if (NIL != dumper.$last_invalid_assertion$.getDynamicValue(thread)) {
													result = cons(assertion2, result);
												} else if (NIL == kb_indexing.find_assertion(
														assertions_high.assertion_cnf(assertion2),
														assertions_high.assertion_mt(assertion2))) {
													count = add(count, ONE_INTEGER);
													result = cons(assertion2, result);
													Errors.warn(dumper.$str714$__S__Unfindable_assertion_id__S__, count,
															assertion_handles.assertion_id(assertion2), assertion2);
												}

											} finally {
												dumper.$current_dump_assertion$.rebind(_prev_bind_0_$893, thread);
											}
											sofar = add(sofar, ONE_INTEGER);
											note_percent_progress(sofar, total);
										}
										a_id2 = add(a_id2, ONE_INTEGER);
									}
								}
							}
						} finally {
							final SubLObject _prev_bind_0_$894 = $is_thread_performing_cleanupP$.currentBinding(thread);
							try {
								$is_thread_performing_cleanupP$.bind(T, thread);
								final SubLObject _values = getValuesAsVector();
								noting_percent_progress_postamble();
								restoreValuesFromVector(_values);
							} finally {
								$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$894, thread);
							}
						}
					} finally {
						$percent_progress_start_time$.rebind(_prev_bind_4, thread);
						$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
						$last_percent_progress_prediction$.rebind(_prev_bind_2, thread);
						$last_percent_progress_index$.rebind(_prev_bind_0, thread);
					}
				} finally {
					final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values2 = getValuesAsVector();
						if (NIL != maintaining_countsP_$886) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$885);
						}
						if (NIL == memory_mappedP_$887) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$885,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values2);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values3 = getValuesAsVector();
					if (NIL != maintaining_countsP_$885) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$884);
					}
					if (NIL == memory_mappedP_$886) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$884, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values3);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values4 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values4);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
			}
		}
		return result;
	}

	public static SubLObject test_that_all_deductions_are_findable() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject result = NIL;
		final SubLObject manager = deduction_manager.$deduction_content_manager$.getGlobalValue();
		final SubLObject maintaining_countsP = kb_object_manager.kb_object_usage_counts_enabledP(manager);
		final SubLObject memory_mappedP = kb_object_manager.kb_object_manager_memory_mappedP(manager);
		try {
			kb_object_manager.dont_maintain_kb_object_usage_counts(manager);
			kb_object_manager.kb_object_manager_enable_memory_mapping(manager);
			final SubLObject manager_$896 = assertion_manager.$assertion_content_manager$.getGlobalValue();
			final SubLObject maintaining_countsP_$897 = kb_object_manager.kb_object_usage_counts_enabledP(manager_$896);
			final SubLObject memory_mappedP_$898 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$896);
			try {
				kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$896);
				kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$896);
				final SubLObject manager_$897 = nart_index_manager.$nart_index_manager$.getGlobalValue();
				final SubLObject maintaining_countsP_$898 = kb_object_manager
						.kb_object_usage_counts_enabledP(manager_$897);
				final SubLObject memory_mappedP_$899 = kb_object_manager.kb_object_manager_memory_mappedP(manager_$897);
				try {
					kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$897);
					kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$897);
					final SubLObject manager_$898 = constant_index_manager.$constant_index_manager$.getGlobalValue();
					final SubLObject maintaining_countsP_$899 = kb_object_manager
							.kb_object_usage_counts_enabledP(manager_$898);
					final SubLObject memory_mappedP_$900 = kb_object_manager
							.kb_object_manager_memory_mappedP(manager_$898);
					try {
						kb_object_manager.dont_maintain_kb_object_usage_counts(manager_$898);
						kb_object_manager.kb_object_manager_enable_memory_mapping(manager_$898);
						SubLObject count = ZERO_INTEGER;
						final SubLObject idx = deduction_handles.do_deductions_table();
						final SubLObject mess = dumper.$str715$Testing_that_deductions_are_finda;
						final SubLObject total = id_index_count(idx);
						SubLObject sofar = ZERO_INTEGER;
						assert NIL != stringp(mess) : "! stringp(mess) "
								+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
						final SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
						final SubLObject _prev_bind_2 = $last_percent_progress_prediction$.currentBinding(thread);
						final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
						final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
						try {
							$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
							$last_percent_progress_prediction$.bind(NIL, thread);
							$within_noting_percent_progress$.bind(T, thread);
							$percent_progress_start_time$.bind(get_universal_time(), thread);
							try {
								noting_percent_progress_preamble(mess);
								final SubLObject idx_$905 = idx;
								if (NIL == id_index_objects_empty_p(idx_$905, $SKIP)) {
									final SubLObject idx_$906 = idx_$905;
									if (NIL == id_index_dense_objects_empty_p(idx_$906, $SKIP)) {
										final SubLObject vector_var = id_index_dense_objects(idx_$906);
										final SubLObject backwardP_var = NIL;
										SubLObject length;
										SubLObject v_iteration;
										SubLObject d_id;
										SubLObject d_handle;
										SubLObject deduction;
										for (length = length(
												vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
														.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
											d_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER)
													: v_iteration;
											d_handle = aref(vector_var, d_id);
											if ((NIL == id_index_tombstone_p(d_handle))
													|| (NIL == id_index_skip_tombstones_p($SKIP))) {
												if (NIL != id_index_tombstone_p(d_handle)) {
													d_handle = $SKIP;
												}
												deduction = deduction_handles.resolve_deduction_id_value_pair(d_id,
														d_handle);
												if (NIL == deductions_high.find_deduction(
														deductions_high.deduction_supported_object(deduction),
														deductions_high.deduction_supports(deduction),
														deductions_high.deduction_truth(deduction))) {
													count = add(count, ONE_INTEGER);
													result = cons(deduction, result);
													Errors.warn(dumper.$str716$__S__Unfindable_deduction_id__S__, count,
															deduction_handles.deduction_id(deduction), deduction);
												}
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
										}
									}
									final SubLObject idx_$907 = idx_$905;
									if ((NIL == id_index_sparse_objects_empty_p(idx_$907))
											|| (NIL == id_index_skip_tombstones_p($SKIP))) {
										final SubLObject sparse = id_index_sparse_objects(idx_$907);
										SubLObject d_id2 = id_index_sparse_id_threshold(idx_$907);
										final SubLObject end_id = id_index_next_id(idx_$907);
										final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL
												: $SKIP;
										while (d_id2.numL(end_id)) {
											final SubLObject d_handle2 = gethash_without_values(d_id2, sparse,
													v_default);
											if ((NIL == id_index_skip_tombstones_p($SKIP))
													|| (NIL == id_index_tombstone_p(d_handle2))) {
												final SubLObject deduction2 = deduction_handles
														.resolve_deduction_id_value_pair(d_id2, d_handle2);
												if (NIL == deductions_high.find_deduction(
														deductions_high.deduction_supported_object(deduction2),
														deductions_high.deduction_supports(deduction2),
														deductions_high.deduction_truth(deduction2))) {
													count = add(count, ONE_INTEGER);
													result = cons(deduction2, result);
													Errors.warn(dumper.$str716$__S__Unfindable_deduction_id__S__, count,
															deduction_handles.deduction_id(deduction2), deduction2);
												}
												sofar = add(sofar, ONE_INTEGER);
												note_percent_progress(sofar, total);
											}
											d_id2 = add(d_id2, ONE_INTEGER);
										}
									}
								}
							} finally {
								final SubLObject _prev_bind_0_$908 = $is_thread_performing_cleanupP$
										.currentBinding(thread);
								try {
									$is_thread_performing_cleanupP$.bind(T, thread);
									final SubLObject _values = getValuesAsVector();
									noting_percent_progress_postamble();
									restoreValuesFromVector(_values);
								} finally {
									$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$908, thread);
								}
							}
						} finally {
							$percent_progress_start_time$.rebind(_prev_bind_4, thread);
							$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
							$last_percent_progress_prediction$.rebind(_prev_bind_2, thread);
							$last_percent_progress_index$.rebind(_prev_bind_0, thread);
						}
					} finally {
						final SubLObject _prev_bind_5 = $is_thread_performing_cleanupP$.currentBinding(thread);
						try {
							$is_thread_performing_cleanupP$.bind(T, thread);
							final SubLObject _values2 = getValuesAsVector();
							if (NIL != maintaining_countsP_$899) {
								kb_object_manager.maintain_kb_object_usage_counts(manager_$898);
							}
							if (NIL == memory_mappedP_$900) {
								kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$898,
										dumper.$int$2048, $int$256);
							}
							restoreValuesFromVector(_values2);
						} finally {
							$is_thread_performing_cleanupP$.rebind(_prev_bind_5, thread);
						}
					}
				} finally {
					final SubLObject _prev_bind_6 = $is_thread_performing_cleanupP$.currentBinding(thread);
					try {
						$is_thread_performing_cleanupP$.bind(T, thread);
						final SubLObject _values3 = getValuesAsVector();
						if (NIL != maintaining_countsP_$898) {
							kb_object_manager.maintain_kb_object_usage_counts(manager_$897);
						}
						if (NIL == memory_mappedP_$899) {
							kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$897,
									dumper.$int$2048, $int$256);
						}
						restoreValuesFromVector(_values3);
					} finally {
						$is_thread_performing_cleanupP$.rebind(_prev_bind_6, thread);
					}
				}
			} finally {
				final SubLObject _prev_bind_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values4 = getValuesAsVector();
					if (NIL != maintaining_countsP_$897) {
						kb_object_manager.maintain_kb_object_usage_counts(manager_$896);
					}
					if (NIL == memory_mappedP_$898) {
						kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager_$896, dumper.$int$2048,
								$int$256);
					}
					restoreValuesFromVector(_values4);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_7, thread);
				}
			}
		} finally {
			final SubLObject _prev_bind_8 = $is_thread_performing_cleanupP$.currentBinding(thread);
			try {
				$is_thread_performing_cleanupP$.bind(T, thread);
				final SubLObject _values5 = getValuesAsVector();
				if (NIL != maintaining_countsP) {
					kb_object_manager.maintain_kb_object_usage_counts(manager);
				}
				if (NIL == memory_mappedP) {
					kb_object_manager.kb_object_manager_change_stream_buffer_sizes(manager, dumper.$int$2048, $int$256);
				}
				restoreValuesFromVector(_values5);
			} finally {
				$is_thread_performing_cleanupP$.rebind(_prev_bind_8, thread);
			}
		}
		return result;
	}

	public static SubLObject fix_bad_narts() {
		for (SubLObject bad_narts = dumper.test_that_all_narts_are_findable(
				UNPROVIDED); NIL != bad_narts; bad_narts = dumper.test_that_all_narts_are_findable(UNPROVIDED)) {
			SubLObject cdolist_list_var = bad_narts;
			SubLObject bad_nart = NIL;
			bad_nart = cdolist_list_var.first();
			while (NIL != cdolist_list_var) {
				dumper.fix_bad_nart(bad_nart);
				cdolist_list_var = cdolist_list_var.rest();
				bad_nart = cdolist_list_var.first();
			}
		}
		return NIL;
	}

	public static SubLObject fix_bad_nart(final SubLObject bad_nart) {
		final SubLThread thread = SubLProcess.currentSubLThread();
		SubLObject cdolist_list_var = kb_mapping.gather_term_assertions(bad_nart, UNPROVIDED);
		SubLObject assertion = NIL;
		assertion = cdolist_list_var.first();
		while (NIL != cdolist_list_var) {
			dumper.fix_bad_assertion(assertion, UNPROVIDED);
			cdolist_list_var = cdolist_list_var.rest();
			assertion = cdolist_list_var.first();
		}
		final SubLObject _prev_bind_0 = api_control_vars.$the_cyclist$.currentBinding(thread);
		try {
			api_control_vars.$the_cyclist$.bind(dumper.$$CycAdministrator, thread);
			cyc_kernel.cyc_kill(bad_nart);
		} finally {
			api_control_vars.$the_cyclist$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject get_robust_nart_removal_form(final SubLObject nart) {
		return list(dumper.IGNORE_ERRORS, list(CLET,
				list(list(dumper.POSSIBLE_NART, list(dumper.FIND_NART_BY_ID, nart_handles.nart_id(nart)))),
				list(PWHEN, dumper.POSSIBLE_NART, listS(PWHEN, list(EQUAL, dumper.$list720,
						list(EVAL, list(READ_FROM_STRING, kb_utilities
								.hl_object_to_evaluatable_string(narts_high.nart_hl_formula(nart), UNPROVIDED)))),
						dumper.$list723))));
	}

	public static SubLObject get_robust_assertion_removal_form(final SubLObject assertion) {
		return list(dumper.IGNORE_ERRORS,
				list(CLET,
						list(list(dumper.POSSIBLE_ASSERTION,
								list(FIND_ASSERTION_BY_ID, assertion_handles.assertion_id(assertion)))),
						list(PWHEN, dumper.POSSIBLE_ASSERTION,
								listS(PWHEN,
										list(CAND,
												list(EQUAL, dumper.$list726, list(EVAL, list(
														READ_FROM_STRING,
														kb_utilities.hl_object_to_evaluatable_string(
																assertions_high.assertion_mt(assertion), UNPROVIDED)))),
												list(EQUAL, dumper.$list727, list(EVAL, list(READ_FROM_STRING,
														kb_utilities.hl_object_to_evaluatable_string(
																cycl_utilities.hl_to_el(
																		assertions_high.assertion_cnf(assertion)),
																UNPROVIDED))))),
										dumper.$list728))));
	}

	public static SubLObject fix_bad_assertion(final SubLObject assertion, SubLObject kill_tous) {
		if (kill_tous == UNPROVIDED) {
			kill_tous = NIL;
		}
		if ((NIL == kill_tous) && (NIL != function_terms.tou_assertionP(assertion))) {
			return NIL;
		}
		final SubLObject meta_assertions = assertion_utilities.all_meta_assertions(assertion);
		SubLObject new_assertion = NIL;
		new_assertion = ke.ke_recanonicalize_assertion_now(assertion, meta_assertions);
		if (NIL == new_assertion) {
			Errors.warn(dumper.$str729$Deleting_potentially_bad_assertio, assertion_handles.assertion_id(assertion),
					assertion);
		} else {
			Errors.warn(dumper.$str730$Recanonicalized__A___A, assertion_handles.assertion_id(assertion), assertion);
		}
		return NIL;
	}

	public static SubLObject find_assertion_with_kb_hl_support_deduction_dependent() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject idx = assertion_handles.do_assertions_table();
		final SubLObject mess = dumper.$str731$Finding_assertions_____;
		final SubLObject total = id_index_count(idx);
		SubLObject sofar = ZERO_INTEGER;
		assert NIL != stringp(mess) : "! stringp(mess) "
				+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
		final SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $last_percent_progress_prediction$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
		try {
			$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
			$last_percent_progress_prediction$.bind(NIL, thread);
			$within_noting_percent_progress$.bind(T, thread);
			$percent_progress_start_time$.bind(get_universal_time(), thread);
			try {
				noting_percent_progress_preamble(mess);
				final SubLObject idx_$909 = idx;
				if (NIL == id_index_objects_empty_p(idx_$909, $SKIP)) {
					final SubLObject idx_$910 = idx_$909;
					if (NIL == id_index_dense_objects_empty_p(idx_$910, $SKIP)) {
						final SubLObject vector_var = id_index_dense_objects(idx_$910);
						final SubLObject backwardP_var = NIL;
						SubLObject length;
						SubLObject v_iteration;
						SubLObject a_id;
						SubLObject a_handle;
						SubLObject assertion;
						SubLObject set_contents_var;
						SubLObject basis_object;
						SubLObject state;
						SubLObject dep;
						for (length = length(vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
								.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
							a_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER) : v_iteration;
							a_handle = aref(vector_var, a_id);
							if ((NIL == id_index_tombstone_p(a_handle)) || (NIL == id_index_skip_tombstones_p($SKIP))) {
								if (NIL != id_index_tombstone_p(a_handle)) {
									a_handle = $SKIP;
								}
								assertion = assertion_handles.resolve_assertion_id_value_pair(a_id, a_handle);
								set_contents_var = assertions_high.assertion_dependents(assertion);
								for (basis_object = set_contents.do_set_contents_basis_object(
										set_contents_var), state = NIL, state = set_contents
												.do_set_contents_initial_state(basis_object,
														set_contents_var); NIL == set_contents.do_set_contents_doneP(
																basis_object, state); state = set_contents
																		.do_set_contents_update_state(state)) {
									dep = set_contents.do_set_contents_next(basis_object, state);
									if (NIL != set_contents.do_set_contents_element_validP(state, dep)) {
										if (NIL == deduction_handles.deduction_p(dep)) {
											Errors.error(dumper.$str732$Expected_a_deduction_got___S__, dep);
										}
										if (NIL != kb_hl_support_handles
												.kb_hl_support_p(deductions_high.deduction_supported_object(dep))) {
											return assertion;
										}
									}
								}
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
							}
						}
					}
					final SubLObject idx_$911 = idx_$909;
					if ((NIL == id_index_sparse_objects_empty_p(idx_$911))
							|| (NIL == id_index_skip_tombstones_p($SKIP))) {
						final SubLObject sparse = id_index_sparse_objects(idx_$911);
						SubLObject a_id2 = id_index_sparse_id_threshold(idx_$911);
						final SubLObject end_id = id_index_next_id(idx_$911);
						final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL : $SKIP;
						while (a_id2.numL(end_id)) {
							final SubLObject a_handle2 = gethash_without_values(a_id2, sparse, v_default);
							if ((NIL == id_index_skip_tombstones_p($SKIP))
									|| (NIL == id_index_tombstone_p(a_handle2))) {
								final SubLObject assertion2 = assertion_handles.resolve_assertion_id_value_pair(a_id2,
										a_handle2);
								final SubLObject set_contents_var2 = assertions_high.assertion_dependents(assertion2);
								SubLObject basis_object2;
								SubLObject state2;
								SubLObject dep2;
								for (basis_object2 = set_contents.do_set_contents_basis_object(
										set_contents_var2), state2 = NIL, state2 = set_contents
												.do_set_contents_initial_state(basis_object2,
														set_contents_var2); NIL == set_contents.do_set_contents_doneP(
																basis_object2, state2); state2 = set_contents
																		.do_set_contents_update_state(state2)) {
									dep2 = set_contents.do_set_contents_next(basis_object2, state2);
									if (NIL != set_contents.do_set_contents_element_validP(state2, dep2)) {
										if (NIL == deduction_handles.deduction_p(dep2)) {
											Errors.error(dumper.$str732$Expected_a_deduction_got___S__, dep2);
										}
										if (NIL != kb_hl_support_handles
												.kb_hl_support_p(deductions_high.deduction_supported_object(dep2))) {
											return assertion2;
										}
									}
								}
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
							}
							a_id2 = add(a_id2, ONE_INTEGER);
						}
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$912 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					noting_percent_progress_postamble();
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$912, thread);
				}
			}
		} finally {
			$percent_progress_start_time$.rebind(_prev_bind_4, thread);
			$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
			$last_percent_progress_prediction$.rebind(_prev_bind_2, thread);
			$last_percent_progress_index$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static SubLObject find_complex_cnf() {
		final SubLThread thread = SubLProcess.currentSubLThread();
		final SubLObject idx = assertion_handles.do_assertions_table();
		final SubLObject mess = dumper.$str733$Finding_cnf_with_non_trivial_term;
		final SubLObject total = id_index_count(idx);
		SubLObject sofar = ZERO_INTEGER;
		assert NIL != stringp(mess) : "! stringp(mess) "
				+ ("Types.stringp(mess) " + "CommonSymbols.NIL != Types.stringp(mess) ") + mess;
		final SubLObject _prev_bind_0 = $last_percent_progress_index$.currentBinding(thread);
		final SubLObject _prev_bind_2 = $last_percent_progress_prediction$.currentBinding(thread);
		final SubLObject _prev_bind_3 = $within_noting_percent_progress$.currentBinding(thread);
		final SubLObject _prev_bind_4 = $percent_progress_start_time$.currentBinding(thread);
		try {
			$last_percent_progress_index$.bind(ZERO_INTEGER, thread);
			$last_percent_progress_prediction$.bind(NIL, thread);
			$within_noting_percent_progress$.bind(T, thread);
			$percent_progress_start_time$.bind(get_universal_time(), thread);
			try {
				noting_percent_progress_preamble(mess);
				final SubLObject idx_$913 = idx;
				if (NIL == id_index_objects_empty_p(idx_$913, $SKIP)) {
					final SubLObject idx_$914 = idx_$913;
					if (NIL == id_index_dense_objects_empty_p(idx_$914, $SKIP)) {
						final SubLObject vector_var = id_index_dense_objects(idx_$914);
						final SubLObject backwardP_var = NIL;
						SubLObject length;
						SubLObject v_iteration;
						SubLObject a_id;
						SubLObject a_handle;
						SubLObject assertion;
						for (length = length(vector_var), v_iteration = NIL, v_iteration = ZERO_INTEGER; v_iteration
								.numL(length); v_iteration = add(v_iteration, ONE_INTEGER)) {
							a_id = (NIL != backwardP_var) ? subtract(length, v_iteration, ONE_INTEGER) : v_iteration;
							a_handle = aref(vector_var, a_id);
							if ((NIL == id_index_tombstone_p(a_handle)) || (NIL == id_index_skip_tombstones_p($SKIP))) {
								if (NIL != id_index_tombstone_p(a_handle)) {
									a_handle = $SKIP;
								}
								assertion = assertion_handles.resolve_assertion_id_value_pair(a_id, a_handle);
								if (kb_utilities.term_order(assertion).numG(TWO_INTEGER)) {
									Errors.warn(dumper.$str734$Found_cnf__A, assertions_high.assertion_cnf(assertion));
									Errors.warn(dumper.$str735$Found_mt__A, assertions_high.assertion_mt(assertion));
									Errors.warn(dumper.$str736$Found_id__A, assertion_handles.assertion_id(assertion));
									return NIL;
								}
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
							}
						}
					}
					final SubLObject idx_$915 = idx_$913;
					if ((NIL == id_index_sparse_objects_empty_p(idx_$915))
							|| (NIL == id_index_skip_tombstones_p($SKIP))) {
						final SubLObject sparse = id_index_sparse_objects(idx_$915);
						SubLObject a_id2 = id_index_sparse_id_threshold(idx_$915);
						final SubLObject end_id = id_index_next_id(idx_$915);
						final SubLObject v_default = (NIL != id_index_skip_tombstones_p($SKIP)) ? NIL : $SKIP;
						while (a_id2.numL(end_id)) {
							final SubLObject a_handle2 = gethash_without_values(a_id2, sparse, v_default);
							if ((NIL == id_index_skip_tombstones_p($SKIP))
									|| (NIL == id_index_tombstone_p(a_handle2))) {
								final SubLObject assertion2 = assertion_handles.resolve_assertion_id_value_pair(a_id2,
										a_handle2);
								if (kb_utilities.term_order(assertion2).numG(TWO_INTEGER)) {
									Errors.warn(dumper.$str734$Found_cnf__A, assertions_high.assertion_cnf(assertion2));
									Errors.warn(dumper.$str735$Found_mt__A, assertions_high.assertion_mt(assertion2));
									Errors.warn(dumper.$str736$Found_id__A, assertion_handles.assertion_id(assertion2));
									return NIL;
								}
								sofar = add(sofar, ONE_INTEGER);
								note_percent_progress(sofar, total);
							}
							a_id2 = add(a_id2, ONE_INTEGER);
						}
					}
				}
			} finally {
				final SubLObject _prev_bind_0_$916 = $is_thread_performing_cleanupP$.currentBinding(thread);
				try {
					$is_thread_performing_cleanupP$.bind(T, thread);
					final SubLObject _values = getValuesAsVector();
					noting_percent_progress_postamble();
					restoreValuesFromVector(_values);
				} finally {
					$is_thread_performing_cleanupP$.rebind(_prev_bind_0_$916, thread);
				}
			}
		} finally {
			$percent_progress_start_time$.rebind(_prev_bind_4, thread);
			$within_noting_percent_progress$.rebind(_prev_bind_3, thread);
			$last_percent_progress_prediction$.rebind(_prev_bind_2, thread);
			$last_percent_progress_index$.rebind(_prev_bind_0, thread);
		}
		return NIL;
	}

	public static final SubLObject declare_dumper_file_alt() {
		declareFunction("force_monolithic_kb_assumptionP", "FORCE-MONOLITHIC-KB-ASSUMPTION?", 0, 0, false);
		declareMacro("with_kb_dump_ids", "WITH-KB-DUMP-IDS");
		declareMacro("with_kb_load_ids", "WITH-KB-LOAD-IDS");
		declareMacro("with_kb_load_area_allocation", "WITH-KB-LOAD-AREA-ALLOCATION");
		declareMacro("without_kb_load_area_allocation", "WITHOUT-KB-LOAD-AREA-ALLOCATION");
		declareMacro("with_kb_dump_filename", "WITH-KB-DUMP-FILENAME");
		declareMacro("with_kb_dump_binary_file", "WITH-KB-DUMP-BINARY-FILE");
		declareMacro("with_kb_dump_text_file", "WITH-KB-DUMP-TEXT-FILE");
		declareFunction("discard_dump_filename", "DISCARD-DUMP-FILENAME", 1, 0, false);
		declareFunction("kb_dump_directory", "KB-DUMP-DIRECTORY", 0, 2, false);
		declareFunction("kb_dump_file", "KB-DUMP-FILE", 2, 1, false);
		declareFunction("kb_dump_product_file", "KB-DUMP-PRODUCT-FILE", 2, 1, false);
		declareFunction("dump_estimated_size", "DUMP-ESTIMATED-SIZE", 0, 1, false);
		declareFunction("verify_file_existence", "VERIFY-FILE-EXISTENCE", 1, 1, false);
		declareFunction("validate_dump_directory", "VALIDATE-DUMP-DIRECTORY", 1, 0, false);
		declareFunction("kb_load_gc_checkpoint", "KB-LOAD-GC-CHECKPOINT", 0, 0, false);
		declareFunction("preprocess_experience_and_dump_standard_kb", "PREPROCESS-EXPERIENCE-AND-DUMP-STANDARD-KB", 0,
				3, false);
		declareFunction("dump_standard_kb", "DUMP-STANDARD-KB", 0, 1, false);
		declareFunction("perform_standard_pre_dump_kb_cleanups", "PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS", 0, 0, false);
		declareFunction("perform_kb_cleanups", "PERFORM-KB-CLEANUPS", 0, 0, false);
		declareFunction("preprocess_experience", "PREPROCESS-EXPERIENCE", 0, 2, false);
		declareFunction("preprocess_experience_and_dump_non_computable_kb",
				"PREPROCESS-EXPERIENCE-AND-DUMP-NON-COMPUTABLE-KB", 0, 3, false);
		declareFunction("dump_non_computable_kb", "DUMP-NON-COMPUTABLE-KB", 1, 0, false);
		declareFunction("load_non_computable_kb_and_rebuild_computable_kb_and_write_image",
				"LOAD-NON-COMPUTABLE-KB-AND-REBUILD-COMPUTABLE-KB-AND-WRITE-IMAGE", 3, 0, false);
		declareFunction("load_non_computable_kb", "LOAD-NON-COMPUTABLE-KB", 1, 0, false);
		declareFunction("dump_computable_kb_and_content", "DUMP-COMPUTABLE-KB-AND-CONTENT", 2, 0, false);
		declareFunction("dump_kb", "DUMP-KB", 0, 1, false);
		declareFunction("load_kb", "LOAD-KB", 1, 0, false);
		declareFunction("kb_dump_to_directory", "KB-DUMP-TO-DIRECTORY", 1, 0, false);
		declareFunction("kb_load_from_directory", "KB-LOAD-FROM-DIRECTORY", 1, 0, false);
		declareFunction("dump_kb_ids", "DUMP-KB-IDS", 1, 0, false);
		declareFunction("dump_essential_kb", "DUMP-ESSENTIAL-KB", 1, 0, false);
		declareFunction("load_essential_kb", "LOAD-ESSENTIAL-KB", 1, 0, false);
		declareFunction("load_essential_kb_initializations", "LOAD-ESSENTIAL-KB-INITIALIZATIONS", 0, 0, false);
		declareFunction("load_computable_kb_initializations", "LOAD-COMPUTABLE-KB-INITIALIZATIONS", 0, 0, false);
		declareFunction("load_computable_remaining_hl_low_initializations",
				"LOAD-COMPUTABLE-REMAINING-HL-LOW-INITIALIZATIONS", 0, 0, false);
		declareFunction("dump_computable_content", "DUMP-COMPUTABLE-CONTENT", 1, 0, false);
		declareFunction("load_computable_content", "LOAD-COMPUTABLE-CONTENT", 1, 0, false);
		declareFunction("rebuild_computable_content", "REBUILD-COMPUTABLE-CONTENT", 0, 0, false);
		declareFunction("rebuild_computable_content_dumpable", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE", 0, 0, false);
		declareFunction("rebuild_computable_content_dumpable_low", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE-LOW", 0, 0,
				false);
		declareFunction("dump_computable_kb", "DUMP-COMPUTABLE-KB", 1, 0, false);
		declareFunction("load_computable_kb", "LOAD-COMPUTABLE-KB", 1, 0, false);
		declareFunction("rebuild_computable_kb", "REBUILD-COMPUTABLE-KB", 0, 0, false);
		declareFunction("dump_computable_remaining_hl", "DUMP-COMPUTABLE-REMAINING-HL", 1, 0, false);
		declareFunction("load_computable_remaining_hl", "LOAD-COMPUTABLE-REMAINING-HL", 1, 0, false);
		declareFunction("rebuild_computable_remaining_hl", "REBUILD-COMPUTABLE-REMAINING-HL", 0, 0, false);
		declareFunction("rebuild_computable_remaining_hl_low", "REBUILD-COMPUTABLE-REMAINING-HL-LOW", 0, 0, false);
		declareFunction("rebuild_computable_remaining_hl_high", "REBUILD-COMPUTABLE-REMAINING-HL-HIGH", 0, 0, false);
		declareFunction("rebuild_computable_but_not_dumpable_yet", "REBUILD-COMPUTABLE-BUT-NOT-DUMPABLE-YET", 0, 0,
				false);
		declareFunction("dump_copyright", "DUMP-COPYRIGHT", 1, 0, false);
		declareFunction("load_copyright", "LOAD-COPYRIGHT", 1, 0, false);
		declareFunction("load_unit_file", "LOAD-UNIT-FILE", 4, 0, false);
		declareFunction("dump_kb_object_count", "DUMP-KB-OBJECT-COUNT", 3, 0, false);
		declareFunction("load_kb_object_count", "LOAD-KB-OBJECT-COUNT", 2, 0, false);
		declareFunction("kb_dump_common_symbols", "KB-DUMP-COMMON-SYMBOLS", 0, 0, false);
		declareFunction("dump_special_objects", "DUMP-SPECIAL-OBJECTS", 1, 0, false);
		declareFunction("dump_special_objects_internal", "DUMP-SPECIAL-OBJECTS-INTERNAL", 2, 0, false);
		declareFunction("load_special_objects", "LOAD-SPECIAL-OBJECTS", 1, 0, false);
		declareFunction("load_kb_product_shared_symbols", "LOAD-KB-PRODUCT-SHARED-SYMBOLS", 1, 0, false);
		declareFunction("setup_kb_state_from_dump", "SETUP-KB-STATE-FROM-DUMP", 1, 0, false);
		declareFunction("get_exclusive_constant_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-CONSTANT-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_constant_shells", "DUMP-CONSTANT-SHELLS", 1, 0, false);
		declareFunction("load_constant_count", "LOAD-CONSTANT-COUNT", 1, 0, false);
		declareFunction("load_constant_shells", "LOAD-CONSTANT-SHELLS", 1, 0, false);
		declareFunction("dump_constant_shell", "DUMP-CONSTANT-SHELL", 2, 0, false);
		declareFunction("dump_constant_shell_internal", "DUMP-CONSTANT-SHELL-INTERNAL", 4, 0, false);
		declareFunction("load_constant_shell", "LOAD-CONSTANT-SHELL", 2, 0, false);
		declareFunction("load_constant_shell_internal", "LOAD-CONSTANT-SHELL-INTERNAL", 3, 0, false);
		declareFunction("generate_constant_shell_file", "GENERATE-CONSTANT-SHELL-FILE", 1, 0, false);
		declareFunction("get_exclusive_nart_internal_id_limit_for_kb", "GET-EXCLUSIVE-NART-INTERNAL-ID-LIMIT-FOR-KB", 1,
				0, false);
		declareFunction("dump_nart_count", "DUMP-NART-COUNT", 1, 0, false);
		declareFunction("load_nart_shells", "LOAD-NART-SHELLS", 1, 0, false);
		declareFunction("load_nart_count", "LOAD-NART-COUNT", 1, 0, false);
		declareFunction("initialize_nart_shells", "INITIALIZE-NART-SHELLS", 1, 0, false);
		declareFunction("load_nart_shells_legacy", "LOAD-NART-SHELLS-LEGACY", 1, 0, false);
		declareFunction("dump_nart_shell", "DUMP-NART-SHELL", 2, 0, false);
		declareFunction("load_nart_shell", "LOAD-NART-SHELL", 2, 0, false);
		declareFunction("get_exclusive_assertion_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-ASSERTION-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_assertion_count", "DUMP-ASSERTION-COUNT", 1, 0, false);
		declareFunction("load_assertion_shells", "LOAD-ASSERTION-SHELLS", 1, 0, false);
		declareFunction("load_assertion_count", "LOAD-ASSERTION-COUNT", 1, 0, false);
		declareFunction("initialize_assertion_shells", "INITIALIZE-ASSERTION-SHELLS", 1, 0, false);
		declareFunction("load_assertion_shells_legacy", "LOAD-ASSERTION-SHELLS-LEGACY", 1, 0, false);
		declareFunction("dump_assertion_shell", "DUMP-ASSERTION-SHELL", 2, 0, false);
		declareFunction("load_assertion_shell", "LOAD-ASSERTION-SHELL", 2, 0, false);
		declareFunction("get_exclusive_kb_hl_support_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-KB-HL-SUPPORT-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_kb_hl_support_count", "DUMP-KB-HL-SUPPORT-COUNT", 1, 0, false);
		declareFunction("load_kb_hl_support_shells", "LOAD-KB-HL-SUPPORT-SHELLS", 1, 0, false);
		declareFunction("load_kb_hl_support_count", "LOAD-KB-HL-SUPPORT-COUNT", 1, 0, false);
		declareFunction("initialize_kb_hl_support_shells", "INITIALIZE-KB-HL-SUPPORT-SHELLS", 1, 0, false);
		declareFunction("load_kb_hl_support_shells_legacy", "LOAD-KB-HL-SUPPORT-SHELLS-LEGACY", 1, 0, false);
		declareFunction("dump_kb_hl_support_shell", "DUMP-KB-HL-SUPPORT-SHELL", 2, 0, false);
		declareFunction("load_kb_hl_support_shell", "LOAD-KB-HL-SUPPORT-SHELL", 2, 0, false);
		declareFunction("get_exclusive_kb_unrepresented_term_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-KB-UNREPRESENTED-TERM-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_kb_unrepresented_terms", "DUMP-KB-UNREPRESENTED-TERMS", 1, 0, false);
		declareFunction("load_kb_unrepresented_terms", "LOAD-KB-UNREPRESENTED-TERMS", 1, 0, false);
		declareFunction("dump_kb_unrepresented_term", "DUMP-KB-UNREPRESENTED-TERM", 2, 0, false);
		declareFunction("load_kb_unrepresented_term", "LOAD-KB-UNREPRESENTED-TERM", 2, 0, false);
		declareFunction("load_kb_unrepresented_term_count", "LOAD-KB-UNREPRESENTED-TERM-COUNT", 1, 0, false);
		declareFunction("get_exclusive_clause_struc_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-CLAUSE-STRUC-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_clause_struc_defs", "DUMP-CLAUSE-STRUC-DEFS", 1, 0, false);
		declareFunction("load_clause_struc_defs", "LOAD-CLAUSE-STRUC-DEFS", 1, 0, false);
		declareFunction("dump_clause_struc_def", "DUMP-CLAUSE-STRUC-DEF", 2, 0, false);
		declareFunction("load_clause_struc_def", "LOAD-CLAUSE-STRUC-DEF", 2, 0, false);
		declareFunction("load_clause_struc_count", "LOAD-CLAUSE-STRUC-COUNT", 1, 0, false);
		declareFunction("get_exclusive_deduction_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-DEDUCTION-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_deduction_defs", "DUMP-DEDUCTION-DEFS", 1, 0, false);
		declareFunction("load_deduction_defs", "LOAD-DEDUCTION-DEFS", 1, 0, false);
		declareFunction("dump_deduction_def", "DUMP-DEDUCTION-DEF", 2, 0, false);
		declareFunction("load_deduction_def", "LOAD-DEDUCTION-DEF", 2, 0, false);
		declareFunction("load_deduction_def_from_cache", "LOAD-DEDUCTION-DEF-FROM-CACHE", 2, 0, false);
		new com.cyc.cycjava.cycl.dumper.$load_deduction_def_from_cache$BinaryFunction();
		declareFunction("load_deduction_count", "LOAD-DEDUCTION-COUNT", 1, 0, false);
		declareFunction("dump_assertion_defs", "DUMP-ASSERTION-DEFS", 1, 0, false);
		declareFunction("load_assertion_defs", "LOAD-ASSERTION-DEFS", 1, 0, false);
		declareFunction("dump_assertion_def", "DUMP-ASSERTION-DEF", 2, 0, false);
		declareFunction("load_assertion_def", "LOAD-ASSERTION-DEF", 2, 0, false);
		declareFunction("load_assertion_def_from_cache", "LOAD-ASSERTION-DEF-FROM-CACHE", 2, 0, false);
		new com.cyc.cycjava.cycl.dumper.$load_assertion_def_from_cache$BinaryFunction();
		declareFunction("dump_kb_hl_support_defs", "DUMP-KB-HL-SUPPORT-DEFS", 1, 0, false);
		declareFunction("load_kb_hl_support_defs", "LOAD-KB-HL-SUPPORT-DEFS", 1, 0, false);
		declareFunction("dump_kb_hl_support_def", "DUMP-KB-HL-SUPPORT-DEF", 2, 0, false);
		declareFunction("load_kb_hl_support_def", "LOAD-KB-HL-SUPPORT-DEF", 2, 0, false);
		declareFunction("load_kb_hl_support_def_from_cache", "LOAD-KB-HL-SUPPORT-DEF-FROM-CACHE", 2, 0, false);
		declareFunction("dump_kb_hl_support_indexing", "DUMP-KB-HL-SUPPORT-INDEXING", 1, 0, false);
		declareFunction("load_kb_hl_support_indexing", "LOAD-KB-HL-SUPPORT-INDEXING", 1, 0, false);
		declareFunction("dump_bookkeeping_assertions", "DUMP-BOOKKEEPING-ASSERTIONS", 1, 0, false);
		declareFunction("dump_bookkeeping_assertions_for_pred", "DUMP-BOOKKEEPING-ASSERTIONS-FOR-PRED", 3, 0, false);
		declareFunction("dump_bookkeeping_assertion", "DUMP-BOOKKEEPING-ASSERTION", 3, 0, false);
		declareFunction("load_bookkeeping_assertions", "LOAD-BOOKKEEPING-ASSERTIONS", 1, 0, false);
		declareFunction("load_bookkeeping_assertions_for_pred", "LOAD-BOOKKEEPING-ASSERTIONS-FOR-PRED", 1, 0, false);
		declareFunction("load_bookkeeping_assertion", "LOAD-BOOKKEEPING-ASSERTION", 2, 0, false);
		declareFunction("dump_experience", "DUMP-EXPERIENCE", 1, 0, false);
		declareFunction("dump_rule_utility_experience", "DUMP-RULE-UTILITY-EXPERIENCE", 1, 1, false);
		declareFunction("load_experience", "LOAD-EXPERIENCE", 1, 0, false);
		declareFunction("load_rule_utility_experience", "LOAD-RULE-UTILITY-EXPERIENCE", 1, 0, false);
		declareFunction("reload_experience", "RELOAD-EXPERIENCE", 0, 1, false);
		declareFunction("dump_non_wff_store", "DUMP-NON-WFF-STORE", 1, 0, false);
		declareFunction("load_non_wff_store", "LOAD-NON-WFF-STORE", 1, 0, false);
		declareFunction("dump_kb_indexing", "DUMP-KB-INDEXING", 1, 0, false);
		declareFunction("load_kb_indexing", "LOAD-KB-INDEXING", 1, 0, false);
		declareFunction("rebuild_kb_indexing", "REBUILD-KB-INDEXING", 0, 0, false);
		declareFunction("test_dump_kb_indexing", "TEST-DUMP-KB-INDEXING", 1, 0, false);
		declareFunction("test_load_kb_indexing", "TEST-LOAD-KB-INDEXING", 1, 0, false);
		declareFunction("dump_constant_indices", "DUMP-CONSTANT-INDICES", 1, 0, false);
		declareFunction("load_constant_indices", "LOAD-CONSTANT-INDICES", 1, 0, false);
		declareFunction("dump_constant_index", "DUMP-CONSTANT-INDEX", 2, 0, false);
		declareFunction("load_constant_index", "LOAD-CONSTANT-INDEX", 2, 0, false);
		declareFunction("load_constant_index_from_cache", "LOAD-CONSTANT-INDEX-FROM-CACHE", 2, 0, false);
		declareFunction("dump_nart_indices", "DUMP-NART-INDICES", 1, 0, false);
		declareFunction("load_nart_indices", "LOAD-NART-INDICES", 1, 0, false);
		declareFunction("dump_nart_index", "DUMP-NART-INDEX", 2, 0, false);
		declareFunction("load_nart_index", "LOAD-NART-INDEX", 2, 0, false);
		declareFunction("load_nart_index_from_cache", "LOAD-NART-INDEX-FROM-CACHE", 2, 0, false);
		declareFunction("dump_unrepresented_term_indices", "DUMP-UNREPRESENTED-TERM-INDICES", 1, 0, false);
		declareFunction("load_unrepresented_term_indices", "LOAD-UNREPRESENTED-TERM-INDICES", 1, 0, false);
		declareFunction("dump_unrepresented_term_index", "DUMP-UNREPRESENTED-TERM-INDEX", 2, 0, false);
		declareFunction("load_unrepresented_term_index", "LOAD-UNREPRESENTED-TERM-INDEX", 2, 0, false);
		declareFunction("load_unrepresented_term_index_from_cache", "LOAD-UNREPRESENTED-TERM-INDEX-FROM-CACHE", 2, 0,
				false);
		declareFunction("dump_assertion_indices", "DUMP-ASSERTION-INDICES", 1, 0, false);
		declareFunction("load_assertion_indices", "LOAD-ASSERTION-INDICES", 1, 0, false);
		declareFunction("dump_assertion_index", "DUMP-ASSERTION-INDEX", 2, 0, false);
		declareFunction("load_assertion_index", "LOAD-ASSERTION-INDEX", 2, 0, false);
		declareFunction("dump_auxiliary_indices_file", "DUMP-AUXILIARY-INDICES-FILE", 1, 0, false);
		declareFunction("load_auxiliary_indices_file", "LOAD-AUXILIARY-INDICES-FILE", 1, 0, false);
		declareFunction("dump_bookkeeping_indices_file", "DUMP-BOOKKEEPING-INDICES-FILE", 1, 0, false);
		declareFunction("load_bookkeeping_indices_file", "LOAD-BOOKKEEPING-INDICES-FILE", 1, 0, false);
		declareFunction("dump_bookkeeping_indices", "DUMP-BOOKKEEPING-INDICES", 1, 0, false);
		declareFunction("load_bookkeeping_indices", "LOAD-BOOKKEEPING-INDICES", 1, 0, false);
		declareFunction("dump_rule_set", "DUMP-RULE-SET", 1, 0, false);
		declareFunction("load_rule_set", "LOAD-RULE-SET", 1, 0, false);
		declareFunction("dump_nart_hl_formulas", "DUMP-NART-HL-FORMULAS", 1, 0, false);
		declareFunction("load_nart_hl_formulas", "LOAD-NART-HL-FORMULAS", 1, 0, false);
		declareFunction("dump_nart_hl_formula", "DUMP-NART-HL-FORMULA", 3, 0, false);
		declareFunction("load_nart_hl_formula", "LOAD-NART-HL-FORMULA", 2, 0, false);
		declareFunction("load_nart_hl_formula_from_cache", "LOAD-NART-HL-FORMULA-FROM-CACHE", 2, 0, false);
		new com.cyc.cycjava.cycl.dumper.$load_nart_hl_formula_from_cache$BinaryFunction();
		declareFunction("dump_miscellaneous", "DUMP-MISCELLANEOUS", 1, 0, false);
		declareFunction("load_miscellaneous", "LOAD-MISCELLANEOUS", 1, 0, false);
		declareFunction("dump_sbhl_data", "DUMP-SBHL-DATA", 1, 0, false);
		declareFunction("old_dump_sbhl_data", "OLD-DUMP-SBHL-DATA", 1, 0, false);
		declareFunction("load_sbhl_data", "LOAD-SBHL-DATA", 1, 0, false);
		declareFunction("rebuild_sbhl_data", "REBUILD-SBHL-DATA", 0, 0, false);
		declareFunction("dump_sbhl_miscellany", "DUMP-SBHL-MISCELLANY", 1, 0, false);
		declareFunction("dump_isa_arg2_naut_table", "DUMP-ISA-ARG2-NAUT-TABLE", 1, 0, false);
		declareFunction("dump_non_fort_isa_table", "DUMP-NON-FORT-ISA-TABLE", 1, 0, false);
		declareFunction("dump_non_fort_instance_table", "DUMP-NON-FORT-INSTANCE-TABLE", 1, 0, false);
		declareFunction("load_sbhl_miscellany", "LOAD-SBHL-MISCELLANY", 1, 0, false);
		declareFunction("load_isa_arg2_naut_table", "LOAD-ISA-ARG2-NAUT-TABLE", 1, 0, false);
		declareFunction("load_non_fort_isa_table", "LOAD-NON-FORT-ISA-TABLE", 1, 0, false);
		declareFunction("load_non_fort_instance_table", "LOAD-NON-FORT-INSTANCE-TABLE", 1, 0, false);
		declareFunction("dump_sbhl_cache", "DUMP-SBHL-CACHE", 1, 0, false);
		declareFunction("load_sbhl_cache", "LOAD-SBHL-CACHE", 1, 0, false);
		declareFunction("rebuild_sbhl_cache", "REBUILD-SBHL-CACHE", 0, 0, false);
		declareFunction("dump_cardinality_estimates", "DUMP-CARDINALITY-ESTIMATES", 1, 0, false);
		declareFunction("load_cardinality_estimates", "LOAD-CARDINALITY-ESTIMATES", 1, 0, false);
		declareMacro("not_computing_arg_type_cache", "NOT-COMPUTING-ARG-TYPE-CACHE");
		declareFunction("dump_arg_type_cache", "DUMP-ARG-TYPE-CACHE", 1, 0, false);
		declareFunction("load_arg_type_cache", "LOAD-ARG-TYPE-CACHE", 1, 0, false);
		declareFunction("rebuild_arg_type_cache", "REBUILD-ARG-TYPE-CACHE", 0, 0, false);
		declareFunction("dump_defns_cache", "DUMP-DEFNS-CACHE", 1, 0, false);
		declareFunction("load_defns_cache", "LOAD-DEFNS-CACHE", 1, 0, false);
		declareFunction("dump_rule_connectivity_graph", "DUMP-RULE-CONNECTIVITY-GRAPH", 1, 0, false);
		declareFunction("load_rule_connectivity_graph", "LOAD-RULE-CONNECTIVITY-GRAPH", 1, 0, false);
		declareFunction("dump_tva_cache", "DUMP-TVA-CACHE", 1, 0, false);
		declareFunction("load_tva_cache", "LOAD-TVA-CACHE", 1, 0, false);
		declareFunction("dump_reformulator_rules", "DUMP-REFORMULATOR-RULES", 1, 0, false);
		declareFunction("load_reformulator_rules", "LOAD-REFORMULATOR-RULES", 1, 0, false);
		declareFunction("dump_english_units_of_measure", "DUMP-ENGLISH-UNITS-OF-MEASURE", 1, 0, false);
		declareFunction("load_english_units_of_measure", "LOAD-ENGLISH-UNITS-OF-MEASURE", 1, 0, false);
		declareFunction("dump_cae_query_search_tables", "DUMP-CAE-QUERY-SEARCH-TABLES", 1, 0, false);
		declareFunction("load_cae_query_search_tables", "LOAD-CAE-QUERY-SEARCH-TABLES", 1, 0, false);
		declareFunction("dump_sbhl_time_state", "DUMP-SBHL-TIME-STATE", 1, 0, false);
		declareFunction("load_sbhl_time_state", "LOAD-SBHL-TIME-STATE", 1, 0, false);
		declareFunction("rebuild_sbhl_time_data", "REBUILD-SBHL-TIME-DATA", 0, 0, false);
		declareFunction("dump_rtp_rules_cache", "DUMP-RTP-RULES-CACHE", 1, 0, false);
		declareFunction("load_rtp_rules_cache", "LOAD-RTP-RULES-CACHE", 1, 0, false);
		declareFunction("dump_somewhere_cache", "DUMP-SOMEWHERE-CACHE", 1, 0, false);
		declareFunction("load_somewhere_cache", "LOAD-SOMEWHERE-CACHE", 1, 0, false);
		declareFunction("dump_arity_cache", "DUMP-ARITY-CACHE", 1, 0, false);
		declareFunction("load_arity_cache", "LOAD-ARITY-CACHE", 1, 0, false);
		declareFunction("dump_pph_phrase_shells", "DUMP-PPH-PHRASE-SHELLS", 1, 0, false);
		declareFunction("load_pph_phrase_shells", "LOAD-PPH-PHRASE-SHELLS", 1, 0, false);
		declareFunction("load_pph_phrase_count", "LOAD-PPH-PHRASE-COUNT", 1, 0, false);
		declareFunction("dump_pph_phrase_shell", "DUMP-PPH-PHRASE-SHELL", 2, 0, false);
		declareFunction("load_pph_phrase_shell", "LOAD-PPH-PHRASE-SHELL", 2, 0, false);
		declareFunction("dump_pph_phrase_defs", "DUMP-PPH-PHRASE-DEFS", 1, 0, false);
		declareFunction("load_pph_phrase_defs", "LOAD-PPH-PHRASE-DEFS", 1, 0, false);
		declareFunction("dump_pph_phrase_def", "DUMP-PPH-PHRASE-DEF", 2, 0, false);
		declareFunction("load_pph_phrase_def", "LOAD-PPH-PHRASE-DEF", 2, 0, false);
		declareFunction("dump_gen_template_store", "DUMP-GEN-TEMPLATE-STORE", 1, 0, false);
		declareFunction("load_gen_template_store", "LOAD-GEN-TEMPLATE-STORE", 1, 0, false);
		declareFunction("dump_paraphrase_cycl_caches", "DUMP-PARAPHRASE-CYCL-CACHES", 1, 0, false);
		declareFunction("rebuild_pph_phrases", "REBUILD-PPH-PHRASES", 0, 0, false);
		declareFunction("load_paraphrase_cycl_caches", "LOAD-PARAPHRASE-CYCL-CACHES", 1, 0, false);
		declareFunction("dump_kb_activities", "DUMP-KB-ACTIVITIES", 1, 0, false);
		declareFunction("load_kb_initializations", "LOAD-KB-INITIALIZATIONS", 0, 0, false);
		declareFunction("initialize_kb_features", "INITIALIZE-KB-FEATURES", 0, 0, false);
		declareFunction("show_kb_features", "SHOW-KB-FEATURES", 0, 0, false);
		declareFunction("generate_kb_dump_reports", "GENERATE-KB-DUMP-REPORTS", 0, 2, false);
		declareFunction("generate_stale_documentation_report", "GENERATE-STALE-DOCUMENTATION-REPORT", 0, 1, false);
		declareFunction("generate_stale_documentation_report_to_file", "GENERATE-STALE-DOCUMENTATION-REPORT-TO-FILE", 1,
				0, false);
		declareFunction("preds_of_strings", "PREDS-OF-STRINGS", 0, 0, false);
		declareFunction("binary_preds_with_arg_isa", "BINARY-PREDS-WITH-ARG-ISA", 1, 0, false);
		declareFunction("invalid_constant_in_string_assertions", "INVALID-CONSTANT-IN-STRING-ASSERTIONS", 0, 0, false);
		declareFunction("invalid_constant_in_string_assertionP", "INVALID-CONSTANT-IN-STRING-ASSERTION?", 1, 0, false);
		declareFunction("invalid_doc_stringP", "INVALID-DOC-STRING?", 1, 0, false);
		declareFunction("mal_constant_referencesP", "MAL-CONSTANT-REFERENCES?", 1, 0, false);
		declareFunction("mal_constant_references", "MAL-CONSTANT-REFERENCES", 1, 0, false);
		declareFunction("report_stale_documentation_references_to_stream",
				"REPORT-STALE-DOCUMENTATION-REFERENCES-TO-STREAM", 1, 0, false);
		declareFunction("report_recent_renames_to_stream", "REPORT-RECENT-RENAMES-TO-STREAM", 1, 0, false);
		return NIL;
	}

	public static SubLObject declare_dumper_file() {
		if (SubLFiles.USE_V1) {
			declareFunction("force_monolithic_kb_assumptionP", "FORCE-MONOLITHIC-KB-ASSUMPTION?", 0, 0, false);
			declareMacro("with_kb_dump_ids", "WITH-KB-DUMP-IDS");
			declareMacro("with_kb_load_ids", "WITH-KB-LOAD-IDS");
			declareMacro("with_kb_load_area_allocation", "WITH-KB-LOAD-AREA-ALLOCATION");
			declareMacro("without_kb_load_area_allocation", "WITHOUT-KB-LOAD-AREA-ALLOCATION");
			declareMacro("with_kb_dump_filename", "WITH-KB-DUMP-FILENAME");
			declareMacro("with_kb_dump_binary_file", "WITH-KB-DUMP-BINARY-FILE");
			declareMacro("with_kb_dump_text_file", "WITH-KB-DUMP-TEXT-FILE");
			declareFunction("discard_dump_filename", "DISCARD-DUMP-FILENAME", 1, 0, false);
			declareMacro("with_pergamom_style_units", "WITH-PERGAMOM-STYLE-UNITS");
			declareMacro("with_kelsos_style_units", "WITH-KELSOS-STYLE-UNITS");
			declareFunction("kb_dump_directory", "KB-DUMP-DIRECTORY", 0, 2, false);
			declareFunction("get_wide_mark_basename_from_index_basename", "GET-WIDE-MARK-BASENAME-FROM-INDEX-BASENAME",
					1, 0, false);
			declareFunction("kb_dump_file", "KB-DUMP-FILE", 2, 1, false);
			declareFunction("kb_dump_product_file", "KB-DUMP-PRODUCT-FILE", 2, 1, false);
			declareFunction("dump_estimated_size", "DUMP-ESTIMATED-SIZE", 0, 1, false);
			declareFunction("verify_file_existence", "VERIFY-FILE-EXISTENCE", 1, 1, false);
			declareFunction("validate_dump_directory", "VALIDATE-DUMP-DIRECTORY", 1, 0, false);
			declareFunction("kb_load_gc_checkpoint", "KB-LOAD-GC-CHECKPOINT", 0, 0, false);
			declareFunction("preprocess_experience_and_dump_standard_kb", "PREPROCESS-EXPERIENCE-AND-DUMP-STANDARD-KB",
					0, 3, false);
			declareFunction("dump_standard_kb", "DUMP-STANDARD-KB", 0, 1, false);
			declareFunction("perform_standard_pre_dump_kb_cleanups", "PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS", 0, 0,
					false);
			declareFunction("perform_standard_pre_dump_kb_cleanups_complete",
					"PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-COMPLETE", 0, 0, false);
			declareFunction("perform_standard_pre_dump_kb_cleanups_partial",
					"PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-PARTIAL", 0, 0, false);
			declareFunction("perform_kb_cleanups", "PERFORM-KB-CLEANUPS", 0, 0, false);
			declareFunction("preprocess_experience", "PREPROCESS-EXPERIENCE", 0, 2, false);
			declareFunction("preprocess_experience_and_dump_non_computable_kb",
					"PREPROCESS-EXPERIENCE-AND-DUMP-NON-COMPUTABLE-KB", 0, 3, false);
			declareFunction("dump_non_computable_kb", "DUMP-NON-COMPUTABLE-KB", 1, 0, false);
			declareFunction("load_non_computable_kb_and_rebuild_computable_kb_and_write_image",
					"LOAD-NON-COMPUTABLE-KB-AND-REBUILD-COMPUTABLE-KB-AND-WRITE-IMAGE", 3, 0, false);
			declareFunction("load_non_computable_kb", "LOAD-NON-COMPUTABLE-KB", 1, 0, false);
			declareFunction("load_non_computable_kb_and_rebuild_computable_kb",
					"LOAD-NON-COMPUTABLE-KB-AND-REBUILD-COMPUTABLE-KB", 2, 0, false);
			declareFunction("dump_computable_kb_and_content", "DUMP-COMPUTABLE-KB-AND-CONTENT", 2, 0, false);
			declareFunction("load_non_computable_kb_plus_rebuild_and_dump_computable_kb",
					"LOAD-NON-COMPUTABLE-KB-PLUS-REBUILD-AND-DUMP-COMPUTABLE-KB", 2, 1, false);
			declareFunction("rebuild_and_reconnect_computable_kb", "REBUILD-AND-RECONNECT-COMPUTABLE-KB", 2, 0, false);
			declareFunction("rebuild_and_reconnect_kb_indexing", "REBUILD-AND-RECONNECT-KB-INDEXING", 0, 0, false);
			declareFunction("rebuild_assertion_indexing_for_reconnect", "REBUILD-ASSERTION-INDEXING-FOR-RECONNECT", 0,
					0, false);
			declareFunction("rebuild_and_dump_assertion_indexing", "REBUILD-AND-DUMP-ASSERTION-INDEXING", 0, 0, false);
			declareFunction("merge_and_redump_assertion_indexing", "MERGE-AND-REDUMP-ASSERTION-INDEXING", 1, 0, false);
			declareFunction("merge_and_redump_constant_assertion_indexing",
					"MERGE-AND-REDUMP-CONSTANT-ASSERTION-INDEXING", 1, 0, false);
			declareFunction("merge_and_redump_nart_assertion_indexing", "MERGE-AND-REDUMP-NART-ASSERTION-INDEXING", 1,
					0, false);
			declareFunction("merge_and_redump_unrepresented_term_assertion_indexing",
					"MERGE-AND-REDUMP-UNREPRESENTED-TERM-ASSERTION-INDEXING", 1, 0, false);
			declareFunction("merge_index_from_partial_results", "MERGE-INDEX-FROM-PARTIAL-RESULTS", 5, 1, false);
			declareFunction("compute_rebuild_part_dirs", "COMPUTE-REBUILD-PART-DIRS", 1, 0, false);
			declareFunction("cleanup_rebuild_part_dirs", "CLEANUP-REBUILD-PART-DIRS", 1, 0, false);
			declareFunction("cyc_dump_kb", "CYC-DUMP-KB", 2, 1, false);
			declareFunction("cyc_dump_kb_unsafe", "CYC-DUMP-KB-UNSAFE", 2, 1, false);
			declareFunction("cyc_dump_kb_int", "CYC-DUMP-KB-INT", 2, 1, false);
			declareMacro("with_timed_kb_store_operation", "WITH-TIMED-KB-STORE-OPERATION");
			declareFunction("dump_kb", "DUMP-KB", 0, 1, false);
			declareFunction("load_kb", "LOAD-KB", 1, 0, false);
			declareFunction("minimal_tombstoning_modeP", "MINIMAL-TOMBSTONING-MODE?", 0, 0, false);
			declareFunction("medium_tombstoning_modeP", "MEDIUM-TOMBSTONING-MODE?", 0, 0, false);
			declareFunction("maximal_tombstoning_modeP", "MAXIMAL-TOMBSTONING-MODE?", 0, 0, false);
			declareFunction("snapshot_kb", "SNAPSHOT-KB", 1, 2, false);
			declareFunction("ensure_valid_dump_directory", "ENSURE-VALID-DUMP-DIRECTORY", 1, 0, false);
			declareFunction("possibly_note_transcript_operations_processed",
					"POSSIBLY-NOTE-TRANSCRIPT-OPERATIONS-PROCESSED", 0, 0, false);
			declareFunction("kb_manifest", "KB-MANIFEST", 0, 0, false);
			declareFunction("kb_possibly_load_manifest_from_directory", "KB-POSSIBLY-LOAD-MANIFEST-FROM-DIRECTORY", 1,
					0, false);
			declareFunction("kb_load_manifest_from_directory", "KB-LOAD-MANIFEST-FROM-DIRECTORY", 1, 0, false);
			declareFunction("describe_knowledge_fvector_files", "DESCRIBE-KNOWLEDGE-FVECTOR-FILES", 1, 0, false);
			declareFunction("describe_index_fvector_files", "DESCRIBE-INDEX-FVECTOR-FILES", 1, 0, false);
			declareFunction("get_kb_units_file_vector_descriptions", "GET-KB-UNITS-FILE-VECTOR-DESCRIPTIONS", 0, 0,
					false);
			declareFunction("get_kb_units_file_vector_categories", "GET-KB-UNITS-FILE-VECTOR-CATEGORIES", 0, 0, false);
			declareFunction("kb_dump_to_directory", "KB-DUMP-TO-DIRECTORY", 1, 0, false);
			declareFunction("kb_snapshot_to_directory", "KB-SNAPSHOT-TO-DIRECTORY", 2, 0, false);
			declareFunction("kb_load_from_directory", "KB-LOAD-FROM-DIRECTORY", 1, 0, false);
			declareFunction("dump_kb_ids", "DUMP-KB-IDS", 1, 0, false);
			declareFunction("dump_essential_kb", "DUMP-ESSENTIAL-KB", 1, 0, false);
			declareFunction("snapshot_essential_kb", "SNAPSHOT-ESSENTIAL-KB", 2, 0, false);
			declareFunction("load_essential_kb", "LOAD-ESSENTIAL-KB", 1, 0, false);
			declareFunction("load_essential_kb_initializations", "LOAD-ESSENTIAL-KB-INITIALIZATIONS", 0, 0, false);
			declareFunction("load_computable_kb_initializations", "LOAD-COMPUTABLE-KB-INITIALIZATIONS", 0, 0, false);
			declareFunction("load_computable_remaining_hl_low_initializations",
					"LOAD-COMPUTABLE-REMAINING-HL-LOW-INITIALIZATIONS", 0, 0, false);
			declareFunction("dump_computable_content", "DUMP-COMPUTABLE-CONTENT", 1, 0, false);
			declareFunction("load_computable_content", "LOAD-COMPUTABLE-CONTENT", 1, 0, false);
			declareFunction("rebuild_computable_content", "REBUILD-COMPUTABLE-CONTENT", 0, 0, false);
			declareFunction("rebuild_computable_content_dumpable", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE", 0, 1, false);
			declareFunction("rebuild_computable_content_dumpable_low", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE-LOW", 0, 0,
					false);
			declareFunction("dump_computable_kb", "DUMP-COMPUTABLE-KB", 1, 0, false);
			declareFunction("snapshot_computable_kb", "SNAPSHOT-COMPUTABLE-KB", 2, 0, false);
			declareFunction("load_computable_kb", "LOAD-COMPUTABLE-KB", 1, 0, false);
			declareFunction("rebuild_computable_kb", "REBUILD-COMPUTABLE-KB", 0, 0, false);
			declareFunction("dump_computable_remaining_hl", "DUMP-COMPUTABLE-REMAINING-HL", 1, 1, false);
			declareFunction("dump_computable_remaining_hl_shared", "DUMP-COMPUTABLE-REMAINING-HL-SHARED", 1, 1, false);
			declareFunction("snapshot_computable_remaining_hl", "SNAPSHOT-COMPUTABLE-REMAINING-HL", 1, 1, false);
			declareFunction("load_computable_remaining_hl", "LOAD-COMPUTABLE-REMAINING-HL", 1, 0, false);
			declareFunction("rebuild_computable_remaining_hl", "REBUILD-COMPUTABLE-REMAINING-HL", 0, 1, false);
			declareFunction("rebuild_computable_remaining_hl_low", "REBUILD-COMPUTABLE-REMAINING-HL-LOW", 0, 1, false);
			declareFunction("rebuild_computable_remaining_hl_high", "REBUILD-COMPUTABLE-REMAINING-HL-HIGH", 0, 1,
					false);
			declareFunction("rebuild_computable_but_not_dumpable_yet", "REBUILD-COMPUTABLE-BUT-NOT-DUMPABLE-YET", 0, 0,
					false);
			declareFunction("dump_copyright", "DUMP-COPYRIGHT", 1, 0, false);
			declareFunction("kb_dump_stamp_file_vector_for_references", "KB-DUMP-STAMP-FILE-VECTOR-FOR-REFERENCES", 1,
					0, false);
			declareFunction("load_copyright", "LOAD-COPYRIGHT", 1, 0, false);
			declareFunction("load_unit_file", "LOAD-UNIT-FILE", 4, 0, false);
			declareFunction("dump_kb_object_count", "DUMP-KB-OBJECT-COUNT", 3, 0, false);
			declareFunction("load_kb_object_count", "LOAD-KB-OBJECT-COUNT", 2, 0, false);
			declareFunction("snapshot_kb_object_deleted_id_set", "SNAPSHOT-KB-OBJECT-DELETED-ID-SET", 3, 1, false);
			declareFunction("load_kb_object_deleted_id_set", "LOAD-KB-OBJECT-DELETED-ID-SET", 2, 0, false);
			declareFunction("snapshot_changed_managed_objects", "SNAPSHOT-CHANGED-MANAGED-OBJECTS", 6, 0, false);
			declareFunction("snapshot_new_managed_objects", "SNAPSHOT-NEW-MANAGED-OBJECTS", 6, 1, false);
			declareFunction("snapshot_managed_object_simple_complex_index",
					"SNAPSHOT-MANAGED-OBJECT-SIMPLE-COMPLEX-INDEX", 4, 0, false);
			declareFunction("snapshot_managed_object_simple_index", "SNAPSHOT-MANAGED-OBJECT-SIMPLE-INDEX", 4, 0,
					false);
			declareFunction("snapshot_deleted_object_tombstones", "SNAPSHOT-DELETED-OBJECT-TOMBSTONES", 3, 0, false);
			declareFunction("replicate_fv_dump_files", "REPLICATE-FV-DUMP-FILES", 7, 0, false);
			declareFunction("replicate_one_dump_file", "REPLICATE-ONE-DUMP-FILE", 3, 1, false);
			declareFunction("replicate_one_index_file", "REPLICATE-ONE-INDEX-FILE", 5, 0, false);
			declareFunction("kb_dump_default_common_symbols", "KB-DUMP-DEFAULT-COMMON-SYMBOLS", 0, 0, false);
			declareFunction("kb_dump_common_symbols", "KB-DUMP-COMMON-SYMBOLS", 0, 0, false);
			declareFunction("dump_special_objects", "DUMP-SPECIAL-OBJECTS", 1, 0, false);
			declareFunction("dump_special_objects_internal", "DUMP-SPECIAL-OBJECTS-INTERNAL", 2, 0, false);
			declareFunction("load_special_objects", "LOAD-SPECIAL-OBJECTS", 1, 1, false);
			declareFunction("load_kb_product_shared_symbols", "LOAD-KB-PRODUCT-SHARED-SYMBOLS", 1, 0, false);
			declareFunction("setup_kb_state_from_dump", "SETUP-KB-STATE-FROM-DUMP", 1, 0, false);
			declareFunction("get_exclusive_constant_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-CONSTANT-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("dump_constant_shells", "DUMP-CONSTANT-SHELLS", 1, 0, false);
			declareFunction("dump_constant_shells_int", "DUMP-CONSTANT-SHELLS-INT", 1, 0, false);
			declareFunction("snapshot_constant_shells", "SNAPSHOT-CONSTANT-SHELLS", 1, 0, false);
			declareFunction("snapshot_deleted_constant_set", "SNAPSHOT-DELETED-CONSTANT-SET", 1, 0, false);
			declareFunction("has_deleted_constant_id_setP", "HAS-DELETED-CONSTANT-ID-SET?", 1, 0, false);
			declareFunction("load_constant_count", "LOAD-CONSTANT-COUNT", 1, 0, false);
			declareFunction("load_constant_shells", "LOAD-CONSTANT-SHELLS", 1, 0, false);
			declareFunction("debug_map_constant_shell_file_position_to_constant_id",
					"DEBUG-MAP-CONSTANT-SHELL-FILE-POSITION-TO-CONSTANT-ID", 2, 0, false);
			declareFunction("dump_constant_shell", "DUMP-CONSTANT-SHELL", 2, 0, false);
			declareFunction("dump_constant_shell_internal", "DUMP-CONSTANT-SHELL-INTERNAL", 4, 0, false);
			declareFunction("load_constant_shell", "LOAD-CONSTANT-SHELL", 2, 0, false);
			declareFunction("load_constant_shell_internal", "LOAD-CONSTANT-SHELL-INTERNAL", 3, 0, false);
			declareFunction("generate_constant_shell_file", "GENERATE-CONSTANT-SHELL-FILE", 1, 0, false);
			declareFunction("get_exclusive_nart_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-NART-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("dump_nart_count", "DUMP-NART-COUNT", 1, 0, false);
			declareFunction("snapshot_nart_count", "SNAPSHOT-NART-COUNT", 1, 0, false);
			declareFunction("snapshot_deleted_nart_id_set", "SNAPSHOT-DELETED-NART-ID-SET", 1, 0, false);
			declareFunction("load_nart_shells", "LOAD-NART-SHELLS", 1, 0, false);
			declareFunction("load_nart_count", "LOAD-NART-COUNT", 1, 0, false);
			declareFunction("load_deleted_nart_id_set", "LOAD-DELETED-NART-ID-SET", 1, 0, false);
			declareFunction("has_deleted_nart_id_setP", "HAS-DELETED-NART-ID-SET?", 1, 0, false);
			declareFunction("initialize_nart_shells", "INITIALIZE-NART-SHELLS", 2, 0, false);
			declareFunction("load_nart_shells_legacy", "LOAD-NART-SHELLS-LEGACY", 1, 0, false);
			declareFunction("dump_nart_shell", "DUMP-NART-SHELL", 2, 0, false);
			declareFunction("load_nart_shell", "LOAD-NART-SHELL", 2, 0, false);
			declareFunction("get_exclusive_assertion_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-ASSERTION-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("dump_assertion_count", "DUMP-ASSERTION-COUNT", 1, 0, false);
			declareFunction("snapshot_assertion_count", "SNAPSHOT-ASSERTION-COUNT", 1, 0, false);
			declareFunction("snapshot_deleted_assertion_id_set", "SNAPSHOT-DELETED-ASSERTION-ID-SET", 1, 0, false);
			declareFunction("load_assertion_shells", "LOAD-ASSERTION-SHELLS", 1, 0, false);
			declareFunction("load_assertion_count", "LOAD-ASSERTION-COUNT", 1, 0, false);
			declareFunction("load_deleted_assertion_id_set", "LOAD-DELETED-ASSERTION-ID-SET", 1, 0, false);
			declareFunction("has_deleted_assertion_id_setP", "HAS-DELETED-ASSERTION-ID-SET?", 1, 0, false);
			declareFunction("initialize_assertion_shells", "INITIALIZE-ASSERTION-SHELLS", 2, 0, false);
			declareFunction("load_assertion_shells_legacy", "LOAD-ASSERTION-SHELLS-LEGACY", 1, 0, false);
			declareFunction("dump_assertion_shell", "DUMP-ASSERTION-SHELL", 2, 0, false);
			declareFunction("load_assertion_shell", "LOAD-ASSERTION-SHELL", 2, 0, false);
			declareFunction("get_exclusive_kb_hl_support_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-KB-HL-SUPPORT-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("dump_kb_hl_support_count", "DUMP-KB-HL-SUPPORT-COUNT", 1, 0, false);
			declareFunction("snapshot_kb_hl_support_count", "SNAPSHOT-KB-HL-SUPPORT-COUNT", 1, 0, false);
			declareFunction("snapshot_deleted_kb_hl_support_id_set", "SNAPSHOT-DELETED-KB-HL-SUPPORT-ID-SET", 1, 0,
					false);
			declareFunction("load_kb_hl_support_shells", "LOAD-KB-HL-SUPPORT-SHELLS", 1, 0, false);
			declareFunction("load_kb_hl_support_count", "LOAD-KB-HL-SUPPORT-COUNT", 1, 0, false);
			declareFunction("load_deleted_kb_hl_support_id_set", "LOAD-DELETED-KB-HL-SUPPORT-ID-SET", 1, 0, false);
			declareFunction("has_deleted_kb_hl_support_id_setP", "HAS-DELETED-KB-HL-SUPPORT-ID-SET?", 1, 0, false);
			declareFunction("initialize_kb_hl_support_shells", "INITIALIZE-KB-HL-SUPPORT-SHELLS", 2, 0, false);
			declareFunction("load_kb_hl_support_shells_legacy", "LOAD-KB-HL-SUPPORT-SHELLS-LEGACY", 1, 0, false);
			declareFunction("dump_kb_hl_support_shell", "DUMP-KB-HL-SUPPORT-SHELL", 2, 0, false);
			declareFunction("load_kb_hl_support_shell", "LOAD-KB-HL-SUPPORT-SHELL", 2, 0, false);
			declareFunction("get_exclusive_kb_unrepresented_term_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-KB-UNREPRESENTED-TERM-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("dump_kb_unrepresented_terms", "DUMP-KB-UNREPRESENTED-TERMS", 1, 0, false);
			declareFunction("dump_kb_unrepresented_terms_int", "DUMP-KB-UNREPRESENTED-TERMS-INT", 1, 0, false);
			declareFunction("snapshot_kb_unrepresented_terms", "SNAPSHOT-KB-UNREPRESENTED-TERMS", 2, 0, false);
			declareFunction("load_kb_unrepresented_terms", "LOAD-KB-UNREPRESENTED-TERMS", 1, 0, false);
			declareFunction("dump_kb_unrepresented_term", "DUMP-KB-UNREPRESENTED-TERM", 2, 0, false);
			declareFunction("load_kb_unrepresented_term", "LOAD-KB-UNREPRESENTED-TERM", 4, 0, false);
			declareFunction("load_kb_unrepresented_term_count", "LOAD-KB-UNREPRESENTED-TERM-COUNT", 1, 0, false);
			declareFunction("get_exclusive_clause_struc_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-CLAUSE-STRUC-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("dump_clause_struc_defs", "DUMP-CLAUSE-STRUC-DEFS", 1, 0, false);
			declareFunction("dump_clause_struc_defs_internal", "DUMP-CLAUSE-STRUC-DEFS-INTERNAL", 1, 0, false);
			declareFunction("snapshot_deleted_clause_struc_id_set", "SNAPSHOT-DELETED-CLAUSE-STRUC-ID-SET", 2, 0,
					false);
			declareFunction("snapshot_clause_struc_defs", "SNAPSHOT-CLAUSE-STRUC-DEFS", 1, 0, false);
			declareFunction("load_deleted_clause_struc_id_set", "LOAD-DELETED-CLAUSE-STRUC-ID-SET", 1, 0, false);
			declareFunction("has_deleted_clause_struc_id_setP", "HAS-DELETED-CLAUSE-STRUC-ID-SET?", 1, 0, false);
			declareFunction("load_clause_struc_defs", "LOAD-CLAUSE-STRUC-DEFS", 1, 0, false);
			declareFunction("dump_clause_struc_def", "DUMP-CLAUSE-STRUC-DEF", 2, 0, false);
			declareFunction("load_clause_struc_def", "LOAD-CLAUSE-STRUC-DEF", 2, 0, false);
			declareFunction("load_clause_struc_count", "LOAD-CLAUSE-STRUC-COUNT", 1, 0, false);
			declareFunction("possibly_persist_wide_fvector_mark", "POSSIBLY-PERSIST-WIDE-FVECTOR-MARK", 4, 0, false);
			declareFunction("get_exclusive_deduction_internal_id_limit_for_kb",
					"GET-EXCLUSIVE-DEDUCTION-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
			declareFunction("snapshot_deduction_count", "SNAPSHOT-DEDUCTION-COUNT", 1, 0, false);
			declareFunction("dump_deduction_defs", "DUMP-DEDUCTION-DEFS", 1, 0, false);
			declareFunction("snapshot_deduction_defs", "SNAPSHOT-DEDUCTION-DEFS", 2, 0, false);
			declareFunction("snapshot_deduction_defs_internal", "SNAPSHOT-DEDUCTION-DEFS-INTERNAL", 2, 1, false);
			declareFunction("load_deduction_defs", "LOAD-DEDUCTION-DEFS", 1, 0, false);
			declareFunction("dump_deduction_def", "DUMP-DEDUCTION-DEF", 2, 0, false);
			declareFunction("snapshot_deleted_deduction_id_set", "SNAPSHOT-DELETED-DEDUCTION-ID-SET", 1, 0, false);
			declareFunction("load_deduction_def", "LOAD-DEDUCTION-DEF", 2, 0, false);
			declareFunction("load_deduction_def_from_cache", "LOAD-DEDUCTION-DEF-FROM-CACHE", 2, 0, false);
			new dumper.$load_deduction_def_from_cache$BinaryFunction();
			declareFunction("load_deduction_count", "LOAD-DEDUCTION-COUNT", 1, 0, false);
			declareFunction("load_deleted_deduction_id_set", "LOAD-DELETED-DEDUCTION-ID-SET", 1, 0, false);
			declareFunction("has_deleted_deduction_id_setP", "HAS-DELETED-DEDUCTION-ID-SET?", 1, 0, false);
			declareFunction("dump_assertion_defs", "DUMP-ASSERTION-DEFS", 1, 0, false);
			declareFunction("snapshot_assertion_defs", "SNAPSHOT-ASSERTION-DEFS", 2, 0, false);
			declareFunction("snapshot_assertion_defs_internal", "SNAPSHOT-ASSERTION-DEFS-INTERNAL", 2, 1, false);
			declareFunction("load_assertion_defs", "LOAD-ASSERTION-DEFS", 1, 0, false);
			declareFunction("dump_assertion_def", "DUMP-ASSERTION-DEF", 2, 0, false);
			declareFunction("snapshot_assertion_def", "SNAPSHOT-ASSERTION-DEF", 3, 1, false);
			declareFunction("load_assertion_def", "LOAD-ASSERTION-DEF", 2, 0, false);
			declareFunction("load_assertion_def_from_cache", "LOAD-ASSERTION-DEF-FROM-CACHE", 2, 0, false);
			new dumper.$load_assertion_def_from_cache$BinaryFunction();
			declareFunction("dump_kb_hl_support_defs", "DUMP-KB-HL-SUPPORT-DEFS", 1, 0, false);
			declareFunction("snapshot_kb_hl_support_defs", "SNAPSHOT-KB-HL-SUPPORT-DEFS", 2, 0, false);
			declareFunction("load_kb_hl_support_defs", "LOAD-KB-HL-SUPPORT-DEFS", 1, 0, false);
			declareFunction("dump_kb_hl_support_def", "DUMP-KB-HL-SUPPORT-DEF", 2, 0, false);
			declareFunction("load_kb_hl_support_def", "LOAD-KB-HL-SUPPORT-DEF", 2, 0, false);
			declareFunction("load_kb_hl_support_def_from_cache", "LOAD-KB-HL-SUPPORT-DEF-FROM-CACHE", 2, 0, false);
			declareFunction("dump_kb_hl_support_indexing", "DUMP-KB-HL-SUPPORT-INDEXING", 1, 0, false);
			declareFunction("load_kb_hl_support_indexing", "LOAD-KB-HL-SUPPORT-INDEXING", 1, 0, false);
			declareFunction("dump_bookkeeping_assertions", "DUMP-BOOKKEEPING-ASSERTIONS", 1, 0, false);
			declareFunction("dump_bookkeeping_assertions_for_pred", "DUMP-BOOKKEEPING-ASSERTIONS-FOR-PRED", 3, 0,
					false);
			declareFunction("dump_bookkeeping_assertion", "DUMP-BOOKKEEPING-ASSERTION", 3, 0, false);
			declareFunction("load_bookkeeping_assertions", "LOAD-BOOKKEEPING-ASSERTIONS", 1, 0, false);
			declareFunction("load_bookkeeping_assertions_for_pred", "LOAD-BOOKKEEPING-ASSERTIONS-FOR-PRED", 1, 0,
					false);
			declareFunction("load_bookkeeping_assertion", "LOAD-BOOKKEEPING-ASSERTION", 2, 0, false);
			declareFunction("dump_experience", "DUMP-EXPERIENCE", 1, 1, false);
			declareFunction("dump_rule_utility_experience", "DUMP-RULE-UTILITY-EXPERIENCE", 1, 1, false);
			declareFunction("load_experience", "LOAD-EXPERIENCE", 1, 0, false);
			declareFunction("load_rule_utility_experience", "LOAD-RULE-UTILITY-EXPERIENCE", 1, 0, false);
			declareFunction("reload_experience", "RELOAD-EXPERIENCE", 0, 1, false);
			declareFunction("new_niniveh_index_iterator", "NEW-NINIVEH-INDEX-ITERATOR", 2, 0, false);
			declareFunction("construct_niniveh_iterator_state", "CONSTRUCT-NINIVEH-ITERATOR-STATE", 1, 0, false);
			declareFunction("niniveh_index_iterator_doneP", "NINIVEH-INDEX-ITERATOR-DONE?", 1, 0, false);
			declareFunction("niniveh_index_iterator_next", "NINIVEH-INDEX-ITERATOR-NEXT", 1, 0, false);
			declareFunction("niniveh_index_iterator_finalize", "NINIVEH-INDEX-ITERATOR-FINALIZE", 1, 0, false);
			declareFunction("dump_kb_indexing", "DUMP-KB-INDEXING", 1, 0, false);
			declareFunction("snapshot_kb_indexing", "SNAPSHOT-KB-INDEXING", 2, 0, false);
			declareFunction("load_kb_indexing", "LOAD-KB-INDEXING", 1, 0, false);
			declareFunction("load_kb_assertion_indexing", "LOAD-KB-ASSERTION-INDEXING", 1, 0, false);
			declareFunction("rebuild_kb_indexing", "REBUILD-KB-INDEXING", 0, 0, false);
			declareFunction("test_dump_kb_indexing", "TEST-DUMP-KB-INDEXING", 1, 0, false);
			declareFunction("test_load_kb_indexing", "TEST-LOAD-KB-INDEXING", 1, 0, false);
			declareFunction("index_writer_print_function_trampoline", "INDEX-WRITER-PRINT-FUNCTION-TRAMPOLINE", 2, 0,
					false);
			declareFunction("index_writer_p", "INDEX-WRITER-P", 1, 0, false);
			new dumper.$index_writer_p$UnaryFunction();
			declareFunction("idxwriter_directory", "IDXWRITER-DIRECTORY", 1, 0, false);
			declareFunction("idxwriter_fvector", "IDXWRITER-FVECTOR", 1, 0, false);
			declareFunction("idxwriter_index_file", "IDXWRITER-INDEX-FILE", 1, 0, false);
			declareFunction("idxwriter_index_label", "IDXWRITER-INDEX-LABEL", 1, 0, false);
			declareFunction("idxwriter_complex_fvector", "IDXWRITER-COMPLEX-FVECTOR", 1, 0, false);
			declareFunction("idxwriter_complex_index_file", "IDXWRITER-COMPLEX-INDEX-FILE", 1, 0, false);
			declareFunction("idxwriter_complex_index_label", "IDXWRITER-COMPLEX-INDEX-LABEL", 1, 0, false);
			declareFunction("idxwriter_dump_fn", "IDXWRITER-DUMP-FN", 1, 0, false);
			declareFunction("_csetf_idxwriter_directory", "_CSETF-IDXWRITER-DIRECTORY", 2, 0, false);
			declareFunction("_csetf_idxwriter_fvector", "_CSETF-IDXWRITER-FVECTOR", 2, 0, false);
			declareFunction("_csetf_idxwriter_index_file", "_CSETF-IDXWRITER-INDEX-FILE", 2, 0, false);
			declareFunction("_csetf_idxwriter_index_label", "_CSETF-IDXWRITER-INDEX-LABEL", 2, 0, false);
			declareFunction("_csetf_idxwriter_complex_fvector", "_CSETF-IDXWRITER-COMPLEX-FVECTOR", 2, 0, false);
			declareFunction("_csetf_idxwriter_complex_index_file", "_CSETF-IDXWRITER-COMPLEX-INDEX-FILE", 2, 0, false);
			declareFunction("_csetf_idxwriter_complex_index_label", "_CSETF-IDXWRITER-COMPLEX-INDEX-LABEL", 2, 0,
					false);
			declareFunction("_csetf_idxwriter_dump_fn", "_CSETF-IDXWRITER-DUMP-FN", 2, 0, false);
			declareFunction("make_index_writer", "MAKE-INDEX-WRITER", 0, 1, false);
			declareFunction("visit_defstruct_index_writer", "VISIT-DEFSTRUCT-INDEX-WRITER", 2, 0, false);
			declareFunction("visit_defstruct_object_index_writer_method", "VISIT-DEFSTRUCT-OBJECT-INDEX-WRITER-METHOD",
					2, 0, false);
			declareFunction("new_index_writer", "NEW-INDEX-WRITER", 8, 0, false);
			declareFunction("index_writer_put_index_entry", "INDEX-WRITER-PUT-INDEX-ENTRY", 2, 0, false);
			declareFunction("close_index_writer", "CLOSE-INDEX-WRITER", 1, 0, false);
			declareFunction("new_constant_indices_writer", "NEW-CONSTANT-INDICES-WRITER", 1, 0, false);
			declareFunction("dump_constant_indices", "DUMP-CONSTANT-INDICES", 1, 0, false);
			declareFunction("snapshot_constant_indices", "SNAPSHOT-CONSTANT-INDICES", 2, 0, false);
			declareFunction("snapshot_constant_indices_internal", "SNAPSHOT-CONSTANT-INDICES-INTERNAL", 2, 2, false);
			declareFunction("new_niniveh_constant_indices_iterator", "NEW-NINIVEH-CONSTANT-INDICES-ITERATOR", 1, 0,
					false);
			declareFunction("load_constant_indices", "LOAD-CONSTANT-INDICES", 1, 0, false);
			declareFunction("dump_constant_index", "DUMP-CONSTANT-INDEX", 3, 0, false);
			declareFunction("dump_top_level_index_of_type", "DUMP-TOP-LEVEL-INDEX-OF-TYPE", 7, 0, false);
			declareFunction("snapshot_constant_index", "SNAPSHOT-CONSTANT-INDEX", 4, 0, false);
			declareFunction("load_constant_index", "LOAD-CONSTANT-INDEX", 2, 0, false);
			declareFunction("load_constant_index_from_cache", "LOAD-CONSTANT-INDEX-FROM-CACHE", 2, 0, false);
			declareFunction("new_nart_indices_writer", "NEW-NART-INDICES-WRITER", 1, 0, false);
			declareFunction("dump_nart_indices", "DUMP-NART-INDICES", 1, 0, false);
			declareFunction("snapshot_nart_indices", "SNAPSHOT-NART-INDICES", 2, 0, false);
			declareFunction("snapshot_nart_indices_internal", "SNAPSHOT-NART-INDICES-INTERNAL", 2, 2, false);
			declareFunction("new_niniveh_nart_indices_iterator", "NEW-NINIVEH-NART-INDICES-ITERATOR", 1, 0, false);
			declareFunction("load_nart_indices", "LOAD-NART-INDICES", 1, 0, false);
			declareFunction("dump_nart_index", "DUMP-NART-INDEX", 3, 0, false);
			declareFunction("snapshot_nart_index", "SNAPSHOT-NART-INDEX", 4, 0, false);
			declareFunction("load_nart_index", "LOAD-NART-INDEX", 2, 0, false);
			declareFunction("load_nart_index_from_cache", "LOAD-NART-INDEX-FROM-CACHE", 2, 0, false);
			declareFunction("new_unrepresented_term_indices_writer", "NEW-UNREPRESENTED-TERM-INDICES-WRITER", 1, 0,
					false);
			declareFunction("dump_unrepresented_term_indices", "DUMP-UNREPRESENTED-TERM-INDICES", 1, 0, false);
			declareFunction("snapshot_unrepresented_term_indices", "SNAPSHOT-UNREPRESENTED-TERM-INDICES", 2, 0, false);
			declareFunction("snapshot_unrepresented_term_indices_internal",
					"SNAPSHOT-UNREPRESENTED-TERM-INDICES-INTERNAL", 2, 2, false);
			declareFunction("new_niniveh_unrepresented_term_indices_iterator",
					"NEW-NINIVEH-UNREPRESENTED-TERM-INDICES-ITERATOR", 1, 0, false);
			declareFunction("load_unrepresented_term_indices", "LOAD-UNREPRESENTED-TERM-INDICES", 1, 0, false);
			declareFunction("dump_unrepresented_term_index", "DUMP-UNREPRESENTED-TERM-INDEX", 3, 0, false);
			declareFunction("snapshot_unrepresented_term_index", "SNAPSHOT-UNREPRESENTED-TERM-INDEX", 4, 0, false);
			declareFunction("load_unrepresented_term_index", "LOAD-UNREPRESENTED-TERM-INDEX", 2, 0, false);
			declareFunction("load_unrepresented_term_index_from_cache", "LOAD-UNREPRESENTED-TERM-INDEX-FROM-CACHE", 2,
					0, false);
			declareFunction("dump_assertion_indices", "DUMP-ASSERTION-INDICES", 1, 0, false);
			declareFunction("load_assertion_indices", "LOAD-ASSERTION-INDICES", 1, 0, false);
			declareFunction("replicate_meta_assertion_indexing", "REPLICATE-META-ASSERTION-INDEXING", 1, 0, false);
			declareFunction("dump_assertion_index", "DUMP-ASSERTION-INDEX", 2, 0, false);
			declareFunction("load_assertion_index", "LOAD-ASSERTION-INDEX", 2, 0, false);
			declareFunction("dump_auxiliary_indices_file", "DUMP-AUXILIARY-INDICES-FILE", 1, 0, false);
			declareFunction("load_auxiliary_indices_file", "LOAD-AUXILIARY-INDICES-FILE", 1, 0, false);
			declareFunction("replicate_auxiliary_assertion_indexing", "REPLICATE-AUXILIARY-ASSERTION-INDEXING", 1, 0,
					false);
			declareFunction("dump_bookkeeping_indices_file", "DUMP-BOOKKEEPING-INDICES-FILE", 1, 0, false);
			declareFunction("load_bookkeeping_indices_file", "LOAD-BOOKKEEPING-INDICES-FILE", 1, 0, false);
			declareFunction("dump_bookkeeping_indices", "DUMP-BOOKKEEPING-INDICES", 1, 0, false);
			declareFunction("load_bookkeeping_indices", "LOAD-BOOKKEEPING-INDICES", 1, 0, false);
			declareFunction("dump_rule_set", "DUMP-RULE-SET", 1, 0, false);
			declareFunction("load_rule_set", "LOAD-RULE-SET", 1, 0, false);
			declareFunction("dump_non_true_assertion_tv_cache", "DUMP-NON-TRUE-ASSERTION-TV-CACHE", 1, 0, false);
			declareFunction("load_non_true_assertion_tv_cache", "LOAD-NON-TRUE-ASSERTION-TV-CACHE", 1, 0, false);
			declareFunction("dump_nart_hl_formulas", "DUMP-NART-HL-FORMULAS", 1, 0, false);
			declareFunction("snapshot_nart_hl_formulas", "SNAPSHOT-NART-HL-FORMULAS", 1, 0, false);
			declareFunction("load_nart_hl_formulas", "LOAD-NART-HL-FORMULAS", 1, 0, false);
			declareFunction("dump_nart_hl_formula", "DUMP-NART-HL-FORMULA", 3, 0, false);
			declareFunction("load_nart_hl_formula", "LOAD-NART-HL-FORMULA", 2, 0, false);
			declareFunction("load_nart_hl_formula_from_cache", "LOAD-NART-HL-FORMULA-FROM-CACHE", 2, 0, false);
			new dumper.$load_nart_hl_formula_from_cache$BinaryFunction();
			declareFunction("dump_miscellaneous", "DUMP-MISCELLANEOUS", 1, 0, false);
			declareFunction("load_miscellaneous", "LOAD-MISCELLANEOUS", 1, 0, false);
			declareFunction("dump_sbhl_data", "DUMP-SBHL-DATA", 1, 0, false);
			declareFunction("load_sbhl_data", "LOAD-SBHL-DATA", 1, 0, false);
			declareFunction("rebuild_sbhl_data", "REBUILD-SBHL-DATA", 0, 0, false);
			declareFunction("recompute_missing_sbhl_graphs", "RECOMPUTE-MISSING-SBHL-GRAPHS", 0, 0, false);
			declareFunction("dump_sbhl_miscellany", "DUMP-SBHL-MISCELLANY", 1, 0, false);
			declareFunction("dump_isa_arg2_naut_table", "DUMP-ISA-ARG2-NAUT-TABLE", 1, 0, false);
			declareFunction("dump_non_fort_isa_table", "DUMP-NON-FORT-ISA-TABLE", 1, 0, false);
			declareFunction("dump_non_fort_instance_table", "DUMP-NON-FORT-INSTANCE-TABLE", 1, 0, false);
			declareFunction("load_sbhl_miscellany", "LOAD-SBHL-MISCELLANY", 1, 0, false);
			declareFunction("load_isa_arg2_naut_table", "LOAD-ISA-ARG2-NAUT-TABLE", 1, 0, false);
			declareFunction("load_non_fort_isa_table", "LOAD-NON-FORT-ISA-TABLE", 1, 0, false);
			declareFunction("load_non_fort_instance_table", "LOAD-NON-FORT-INSTANCE-TABLE", 1, 0, false);
			declareFunction("dump_sbhl_cache", "DUMP-SBHL-CACHE", 1, 0, false);
			declareFunction("load_sbhl_cache", "LOAD-SBHL-CACHE", 1, 0, false);
			declareFunction("rebuild_sbhl_cache", "REBUILD-SBHL-CACHE", 0, 0, false);
			declareFunction("dump_cardinality_estimates", "DUMP-CARDINALITY-ESTIMATES", 1, 0, false);
			declareFunction("load_cardinality_estimates", "LOAD-CARDINALITY-ESTIMATES", 1, 0, false);
			declareMacro("not_computing_arg_type_cache", "NOT-COMPUTING-ARG-TYPE-CACHE");
			declareFunction("dump_arg_type_cache", "DUMP-ARG-TYPE-CACHE", 1, 0, false);
			declareFunction("load_arg_type_cache", "LOAD-ARG-TYPE-CACHE", 1, 0, false);
			declareFunction("rebuild_arg_type_cache", "REBUILD-ARG-TYPE-CACHE", 0, 0, false);
			declareFunction("dump_defns_cache", "DUMP-DEFNS-CACHE", 1, 0, false);
			declareFunction("load_defns_cache", "LOAD-DEFNS-CACHE", 1, 0, false);
			declareFunction("dump_rule_connectivity_graph", "DUMP-RULE-CONNECTIVITY-GRAPH", 1, 0, false);
			declareFunction("load_rule_connectivity_graph", "LOAD-RULE-CONNECTIVITY-GRAPH", 1, 0, false);
			declareFunction("dump_tva_cache", "DUMP-TVA-CACHE", 1, 0, false);
			declareFunction("load_tva_cache", "LOAD-TVA-CACHE", 1, 0, false);
			declareFunction("dump_reformulator_rules", "DUMP-REFORMULATOR-RULES", 1, 0, false);
			declareFunction("load_reformulator_rules", "LOAD-REFORMULATOR-RULES", 1, 0, false);
			declareFunction("dump_english_units_of_measure", "DUMP-ENGLISH-UNITS-OF-MEASURE", 1, 0, false);
			declareFunction("load_english_units_of_measure", "LOAD-ENGLISH-UNITS-OF-MEASURE", 1, 0, false);
			declareFunction("dump_cae_query_search_tables", "DUMP-CAE-QUERY-SEARCH-TABLES", 1, 0, false);
			declareFunction("load_cae_query_search_tables", "LOAD-CAE-QUERY-SEARCH-TABLES", 1, 0, false);
			declareFunction("dump_sbhl_time_state", "DUMP-SBHL-TIME-STATE", 1, 0, false);
			declareFunction("load_sbhl_time_state", "LOAD-SBHL-TIME-STATE", 1, 0, false);
			declareFunction("rebuild_sbhl_time_data", "REBUILD-SBHL-TIME-DATA", 0, 0, false);
			declareFunction("dump_rtp_rules_cache", "DUMP-RTP-RULES-CACHE", 1, 0, false);
			declareFunction("load_rtp_rules_cache", "LOAD-RTP-RULES-CACHE", 1, 0, false);
			declareFunction("dump_somewhere_cache", "DUMP-SOMEWHERE-CACHE", 1, 0, false);
			declareFunction("load_somewhere_cache", "LOAD-SOMEWHERE-CACHE", 1, 0, false);
			declareFunction("dump_arity_cache", "DUMP-ARITY-CACHE", 1, 0, false);
			declareFunction("load_arity_cache", "LOAD-ARITY-CACHE", 1, 0, false);
			declareFunction("dump_pph_phrase_shells", "DUMP-PPH-PHRASE-SHELLS", 1, 0, false);
			declareFunction("load_pph_phrase_shells", "LOAD-PPH-PHRASE-SHELLS", 1, 0, false);
			declareFunction("load_pph_phrase_count", "LOAD-PPH-PHRASE-COUNT", 1, 0, false);
			declareFunction("dump_pph_phrase_shell", "DUMP-PPH-PHRASE-SHELL", 2, 0, false);
			declareFunction("load_pph_phrase_shell", "LOAD-PPH-PHRASE-SHELL", 2, 0, false);
			declareFunction("dump_pph_phrase_defs", "DUMP-PPH-PHRASE-DEFS", 1, 0, false);
			declareFunction("load_pph_phrase_defs", "LOAD-PPH-PHRASE-DEFS", 1, 0, false);
			declareFunction("dump_pph_phrase_def", "DUMP-PPH-PHRASE-DEF", 2, 0, false);
			declareFunction("load_pph_phrase_def", "LOAD-PPH-PHRASE-DEF", 2, 0, false);
			declareFunction("dump_gen_template_store", "DUMP-GEN-TEMPLATE-STORE", 1, 0, false);
			declareFunction("load_gen_template_store", "LOAD-GEN-TEMPLATE-STORE", 1, 0, false);
			declareFunction("dump_pph_name_string_preds", "DUMP-PPH-NAME-STRING-PREDS", 1, 0, false);
			declareFunction("dump_pph_phrase_fns", "DUMP-PPH-PHRASE-FNS", 1, 0, false);
			declareFunction("load_pph_phrase_fns", "LOAD-PPH-PHRASE-FNS", 1, 0, false);
			declareFunction("dump_paraphrase_cycl_caches", "DUMP-PARAPHRASE-CYCL-CACHES", 1, 0, false);
			declareFunction("rebuild_pph_phrases", "REBUILD-PPH-PHRASES", 0, 0, false);
			declareFunction("load_paraphrase_cycl_caches", "LOAD-PARAPHRASE-CYCL-CACHES", 1, 0, false);
			declareFunction("dump_kb_activities", "DUMP-KB-ACTIVITIES", 1, 0, false);
			declareFunction("load_kb_initializations", "LOAD-KB-INITIALIZATIONS", 0, 0, false);
			declareFunction("initialize_kb_features", "INITIALIZE-KB-FEATURES", 0, 0, false);
			declareFunction("show_kb_features", "SHOW-KB-FEATURES", 0, 0, false);
			declareFunction("dump_essential_kb_evaluatable", "DUMP-ESSENTIAL-KB-EVALUATABLE", 0, 1, false);
			declareFunction("load_essential_kb_evaluatable_file", "LOAD-ESSENTIAL-KB-EVALUATABLE-FILE", 9, 0, false);
			declareFunction("load_essential_kb_evaluatable", "LOAD-ESSENTIAL-KB-EVALUATABLE", 1, 7, false);
			declareFunction("rebuild_alexandria_computable_kb", "REBUILD-ALEXANDRIA-COMPUTABLE-KB", 0, 0, false);
			declareFunction("load_alexandria_computable_kb_from_directory",
					"LOAD-ALEXANDRIA-COMPUTABLE-KB-FROM-DIRECTORY", 1, 0, false);
			declareFunction("dump_alexandria_units", "DUMP-ALEXANDRIA-UNITS", 3, 0, false);
			declareFunction("load_rebuild_and_dump_alexandria_computable_kb",
					"LOAD-REBUILD-AND-DUMP-ALEXANDRIA-COMPUTABLE-KB", 3, 0, false);
			declareFunction("rebuild_and_dump_alexandria_computable_kb", "REBUILD-AND-DUMP-ALEXANDRIA-COMPUTABLE-KB", 3,
					0, false);
			declareFunction("count_forms_in_file", "COUNT-FORMS-IN-FILE", 1, 0, false);
			declareFunction("read_and_eval_evaluatable_dump_file", "READ-AND-EVAL-EVALUATABLE-DUMP-FILE", 1, 3, false);
			declareFunction("eval_test_operation", "EVAL-TEST-OPERATION", 1, 0, false);
			declareFunction("read_and_eval_test_file", "READ-AND-EVAL-TEST-FILE", 1, 1, false);
			declareFunction("dump_essential_kb_constants_evaluatable", "DUMP-ESSENTIAL-KB-CONSTANTS-EVALUATABLE", 1, 0,
					false);
			declareFunction("dump_essential_kb_narts_evaluatable", "DUMP-ESSENTIAL-KB-NARTS-EVALUATABLE", 1, 0, false);
			declareFunction("exportable_assertionP", "EXPORTABLE-ASSERTION?", 1, 1, false);
			declareFunction("clear_exportable_mtP", "CLEAR-EXPORTABLE-MT?", 0, 0, false);
			declareFunction("remove_exportable_mtP", "REMOVE-EXPORTABLE-MT?", 1, 0, false);
			declareFunction("exportable_mtP_internal", "EXPORTABLE-MT?-INTERNAL", 1, 0, false);
			declareFunction("exportable_mtP", "EXPORTABLE-MT?", 1, 0, false);
			declareFunction("exportable_deduction_supportsP", "EXPORTABLE-DEDUCTION-SUPPORTS?", 1, 0, false);
			declareFunction("clear_exportable_deduction_supportP", "CLEAR-EXPORTABLE-DEDUCTION-SUPPORT?", 0, 0, false);
			declareFunction("remove_exportable_deduction_supportP", "REMOVE-EXPORTABLE-DEDUCTION-SUPPORT?", 1, 0,
					false);
			declareFunction("exportable_deduction_supportP_internal", "EXPORTABLE-DEDUCTION-SUPPORT?-INTERNAL", 1, 0,
					false);
			declareFunction("exportable_deduction_supportP", "EXPORTABLE-DEDUCTION-SUPPORT?", 1, 0, false);
			declareFunction("clear_exportable_deduction_supported_objectP",
					"CLEAR-EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?", 0, 0, false);
			declareFunction("remove_exportable_deduction_supported_objectP",
					"REMOVE-EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?", 1, 0, false);
			declareFunction("exportable_deduction_supported_objectP_internal",
					"EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?-INTERNAL", 1, 0, false);
			declareFunction("exportable_deduction_supported_objectP", "EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?", 1, 0,
					false);
			declareFunction("exportable_deductionP", "EXPORTABLE-DEDUCTION?", 1, 0, false);
			declareFunction("exportable_kb_hl_supportP", "EXPORTABLE-KB-HL-SUPPORT?", 1, 0, false);
			declareFunction("exportable_hl_supportP", "EXPORTABLE-HL-SUPPORT?", 1, 0, false);
			declareFunction("clear_evaluatable_export_caches", "CLEAR-EVALUATABLE-EXPORT-CACHES", 0, 0, false);
			declareFunction("dump_essential_kb_assertions_evaluatable", "DUMP-ESSENTIAL-KB-ASSERTIONS-EVALUATABLE", 1,
					0, false);
			declareFunction("dump_essential_kb_kb_hl_supports_evaluatable",
					"DUMP-ESSENTIAL-KB-KB-HL-SUPPORTS-EVALUATABLE", 2, 0, false);
			declareFunction("dump_essential_kb_deductions_evaluatable_in_parts",
					"DUMP-ESSENTIAL-KB-DEDUCTIONS-EVALUATABLE-IN-PARTS", 3, 0, false);
			declareFunction("dump_essential_kb_deductions_evaluatable", "DUMP-ESSENTIAL-KB-DEDUCTIONS-EVALUATABLE", 1,
					2, false);
			declareFunction("dump_essential_kb_bookkeeping_gafs_evaluatable",
					"DUMP-ESSENTIAL-KB-BOOKKEEPING-GAFS-EVALUATABLE", 1, 0, false);
			declareFunction("nart_depth_internal", "NART-DEPTH-INTERNAL", 1, 1, false);
			declareFunction("nart_depth", "NART-DEPTH", 1, 0, false);
			declareFunction("kb_hl_support_depth_internal", "KB-HL-SUPPORT-DEPTH-INTERNAL", 1, 1, false);
			declareFunction("kb_hl_support_depth", "KB-HL-SUPPORT-DEPTH", 1, 0, false);
			declareFunction("test_that_all_narts_are_findable", "TEST-THAT-ALL-NARTS-ARE-FINDABLE", 0, 1, false);
			declareFunction("test_that_all_assertions_are_findable", "TEST-THAT-ALL-ASSERTIONS-ARE-FINDABLE", 0, 0,
					false);
			declareFunction("test_that_all_deductions_are_findable", "TEST-THAT-ALL-DEDUCTIONS-ARE-FINDABLE", 0, 0,
					false);
			declareFunction("fix_bad_narts", "FIX-BAD-NARTS", 0, 0, false);
			declareFunction("fix_bad_nart", "FIX-BAD-NART", 1, 0, false);
			declareFunction("get_robust_nart_removal_form", "GET-ROBUST-NART-REMOVAL-FORM", 1, 0, false);
			declareFunction("get_robust_assertion_removal_form", "GET-ROBUST-ASSERTION-REMOVAL-FORM", 1, 0, false);
			declareFunction("fix_bad_assertion", "FIX-BAD-ASSERTION", 1, 1, false);
			declareFunction("find_assertion_with_kb_hl_support_deduction_dependent",
					"FIND-ASSERTION-WITH-KB-HL-SUPPORT-DEDUCTION-DEPENDENT", 0, 0, false);
			declareFunction("find_complex_cnf", "FIND-COMPLEX-CNF", 0, 0, false);
		}
		if (SubLFiles.USE_V2) {
			declareFunction("rebuild_computable_content_dumpable", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE", 0, 0, false);
			declareFunction("dump_computable_remaining_hl", "DUMP-COMPUTABLE-REMAINING-HL", 1, 0, false);
			declareFunction("rebuild_computable_remaining_hl", "REBUILD-COMPUTABLE-REMAINING-HL", 0, 0, false);
			declareFunction("rebuild_computable_remaining_hl_low", "REBUILD-COMPUTABLE-REMAINING-HL-LOW", 0, 0, false);
			declareFunction("rebuild_computable_remaining_hl_high", "REBUILD-COMPUTABLE-REMAINING-HL-HIGH", 0, 0,
					false);
			declareFunction("load_special_objects", "LOAD-SPECIAL-OBJECTS", 1, 0, false);
			declareFunction("initialize_nart_shells", "INITIALIZE-NART-SHELLS", 1, 0, false);
			declareFunction("initialize_assertion_shells", "INITIALIZE-ASSERTION-SHELLS", 1, 0, false);
			declareFunction("initialize_kb_hl_support_shells", "INITIALIZE-KB-HL-SUPPORT-SHELLS", 1, 0, false);
			declareFunction("load_kb_unrepresented_term", "LOAD-KB-UNREPRESENTED-TERM", 2, 0, false);
			declareFunction("dump_experience", "DUMP-EXPERIENCE", 1, 0, false);
			declareFunction("dump_non_wff_store", "DUMP-NON-WFF-STORE", 1, 0, false);
			declareFunction("load_non_wff_store", "LOAD-NON-WFF-STORE", 1, 0, false);
			declareFunction("dump_constant_index", "DUMP-CONSTANT-INDEX", 2, 0, false);
			declareFunction("dump_nart_index", "DUMP-NART-INDEX", 2, 0, false);
			declareFunction("dump_unrepresented_term_index", "DUMP-UNREPRESENTED-TERM-INDEX", 2, 0, false);
			declareFunction("old_dump_sbhl_data", "OLD-DUMP-SBHL-DATA", 1, 0, false);
			declareFunction("generate_kb_dump_reports", "GENERATE-KB-DUMP-REPORTS", 0, 2, false);
			declareFunction("generate_stale_documentation_report", "GENERATE-STALE-DOCUMENTATION-REPORT", 0, 1, false);
			declareFunction("generate_stale_documentation_report_to_file",
					"GENERATE-STALE-DOCUMENTATION-REPORT-TO-FILE", 1, 0, false);
			declareFunction("preds_of_strings", "PREDS-OF-STRINGS", 0, 0, false);
			declareFunction("binary_preds_with_arg_isa", "BINARY-PREDS-WITH-ARG-ISA", 1, 0, false);
			declareFunction("invalid_constant_in_string_assertions", "INVALID-CONSTANT-IN-STRING-ASSERTIONS", 0, 0,
					false);
			declareFunction("invalid_constant_in_string_assertionP", "INVALID-CONSTANT-IN-STRING-ASSERTION?", 1, 0,
					false);
			declareFunction("invalid_doc_stringP", "INVALID-DOC-STRING?", 1, 0, false);
			declareFunction("mal_constant_referencesP", "MAL-CONSTANT-REFERENCES?", 1, 0, false);
			declareFunction("mal_constant_references", "MAL-CONSTANT-REFERENCES", 1, 0, false);
			declareFunction("report_stale_documentation_references_to_stream",
					"REPORT-STALE-DOCUMENTATION-REFERENCES-TO-STREAM", 1, 0, false);
			declareFunction("report_recent_renames_to_stream", "REPORT-RECENT-RENAMES-TO-STREAM", 1, 0, false);
		}
		return NIL;
	}

	public static SubLObject declare_dumper_file_Previous() {
		declareFunction("force_monolithic_kb_assumptionP", "FORCE-MONOLITHIC-KB-ASSUMPTION?", 0, 0, false);
		declareMacro("with_kb_dump_ids", "WITH-KB-DUMP-IDS");
		declareMacro("with_kb_load_ids", "WITH-KB-LOAD-IDS");
		declareMacro("with_kb_load_area_allocation", "WITH-KB-LOAD-AREA-ALLOCATION");
		declareMacro("without_kb_load_area_allocation", "WITHOUT-KB-LOAD-AREA-ALLOCATION");
		declareMacro("with_kb_dump_filename", "WITH-KB-DUMP-FILENAME");
		declareMacro("with_kb_dump_binary_file", "WITH-KB-DUMP-BINARY-FILE");
		declareMacro("with_kb_dump_text_file", "WITH-KB-DUMP-TEXT-FILE");
		declareFunction("discard_dump_filename", "DISCARD-DUMP-FILENAME", 1, 0, false);
		declareMacro("with_pergamom_style_units", "WITH-PERGAMOM-STYLE-UNITS");
		declareMacro("with_kelsos_style_units", "WITH-KELSOS-STYLE-UNITS");
		declareFunction("kb_dump_directory", "KB-DUMP-DIRECTORY", 0, 2, false);
		declareFunction("get_wide_mark_basename_from_index_basename", "GET-WIDE-MARK-BASENAME-FROM-INDEX-BASENAME", 1,
				0, false);
		declareFunction("kb_dump_file", "KB-DUMP-FILE", 2, 1, false);
		declareFunction("kb_dump_product_file", "KB-DUMP-PRODUCT-FILE", 2, 1, false);
		declareFunction("dump_estimated_size", "DUMP-ESTIMATED-SIZE", 0, 1, false);
		declareFunction("verify_file_existence", "VERIFY-FILE-EXISTENCE", 1, 1, false);
		declareFunction("validate_dump_directory", "VALIDATE-DUMP-DIRECTORY", 1, 0, false);
		declareFunction("kb_load_gc_checkpoint", "KB-LOAD-GC-CHECKPOINT", 0, 0, false);
		declareFunction("preprocess_experience_and_dump_standard_kb", "PREPROCESS-EXPERIENCE-AND-DUMP-STANDARD-KB", 0,
				3, false);
		declareFunction("dump_standard_kb", "DUMP-STANDARD-KB", 0, 1, false);
		declareFunction("perform_standard_pre_dump_kb_cleanups", "PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS", 0, 0, false);
		declareFunction("perform_standard_pre_dump_kb_cleanups_complete",
				"PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-COMPLETE", 0, 0, false);
		declareFunction("perform_standard_pre_dump_kb_cleanups_partial",
				"PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-PARTIAL", 0, 0, false);
		declareFunction("perform_kb_cleanups", "PERFORM-KB-CLEANUPS", 0, 0, false);
		declareFunction("preprocess_experience", "PREPROCESS-EXPERIENCE", 0, 2, false);
		declareFunction("preprocess_experience_and_dump_non_computable_kb",
				"PREPROCESS-EXPERIENCE-AND-DUMP-NON-COMPUTABLE-KB", 0, 3, false);
		declareFunction("dump_non_computable_kb", "DUMP-NON-COMPUTABLE-KB", 1, 0, false);
		declareFunction("load_non_computable_kb_and_rebuild_computable_kb_and_write_image",
				"LOAD-NON-COMPUTABLE-KB-AND-REBUILD-COMPUTABLE-KB-AND-WRITE-IMAGE", 3, 0, false);
		declareFunction("load_non_computable_kb", "LOAD-NON-COMPUTABLE-KB", 1, 0, false);
		declareFunction("load_non_computable_kb_and_rebuild_computable_kb",
				"LOAD-NON-COMPUTABLE-KB-AND-REBUILD-COMPUTABLE-KB", 2, 0, false);
		declareFunction("dump_computable_kb_and_content", "DUMP-COMPUTABLE-KB-AND-CONTENT", 2, 0, false);
		declareFunction("load_non_computable_kb_plus_rebuild_and_dump_computable_kb",
				"LOAD-NON-COMPUTABLE-KB-PLUS-REBUILD-AND-DUMP-COMPUTABLE-KB", 2, 1, false);
		declareFunction("rebuild_and_reconnect_computable_kb", "REBUILD-AND-RECONNECT-COMPUTABLE-KB", 2, 0, false);
		declareFunction("rebuild_and_reconnect_kb_indexing", "REBUILD-AND-RECONNECT-KB-INDEXING", 0, 0, false);
		declareFunction("rebuild_assertion_indexing_for_reconnect", "REBUILD-ASSERTION-INDEXING-FOR-RECONNECT", 0, 0,
				false);
		declareFunction("rebuild_and_dump_assertion_indexing", "REBUILD-AND-DUMP-ASSERTION-INDEXING", 0, 0, false);
		declareFunction("merge_and_redump_assertion_indexing", "MERGE-AND-REDUMP-ASSERTION-INDEXING", 1, 0, false);
		declareFunction("merge_and_redump_constant_assertion_indexing", "MERGE-AND-REDUMP-CONSTANT-ASSERTION-INDEXING",
				1, 0, false);
		declareFunction("merge_and_redump_nart_assertion_indexing", "MERGE-AND-REDUMP-NART-ASSERTION-INDEXING", 1, 0,
				false);
		declareFunction("merge_and_redump_unrepresented_term_assertion_indexing",
				"MERGE-AND-REDUMP-UNREPRESENTED-TERM-ASSERTION-INDEXING", 1, 0, false);
		declareFunction("merge_index_from_partial_results", "MERGE-INDEX-FROM-PARTIAL-RESULTS", 5, 1, false);
		declareFunction("compute_rebuild_part_dirs", "COMPUTE-REBUILD-PART-DIRS", 1, 0, false);
		declareFunction("cleanup_rebuild_part_dirs", "CLEANUP-REBUILD-PART-DIRS", 1, 0, false);
		declareFunction("cyc_dump_kb", "CYC-DUMP-KB", 2, 1, false);
		declareFunction("cyc_dump_kb_unsafe", "CYC-DUMP-KB-UNSAFE", 2, 1, false);
		declareFunction("cyc_dump_kb_int", "CYC-DUMP-KB-INT", 2, 1, false);
		declareMacro("with_timed_kb_store_operation", "WITH-TIMED-KB-STORE-OPERATION");
		declareFunction("dump_kb", "DUMP-KB", 0, 1, false);
		declareFunction("load_kb", "LOAD-KB", 1, 0, false);
		declareFunction("minimal_tombstoning_modeP", "MINIMAL-TOMBSTONING-MODE?", 0, 0, false);
		declareFunction("medium_tombstoning_modeP", "MEDIUM-TOMBSTONING-MODE?", 0, 0, false);
		declareFunction("maximal_tombstoning_modeP", "MAXIMAL-TOMBSTONING-MODE?", 0, 0, false);
		declareFunction("snapshot_kb", "SNAPSHOT-KB", 1, 2, false);
		declareFunction("ensure_valid_dump_directory", "ENSURE-VALID-DUMP-DIRECTORY", 1, 0, false);
		declareFunction("possibly_note_transcript_operations_processed",
				"POSSIBLY-NOTE-TRANSCRIPT-OPERATIONS-PROCESSED", 0, 0, false);
		declareFunction("kb_manifest", "KB-MANIFEST", 0, 0, false);
		declareFunction("kb_possibly_load_manifest_from_directory", "KB-POSSIBLY-LOAD-MANIFEST-FROM-DIRECTORY", 1, 0,
				false);
		declareFunction("kb_load_manifest_from_directory", "KB-LOAD-MANIFEST-FROM-DIRECTORY", 1, 0, false);
		declareFunction("describe_knowledge_fvector_files", "DESCRIBE-KNOWLEDGE-FVECTOR-FILES", 1, 0, false);
		declareFunction("describe_index_fvector_files", "DESCRIBE-INDEX-FVECTOR-FILES", 1, 0, false);
		declareFunction("get_kb_units_file_vector_descriptions", "GET-KB-UNITS-FILE-VECTOR-DESCRIPTIONS", 0, 0, false);
		declareFunction("get_kb_units_file_vector_categories", "GET-KB-UNITS-FILE-VECTOR-CATEGORIES", 0, 0, false);
		declareFunction("kb_dump_to_directory", "KB-DUMP-TO-DIRECTORY", 1, 0, false);
		declareFunction("kb_snapshot_to_directory", "KB-SNAPSHOT-TO-DIRECTORY", 2, 0, false);
		declareFunction("kb_load_from_directory", "KB-LOAD-FROM-DIRECTORY", 1, 0, false);
		declareFunction("dump_kb_ids", "DUMP-KB-IDS", 1, 0, false);
		declareFunction("dump_essential_kb", "DUMP-ESSENTIAL-KB", 1, 0, false);
		declareFunction("snapshot_essential_kb", "SNAPSHOT-ESSENTIAL-KB", 2, 0, false);
		declareFunction("load_essential_kb", "LOAD-ESSENTIAL-KB", 1, 0, false);
		declareFunction("load_essential_kb_initializations", "LOAD-ESSENTIAL-KB-INITIALIZATIONS", 0, 0, false);
		declareFunction("load_computable_kb_initializations", "LOAD-COMPUTABLE-KB-INITIALIZATIONS", 0, 0, false);
		declareFunction("load_computable_remaining_hl_low_initializations",
				"LOAD-COMPUTABLE-REMAINING-HL-LOW-INITIALIZATIONS", 0, 0, false);
		declareFunction("dump_computable_content", "DUMP-COMPUTABLE-CONTENT", 1, 0, false);
		declareFunction("load_computable_content", "LOAD-COMPUTABLE-CONTENT", 1, 0, false);
		declareFunction("rebuild_computable_content", "REBUILD-COMPUTABLE-CONTENT", 0, 0, false);
		declareFunction("rebuild_computable_content_dumpable", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE", 0, 1, false);
		declareFunction("rebuild_computable_content_dumpable_low", "REBUILD-COMPUTABLE-CONTENT-DUMPABLE-LOW", 0, 0,
				false);
		declareFunction("dump_computable_kb", "DUMP-COMPUTABLE-KB", 1, 0, false);
		declareFunction("snapshot_computable_kb", "SNAPSHOT-COMPUTABLE-KB", 2, 0, false);
		declareFunction("load_computable_kb", "LOAD-COMPUTABLE-KB", 1, 0, false);
		declareFunction("rebuild_computable_kb", "REBUILD-COMPUTABLE-KB", 0, 0, false);
		declareFunction("dump_computable_remaining_hl", "DUMP-COMPUTABLE-REMAINING-HL", 1, 1, false);
		declareFunction("dump_computable_remaining_hl_shared", "DUMP-COMPUTABLE-REMAINING-HL-SHARED", 1, 1, false);
		declareFunction("snapshot_computable_remaining_hl", "SNAPSHOT-COMPUTABLE-REMAINING-HL", 1, 1, false);
		declareFunction("load_computable_remaining_hl", "LOAD-COMPUTABLE-REMAINING-HL", 1, 0, false);
		declareFunction("rebuild_computable_remaining_hl", "REBUILD-COMPUTABLE-REMAINING-HL", 0, 1, false);
		declareFunction("rebuild_computable_remaining_hl_low", "REBUILD-COMPUTABLE-REMAINING-HL-LOW", 0, 1, false);
		declareFunction("rebuild_computable_remaining_hl_high", "REBUILD-COMPUTABLE-REMAINING-HL-HIGH", 0, 1, false);
		declareFunction("rebuild_computable_but_not_dumpable_yet", "REBUILD-COMPUTABLE-BUT-NOT-DUMPABLE-YET", 0, 0,
				false);
		declareFunction("dump_copyright", "DUMP-COPYRIGHT", 1, 0, false);
		declareFunction("kb_dump_stamp_file_vector_for_references", "KB-DUMP-STAMP-FILE-VECTOR-FOR-REFERENCES", 1, 0,
				false);
		declareFunction("load_copyright", "LOAD-COPYRIGHT", 1, 0, false);
		declareFunction("load_unit_file", "LOAD-UNIT-FILE", 4, 0, false);
		declareFunction("dump_kb_object_count", "DUMP-KB-OBJECT-COUNT", 3, 0, false);
		declareFunction("load_kb_object_count", "LOAD-KB-OBJECT-COUNT", 2, 0, false);
		declareFunction("snapshot_kb_object_deleted_id_set", "SNAPSHOT-KB-OBJECT-DELETED-ID-SET", 3, 1, false);
		declareFunction("load_kb_object_deleted_id_set", "LOAD-KB-OBJECT-DELETED-ID-SET", 2, 0, false);
		declareFunction("snapshot_changed_managed_objects", "SNAPSHOT-CHANGED-MANAGED-OBJECTS", 6, 0, false);
		declareFunction("snapshot_new_managed_objects", "SNAPSHOT-NEW-MANAGED-OBJECTS", 6, 1, false);
		declareFunction("snapshot_managed_object_simple_complex_index", "SNAPSHOT-MANAGED-OBJECT-SIMPLE-COMPLEX-INDEX",
				4, 0, false);
		declareFunction("snapshot_managed_object_simple_index", "SNAPSHOT-MANAGED-OBJECT-SIMPLE-INDEX", 4, 0, false);
		declareFunction("snapshot_deleted_object_tombstones", "SNAPSHOT-DELETED-OBJECT-TOMBSTONES", 3, 0, false);
		declareFunction("replicate_fv_dump_files", "REPLICATE-FV-DUMP-FILES", 7, 0, false);
		declareFunction("replicate_one_dump_file", "REPLICATE-ONE-DUMP-FILE", 3, 1, false);
		declareFunction("replicate_one_index_file", "REPLICATE-ONE-INDEX-FILE", 5, 0, false);
		declareFunction("kb_dump_default_common_symbols", "KB-DUMP-DEFAULT-COMMON-SYMBOLS", 0, 0, false);
		declareFunction("kb_dump_common_symbols", "KB-DUMP-COMMON-SYMBOLS", 0, 0, false);
		declareFunction("dump_special_objects", "DUMP-SPECIAL-OBJECTS", 1, 0, false);
		declareFunction("dump_special_objects_internal", "DUMP-SPECIAL-OBJECTS-INTERNAL", 2, 0, false);
		declareFunction("load_special_objects", "LOAD-SPECIAL-OBJECTS", 1, 1, false);
		declareFunction("load_kb_product_shared_symbols", "LOAD-KB-PRODUCT-SHARED-SYMBOLS", 1, 0, false);
		declareFunction("setup_kb_state_from_dump", "SETUP-KB-STATE-FROM-DUMP", 1, 0, false);
		declareFunction("get_exclusive_constant_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-CONSTANT-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_constant_shells", "DUMP-CONSTANT-SHELLS", 1, 0, false);
		declareFunction("dump_constant_shells_int", "DUMP-CONSTANT-SHELLS-INT", 1, 0, false);
		declareFunction("snapshot_constant_shells", "SNAPSHOT-CONSTANT-SHELLS", 1, 0, false);
		declareFunction("snapshot_deleted_constant_set", "SNAPSHOT-DELETED-CONSTANT-SET", 1, 0, false);
		declareFunction("has_deleted_constant_id_setP", "HAS-DELETED-CONSTANT-ID-SET?", 1, 0, false);
		declareFunction("load_constant_count", "LOAD-CONSTANT-COUNT", 1, 0, false);
		declareFunction("load_constant_shells", "LOAD-CONSTANT-SHELLS", 1, 0, false);
		declareFunction("debug_map_constant_shell_file_position_to_constant_id",
				"DEBUG-MAP-CONSTANT-SHELL-FILE-POSITION-TO-CONSTANT-ID", 2, 0, false);
		declareFunction("dump_constant_shell", "DUMP-CONSTANT-SHELL", 2, 0, false);
		declareFunction("dump_constant_shell_internal", "DUMP-CONSTANT-SHELL-INTERNAL", 4, 0, false);
		declareFunction("load_constant_shell", "LOAD-CONSTANT-SHELL", 2, 0, false);
		declareFunction("load_constant_shell_internal", "LOAD-CONSTANT-SHELL-INTERNAL", 3, 0, false);
		declareFunction("generate_constant_shell_file", "GENERATE-CONSTANT-SHELL-FILE", 1, 0, false);
		declareFunction("get_exclusive_nart_internal_id_limit_for_kb", "GET-EXCLUSIVE-NART-INTERNAL-ID-LIMIT-FOR-KB", 1,
				0, false);
		declareFunction("dump_nart_count", "DUMP-NART-COUNT", 1, 0, false);
		declareFunction("snapshot_nart_count", "SNAPSHOT-NART-COUNT", 1, 0, false);
		declareFunction("snapshot_deleted_nart_id_set", "SNAPSHOT-DELETED-NART-ID-SET", 1, 0, false);
		declareFunction("load_nart_shells", "LOAD-NART-SHELLS", 1, 0, false);
		declareFunction("load_nart_count", "LOAD-NART-COUNT", 1, 0, false);
		declareFunction("load_deleted_nart_id_set", "LOAD-DELETED-NART-ID-SET", 1, 0, false);
		declareFunction("has_deleted_nart_id_setP", "HAS-DELETED-NART-ID-SET?", 1, 0, false);
		declareFunction("initialize_nart_shells", "INITIALIZE-NART-SHELLS", 2, 0, false);
		declareFunction("load_nart_shells_legacy", "LOAD-NART-SHELLS-LEGACY", 1, 0, false);
		declareFunction("dump_nart_shell", "DUMP-NART-SHELL", 2, 0, false);
		declareFunction("load_nart_shell", "LOAD-NART-SHELL", 2, 0, false);
		declareFunction("get_exclusive_assertion_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-ASSERTION-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_assertion_count", "DUMP-ASSERTION-COUNT", 1, 0, false);
		declareFunction("snapshot_assertion_count", "SNAPSHOT-ASSERTION-COUNT", 1, 0, false);
		declareFunction("snapshot_deleted_assertion_id_set", "SNAPSHOT-DELETED-ASSERTION-ID-SET", 1, 0, false);
		declareFunction("load_assertion_shells", "LOAD-ASSERTION-SHELLS", 1, 0, false);
		declareFunction("load_assertion_count", "LOAD-ASSERTION-COUNT", 1, 0, false);
		declareFunction("load_deleted_assertion_id_set", "LOAD-DELETED-ASSERTION-ID-SET", 1, 0, false);
		declareFunction("has_deleted_assertion_id_setP", "HAS-DELETED-ASSERTION-ID-SET?", 1, 0, false);
		declareFunction("initialize_assertion_shells", "INITIALIZE-ASSERTION-SHELLS", 2, 0, false);
		declareFunction("load_assertion_shells_legacy", "LOAD-ASSERTION-SHELLS-LEGACY", 1, 0, false);
		declareFunction("dump_assertion_shell", "DUMP-ASSERTION-SHELL", 2, 0, false);
		declareFunction("load_assertion_shell", "LOAD-ASSERTION-SHELL", 2, 0, false);
		declareFunction("get_exclusive_kb_hl_support_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-KB-HL-SUPPORT-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_kb_hl_support_count", "DUMP-KB-HL-SUPPORT-COUNT", 1, 0, false);
		declareFunction("snapshot_kb_hl_support_count", "SNAPSHOT-KB-HL-SUPPORT-COUNT", 1, 0, false);
		declareFunction("snapshot_deleted_kb_hl_support_id_set", "SNAPSHOT-DELETED-KB-HL-SUPPORT-ID-SET", 1, 0, false);
		declareFunction("load_kb_hl_support_shells", "LOAD-KB-HL-SUPPORT-SHELLS", 1, 0, false);
		declareFunction("load_kb_hl_support_count", "LOAD-KB-HL-SUPPORT-COUNT", 1, 0, false);
		declareFunction("load_deleted_kb_hl_support_id_set", "LOAD-DELETED-KB-HL-SUPPORT-ID-SET", 1, 0, false);
		declareFunction("has_deleted_kb_hl_support_id_setP", "HAS-DELETED-KB-HL-SUPPORT-ID-SET?", 1, 0, false);
		declareFunction("initialize_kb_hl_support_shells", "INITIALIZE-KB-HL-SUPPORT-SHELLS", 2, 0, false);
		declareFunction("load_kb_hl_support_shells_legacy", "LOAD-KB-HL-SUPPORT-SHELLS-LEGACY", 1, 0, false);
		declareFunction("dump_kb_hl_support_shell", "DUMP-KB-HL-SUPPORT-SHELL", 2, 0, false);
		declareFunction("load_kb_hl_support_shell", "LOAD-KB-HL-SUPPORT-SHELL", 2, 0, false);
		declareFunction("get_exclusive_kb_unrepresented_term_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-KB-UNREPRESENTED-TERM-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_kb_unrepresented_terms", "DUMP-KB-UNREPRESENTED-TERMS", 1, 0, false);
		declareFunction("dump_kb_unrepresented_terms_int", "DUMP-KB-UNREPRESENTED-TERMS-INT", 1, 0, false);
		declareFunction("snapshot_kb_unrepresented_terms", "SNAPSHOT-KB-UNREPRESENTED-TERMS", 2, 0, false);
		declareFunction("load_kb_unrepresented_terms", "LOAD-KB-UNREPRESENTED-TERMS", 1, 0, false);
		declareFunction("dump_kb_unrepresented_term", "DUMP-KB-UNREPRESENTED-TERM", 2, 0, false);
		declareFunction("load_kb_unrepresented_term", "LOAD-KB-UNREPRESENTED-TERM", 4, 0, false);
		declareFunction("load_kb_unrepresented_term_count", "LOAD-KB-UNREPRESENTED-TERM-COUNT", 1, 0, false);
		declareFunction("get_exclusive_clause_struc_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-CLAUSE-STRUC-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("dump_clause_struc_defs", "DUMP-CLAUSE-STRUC-DEFS", 1, 0, false);
		declareFunction("dump_clause_struc_defs_internal", "DUMP-CLAUSE-STRUC-DEFS-INTERNAL", 1, 0, false);
		declareFunction("snapshot_deleted_clause_struc_id_set", "SNAPSHOT-DELETED-CLAUSE-STRUC-ID-SET", 2, 0, false);
		declareFunction("snapshot_clause_struc_defs", "SNAPSHOT-CLAUSE-STRUC-DEFS", 1, 0, false);
		declareFunction("load_deleted_clause_struc_id_set", "LOAD-DELETED-CLAUSE-STRUC-ID-SET", 1, 0, false);
		declareFunction("has_deleted_clause_struc_id_setP", "HAS-DELETED-CLAUSE-STRUC-ID-SET?", 1, 0, false);
		declareFunction("load_clause_struc_defs", "LOAD-CLAUSE-STRUC-DEFS", 1, 0, false);
		declareFunction("dump_clause_struc_def", "DUMP-CLAUSE-STRUC-DEF", 2, 0, false);
		declareFunction("load_clause_struc_def", "LOAD-CLAUSE-STRUC-DEF", 2, 0, false);
		declareFunction("load_clause_struc_count", "LOAD-CLAUSE-STRUC-COUNT", 1, 0, false);
		declareFunction("possibly_persist_wide_fvector_mark", "POSSIBLY-PERSIST-WIDE-FVECTOR-MARK", 4, 0, false);
		declareFunction("get_exclusive_deduction_internal_id_limit_for_kb",
				"GET-EXCLUSIVE-DEDUCTION-INTERNAL-ID-LIMIT-FOR-KB", 1, 0, false);
		declareFunction("snapshot_deduction_count", "SNAPSHOT-DEDUCTION-COUNT", 1, 0, false);
		declareFunction("dump_deduction_defs", "DUMP-DEDUCTION-DEFS", 1, 0, false);
		declareFunction("snapshot_deduction_defs", "SNAPSHOT-DEDUCTION-DEFS", 2, 0, false);
		declareFunction("snapshot_deduction_defs_internal", "SNAPSHOT-DEDUCTION-DEFS-INTERNAL", 2, 1, false);
		declareFunction("load_deduction_defs", "LOAD-DEDUCTION-DEFS", 1, 0, false);
		declareFunction("dump_deduction_def", "DUMP-DEDUCTION-DEF", 2, 0, false);
		declareFunction("snapshot_deleted_deduction_id_set", "SNAPSHOT-DELETED-DEDUCTION-ID-SET", 1, 0, false);
		declareFunction("load_deduction_def", "LOAD-DEDUCTION-DEF", 2, 0, false);
		declareFunction("load_deduction_def_from_cache", "LOAD-DEDUCTION-DEF-FROM-CACHE", 2, 0, false);
		new dumper.$load_deduction_def_from_cache$BinaryFunction();
		declareFunction("load_deduction_count", "LOAD-DEDUCTION-COUNT", 1, 0, false);
		declareFunction("load_deleted_deduction_id_set", "LOAD-DELETED-DEDUCTION-ID-SET", 1, 0, false);
		declareFunction("has_deleted_deduction_id_setP", "HAS-DELETED-DEDUCTION-ID-SET?", 1, 0, false);
		declareFunction("dump_assertion_defs", "DUMP-ASSERTION-DEFS", 1, 0, false);
		declareFunction("snapshot_assertion_defs", "SNAPSHOT-ASSERTION-DEFS", 2, 0, false);
		declareFunction("snapshot_assertion_defs_internal", "SNAPSHOT-ASSERTION-DEFS-INTERNAL", 2, 1, false);
		declareFunction("load_assertion_defs", "LOAD-ASSERTION-DEFS", 1, 0, false);
		declareFunction("dump_assertion_def", "DUMP-ASSERTION-DEF", 2, 0, false);
		declareFunction("snapshot_assertion_def", "SNAPSHOT-ASSERTION-DEF", 3, 1, false);
		declareFunction("load_assertion_def", "LOAD-ASSERTION-DEF", 2, 0, false);
		declareFunction("load_assertion_def_from_cache", "LOAD-ASSERTION-DEF-FROM-CACHE", 2, 0, false);
		new dumper.$load_assertion_def_from_cache$BinaryFunction();
		declareFunction("dump_kb_hl_support_defs", "DUMP-KB-HL-SUPPORT-DEFS", 1, 0, false);
		declareFunction("snapshot_kb_hl_support_defs", "SNAPSHOT-KB-HL-SUPPORT-DEFS", 2, 0, false);
		declareFunction("load_kb_hl_support_defs", "LOAD-KB-HL-SUPPORT-DEFS", 1, 0, false);
		declareFunction("dump_kb_hl_support_def", "DUMP-KB-HL-SUPPORT-DEF", 2, 0, false);
		declareFunction("load_kb_hl_support_def", "LOAD-KB-HL-SUPPORT-DEF", 2, 0, false);
		declareFunction("load_kb_hl_support_def_from_cache", "LOAD-KB-HL-SUPPORT-DEF-FROM-CACHE", 2, 0, false);
		declareFunction("dump_kb_hl_support_indexing", "DUMP-KB-HL-SUPPORT-INDEXING", 1, 0, false);
		declareFunction("load_kb_hl_support_indexing", "LOAD-KB-HL-SUPPORT-INDEXING", 1, 0, false);
		declareFunction("dump_bookkeeping_assertions", "DUMP-BOOKKEEPING-ASSERTIONS", 1, 0, false);
		declareFunction("dump_bookkeeping_assertions_for_pred", "DUMP-BOOKKEEPING-ASSERTIONS-FOR-PRED", 3, 0, false);
		declareFunction("dump_bookkeeping_assertion", "DUMP-BOOKKEEPING-ASSERTION", 3, 0, false);
		declareFunction("load_bookkeeping_assertions", "LOAD-BOOKKEEPING-ASSERTIONS", 1, 0, false);
		declareFunction("load_bookkeeping_assertions_for_pred", "LOAD-BOOKKEEPING-ASSERTIONS-FOR-PRED", 1, 0, false);
		declareFunction("load_bookkeeping_assertion", "LOAD-BOOKKEEPING-ASSERTION", 2, 0, false);
		declareFunction("dump_experience", "DUMP-EXPERIENCE", 1, 1, false);
		declareFunction("dump_rule_utility_experience", "DUMP-RULE-UTILITY-EXPERIENCE", 1, 1, false);
		declareFunction("load_experience", "LOAD-EXPERIENCE", 1, 0, false);
		declareFunction("load_rule_utility_experience", "LOAD-RULE-UTILITY-EXPERIENCE", 1, 0, false);
		declareFunction("reload_experience", "RELOAD-EXPERIENCE", 0, 1, false);
		declareFunction("new_niniveh_index_iterator", "NEW-NINIVEH-INDEX-ITERATOR", 2, 0, false);
		declareFunction("construct_niniveh_iterator_state", "CONSTRUCT-NINIVEH-ITERATOR-STATE", 1, 0, false);
		declareFunction("niniveh_index_iterator_doneP", "NINIVEH-INDEX-ITERATOR-DONE?", 1, 0, false);
		declareFunction("niniveh_index_iterator_next", "NINIVEH-INDEX-ITERATOR-NEXT", 1, 0, false);
		declareFunction("niniveh_index_iterator_finalize", "NINIVEH-INDEX-ITERATOR-FINALIZE", 1, 0, false);
		declareFunction("dump_kb_indexing", "DUMP-KB-INDEXING", 1, 0, false);
		declareFunction("snapshot_kb_indexing", "SNAPSHOT-KB-INDEXING", 2, 0, false);
		declareFunction("load_kb_indexing", "LOAD-KB-INDEXING", 1, 0, false);
		declareFunction("load_kb_assertion_indexing", "LOAD-KB-ASSERTION-INDEXING", 1, 0, false);
		declareFunction("rebuild_kb_indexing", "REBUILD-KB-INDEXING", 0, 0, false);
		declareFunction("test_dump_kb_indexing", "TEST-DUMP-KB-INDEXING", 1, 0, false);
		declareFunction("test_load_kb_indexing", "TEST-LOAD-KB-INDEXING", 1, 0, false);
		declareFunction("index_writer_print_function_trampoline", "INDEX-WRITER-PRINT-FUNCTION-TRAMPOLINE", 2, 0,
				false);
		declareFunction("index_writer_p", "INDEX-WRITER-P", 1, 0, false);
		new dumper.$index_writer_p$UnaryFunction();
		declareFunction("idxwriter_directory", "IDXWRITER-DIRECTORY", 1, 0, false);
		declareFunction("idxwriter_fvector", "IDXWRITER-FVECTOR", 1, 0, false);
		declareFunction("idxwriter_index_file", "IDXWRITER-INDEX-FILE", 1, 0, false);
		declareFunction("idxwriter_index_label", "IDXWRITER-INDEX-LABEL", 1, 0, false);
		declareFunction("idxwriter_complex_fvector", "IDXWRITER-COMPLEX-FVECTOR", 1, 0, false);
		declareFunction("idxwriter_complex_index_file", "IDXWRITER-COMPLEX-INDEX-FILE", 1, 0, false);
		declareFunction("idxwriter_complex_index_label", "IDXWRITER-COMPLEX-INDEX-LABEL", 1, 0, false);
		declareFunction("idxwriter_dump_fn", "IDXWRITER-DUMP-FN", 1, 0, false);
		declareFunction("_csetf_idxwriter_directory", "_CSETF-IDXWRITER-DIRECTORY", 2, 0, false);
		declareFunction("_csetf_idxwriter_fvector", "_CSETF-IDXWRITER-FVECTOR", 2, 0, false);
		declareFunction("_csetf_idxwriter_index_file", "_CSETF-IDXWRITER-INDEX-FILE", 2, 0, false);
		declareFunction("_csetf_idxwriter_index_label", "_CSETF-IDXWRITER-INDEX-LABEL", 2, 0, false);
		declareFunction("_csetf_idxwriter_complex_fvector", "_CSETF-IDXWRITER-COMPLEX-FVECTOR", 2, 0, false);
		declareFunction("_csetf_idxwriter_complex_index_file", "_CSETF-IDXWRITER-COMPLEX-INDEX-FILE", 2, 0, false);
		declareFunction("_csetf_idxwriter_complex_index_label", "_CSETF-IDXWRITER-COMPLEX-INDEX-LABEL", 2, 0, false);
		declareFunction("_csetf_idxwriter_dump_fn", "_CSETF-IDXWRITER-DUMP-FN", 2, 0, false);
		declareFunction("make_index_writer", "MAKE-INDEX-WRITER", 0, 1, false);
		declareFunction("visit_defstruct_index_writer", "VISIT-DEFSTRUCT-INDEX-WRITER", 2, 0, false);
		declareFunction("visit_defstruct_object_index_writer_method", "VISIT-DEFSTRUCT-OBJECT-INDEX-WRITER-METHOD", 2,
				0, false);
		declareFunction("new_index_writer", "NEW-INDEX-WRITER", 8, 0, false);
		declareFunction("index_writer_put_index_entry", "INDEX-WRITER-PUT-INDEX-ENTRY", 2, 0, false);
		declareFunction("close_index_writer", "CLOSE-INDEX-WRITER", 1, 0, false);
		declareFunction("new_constant_indices_writer", "NEW-CONSTANT-INDICES-WRITER", 1, 0, false);
		declareFunction("dump_constant_indices", "DUMP-CONSTANT-INDICES", 1, 0, false);
		declareFunction("snapshot_constant_indices", "SNAPSHOT-CONSTANT-INDICES", 2, 0, false);
		declareFunction("snapshot_constant_indices_internal", "SNAPSHOT-CONSTANT-INDICES-INTERNAL", 2, 2, false);
		declareFunction("new_niniveh_constant_indices_iterator", "NEW-NINIVEH-CONSTANT-INDICES-ITERATOR", 1, 0, false);
		declareFunction("load_constant_indices", "LOAD-CONSTANT-INDICES", 1, 0, false);
		declareFunction("dump_constant_index", "DUMP-CONSTANT-INDEX", 3, 0, false);
		declareFunction("dump_top_level_index_of_type", "DUMP-TOP-LEVEL-INDEX-OF-TYPE", 7, 0, false);
		declareFunction("snapshot_constant_index", "SNAPSHOT-CONSTANT-INDEX", 4, 0, false);
		declareFunction("load_constant_index", "LOAD-CONSTANT-INDEX", 2, 0, false);
		declareFunction("load_constant_index_from_cache", "LOAD-CONSTANT-INDEX-FROM-CACHE", 2, 0, false);
		declareFunction("new_nart_indices_writer", "NEW-NART-INDICES-WRITER", 1, 0, false);
		declareFunction("dump_nart_indices", "DUMP-NART-INDICES", 1, 0, false);
		declareFunction("snapshot_nart_indices", "SNAPSHOT-NART-INDICES", 2, 0, false);
		declareFunction("snapshot_nart_indices_internal", "SNAPSHOT-NART-INDICES-INTERNAL", 2, 2, false);
		declareFunction("new_niniveh_nart_indices_iterator", "NEW-NINIVEH-NART-INDICES-ITERATOR", 1, 0, false);
		declareFunction("load_nart_indices", "LOAD-NART-INDICES", 1, 0, false);
		declareFunction("dump_nart_index", "DUMP-NART-INDEX", 3, 0, false);
		declareFunction("snapshot_nart_index", "SNAPSHOT-NART-INDEX", 4, 0, false);
		declareFunction("load_nart_index", "LOAD-NART-INDEX", 2, 0, false);
		declareFunction("load_nart_index_from_cache", "LOAD-NART-INDEX-FROM-CACHE", 2, 0, false);
		declareFunction("new_unrepresented_term_indices_writer", "NEW-UNREPRESENTED-TERM-INDICES-WRITER", 1, 0, false);
		declareFunction("dump_unrepresented_term_indices", "DUMP-UNREPRESENTED-TERM-INDICES", 1, 0, false);
		declareFunction("snapshot_unrepresented_term_indices", "SNAPSHOT-UNREPRESENTED-TERM-INDICES", 2, 0, false);
		declareFunction("snapshot_unrepresented_term_indices_internal", "SNAPSHOT-UNREPRESENTED-TERM-INDICES-INTERNAL",
				2, 2, false);
		declareFunction("new_niniveh_unrepresented_term_indices_iterator",
				"NEW-NINIVEH-UNREPRESENTED-TERM-INDICES-ITERATOR", 1, 0, false);
		declareFunction("load_unrepresented_term_indices", "LOAD-UNREPRESENTED-TERM-INDICES", 1, 0, false);
		declareFunction("dump_unrepresented_term_index", "DUMP-UNREPRESENTED-TERM-INDEX", 3, 0, false);
		declareFunction("snapshot_unrepresented_term_index", "SNAPSHOT-UNREPRESENTED-TERM-INDEX", 4, 0, false);
		declareFunction("load_unrepresented_term_index", "LOAD-UNREPRESENTED-TERM-INDEX", 2, 0, false);
		declareFunction("load_unrepresented_term_index_from_cache", "LOAD-UNREPRESENTED-TERM-INDEX-FROM-CACHE", 2, 0,
				false);
		declareFunction("dump_assertion_indices", "DUMP-ASSERTION-INDICES", 1, 0, false);
		declareFunction("load_assertion_indices", "LOAD-ASSERTION-INDICES", 1, 0, false);
		declareFunction("replicate_meta_assertion_indexing", "REPLICATE-META-ASSERTION-INDEXING", 1, 0, false);
		declareFunction("dump_assertion_index", "DUMP-ASSERTION-INDEX", 2, 0, false);
		declareFunction("load_assertion_index", "LOAD-ASSERTION-INDEX", 2, 0, false);
		declareFunction("dump_auxiliary_indices_file", "DUMP-AUXILIARY-INDICES-FILE", 1, 0, false);
		declareFunction("load_auxiliary_indices_file", "LOAD-AUXILIARY-INDICES-FILE", 1, 0, false);
		declareFunction("replicate_auxiliary_assertion_indexing", "REPLICATE-AUXILIARY-ASSERTION-INDEXING", 1, 0,
				false);
		declareFunction("dump_bookkeeping_indices_file", "DUMP-BOOKKEEPING-INDICES-FILE", 1, 0, false);
		declareFunction("load_bookkeeping_indices_file", "LOAD-BOOKKEEPING-INDICES-FILE", 1, 0, false);
		declareFunction("dump_bookkeeping_indices", "DUMP-BOOKKEEPING-INDICES", 1, 0, false);
		declareFunction("load_bookkeeping_indices", "LOAD-BOOKKEEPING-INDICES", 1, 0, false);
		declareFunction("dump_rule_set", "DUMP-RULE-SET", 1, 0, false);
		declareFunction("load_rule_set", "LOAD-RULE-SET", 1, 0, false);
		declareFunction("dump_non_true_assertion_tv_cache", "DUMP-NON-TRUE-ASSERTION-TV-CACHE", 1, 0, false);
		declareFunction("load_non_true_assertion_tv_cache", "LOAD-NON-TRUE-ASSERTION-TV-CACHE", 1, 0, false);
		declareFunction("dump_nart_hl_formulas", "DUMP-NART-HL-FORMULAS", 1, 0, false);
		declareFunction("snapshot_nart_hl_formulas", "SNAPSHOT-NART-HL-FORMULAS", 1, 0, false);
		declareFunction("load_nart_hl_formulas", "LOAD-NART-HL-FORMULAS", 1, 0, false);
		declareFunction("dump_nart_hl_formula", "DUMP-NART-HL-FORMULA", 3, 0, false);
		declareFunction("load_nart_hl_formula", "LOAD-NART-HL-FORMULA", 2, 0, false);
		declareFunction("load_nart_hl_formula_from_cache", "LOAD-NART-HL-FORMULA-FROM-CACHE", 2, 0, false);
		new dumper.$load_nart_hl_formula_from_cache$BinaryFunction();
		declareFunction("dump_miscellaneous", "DUMP-MISCELLANEOUS", 1, 0, false);
		declareFunction("load_miscellaneous", "LOAD-MISCELLANEOUS", 1, 0, false);
		declareFunction("dump_sbhl_data", "DUMP-SBHL-DATA", 1, 0, false);
		declareFunction("load_sbhl_data", "LOAD-SBHL-DATA", 1, 0, false);
		declareFunction("rebuild_sbhl_data", "REBUILD-SBHL-DATA", 0, 0, false);
		declareFunction("recompute_missing_sbhl_graphs", "RECOMPUTE-MISSING-SBHL-GRAPHS", 0, 0, false);
		declareFunction("dump_sbhl_miscellany", "DUMP-SBHL-MISCELLANY", 1, 0, false);
		declareFunction("dump_isa_arg2_naut_table", "DUMP-ISA-ARG2-NAUT-TABLE", 1, 0, false);
		declareFunction("dump_non_fort_isa_table", "DUMP-NON-FORT-ISA-TABLE", 1, 0, false);
		declareFunction("dump_non_fort_instance_table", "DUMP-NON-FORT-INSTANCE-TABLE", 1, 0, false);
		declareFunction("load_sbhl_miscellany", "LOAD-SBHL-MISCELLANY", 1, 0, false);
		declareFunction("load_isa_arg2_naut_table", "LOAD-ISA-ARG2-NAUT-TABLE", 1, 0, false);
		declareFunction("load_non_fort_isa_table", "LOAD-NON-FORT-ISA-TABLE", 1, 0, false);
		declareFunction("load_non_fort_instance_table", "LOAD-NON-FORT-INSTANCE-TABLE", 1, 0, false);
		declareFunction("dump_sbhl_cache", "DUMP-SBHL-CACHE", 1, 0, false);
		declareFunction("load_sbhl_cache", "LOAD-SBHL-CACHE", 1, 0, false);
		declareFunction("rebuild_sbhl_cache", "REBUILD-SBHL-CACHE", 0, 0, false);
		declareFunction("dump_cardinality_estimates", "DUMP-CARDINALITY-ESTIMATES", 1, 0, false);
		declareFunction("load_cardinality_estimates", "LOAD-CARDINALITY-ESTIMATES", 1, 0, false);
		declareMacro("not_computing_arg_type_cache", "NOT-COMPUTING-ARG-TYPE-CACHE");
		declareFunction("dump_arg_type_cache", "DUMP-ARG-TYPE-CACHE", 1, 0, false);
		declareFunction("load_arg_type_cache", "LOAD-ARG-TYPE-CACHE", 1, 0, false);
		declareFunction("rebuild_arg_type_cache", "REBUILD-ARG-TYPE-CACHE", 0, 0, false);
		declareFunction("dump_defns_cache", "DUMP-DEFNS-CACHE", 1, 0, false);
		declareFunction("load_defns_cache", "LOAD-DEFNS-CACHE", 1, 0, false);
		declareFunction("dump_rule_connectivity_graph", "DUMP-RULE-CONNECTIVITY-GRAPH", 1, 0, false);
		declareFunction("load_rule_connectivity_graph", "LOAD-RULE-CONNECTIVITY-GRAPH", 1, 0, false);
		declareFunction("dump_tva_cache", "DUMP-TVA-CACHE", 1, 0, false);
		declareFunction("load_tva_cache", "LOAD-TVA-CACHE", 1, 0, false);
		declareFunction("dump_reformulator_rules", "DUMP-REFORMULATOR-RULES", 1, 0, false);
		declareFunction("load_reformulator_rules", "LOAD-REFORMULATOR-RULES", 1, 0, false);
		declareFunction("dump_english_units_of_measure", "DUMP-ENGLISH-UNITS-OF-MEASURE", 1, 0, false);
		declareFunction("load_english_units_of_measure", "LOAD-ENGLISH-UNITS-OF-MEASURE", 1, 0, false);
		declareFunction("dump_cae_query_search_tables", "DUMP-CAE-QUERY-SEARCH-TABLES", 1, 0, false);
		declareFunction("load_cae_query_search_tables", "LOAD-CAE-QUERY-SEARCH-TABLES", 1, 0, false);
		declareFunction("dump_sbhl_time_state", "DUMP-SBHL-TIME-STATE", 1, 0, false);
		declareFunction("load_sbhl_time_state", "LOAD-SBHL-TIME-STATE", 1, 0, false);
		declareFunction("rebuild_sbhl_time_data", "REBUILD-SBHL-TIME-DATA", 0, 0, false);
		declareFunction("dump_rtp_rules_cache", "DUMP-RTP-RULES-CACHE", 1, 0, false);
		declareFunction("load_rtp_rules_cache", "LOAD-RTP-RULES-CACHE", 1, 0, false);
		declareFunction("dump_somewhere_cache", "DUMP-SOMEWHERE-CACHE", 1, 0, false);
		declareFunction("load_somewhere_cache", "LOAD-SOMEWHERE-CACHE", 1, 0, false);
		declareFunction("dump_arity_cache", "DUMP-ARITY-CACHE", 1, 0, false);
		declareFunction("load_arity_cache", "LOAD-ARITY-CACHE", 1, 0, false);
		declareFunction("dump_pph_phrase_shells", "DUMP-PPH-PHRASE-SHELLS", 1, 0, false);
		declareFunction("load_pph_phrase_shells", "LOAD-PPH-PHRASE-SHELLS", 1, 0, false);
		declareFunction("load_pph_phrase_count", "LOAD-PPH-PHRASE-COUNT", 1, 0, false);
		declareFunction("dump_pph_phrase_shell", "DUMP-PPH-PHRASE-SHELL", 2, 0, false);
		declareFunction("load_pph_phrase_shell", "LOAD-PPH-PHRASE-SHELL", 2, 0, false);
		declareFunction("dump_pph_phrase_defs", "DUMP-PPH-PHRASE-DEFS", 1, 0, false);
		declareFunction("load_pph_phrase_defs", "LOAD-PPH-PHRASE-DEFS", 1, 0, false);
		declareFunction("dump_pph_phrase_def", "DUMP-PPH-PHRASE-DEF", 2, 0, false);
		declareFunction("load_pph_phrase_def", "LOAD-PPH-PHRASE-DEF", 2, 0, false);
		declareFunction("dump_gen_template_store", "DUMP-GEN-TEMPLATE-STORE", 1, 0, false);
		declareFunction("load_gen_template_store", "LOAD-GEN-TEMPLATE-STORE", 1, 0, false);
		declareFunction("dump_pph_name_string_preds", "DUMP-PPH-NAME-STRING-PREDS", 1, 0, false);
		declareFunction("dump_pph_phrase_fns", "DUMP-PPH-PHRASE-FNS", 1, 0, false);
		declareFunction("load_pph_phrase_fns", "LOAD-PPH-PHRASE-FNS", 1, 0, false);
		declareFunction("dump_paraphrase_cycl_caches", "DUMP-PARAPHRASE-CYCL-CACHES", 1, 0, false);
		declareFunction("rebuild_pph_phrases", "REBUILD-PPH-PHRASES", 0, 0, false);
		declareFunction("load_paraphrase_cycl_caches", "LOAD-PARAPHRASE-CYCL-CACHES", 1, 0, false);
		declareFunction("dump_kb_activities", "DUMP-KB-ACTIVITIES", 1, 0, false);
		declareFunction("load_kb_initializations", "LOAD-KB-INITIALIZATIONS", 0, 0, false);
		declareFunction("initialize_kb_features", "INITIALIZE-KB-FEATURES", 0, 0, false);
		declareFunction("show_kb_features", "SHOW-KB-FEATURES", 0, 0, false);
		declareFunction("dump_essential_kb_evaluatable", "DUMP-ESSENTIAL-KB-EVALUATABLE", 0, 1, false);
		declareFunction("load_essential_kb_evaluatable_file", "LOAD-ESSENTIAL-KB-EVALUATABLE-FILE", 9, 0, false);
		declareFunction("load_essential_kb_evaluatable", "LOAD-ESSENTIAL-KB-EVALUATABLE", 1, 7, false);
		declareFunction("rebuild_alexandria_computable_kb", "REBUILD-ALEXANDRIA-COMPUTABLE-KB", 0, 0, false);
		declareFunction("load_alexandria_computable_kb_from_directory", "LOAD-ALEXANDRIA-COMPUTABLE-KB-FROM-DIRECTORY",
				1, 0, false);
		declareFunction("dump_alexandria_units", "DUMP-ALEXANDRIA-UNITS", 3, 0, false);
		declareFunction("load_rebuild_and_dump_alexandria_computable_kb",
				"LOAD-REBUILD-AND-DUMP-ALEXANDRIA-COMPUTABLE-KB", 3, 0, false);
		declareFunction("rebuild_and_dump_alexandria_computable_kb", "REBUILD-AND-DUMP-ALEXANDRIA-COMPUTABLE-KB", 3, 0,
				false);
		declareFunction("count_forms_in_file", "COUNT-FORMS-IN-FILE", 1, 0, false);
		declareFunction("read_and_eval_evaluatable_dump_file", "READ-AND-EVAL-EVALUATABLE-DUMP-FILE", 1, 3, false);
		declareFunction("eval_test_operation", "EVAL-TEST-OPERATION", 1, 0, false);
		declareFunction("read_and_eval_test_file", "READ-AND-EVAL-TEST-FILE", 1, 1, false);
		declareFunction("dump_essential_kb_constants_evaluatable", "DUMP-ESSENTIAL-KB-CONSTANTS-EVALUATABLE", 1, 0,
				false);
		declareFunction("dump_essential_kb_narts_evaluatable", "DUMP-ESSENTIAL-KB-NARTS-EVALUATABLE", 1, 0, false);
		declareFunction("exportable_assertionP", "EXPORTABLE-ASSERTION?", 1, 1, false);
		declareFunction("clear_exportable_mtP", "CLEAR-EXPORTABLE-MT?", 0, 0, false);
		declareFunction("remove_exportable_mtP", "REMOVE-EXPORTABLE-MT?", 1, 0, false);
		declareFunction("exportable_mtP_internal", "EXPORTABLE-MT?-INTERNAL", 1, 0, false);
		declareFunction("exportable_mtP", "EXPORTABLE-MT?", 1, 0, false);
		declareFunction("exportable_deduction_supportsP", "EXPORTABLE-DEDUCTION-SUPPORTS?", 1, 0, false);
		declareFunction("clear_exportable_deduction_supportP", "CLEAR-EXPORTABLE-DEDUCTION-SUPPORT?", 0, 0, false);
		declareFunction("remove_exportable_deduction_supportP", "REMOVE-EXPORTABLE-DEDUCTION-SUPPORT?", 1, 0, false);
		declareFunction("exportable_deduction_supportP_internal", "EXPORTABLE-DEDUCTION-SUPPORT?-INTERNAL", 1, 0,
				false);
		declareFunction("exportable_deduction_supportP", "EXPORTABLE-DEDUCTION-SUPPORT?", 1, 0, false);
		declareFunction("clear_exportable_deduction_supported_objectP", "CLEAR-EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?",
				0, 0, false);
		declareFunction("remove_exportable_deduction_supported_objectP",
				"REMOVE-EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?", 1, 0, false);
		declareFunction("exportable_deduction_supported_objectP_internal",
				"EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?-INTERNAL", 1, 0, false);
		declareFunction("exportable_deduction_supported_objectP", "EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?", 1, 0,
				false);
		declareFunction("exportable_deductionP", "EXPORTABLE-DEDUCTION?", 1, 0, false);
		declareFunction("exportable_kb_hl_supportP", "EXPORTABLE-KB-HL-SUPPORT?", 1, 0, false);
		declareFunction("exportable_hl_supportP", "EXPORTABLE-HL-SUPPORT?", 1, 0, false);
		declareFunction("clear_evaluatable_export_caches", "CLEAR-EVALUATABLE-EXPORT-CACHES", 0, 0, false);
		declareFunction("dump_essential_kb_assertions_evaluatable", "DUMP-ESSENTIAL-KB-ASSERTIONS-EVALUATABLE", 1, 0,
				false);
		declareFunction("dump_essential_kb_kb_hl_supports_evaluatable", "DUMP-ESSENTIAL-KB-KB-HL-SUPPORTS-EVALUATABLE",
				2, 0, false);
		declareFunction("dump_essential_kb_deductions_evaluatable_in_parts",
				"DUMP-ESSENTIAL-KB-DEDUCTIONS-EVALUATABLE-IN-PARTS", 3, 0, false);
		declareFunction("dump_essential_kb_deductions_evaluatable", "DUMP-ESSENTIAL-KB-DEDUCTIONS-EVALUATABLE", 1, 2,
				false);
		declareFunction("dump_essential_kb_bookkeeping_gafs_evaluatable",
				"DUMP-ESSENTIAL-KB-BOOKKEEPING-GAFS-EVALUATABLE", 1, 0, false);
		declareFunction("nart_depth_internal", "NART-DEPTH-INTERNAL", 1, 1, false);
		declareFunction("nart_depth", "NART-DEPTH", 1, 0, false);
		declareFunction("kb_hl_support_depth_internal", "KB-HL-SUPPORT-DEPTH-INTERNAL", 1, 1, false);
		declareFunction("kb_hl_support_depth", "KB-HL-SUPPORT-DEPTH", 1, 0, false);
		declareFunction("test_that_all_narts_are_findable", "TEST-THAT-ALL-NARTS-ARE-FINDABLE", 0, 1, false);
		declareFunction("test_that_all_assertions_are_findable", "TEST-THAT-ALL-ASSERTIONS-ARE-FINDABLE", 0, 0, false);
		declareFunction("test_that_all_deductions_are_findable", "TEST-THAT-ALL-DEDUCTIONS-ARE-FINDABLE", 0, 0, false);
		declareFunction("fix_bad_narts", "FIX-BAD-NARTS", 0, 0, false);
		declareFunction("fix_bad_nart", "FIX-BAD-NART", 1, 0, false);
		declareFunction("get_robust_nart_removal_form", "GET-ROBUST-NART-REMOVAL-FORM", 1, 0, false);
		declareFunction("get_robust_assertion_removal_form", "GET-ROBUST-ASSERTION-REMOVAL-FORM", 1, 0, false);
		declareFunction("fix_bad_assertion", "FIX-BAD-ASSERTION", 1, 1, false);
		declareFunction("find_assertion_with_kb_hl_support_deduction_dependent",
				"FIND-ASSERTION-WITH-KB-HL-SUPPORT-DEDUCTION-DEPENDENT", 0, 0, false);
		declareFunction("find_complex_cnf", "FIND-COMPLEX-CNF", 0, 0, false);
		return NIL;
	}

	public static final SubLObject init_dumper_file_alt() {
		deflexical("*FORCE-MONOLITHIC-KB-ASSUMPTION*",
				NIL != boundp($force_monolithic_kb_assumption$)
						? ((SubLObject) ($force_monolithic_kb_assumption$.getGlobalValue()))
						: NIL);
		defparameter("*DEFAULT-DUMP-PATH*", $list_alt21);
		defparameter("*DEFAULT-DUMP-EXTENSION*", $$$cfasl);
		defparameter("*DEFAULT-DUMP-PRODUCT-EXTENSION*", $$$fht);
		deflexical("*DUMP-BYTES-PER-ASSERTION*", $int$192);
		defparameter("*DUMP-VERIFY*", T);
		defparameter("*KB-LOAD-GC-CHECKPOINTS-ENABLED?*", NIL);
		defparameter("*DUMP-VERBOSE*", T);
		defparameter("*KB-DUMP-COMMON-SYMBOLS*",
				append(new SubLObject[] { enumeration_types.valid_hl_truth_values(),
						enumeration_types.valid_directions(), asserted_argument_tokens(),
						hl_supports.hl_support_modules(), valid_hash_test_symbols(), $list_alt72 }));
		defparameter("*COMPUTE-ARG-TYPE-CACHE-ON-DUMP?*", T);
		return NIL;
	}

	public static SubLObject init_dumper_file() {
		if (SubLFiles.USE_V1) {
			deflexical("*FORCE-MONOLITHIC-KB-ASSUMPTION*",
					NIL != boundp(dumper.$force_monolithic_kb_assumption$)
							? dumper.$force_monolithic_kb_assumption$.getGlobalValue()
							: NIL);
			defparameter("*SEPARATE-FILE-FOR-COMPLEX-INDEXING?*", T);
			defparameter("*DEFAULT-DUMP-PATH*", dumper.$list30);
			defparameter("*DEFAULT-DUMP-EXTENSION*", dumper.$$$cfasl);
			defparameter("*DEFAULT-DUMP-PRODUCT-EXTENSION*", dumper.$$$fht);
			deflexical("*KB-DUMP-FVECTOR-WIDE-MARK-TAG*", dumper.$str33$_wide_mark);
			deflexical("*DUMP-BYTES-PER-ASSERTION*", dumper.$int$192);
			defparameter("*DUMP-VERIFY*", T);
			defparameter("*KB-LOAD-GC-CHECKPOINTS-ENABLED?*", NIL);
			defparameter("*PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-COMPLETE?*", T);
			deflexical("*ASSERTION-TILE-SIZE*", dumper.$int$1000000);
			defparameter("*DUMP-VERBOSE*", T);
			defparameter("*DUMP-VERBOSE-DETAIL*", NIL);
			defparameter("*AUTO-INCREMENT-KB-NUMBER-ON-DUMP?*", T);
			defparameter("*SNAPSHOT-TOMBSTONING-MODE*", $MINIMAL);
			deflexical("*KB-MANIFEST*",
					NIL != boundp(dumper.$kb_manifest$) ? dumper.$kb_manifest$.getGlobalValue() : NIL);
			deflexical("*KB-UNITS-FVECTOR-DESCRIPTIONS*",
					list(dumper.describe_knowledge_fvector_files(dumper.$$$assertion),
							dumper.describe_knowledge_fvector_files(dumper.$$$deduction),
							dumper.describe_knowledge_fvector_files(dumper.$str170$kb_hl_support),
							dumper.describe_knowledge_fvector_files(dumper.$str171$nart_hl_formula),
							dumper.describe_index_fvector_files(dumper.$$$constant),
							dumper.describe_index_fvector_files(dumper.$$$nat),
							dumper.describe_index_fvector_files(dumper.$str173$unrepresented_term)));
			deflexical("*KB-DUMP-DEFAULT-COMMON-SYMBOLS*", dumper.$list258);
			defparameter("*KB-DUMP-COMMON-SYMBOLS*", dumper.$kb_dump_default_common_symbols$.getGlobalValue());
			defconstant("*DTP-INDEX-WRITER*", dumper.INDEX_WRITER);
			defparameter("*COMPUTE-ARG-TYPE-CACHE-ON-DUMP?*", T);
			deflexical("*CYC-ALEXANDRIA-DEFNS-DUMP-LOAD-SUPPORTED?*",
					NIL != boundp(dumper.$cyc_alexandria_defns_dump_load_supportedP$)
							? dumper.$cyc_alexandria_defns_dump_load_supportedP$.getGlobalValue()
							: NIL);
			defparameter("BOOTSTRAPPING-CONSTANTS?", NIL);
			defparameter("BOOTSTRAPPING-NARTS?", NIL);
			defparameter("BOOTSTRAPPING-ASSERTIONS?", NIL);
			defparameter("BOOTSTRAPPING-KB-HL-SUPPORTS?", NIL);
			defparameter("BOOTSTRAPPING-DEDUCTIONS?", NIL);
			defparameter("BOOTSTRAPPING-BOOKKEEPING-GAFS?", NIL);
			deflexical("ESSENTIAL-KB-EVALUATABLE-FILE-TYPE",
					NIL != boundp(dumper.ESSENTIAL_KB_EVALUATABLE_FILE_TYPE)
							? dumper.$essential_kb_evaluatable_file_type$.getGlobalValue()
							: dumper.$list638);
			deflexical("*DUMP-INVALID-CONSTANTS*",
					NIL != boundp(dumper.$dump_invalid_constants$) ? dumper.$dump_invalid_constants$.getGlobalValue()
							: set.new_set(symbol_function(EQL), ZERO_INTEGER));
			deflexical("*DUMP-INVALID-NARTS*",
					NIL != boundp(dumper.$dump_invalid_narts$) ? dumper.$dump_invalid_narts$.getGlobalValue()
							: set.new_set(symbol_function(EQL), ZERO_INTEGER));
			deflexical("*DUMP-INVALID-ASSERTIONS*",
					NIL != boundp(dumper.$dump_invalid_assertions$) ? dumper.$dump_invalid_assertions$.getGlobalValue()
							: set.new_set(symbol_function(EQL), ZERO_INTEGER));
			deflexical("*DUMP-INVALID-KB-HL-SUPPORTS*",
					NIL != boundp(dumper.$dump_invalid_kb_hl_supports$)
							? dumper.$dump_invalid_kb_hl_supports$.getGlobalValue()
							: set.new_set(symbol_function(EQL), ZERO_INTEGER));
			deflexical("*DUMP-INVALID-DEDUCTIONS*",
					NIL != boundp(dumper.$dump_invalid_deductions$) ? dumper.$dump_invalid_deductions$.getGlobalValue()
							: set.new_set(symbol_function(EQL), ZERO_INTEGER));
			deflexical("*DUMP-INVALID-BOOKKEEPING-GAFS*",
					NIL != boundp(dumper.$dump_invalid_bookkeeping_gafs$)
							? dumper.$dump_invalid_bookkeeping_gafs$.getGlobalValue()
							: set.new_set(symbol_function(EQL), ZERO_INTEGER));
			deflexical("*EXPORTABLE-MT?-CACHING-STATE*", NIL);
			deflexical("*EXPORTABLE-DEDUCTION-SUPPORT?-CACHING-STATE*", NIL);
			deflexical("*EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?-CACHING-STATE*", NIL);
			defparameter("*CURRENT-DUMP-ASSERTION*", NIL);
			defparameter("*LAST-INVALID-ASSERTION*", NIL);
		}
		if (SubLFiles.USE_V2) {
			deflexical("*FORCE-MONOLITHIC-KB-ASSUMPTION*",
					NIL != boundp($force_monolithic_kb_assumption$)
							? ((SubLObject) ($force_monolithic_kb_assumption$.getGlobalValue()))
							: NIL);
			defparameter("*DEFAULT-DUMP-PATH*", $list_alt21);
			defparameter("*KB-DUMP-COMMON-SYMBOLS*",
					append(new SubLObject[] { enumeration_types.valid_hl_truth_values(),
							enumeration_types.valid_directions(), asserted_argument_tokens(),
							hl_supports.hl_support_modules(), valid_hash_test_symbols(), $list_alt72 }));
		}
		return NIL;
	}

	public static SubLObject init_dumper_file_Previous() {
		deflexical("*FORCE-MONOLITHIC-KB-ASSUMPTION*",
				NIL != boundp(dumper.$force_monolithic_kb_assumption$)
						? dumper.$force_monolithic_kb_assumption$.getGlobalValue()
						: NIL);
		defparameter("*SEPARATE-FILE-FOR-COMPLEX-INDEXING?*", T);
		defparameter("*DEFAULT-DUMP-PATH*", dumper.$list30);
		defparameter("*DEFAULT-DUMP-EXTENSION*", dumper.$$$cfasl);
		defparameter("*DEFAULT-DUMP-PRODUCT-EXTENSION*", dumper.$$$fht);
		deflexical("*KB-DUMP-FVECTOR-WIDE-MARK-TAG*", dumper.$str33$_wide_mark);
		deflexical("*DUMP-BYTES-PER-ASSERTION*", dumper.$int$192);
		defparameter("*DUMP-VERIFY*", T);
		defparameter("*KB-LOAD-GC-CHECKPOINTS-ENABLED?*", NIL);
		defparameter("*PERFORM-STANDARD-PRE-DUMP-KB-CLEANUPS-COMPLETE?*", T);
		deflexical("*ASSERTION-TILE-SIZE*", dumper.$int$1000000);
		defparameter("*DUMP-VERBOSE*", T);
		defparameter("*DUMP-VERBOSE-DETAIL*", NIL);
		defparameter("*AUTO-INCREMENT-KB-NUMBER-ON-DUMP?*", T);
		defparameter("*SNAPSHOT-TOMBSTONING-MODE*", $MINIMAL);
		deflexical("*KB-MANIFEST*", NIL != boundp(dumper.$kb_manifest$) ? dumper.$kb_manifest$.getGlobalValue() : NIL);
		deflexical("*KB-UNITS-FVECTOR-DESCRIPTIONS*",
				list(dumper.describe_knowledge_fvector_files(dumper.$$$assertion),
						dumper.describe_knowledge_fvector_files(dumper.$$$deduction),
						dumper.describe_knowledge_fvector_files(dumper.$str170$kb_hl_support),
						dumper.describe_knowledge_fvector_files(dumper.$str171$nart_hl_formula),
						dumper.describe_index_fvector_files(dumper.$$$constant),
						dumper.describe_index_fvector_files(dumper.$$$nat),
						dumper.describe_index_fvector_files(dumper.$str173$unrepresented_term)));
		deflexical("*KB-DUMP-DEFAULT-COMMON-SYMBOLS*", dumper.$list258);
		defparameter("*KB-DUMP-COMMON-SYMBOLS*", dumper.$kb_dump_default_common_symbols$.getGlobalValue());
		defconstant("*DTP-INDEX-WRITER*", dumper.INDEX_WRITER);
		defparameter("*COMPUTE-ARG-TYPE-CACHE-ON-DUMP?*", T);
		deflexical("*CYC-ALEXANDRIA-DEFNS-DUMP-LOAD-SUPPORTED?*",
				NIL != boundp(dumper.$cyc_alexandria_defns_dump_load_supportedP$)
						? dumper.$cyc_alexandria_defns_dump_load_supportedP$.getGlobalValue()
						: NIL);
		defparameter("BOOTSTRAPPING-CONSTANTS?", NIL);
		defparameter("BOOTSTRAPPING-NARTS?", NIL);
		defparameter("BOOTSTRAPPING-ASSERTIONS?", NIL);
		defparameter("BOOTSTRAPPING-KB-HL-SUPPORTS?", NIL);
		defparameter("BOOTSTRAPPING-DEDUCTIONS?", NIL);
		defparameter("BOOTSTRAPPING-BOOKKEEPING-GAFS?", NIL);
		deflexical("ESSENTIAL-KB-EVALUATABLE-FILE-TYPE",
				NIL != boundp(dumper.ESSENTIAL_KB_EVALUATABLE_FILE_TYPE)
						? dumper.$essential_kb_evaluatable_file_type$.getGlobalValue()
						: dumper.$list638);
		deflexical("*DUMP-INVALID-CONSTANTS*",
				NIL != boundp(dumper.$dump_invalid_constants$) ? dumper.$dump_invalid_constants$.getGlobalValue()
						: set.new_set(symbol_function(EQL), ZERO_INTEGER));
		deflexical("*DUMP-INVALID-NARTS*",
				NIL != boundp(dumper.$dump_invalid_narts$) ? dumper.$dump_invalid_narts$.getGlobalValue()
						: set.new_set(symbol_function(EQL), ZERO_INTEGER));
		deflexical("*DUMP-INVALID-ASSERTIONS*",
				NIL != boundp(dumper.$dump_invalid_assertions$) ? dumper.$dump_invalid_assertions$.getGlobalValue()
						: set.new_set(symbol_function(EQL), ZERO_INTEGER));
		deflexical("*DUMP-INVALID-KB-HL-SUPPORTS*",
				NIL != boundp(dumper.$dump_invalid_kb_hl_supports$)
						? dumper.$dump_invalid_kb_hl_supports$.getGlobalValue()
						: set.new_set(symbol_function(EQL), ZERO_INTEGER));
		deflexical("*DUMP-INVALID-DEDUCTIONS*",
				NIL != boundp(dumper.$dump_invalid_deductions$) ? dumper.$dump_invalid_deductions$.getGlobalValue()
						: set.new_set(symbol_function(EQL), ZERO_INTEGER));
		deflexical("*DUMP-INVALID-BOOKKEEPING-GAFS*",
				NIL != boundp(dumper.$dump_invalid_bookkeeping_gafs$)
						? dumper.$dump_invalid_bookkeeping_gafs$.getGlobalValue()
						: set.new_set(symbol_function(EQL), ZERO_INTEGER));
		deflexical("*EXPORTABLE-MT?-CACHING-STATE*", NIL);
		deflexical("*EXPORTABLE-DEDUCTION-SUPPORT?-CACHING-STATE*", NIL);
		deflexical("*EXPORTABLE-DEDUCTION-SUPPORTED-OBJECT?-CACHING-STATE*", NIL);
		defparameter("*CURRENT-DUMP-ASSERTION*", NIL);
		defparameter("*LAST-INVALID-ASSERTION*", NIL);
		return NIL;
	}

	public static SubLObject setup_dumper_file() {
		declare_defglobal(dumper.$force_monolithic_kb_assumption$);
		register_external_symbol(dumper.LOAD_NON_COMPUTABLE_KB_PLUS_REBUILD_AND_DUMP_COMPUTABLE_KB);
		register_external_symbol(dumper.REBUILD_AND_RECONNECT_COMPUTABLE_KB);
		register_external_symbol(dumper.$assertion_tile_size$);
		register_external_symbol(dumper.CYC_DUMP_KB);
		register_external_symbol(dumper.CYC_DUMP_KB_UNSAFE);
		declare_defglobal(dumper.$kb_manifest$);
		register_external_symbol(dumper.GET_KB_UNITS_FILE_VECTOR_DESCRIPTIONS);
		register_external_symbol(dumper.GET_KB_UNITS_FILE_VECTOR_CATEGORIES);
		note_funcall_helper_function(dumper.LOAD_DEDUCTION_DEF_FROM_CACHE);
		note_funcall_helper_function(dumper.LOAD_ASSERTION_DEF_FROM_CACHE);
		note_funcall_helper_function(dumper.LOAD_KB_HL_SUPPORT_DEF_FROM_CACHE);
		register_method($print_object_method_table$.getGlobalValue(), dumper.$dtp_index_writer$.getGlobalValue(),
				symbol_function(dumper.INDEX_WRITER_PRINT_FUNCTION_TRAMPOLINE));
		SubLSpecialOperatorDeclarations.proclaim(dumper.$list389);
		def_csetf(dumper.IDXWRITER_DIRECTORY, dumper._CSETF_IDXWRITER_DIRECTORY);
		def_csetf(dumper.IDXWRITER_FVECTOR, dumper._CSETF_IDXWRITER_FVECTOR);
		def_csetf(dumper.IDXWRITER_INDEX_FILE, dumper._CSETF_IDXWRITER_INDEX_FILE);
		def_csetf(dumper.IDXWRITER_INDEX_LABEL, dumper._CSETF_IDXWRITER_INDEX_LABEL);
		def_csetf(dumper.IDXWRITER_COMPLEX_FVECTOR, dumper._CSETF_IDXWRITER_COMPLEX_FVECTOR);
		def_csetf(dumper.IDXWRITER_COMPLEX_INDEX_FILE, dumper._CSETF_IDXWRITER_COMPLEX_INDEX_FILE);
		def_csetf(dumper.IDXWRITER_COMPLEX_INDEX_LABEL, dumper._CSETF_IDXWRITER_COMPLEX_INDEX_LABEL);
		def_csetf(dumper.IDXWRITER_DUMP_FN, dumper._CSETF_IDXWRITER_DUMP_FN);
		identity(dumper.INDEX_WRITER);
		register_method(visitation.$visit_defstruct_object_method_table$.getGlobalValue(),
				dumper.$dtp_index_writer$.getGlobalValue(),
				symbol_function(dumper.VISIT_DEFSTRUCT_OBJECT_INDEX_WRITER_METHOD));
		note_funcall_helper_function(dumper.LOAD_CONSTANT_INDEX_FROM_CACHE);
		note_funcall_helper_function(dumper.LOAD_NART_INDEX_FROM_CACHE);
		note_funcall_helper_function(dumper.LOAD_UNREPRESENTED_TERM_INDEX_FROM_CACHE);
		declare_defglobal(dumper.$cyc_alexandria_defns_dump_load_supportedP$);
		declare_defglobal(dumper.ESSENTIAL_KB_EVALUATABLE_FILE_TYPE);
		declare_defglobal(dumper.$dump_invalid_constants$);
		declare_defglobal(dumper.$dump_invalid_narts$);
		declare_defglobal(dumper.$dump_invalid_assertions$);
		declare_defglobal(dumper.$dump_invalid_kb_hl_supports$);
		declare_defglobal(dumper.$dump_invalid_deductions$);
		declare_defglobal(dumper.$dump_invalid_bookkeeping_gafs$);
		memoization_state.note_globally_cached_function(dumper.$sym683$EXPORTABLE_MT_);
		memoization_state.note_globally_cached_function(dumper.$sym686$EXPORTABLE_DEDUCTION_SUPPORT_);
		memoization_state.note_globally_cached_function(dumper.$sym689$EXPORTABLE_DEDUCTION_SUPPORTED_OBJECT_);
		return NIL;
	}

	@Override
	public void declareFunctions() {
		dumper.declare_dumper_file();
	}

	@Override
	public void initializeVariables() {
		dumper.init_dumper_file();
	}

	@Override
	public void runTopLevelForms() {
		dumper.setup_dumper_file();
	}

	static {
	}

	public static final class $load_deduction_def_from_cache$BinaryFunction extends BinaryFunction {
		public $load_deduction_def_from_cache$BinaryFunction() {
			super(extractFunctionNamed("LOAD-DEDUCTION-DEF-FROM-CACHE"));
		}

		@Override
		public SubLObject processItem(final SubLObject arg1, final SubLObject arg2) {
			return dumper.load_deduction_def_from_cache(arg1, arg2);
		}
	}

	public static final class $load_assertion_def_from_cache$BinaryFunction extends BinaryFunction {
		public $load_assertion_def_from_cache$BinaryFunction() {
			super(extractFunctionNamed("LOAD-ASSERTION-DEF-FROM-CACHE"));
		}

		@Override
		public SubLObject processItem(final SubLObject arg1, final SubLObject arg2) {
			return dumper.load_assertion_def_from_cache(arg1, arg2);
		}
	}

	public static final class $index_writer_native extends SubLStructNative {
		public SubLObject $directory;

		public SubLObject $fvector;

		public SubLObject $index_file;

		public SubLObject $index_label;

		public SubLObject $complex_fvector;

		public SubLObject $complex_index_file;

		public SubLObject $complex_index_label;

		public SubLObject $dump_fn;

		private static final SubLStructDeclNative structDecl;

		public $index_writer_native() {
			this.$directory = Lisp.NIL;
			this.$fvector = Lisp.NIL;
			this.$index_file = Lisp.NIL;
			this.$index_label = Lisp.NIL;
			this.$complex_fvector = Lisp.NIL;
			this.$complex_index_file = Lisp.NIL;
			this.$complex_index_label = Lisp.NIL;
			this.$dump_fn = Lisp.NIL;
		}

		@Override
		public SubLStructDecl getStructDecl() {
			return structDecl;
		}

		@Override
		public SubLObject getField2() {
			return this.$directory;
		}

		@Override
		public SubLObject getField3() {
			return this.$fvector;
		}

		@Override
		public SubLObject getField4() {
			return this.$index_file;
		}

		@Override
		public SubLObject getField5() {
			return this.$index_label;
		}

		@Override
		public SubLObject getField6() {
			return this.$complex_fvector;
		}

		@Override
		public SubLObject getField7() {
			return this.$complex_index_file;
		}

		@Override
		public SubLObject getField8() {
			return this.$complex_index_label;
		}

		@Override
		public SubLObject getField9() {
			return this.$dump_fn;
		}

		@Override
		public SubLObject setField2(final SubLObject value) {
			return this.$directory = value;
		}

		@Override
		public SubLObject setField3(final SubLObject value) {
			return this.$fvector = value;
		}

		@Override
		public SubLObject setField4(final SubLObject value) {
			return this.$index_file = value;
		}

		@Override
		public SubLObject setField5(final SubLObject value) {
			return this.$index_label = value;
		}

		@Override
		public SubLObject setField6(final SubLObject value) {
			return this.$complex_fvector = value;
		}

		@Override
		public SubLObject setField7(final SubLObject value) {
			return this.$complex_index_file = value;
		}

		@Override
		public SubLObject setField8(final SubLObject value) {
			return this.$complex_index_label = value;
		}

		@Override
		public SubLObject setField9(final SubLObject value) {
			return this.$dump_fn = value;
		}

		static {
			structDecl = makeStructDeclNative(dumper.$index_writer_native.class, dumper.INDEX_WRITER,
					dumper.INDEX_WRITER_P, dumper.$list383, dumper.$list384,
					new String[] { "$directory", "$fvector", "$index_file", "$index_label", "$complex_fvector",
							"$complex_index_file", "$complex_index_label", "$dump_fn" },
					dumper.$list385, dumper.$list386, DEFAULT_STRUCT_PRINT_FUNCTION);
		}
	}

	public static final class $index_writer_p$UnaryFunction extends UnaryFunction {
		public $index_writer_p$UnaryFunction() {
			super(extractFunctionNamed("INDEX-WRITER-P"));
		}

		@Override
		public SubLObject processItem(final SubLObject arg1) {
			return dumper.index_writer_p(arg1);
		}
	}

	public static final class $load_nart_hl_formula_from_cache$BinaryFunction extends BinaryFunction {
		public $load_nart_hl_formula_from_cache$BinaryFunction() {
			super(extractFunctionNamed("LOAD-NART-HL-FORMULA-FROM-CACHE"));
		}

		@Override
		public SubLObject processItem(final SubLObject arg1, final SubLObject arg2) {
			return dumper.load_nart_hl_formula_from_cache(arg1, arg2);
		}
	}
}

/**
 * Total time: 19051 ms alexandriaP alexandriaP thread directory_path
 * directory_path directory_path directory_path directory_path directory_path
 * directory_path directory_path directory_path directory_path directory_path
 * directory_path directory_path directory_path directory_path alexandriaP
 * thread alexandriaP directory_path directory_path file file thread thread
 * thread thread thread thread thread thread thread thread thread thread thread
 * thread thread thread thread thread thread thread
 */
