/**
 * Copyright (c) 1995 - 2019 Cycorp, Inc.  All rights reserved.
 */
package com.cyc.cycjava.cycl;


import static com.cyc.cycjava.cycl.access_macros.register_external_symbol;
import static com.cyc.cycjava.cycl.constant_handles.reader_make_constant_shell;
import static com.cyc.cycjava.cycl.constant_handles.valid_constantP;
import static com.cyc.cycjava.cycl.control_vars.kb_loaded;
import static com.cyc.cycjava.cycl.cyc_testing.generic_testing.define_test_case_table_int;
import static com.cyc.cycjava.cycl.el_utilities.el_formula_with_operator_p;
import static com.cyc.cycjava.cycl.el_utilities.make_binary_formula;
import static com.cyc.cycjava.cycl.el_utilities.make_el_formula;
import static com.cyc.cycjava.cycl.el_utilities.make_unary_formula;
import static com.cyc.cycjava.cycl.kb_indexing_datastructures.indexed_term_p;
import static com.cyc.cycjava.cycl.set.clear_set;
import static com.cyc.cycjava.cycl.set.new_set;
import static com.cyc.cycjava.cycl.set.set_add;
import static com.cyc.cycjava.cycl.set.set_emptyP;
import static com.cyc.cycjava.cycl.set.set_memberP;
import static com.cyc.cycjava.cycl.subl_macro_promotions.declare_defglobal;
import static com.cyc.cycjava.cycl.utilities_macros.$is_noting_progressP$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_count$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_elapsed_seconds_for_notification$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_last_pacification_time$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_notification_count$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_pacifications_since_last_nl$;
import static com.cyc.cycjava.cycl.utilities_macros.$progress_start_time$;
import static com.cyc.cycjava.cycl.utilities_macros.$silent_progressP$;
import static com.cyc.cycjava.cycl.utilities_macros.$suppress_all_progress_faster_than_seconds$;
import static com.cyc.cycjava.cycl.utilities_macros.note_progress;
import static com.cyc.cycjava.cycl.utilities_macros.noting_progress_postamble;
import static com.cyc.cycjava.cycl.utilities_macros.noting_progress_preamble;
import static com.cyc.cycjava.cycl.utilities_macros.register_cyc_api_function;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_asterisk;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.CHAR_hyphen;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Characters.upper_case_p;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.append;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.cons;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.listS;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.make_list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.nth;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.ConsesLow.set_nth;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.eq;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Equality.equalp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Functions.funcall;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.clrhash;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntryKey;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntrySetIterator;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.getEntryValue;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.gethash;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.hash_table_count;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.iteratorHasNext;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.iteratorNextEntry;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.make_hash_table;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Hashtables.releaseEntrySetIterator;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.add;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Numbers.subtract;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.cconcatenate;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.delete;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.delete_duplicates;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.find;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.find_if;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.length;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.nreverse;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.position;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.remove_duplicates;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sequences.search;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.boundp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Symbols.symbol_function;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Threads.$is_thread_performing_cleanupP$;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Threads.current_process;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Time.get_universal_time;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.integerp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.keywordp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.listp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.stringp;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Types.sublisp_null;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.arg2;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.getValuesAsVector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.multiple_value_list;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.resetMultipleValues;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.restoreValuesFromVector;
import static com.cyc.tool.subl.jrtl.nativeCode.subLisp.Values.values;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeBoolean;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeInteger;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeKeyword;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeString;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeSymbol;
import static com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObjectFactory.makeUninternedSymbol;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.cdestructuring_bind_error;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.destructuring_bind_must_consp;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.cdestructuring_bind.property_list_member;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.butlast;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.cadr;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.copy_list;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.member;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.second;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.set_difference;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.conses_high.union;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.bq_cons;
import static com.cyc.tool.subl.jrtl.translatedCode.sublisp.reader.read_from_string_ignoring_errors;
import static com.cyc.tool.subl.util.SubLFiles.declareFunction;
import static com.cyc.tool.subl.util.SubLFiles.declareMacro;
import static com.cyc.tool.subl.util.SubLFiles.deflexical;
import static com.cyc.tool.subl.util.SubLFiles.defparameter;

import java.util.Iterator;
import java.util.Map;

import com.cyc.cycjava.cycl.inference.ask_utilities;
import com.cyc.cycjava.cycl.inference.harness.inference_kernel;
import com.cyc.cycjava.cycl.inference.modules.removal.removal_modules_lexicon;
import com.cyc.cycjava.cycl.sbhl.sbhl_graphs;
import com.cyc.cycjava.cycl.sbhl.sbhl_link_methods;
import com.cyc.cycjava.cycl.sbhl.sbhl_link_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_links;
import com.cyc.cycjava.cycl.sbhl.sbhl_macros;
import com.cyc.cycjava.cycl.sbhl.sbhl_marking_utilities;
import com.cyc.cycjava.cycl.sbhl.sbhl_marking_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_module_utilities;
import com.cyc.cycjava.cycl.sbhl.sbhl_module_vars;
import com.cyc.cycjava.cycl.sbhl.sbhl_paranoia;
import com.cyc.cycjava.cycl.sbhl.sbhl_search_vars;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.BinaryFunction;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Errors;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Mapping;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Sort;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.Strings;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.SubLThread;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.UnaryFunction;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.ZeroArityFunction;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLList;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLObject;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLProcess;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.SubLString;
import com.cyc.tool.subl.jrtl.nativeCode.type.number.SubLInteger;
import com.cyc.tool.subl.jrtl.nativeCode.type.symbol.SubLSymbol;
import com.cyc.tool.subl.util.SubLFile;
import com.cyc.tool.subl.util.SubLFiles;
import com.cyc.tool.subl.util.SubLFiles.LispMethod;
import com.cyc.tool.subl.util.SubLTrampolineFile;
import com.cyc.tool.subl.util.SubLTranslatedFile;


/**
 * Copyright (c) 1995 - 2019 Cycorp, Inc.  All rights reserved.
 * module:      LEXICON-ACCESSORS
 * source file: /cyc/top/cycl/lexicon-accessors.lisp
 * created:     2019/07/03 17:38:15
 */
public final class lexicon_accessors extends SubLTranslatedFile implements V12 {
    public static final SubLObject remove_genl_lexicon_mtP(SubLObject spec_mt, SubLObject genl_mt) {
        return memoization_state.caching_state_remove_function_results_with_args($genl_lexicon_mtP_caching_state$.getGlobalValue(), list(spec_mt, genl_mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @param spec-mt;
    		possibly-hlmt-p
     * 		
     * @param genl-mt;
    		possibly-hlmt-p
     * 		
     * @return boolean : T if SPEC-MT is a spec MT of GENL-MT; nil otherwise.
     */
    @LispMethod(comment = "@param spec-mt;\n\t\tpossibly-hlmt-p\r\n\t\t\r\n@param genl-mt;\n\t\tpossibly-hlmt-p\r\n\t\t\r\n@return boolean : T if SPEC-MT is a spec MT of GENL-MT; nil otherwise.")
    public static final SubLObject genl_lexicon_mtP_internal(SubLObject spec_mt, SubLObject genl_mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(spec_mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = mt_relevance_macros.relevant_mtP(genl_mt);
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    public static final SubLObject clear_genl_lexicon_mtP() {
        {
            SubLObject cs = $genl_lexicon_mtP_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    static private final SubLString $str_alt196$ = makeString("");

    // Definitions
    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $genl_lexicon_mtP_caching_state$ = makeSymbol("*GENL-LEXICON-MT?-CACHING-STATE*");

    public static final SubLFile me = new lexicon_accessors();

 public static final String myName = "com.cyc.cycjava.cycl.lexicon_accessors";


    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $genl_lexicon_mtP_cached_caching_state$ = makeSymbol("*GENL-LEXICON-MT?-CACHED-CACHING-STATE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $genl_pos_predP_caching_state$ = makeSymbol("*GENL-POS-PRED?-CACHING-STATE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $genl_pos_pred_from_mt_infoP_caching_state$ = makeSymbol("*GENL-POS-PRED-FROM-MT-INFO?-CACHING-STATE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $preds_of_stringXword_cached_caching_state$ = makeSymbol("*PREDS-OF-STRING&WORD-CACHED-CACHING-STATE*");

    // defparameter
    @LispMethod(comment = "defparameter")
    private static final SubLSymbol $preposition_strings$ = makeSymbol("*PREPOSITION-STRINGS*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $pos_forms_spec_preds$ = makeSymbol("*POS-FORMS-SPEC-PREDS*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $verb_only_stringP_caching_state$ = makeSymbol("*VERB-ONLY-STRING?-CACHING-STATE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $indirect_lexical_assertionP_caching_state$ = makeSymbol("*INDIRECT-LEXICAL-ASSERTION?-CACHING-STATE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $genl_posP_caching_state$ = makeSymbol("*GENL-POS?-CACHING-STATE*");

    // deflexical
    @LispMethod(comment = "deflexical")
    public static final SubLSymbol $most_general_speech_part$ = makeSymbol("*MOST-GENERAL-SPEECH-PART*");

    // deflexical
    @LispMethod(comment = "deflexical")
    private static final SubLSymbol $relational_noun_denot_templates$ = makeSymbol("*RELATIONAL-NOUN-DENOT-TEMPLATES*");





    private static final SubLSymbol $sym2$GENL_LEXICON_MT__CACHED = makeSymbol("GENL-LEXICON-MT?-CACHED");

    private static final SubLSymbol $sym3$_GENL_LEXICON_MT__CACHED_CACHING_STATE_ = makeSymbol("*GENL-LEXICON-MT?-CACHED-CACHING-STATE*");

    private static final SubLSymbol $sym5$CLEAR_GENL_LEXICON_MT__CACHED = makeSymbol("CLEAR-GENL-LEXICON-MT?-CACHED");

    private static final SubLSymbol $sym7$SPEECH_PART_ = makeSymbol("SPEECH-PART?");

    private static final SubLSymbol MAX_PREDS_MATCHING_POS_CACHED = makeSymbol("MAX-PREDS-MATCHING-POS-CACHED");

    private static final SubLSymbol $max_preds_matching_pos_cached_caching_state$ = makeSymbol("*MAX-PREDS-MATCHING-POS-CACHED-CACHING-STATE*");

    private static final SubLSymbol MAX_PREDS_OF_POS = makeSymbol("MAX-PREDS-OF-POS");

    private static final SubLSymbol $max_preds_of_pos_caching_state$ = makeSymbol("*MAX-PREDS-OF-POS-CACHING-STATE*");

    private static final SubLSymbol CLEAR_MAX_PREDS_OF_POS = makeSymbol("CLEAR-MAX-PREDS-OF-POS");

    private static final SubLSymbol MAX_PREDS_LICENSED_BY_POS = makeSymbol("MAX-PREDS-LICENSED-BY-POS");

    private static final SubLSymbol $max_preds_licensed_by_pos_caching_state$ = makeSymbol("*MAX-PREDS-LICENSED-BY-POS-CACHING-STATE*");

    private static final SubLSymbol CLEAR_MAX_PREDS_LICENSED_BY_POS = makeSymbol("CLEAR-MAX-PREDS-LICENSED-BY-POS");



    private static final SubLList $list21 = cons(makeSymbol("NOW"), makeSymbol("LATER"));

    private static final SubLSymbol LEX_REMOVE_SPEC_PREDS_HELPER = makeSymbol("LEX-REMOVE-SPEC-PREDS-HELPER");

    private static final SubLSymbol SPEECH_PART_PRED_MIN_CEILINGS_INT = makeSymbol("SPEECH-PART-PRED-MIN-CEILINGS-INT");

    private static final SubLSymbol $speech_part_pred_min_ceilings_int_caching_state$ = makeSymbol("*SPEECH-PART-PRED-MIN-CEILINGS-INT-CACHING-STATE*");

    private static final SubLSymbol CLEAR_SPEECH_PART_PRED_MIN_CEILINGS_INT = makeSymbol("CLEAR-SPEECH-PART-PRED-MIN-CEILINGS-INT");

    private static final SubLSymbol SPEECH_PART_PRED_MAX_FLOORS_INT = makeSymbol("SPEECH-PART-PRED-MAX-FLOORS-INT");

    private static final SubLSymbol $speech_part_pred_max_floors_int_caching_state$ = makeSymbol("*SPEECH-PART-PRED-MAX-FLOORS-INT-CACHING-STATE*");

    private static final SubLSymbol CLEAR_SPEECH_PART_PRED_MAX_FLOORS_INT = makeSymbol("CLEAR-SPEECH-PART-PRED-MAX-FLOORS-INT");

    private static final SubLSymbol POS_OF_PRED = makeSymbol("POS-OF-PRED");

    private static final SubLSymbol $sym31$SPEECH_PART_PRED_ = makeSymbol("SPEECH-PART-PRED?");



    private static final SubLSymbol $sym33$SPEC_POS_ = makeSymbol("SPEC-POS?");

    private static final SubLSymbol $pos_of_pred_caching_state$ = makeSymbol("*POS-OF-PRED-CACHING-STATE*");

    private static final SubLInteger $int$128 = makeInteger(128);



    private static final SubLObject $$singular_Generic = reader_make_constant_shell("singular-Generic");

    private static final SubLObject $$plural_Generic = reader_make_constant_shell("plural-Generic");

    private static final SubLSymbol $derived_preds$ = makeSymbol("*DERIVED-PREDS*");





    private static final SubLString $str49$_A_is_not_a__A = makeString("~A is not a ~A");

    private static final SubLString $$$continue_anyway = makeString("continue anyway");

    private static final SubLString $str54$_A_is_not_a_valid__sbhl_type_erro = makeString("~A is not a valid *sbhl-type-error-action* value");



    private static final SubLString $str57$_A_is_neither_SET_P_nor_LISTP_ = makeString("~A is neither SET-P nor LISTP.");

    private static final SubLString $str58$attempting_to_bind_direction_link = makeString("attempting to bind direction link variable, to NIL. macro body not executed.");

    private static final SubLString $str59$Node__a_does_not_pass_sbhl_type_t = makeString("Node ~a does not pass sbhl-type-test ~a~%");



    private static final SubLSymbol $speech_part_preds$ = makeSymbol("*SPEECH-PART-PREDS*");

    private static final SubLList $list62 = list(list(makeSymbol("PRED"), makeSymbol("&KEY"), list(makeSymbol("MT"), reader_make_constant_shell("InferencePSC")), list(makeSymbol("DONE"), NIL)), makeSymbol("&BODY"), makeSymbol("BODY"));

    private static final SubLList $list63 = list(makeKeyword("MT"), $DONE);

    private static final SubLSymbol $ALLOW_OTHER_KEYS = makeKeyword("ALLOW-OTHER-KEYS");

    private static final SubLSymbol $sym67$DEFINING_MT = makeUninternedSymbol("DEFINING-MT");

    private static final SubLList $list69 = list(makeSymbol("ENSURE-SPEECH-PART-PREDS-INITIALIZED"));

    private static final SubLSymbol KBEQ = makeSymbol("KBEQ");

    private static final SubLList $list74 = list(reader_make_constant_shell("InferencePSC"));

    private static final SubLSymbol $sym75$GENL_LEXICON_MT_ = makeSymbol("GENL-LEXICON-MT?");





    private static final SubLSymbol $sym78$GENL_POS_PRED_ = makeSymbol("GENL-POS-PRED?");

    private static final SubLSymbol $sym79$_GENL_POS_PRED__CACHING_STATE_ = makeSymbol("*GENL-POS-PRED?-CACHING-STATE*");

    private static final SubLSymbol $sym80$CLEAR_GENL_POS_PRED_ = makeSymbol("CLEAR-GENL-POS-PRED?");

    private static final SubLSymbol $sym81$GENL_POS_PRED_FROM_MT_INFO_ = makeSymbol("GENL-POS-PRED-FROM-MT-INFO?");

    private static final SubLSymbol $sym85$_GENL_POS_PRED_FROM_MT_INFO__CACHING_STATE_ = makeSymbol("*GENL-POS-PRED-FROM-MT-INFO?-CACHING-STATE*");

    private static final SubLSymbol $sym86$CLEAR_GENL_POS_PRED_FROM_MT_INFO_ = makeSymbol("CLEAR-GENL-POS-PRED-FROM-MT-INFO?");

    private static final SubLSymbol $sym88$STRING_ = makeSymbol("STRING=");





    private static final SubLSymbol GET_STRINGS_OF_TYPE_CACHED = makeSymbol("GET-STRINGS-OF-TYPE-CACHED");

    private static final SubLSymbol $get_strings_of_type_cached_caching_state$ = makeSymbol("*GET-STRINGS-OF-TYPE-CACHED-CACHING-STATE*");

    private static final SubLSymbol $sym93$STRING_IS_POS_ON_WU_ = makeSymbol("STRING-IS-POS-ON-WU?");

    private static final SubLSymbol $sym95$LEXICAL_WORD_ = makeSymbol("LEXICAL-WORD?");

    private static final SubLSymbol PARSE_MORPHOLOGICALLY_OPTION_P = makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P");

    private static final SubLSymbol $sym98$EQUALS_EL_ = makeSymbol("EQUALS-EL?");

    private static final SubLSymbol $sym100$SPEC_ = makeSymbol("SPEC?");



    private static final SubLSymbol POS_FOR_KEYWORD = makeSymbol("POS-FOR-KEYWORD");

    private static final SubLSymbol $ALL_NOUN_FORMS = makeKeyword("ALL-NOUN-FORMS");

    private static final SubLList $list106 = list(reader_make_constant_shell("CountNoun"), reader_make_constant_shell("AgentiveNoun"), reader_make_constant_shell("MassNoun"), reader_make_constant_shell("GerundiveNoun"));

    private static final SubLList $list108 = list(reader_make_constant_shell("MassNoun"));









    private static final SubLList $list119 = list(reader_make_constant_shell("Verb"));













    private static final SubLSymbol $pos_for_keyword_caching_state$ = makeSymbol("*POS-FOR-KEYWORD-CACHING-STATE*");

    private static final SubLList $list135 = list(reader_make_constant_shell("abbreviationForLexicalWord"));

    private static final SubLSymbol PROPER_NOUN_FORM_OF_PRED = makeSymbol("PROPER-NOUN-FORM-OF-PRED");

    private static final SubLSymbol $sym137$PREDS_OF_STRING_WORD_CACHED = makeSymbol("PREDS-OF-STRING&WORD-CACHED");

    private static final SubLSymbol $sym138$_PREDS_OF_STRING_WORD_CACHED_CACHING_STATE_ = makeSymbol("*PREDS-OF-STRING&WORD-CACHED-CACHING-STATE*");

    private static final SubLSymbol $sym139$_STRING = makeSymbol("?STRING");

    private static final SubLSymbol $MAX_TRANSFORMATION_DEPTH = makeKeyword("MAX-TRANSFORMATION-DEPTH");

    private static final SubLSymbol $sym141$_POS = makeSymbol("?POS");









    private static final SubLList $list146 = list(reader_make_constant_shell("DefiniteDeterminerFrame"));











    private static final SubLSymbol $closed_lexical_class_strings$ = makeSymbol("*CLOSED-LEXICAL-CLASS-STRINGS*");

    private static final SubLSymbol $closed_lexical_class_strings_case_insensitive$ = makeSymbol("*CLOSED-LEXICAL-CLASS-STRINGS-CASE-INSENSITIVE*");



    private static final SubLSymbol NOT_TEST_CHAR = makeSymbol("NOT-TEST-CHAR");

    private static final SubLSymbol CLOSED_LEXICAL_CLASS_STRINGS = makeSymbol("CLOSED-LEXICAL-CLASS-STRINGS");

    private static final SubLSymbol $closed_lexical_class_strings_caching_state$ = makeSymbol("*CLOSED-LEXICAL-CLASS-STRINGS-CACHING-STATE*");

    private static final SubLSymbol CLOSED_LEXICAL_CLASSES = makeSymbol("CLOSED-LEXICAL-CLASSES");

    private static final SubLSymbol $closed_lexical_classes_caching_state$ = makeSymbol("*CLOSED-LEXICAL-CLASSES-CACHING-STATE*");

    private static final SubLList $list160 = list(reader_make_constant_shell("posForms"), reader_make_constant_shell("posBaseForms"));

    private static final SubLList $list161 = cons(list(makeKeyword("OR"), reader_make_constant_shell("WordWithPrefixFn"), reader_make_constant_shell("WordWithSuffixFn"), reader_make_constant_shell("CompoundWordFn"), reader_make_constant_shell("WordFn"), reader_make_constant_shell("CompoundWordFn-HeadMedial"), reader_make_constant_shell("CompoundWordFn-HeadInitial")), makeKeyword("ANYTHING"));



    private static final SubLSymbol $sym164$DERIVED_WORD_ = makeSymbol("DERIVED-WORD?");



    private static final SubLSymbol $vulgar_words$ = makeSymbol("*VULGAR-WORDS*");



    private static final SubLList $list168 = list(makeUninternedSymbol("LINK-NODE"), makeUninternedSymbol("MT"), makeUninternedSymbol("TV"));

    private static final SubLString $str169$The_word_unit__S_is_neither_a_FOR = makeString("The word-unit ~S is neither a FORT nor a NAUT.");

    private static final SubLSymbol $sym170$VERB_ONLY_STRING_ = makeSymbol("VERB-ONLY-STRING?");

    private static final SubLSymbol $sym171$_VERB_ONLY_STRING__CACHING_STATE_ = makeSymbol("*VERB-ONLY-STRING?-CACHING-STATE*");

    private static final SubLSymbol $sym176$HLMT_ = makeSymbol("HLMT?");

    private static final SubLSymbol TYPED_DENOTS_OF_STRING = makeSymbol("TYPED-DENOTS-OF-STRING");

    private static final SubLList $list179 = list(new SubLObject[]{ makeSymbol("STRING"), makeSymbol("TYPE"), makeSymbol("&OPTIONAL"), list(makeSymbol("ABBREV-TYPES"), NIL), list(makeSymbol("DENOT-TYPE"), makeKeyword("DENOT")), list(makeSymbol("MISSPELLINGS?"), T), list(makeSymbol("SKIP-NAMESTRINGS?"), NIL), list(makeSymbol("LOOKUP-MT"), makeSymbol("*LEXICON-LOOKUP-MT*")), list(makeSymbol("SEMANTIC-MT"), reader_make_constant_shell("InferencePSC")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("*PARSE-MORPHOLOGICALLY*")), list(makeSymbol("EXCLUDED-PREDICATES"), makeSymbol("*SEMANTIC-PREDICATES-EXCLUDED-FROM-LEXICAL-LOOKUP*")) });

    private static final SubLString $str180$_param_STRING_string_____param_TY = makeString("@param STRING string\n   @param TYPE collection\n   @param PARSE-MORPHOLOGICALLY: PARSE-MORPHOLOGICALLY-OPTION-P\n                                  Do we attempt to parse STRING as a complex (multi-morpheme) word?\n   @return list; a list of denotata for STRING that are instances of TYPE\n   note that this function does some parsing, if the type sent in is appropriate");

    private static final SubLList $list181 = list(new SubLObject[]{ list(makeSymbol("STRING"), makeSymbol("STRINGP")), list(makeSymbol("TYPE"), makeSymbol("EL-FORT-P")), list(makeSymbol("ABBREV-TYPES"), makeSymbol("LISTP")), list(makeSymbol("DENOT-TYPE"), makeSymbol("KEYWORDP")), list(makeSymbol("MISSPELLINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("SKIP-NAMESTRINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("LOOKUP-MT"), makeSymbol("HLMT?")), list(makeSymbol("SEMANTIC-MT"), makeSymbol("HLMT?")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P")), list(makeSymbol("EXCLUDED-PREDICATES"), makeSymbol("SET-P")) });

    private static final SubLList $list182 = list(makeSymbol("LISTP"));

    private static final SubLSymbol $sym183$DENOT_HAS_TYPE_ = makeSymbol("DENOT-HAS-TYPE?");

    private static final SubLSymbol $sym184$DENOT_MIGHT_HAVE_TYPE_ = makeSymbol("DENOT-MIGHT-HAVE-TYPE?");





















    private static final SubLString $str196$_ = makeString("*");

    private static final SubLList $list197 = list(CHAR_asterisk);

    private static final SubLList $list198 = list(makeString("*"));

    private static final SubLString $str200$ = makeString("");

    private static final SubLString $str201$I_should_never_be_called___ = makeString("I should never be called...");

    private static final SubLSymbol LIST_OF_PREDICATES_P = makeSymbol("LIST-OF-PREDICATES-P");

    private static final SubLSymbol DENOTATION_MAPPER = makeSymbol("DENOTATION-MAPPER");

    static private final SubLList $list205 = list(makeSymbol("STRING"), makeSymbol("&OPTIONAL"), makeSymbol("EXCLUDED-PREDS"), list(makeSymbol("MODE"), makeKeyword("GREEDY")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("*PARSE-MORPHOLOGICALLY*")));

    private static final SubLString $str206$_param_STRING_string__the_string_ = makeString("@param STRING string; the string to map to its denotations\n   @param EXCLUDED-PREDS list; a list of semantic predicates which should be ignored when computing mappings \n   @param MODE keyword; :greedy or :diligent\n   @param PARSE-MORPHOLOGICALLY: PARSE-MORPHOLOGICALLY-OPTION-P\n                                  Do we attempt to parse STRING as a complex (multi-morpheme) word?\n   @return 0 LISTP; a list of STRING-TOKENs, each of which contains as its STRING-TOKEN-STRING some substring \n                    of STRING and as its STRING-TOKEN-VALUE a denotatum for that string\n   @return 1 LISTP; a list of STRING-TOKENS for which no denotatum could be found");

    private static final SubLList $list207 = list(list(makeSymbol("STRING"), makeSymbol("STRINGP")), list(makeSymbol("EXCLUDED-PREDS"), makeSymbol("LIST-OF-PREDICATES-P")), list(makeSymbol("MODE"), makeSymbol("KEYWORDP")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P")));

    static private final SubLList $list208 = list(list(makeSymbol("LIST"), makeSymbol("STRING-TOKEN-P")), list(makeSymbol("LIST"), makeSymbol("STRING-TOKEN-P")));

    private static final SubLList $list209 = list(makeKeyword("ABBREVS"), makeKeyword("ACRONYMS"));

    private static final SubLSymbol CYCL_STRING_P = makeSymbol("CYCL-STRING-P");

    private static final SubLSymbol $sym212$VALID_DENOTS_OF_STRING_LOOKUP_MT_SPECIFICATION_ = makeSymbol("VALID-DENOTS-OF-STRING-LOOKUP-MT-SPECIFICATION?");

    private static final SubLList $list213 = list(reader_make_constant_shell("termStrings"));

    private static final SubLSymbol DENOTS_OF_STRING = makeSymbol("DENOTS-OF-STRING");

    private static final SubLList $list215 = list(new SubLObject[]{ makeSymbol("STRING"), makeSymbol("&OPTIONAL"), list(makeSymbol("ABBREV-TYPES"), NIL), list(makeSymbol("DENOT-TYPE"), makeKeyword("DENOT")), list(makeSymbol("MISSPELLINGS?"), T), list(makeSymbol("SKIP-NAMESTRINGS?"), NIL), list(makeSymbol("LOOKUP-MT"), makeSymbol("*LEXICON-LOOKUP-MT*")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("*PARSE-MORPHOLOGICALLY*")), list(makeSymbol("PARSE-DATES-AND-NUMBERS?"), T), list(makeSymbol("LEXICON"), NIL) });

    private static final SubLString $str216$_param_PARSE_MORPHOLOGICALLY__PAR = makeString("@param PARSE-MORPHOLOGICALLY: PARSE-MORPHOLOGICALLY-OPTION-P\n                                  Do we attempt to parse STRING as a complex (multi-morpheme) word?\n   @param abbrev-types; listp: if it includes :abbrevs, include abbreviations;\n                               if it includes :acronyms, include acronyms\n   @param denot-type; keywordp: \n      :denot =  #$denotation assertions  (parsing)\n      :related = #$denotation and #$denotationRelatedTo (generation)\n      :any = #$denotation, #$denotationRelatedTo, and #$denotationPlaceholder\n   @param LOOKUP-MT: Lexical microtheory or ISO language code such as \'en\'.\n   @param PARSE-DATES-AND-NUMBERS? booleanp; if set to NIL, DENOTS-OF-STRING will only perform lexical lookup, and \n      not try to parse any dates or numbers\n   @param LEXICON term-lexicon-p; if present, LOOKUP-MT will be ignored and LEXICON will be used instead.\n   @return 0. LISTP ; CycL denotational terms serving as denotations for the phrase\n   @return 1. LISTP ; list of predicate lists for each denotation");

    private static final SubLList $list217 = list(list(makeSymbol("STRING"), makeSymbol("CYCL-STRING-P")), list(makeSymbol("ABBREV-TYPES"), makeSymbol("LISTP")), list(makeSymbol("DENOT-TYPE"), makeSymbol("KEYWORDP")), list(makeSymbol("MISSPELLINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("SKIP-NAMESTRINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("LOOKUP-MT"), makeSymbol("VALID-DENOTS-OF-STRING-LOOKUP-MT-SPECIFICATION?")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P")));

    private static final SubLSymbol DENOTS_MT_FOR_LANGUAGE = makeSymbol("DENOTS-MT-FOR-LANGUAGE");







    private static final SubLString $str222$_S_passes_neither_SPEECH_PART_PRE = makeString("~S passes neither SPEECH-PART-PRED? nor NAME-STRING-PRED?");

    private static final SubLSymbol $sym223$NAME_STRING_PRED_ = makeSymbol("NAME-STRING-PRED?");

    private static final SubLObject $$ProperNamePredicate_Strict = reader_make_constant_shell("ProperNamePredicate-Strict");

    private static final SubLList $list228 = list(reader_make_constant_shell("denotationRelatedTo"));

    private static final SubLList $list230 = list(reader_make_constant_shell("denotationPlaceholder"));

    private static final SubLList $list231 = list(reader_make_constant_shell("denotationRelatedTo"), reader_make_constant_shell("denotation"));

    private static final SubLList $list232 = list(reader_make_constant_shell("denotationPlaceholder"), reader_make_constant_shell("denotationRelatedTo"), reader_make_constant_shell("denotation"));

    private static final SubLList $list233 = list(reader_make_constant_shell("denotation"));









    private static final SubLSymbol $sym239$_ = makeSymbol("<");







    private static final SubLSymbol $sym244$_LEVEL = makeSymbol("?LEVEL");

    private static final SubLList $list245 = list(makeSymbol("?LEVEL"));

    private static final SubLList $list246 = list(reader_make_constant_shell("RudeSpeech"), reader_make_constant_shell("VulgarSpeech"), reader_make_constant_shell("ObjectionableSpeech"));

    private static final SubLSymbol $sym247$POTENTIALLY_OFFENSIVE_POLITENESS_LEVEL_ = makeSymbol("POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?");





    private static final SubLSymbol $sym250$INDIRECT_LEXICAL_ASSERTION_ = makeSymbol("INDIRECT-LEXICAL-ASSERTION?");

    private static final SubLObject $const251$DenotationPredicate_ExcludedFromN = reader_make_constant_shell("DenotationPredicate-ExcludedFromNPParser");

    private static final SubLSymbol $sym252$_INDIRECT_LEXICAL_ASSERTION__CACHING_STATE_ = makeSymbol("*INDIRECT-LEXICAL-ASSERTION?-CACHING-STATE*");

    private static final SubLSymbol $sym253$CLEAR_INDIRECT_LEXICAL_ASSERTION_ = makeSymbol("CLEAR-INDIRECT-LEXICAL-ASSERTION?");

    private static final SubLSymbol $sym255$GAF_ASSERTION_ = makeSymbol("GAF-ASSERTION?");







    private static final SubLSymbol AGR_OF_DET_STRING = makeSymbol("AGR-OF-DET-STRING");

    private static final SubLList $list262 = list(reader_make_constant_shell("nonSingular-Generic"));

    private static final SubLSymbol $agr_of_det_string_caching_state$ = makeSymbol("*AGR-OF-DET-STRING-CACHING-STATE*");



    private static final SubLSymbol POS_TO_SEMTRANS_PRED_CACHED = makeSymbol("POS-TO-SEMTRANS-PRED-CACHED");



    private static final SubLSymbol $pos_to_semtrans_pred_cached_caching_state$ = makeSymbol("*POS-TO-SEMTRANS-PRED-CACHED-CACHING-STATE*");

    private static final SubLSymbol CLEAR_POS_TO_SEMTRANS_PRED_CACHED = makeSymbol("CLEAR-POS-TO-SEMTRANS-PRED-CACHED");

    private static final SubLSymbol SEMTRANS_PRED_TO_POS = makeSymbol("SEMTRANS-PRED-TO-POS");

    private static final SubLSymbol $semtrans_pred_to_pos_caching_state$ = makeSymbol("*SEMTRANS-PRED-TO-POS-CACHING-STATE*");







    private static final SubLSymbol $speech_parts$ = makeSymbol("*SPEECH-PARTS*");

    private static final SubLSymbol $sym275$GENL_POS_ = makeSymbol("GENL-POS?");

    private static final SubLSymbol $sym276$_GENL_POS__CACHING_STATE_ = makeSymbol("*GENL-POS?-CACHING-STATE*");



    private static final SubLList $list278 = list(reader_make_constant_shell("PhraseFn"), reader_make_constant_shell("Adjective"));

    private static final SubLObject $$PhraseFn_Bar1 = reader_make_constant_shell("PhraseFn-Bar1");

    private static final SubLSymbol COMPOSITIONAL_POS_NART = makeSymbol("COMPOSITIONAL-POS-NART");

    private static final SubLSymbol $compositional_pos_nart_caching_state$ = makeSymbol("*COMPOSITIONAL-POS-NART-CACHING-STATE*");

    private static final SubLList $list282 = list(list(reader_make_constant_shell("PhraseFn"), reader_make_constant_shell("Noun")), reader_make_constant_shell("NounPhrase"));

    static private final SubLList $list283 = list(list(reader_make_constant_shell("PhraseFn"), reader_make_constant_shell("Preposition")), reader_make_constant_shell("PrepositionalPhrase"));

    private static final SubLList $list289 = list(list(T, list(ONE_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationToTypeFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR-TYPE")), list(TWO_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationFromTypeFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR-TYPE"))), list(NIL, list(ONE_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationToFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR")), list(TWO_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationFromFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR"))));









    private static final SubLList $list294 = list(ONE_INTEGER);

    private static final SubLSymbol $sym295$_PRED = makeSymbol("?PRED");

    private static final SubLList $list296 = list(makeSymbol("?PRED"), makeSymbol("?ARGNUM"));



    private static final SubLSymbol $sym299$SETS_EQUAL_EQUAL_ = makeSymbol("SETS-EQUAL-EQUAL?");

    private static final SubLList $list305 = list(list(list(makeString("ABEDA"), list(makeSymbol("ABBREV-TYPES"), makeKeyword("ACRONYMS"))), list(reader_make_constant_shell("ArabBankForEconomicDevelopmentInAfrica")), list(list(reader_make_constant_shell("acronymString")))), list(list(makeString("platform")), list(reader_make_constant_shell("Platform-Military"), reader_make_constant_shell("ComputerProcessor"), reader_make_constant_shell("PoliticalBeliefSystem"), reader_make_constant_shell("Platform")), list(list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("singular")))), list(list(makeString("chemical engineering")), list(reader_make_constant_shell("ChemicalEngineering")), list(list(reader_make_constant_shell("massNumber")))), list(list(makeString("heart attack")), list(reader_make_constant_shell("HeartAttack")), list(list(reader_make_constant_shell("singular")))), list(list(list(reader_make_constant_shell("UnicodeStringFn"), makeString("&u99ac;")), NIL, makeKeyword("DENOT"), NIL, NIL, reader_make_constant_shell("ChineseLexicalMt")), list(reader_make_constant_shell("Horse"), reader_make_constant_shell("YoYoMa-Cellist")), list(list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("familyName")))));

    private static final SubLString $str306$missing___S = makeString("missing: ~S");

    private static final SubLSymbol HL_TERM_WITH_EL_COUNTERPART_P = makeSymbol("HL-TERM-WITH-EL-COUNTERPART-P");

    private static final SubLSymbol HL_TERM_TO_EL_TERM = makeSymbol("HL-TERM-TO-EL-TERM");

    public static final SubLObject genl_lexicon_mtP_alt(SubLObject spec_mt, SubLObject genl_mt) {
        {
            SubLObject caching_state = $genl_lexicon_mtP_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name($sym0$GENL_LEXICON_MT_, $sym1$_GENL_LEXICON_MT__CACHING_STATE_, $int$512, EQUAL, TWO_INTEGER, ZERO_INTEGER);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(spec_mt, genl_mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (spec_mt.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && genl_mt.equal(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP_internal(spec_mt, genl_mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(spec_mt, genl_mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject genl_lexicon_mtP(final SubLObject spec_mt, final SubLObject genl_mt) {
        if ((spec_mt.equal(genl_mt) || (NIL != kb_utilities.kbeq(genl_mt, $$UniversalVocabularyMt))) || (NIL != kb_utilities.kbeq(spec_mt, $$InferencePSC))) {
            return T;
        }
        return genl_lexicon_mtP_cached(spec_mt, genl_mt);
    }

    public static SubLObject clear_genl_lexicon_mtP_cached() {
        final SubLObject cs = $genl_lexicon_mtP_cached_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static SubLObject remove_genl_lexicon_mtP_cached(final SubLObject spec_mt, final SubLObject genl_mt) {
        return memoization_state.caching_state_remove_function_results_with_args($genl_lexicon_mtP_cached_caching_state$.getGlobalValue(), list(spec_mt, genl_mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject genl_lexicon_mtP_cached_internal(final SubLObject spec_mt, final SubLObject genl_mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(spec_mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = mt_relevance_macros.relevant_mtP(genl_mt);
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static SubLObject genl_lexicon_mtP_cached(final SubLObject spec_mt, final SubLObject genl_mt) {
        SubLObject caching_state = $genl_lexicon_mtP_cached_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym2$GENL_LEXICON_MT__CACHED, $sym3$_GENL_LEXICON_MT__CACHED_CACHING_STATE_, $int$4096, EQUAL, TWO_INTEGER, ZERO_INTEGER);
            memoization_state.register_mt_dependent_cache_clear_callback($sym5$CLEAR_GENL_LEXICON_MT__CACHED);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(spec_mt, genl_mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (spec_mt.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && genl_mt.equal(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(genl_lexicon_mtP_cached_internal(spec_mt, genl_mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(spec_mt, genl_mt));
        return memoization_state.caching_results(results3);
    }

    /**
     * Initialize the cached functions and variables dealign with SpeechPart's and SpeechPartPredicate's. This is intended for use in the lexicon after addings for speechPartPreds @see add-speech-part-preds.
     *
     * @unknown Since after addings are generally only specified for predicates, new SpeechPart will only be recognized when there is a corresponding SpeechPartPredicate associated via speechPartPreds.
     */
    @LispMethod(comment = "Initialize the cached functions and variables dealign with SpeechPart\'s and SpeechPartPredicate\'s. This is intended for use in the lexicon after addings for speechPartPreds @see add-speech-part-preds.\r\n\r\n@unknown Since after addings are generally only specified for predicates, new SpeechPart will only be recognized when there is a corresponding SpeechPartPredicate associated via speechPartPreds.")
    public static final SubLObject initialize_speech_part_caches_alt() {
        com.cyc.cycjava.cycl.lexicon_accessors.clear_speech_part_pred_caches();
        com.cyc.cycjava.cycl.lexicon_accessors.initialize_derived_preds();
        com.cyc.cycjava.cycl.lexicon_accessors.initialize_closed_lexical_class_strings();
        com.cyc.cycjava.cycl.lexicon_accessors.initialize_speech_parts();
        com.cyc.cycjava.cycl.lexicon_accessors.initialize_speech_part_preds();
        return $INITIALIZED;
    }

    /**
     * Initialize the cached functions and variables dealign with SpeechPart's and SpeechPartPredicate's. This is intended for use in the lexicon after addings for speechPartPreds @see add-speech-part-preds.
     *
     * @unknown Since after addings are generally only specified for predicates, new SpeechPart will only be recognized when there is a corresponding SpeechPartPredicate associated via speechPartPreds.
     */
    @LispMethod(comment = "Initialize the cached functions and variables dealign with SpeechPart\'s and SpeechPartPredicate\'s. This is intended for use in the lexicon after addings for speechPartPreds @see add-speech-part-preds.\r\n\r\n@unknown Since after addings are generally only specified for predicates, new SpeechPart will only be recognized when there is a corresponding SpeechPartPredicate associated via speechPartPreds.")
    public static SubLObject initialize_speech_part_caches() {
        clear_speech_part_pred_caches();
        initialize_derived_preds();
        initialize_closed_lexical_class_strings();
        initialize_speech_parts();
        initialize_speech_part_preds();
        return $INITIALIZED;
    }

    /**
     * Filter NL-PRED-LIST, returning only those members which are
     * appropriate predicates for POS.
     */
    @LispMethod(comment = "Filter NL-PRED-LIST, returning only those members which are\r\nappropriate predicates for POS.\nFilter NL-PRED-LIST, returning only those members which are\nappropriate predicates for POS.")
    public static final SubLObject preds_matching_pos_alt(SubLObject nl_pred_list, SubLObject pos, SubLObject include_specsP) {
        if (include_specsP == UNPROVIDED) {
            include_specsP = NIL;
        }
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        if (nl_pred_list == $ALL) {
            nl_pred_list = com.cyc.cycjava.cycl.lexicon_accessors.top_level_nl_preds();
        }
        {
            SubLObject preds = (NIL != include_specsP) ? ((SubLObject) (com.cyc.cycjava.cycl.lexicon_accessors.all_preds_of_pos(pos))) : com.cyc.cycjava.cycl.lexicon_accessors.max_preds_of_pos(pos);
            return (NIL != nl_pred_list) && (NIL != preds) ? ((SubLObject) (lexicon_utilities.filter_lexicon_preds(nl_pred_list, preds, UNPROVIDED))) : NIL;
        }
    }

    /**
     * Filter NL-PRED-LIST, returning only those members which are
     * appropriate predicates for POS.
     */
    @LispMethod(comment = "Filter NL-PRED-LIST, returning only those members which are\r\nappropriate predicates for POS.\nFilter NL-PRED-LIST, returning only those members which are\nappropriate predicates for POS.")
    public static SubLObject preds_matching_pos(SubLObject nl_pred_list, final SubLObject pos, SubLObject include_specsP) {
        if (include_specsP == UNPROVIDED) {
            include_specsP = NIL;
        }
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        if (nl_pred_list == $ALL) {
            nl_pred_list = top_level_nl_preds();
        }
        final SubLObject preds = (NIL != include_specsP) ? all_preds_of_pos(pos) : max_preds_of_pos(pos);
        return (NIL != nl_pred_list) && (NIL != preds) ? lexicon_utilities.filter_lexicon_preds(nl_pred_list, preds, UNPROVIDED, UNPROVIDED) : NIL;
    }

    /**
     *
     *
     * @return LISTP of NL-preds of which every other NL pred is a spec-pred.
     */
    @LispMethod(comment = "@return LISTP of NL-preds of which every other NL pred is a spec-pred.")
    public static final SubLObject top_level_nl_preds_alt() {
        return list(lexicon_vars.$top_level_nl_pred$.getGlobalValue());
    }

    /**
     *
     *
     * @return LISTP of NL-preds of which every other NL pred is a spec-pred.
     */
    @LispMethod(comment = "@return LISTP of NL-preds of which every other NL pred is a spec-pred.")
    public static SubLObject top_level_nl_preds() {
        return list(lexicon_vars.$top_level_nl_pred$.getGlobalValue());
    }

    public static final SubLObject clear_speech_part_pred_caches_alt() {
        com.cyc.cycjava.cycl.lexicon_accessors.clear_max_preds_matching_pos_cached();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_max_preds_of_pos();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_max_preds_licensed_by_pos();
        lexicon_utilities.clear_preds_licensed_by_pos();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_speech_part_pred_min_ceilings_int();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_speech_part_pred_max_floors_int();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_derived_preds();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_speech_part_preds();
        return $CLEARED;
    }

    public static SubLObject clear_speech_part_pred_caches() {
        clear_max_preds_matching_pos_cached();
        clear_max_preds_of_pos();
        clear_max_preds_licensed_by_pos();
        lexicon_utilities.clear_preds_licensed_by_pos();
        clear_speech_part_pred_min_ceilings_int();
        clear_speech_part_pred_max_floors_int();
        clear_derived_preds();
        clear_speech_part_preds();
        return $CLEARED;
    }

    /**
     * filter NL-PRED-LIST, returning the min-ceiling of those members which are appropriate predicates for POS in MT
     */
    @LispMethod(comment = "filter NL-PRED-LIST, returning the min-ceiling of those members which are appropriate predicates for POS in MT")
    public static final SubLObject max_preds_matching_pos_alt(SubLObject nl_pred_list, SubLObject pos, SubLObject mt, SubLObject include_specsP) {
        if (include_specsP == UNPROVIDED) {
            include_specsP = NIL;
        }
        return NIL != kb_loaded() ? ((SubLObject) (copy_list(com.cyc.cycjava.cycl.lexicon_accessors.max_preds_matching_pos_cached(nl_pred_list, pos, mt, include_specsP)))) : NIL;
    }

    /**
     * filter NL-PRED-LIST, returning the min-ceiling of those members which are appropriate predicates for POS in MT
     */
    @LispMethod(comment = "filter NL-PRED-LIST, returning the min-ceiling of those members which are appropriate predicates for POS in MT")
    public static SubLObject max_preds_matching_pos(final SubLObject nl_pred_list, final SubLObject pos, final SubLObject mt, SubLObject include_specsP) {
        if (include_specsP == UNPROVIDED) {
            include_specsP = NIL;
        }
        return NIL != kb_loaded() ? copy_list(max_preds_matching_pos_cached(nl_pred_list, pos, mt, include_specsP)) : NIL;
    }

    public static final SubLObject clear_max_preds_matching_pos_cached_alt() {
        {
            SubLObject cs = $max_preds_matching_pos_cached_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_max_preds_matching_pos_cached() {
        final SubLObject cs = $max_preds_matching_pos_cached_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_max_preds_matching_pos_cached_alt(SubLObject nl_pred_list, SubLObject pos, SubLObject mt, SubLObject include_specsP) {
        return memoization_state.caching_state_remove_function_results_with_args($max_preds_matching_pos_cached_caching_state$.getGlobalValue(), list(nl_pred_list, pos, mt, include_specsP), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_max_preds_matching_pos_cached(final SubLObject nl_pred_list, final SubLObject pos, final SubLObject mt, final SubLObject include_specsP) {
        return memoization_state.caching_state_remove_function_results_with_args($max_preds_matching_pos_cached_caching_state$.getGlobalValue(), list(nl_pred_list, pos, mt, include_specsP), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject max_preds_matching_pos_cached_internal_alt(SubLObject nl_pred_list, SubLObject pos, SubLObject mt, SubLObject include_specsP) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject preds = com.cyc.cycjava.cycl.lexicon_accessors.preds_matching_pos(nl_pred_list, pos, include_specsP);
                SubLObject result = NIL;
                SubLObject mt_var = mt;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject nearest_common_genl_preds = com.cyc.cycjava.cycl.lexicon_accessors.speech_part_pred_min_ceilings(preds, UNPROVIDED);
                            result = (NIL != nearest_common_genl_preds) ? ((SubLObject) (nearest_common_genl_preds)) : preds;
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    public static SubLObject max_preds_matching_pos_cached_internal(final SubLObject nl_pred_list, final SubLObject pos, final SubLObject mt, final SubLObject include_specsP) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject preds = preds_matching_pos(nl_pred_list, pos, include_specsP);
        SubLObject result = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt), thread);
            final SubLObject nearest_common_genl_preds = speech_part_pred_min_ceilings(preds, UNPROVIDED);
            result = (NIL != nearest_common_genl_preds) ? nearest_common_genl_preds : preds;
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    public static final SubLObject max_preds_matching_pos_cached_alt(SubLObject nl_pred_list, SubLObject pos, SubLObject mt, SubLObject include_specsP) {
        {
            SubLObject caching_state = $max_preds_matching_pos_cached_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(MAX_PREDS_MATCHING_POS_CACHED, $max_preds_matching_pos_cached_caching_state$, NIL, EQUAL, FOUR_INTEGER, $int$32);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_4(nl_pred_list, pos, mt, include_specsP);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (nl_pred_list.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (pos.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (mt.equal(cached_args.first())) {
                                            cached_args = cached_args.rest();
                                            if (((NIL != cached_args) && (NIL == cached_args.rest())) && include_specsP.equal(cached_args.first())) {
                                                return memoization_state.caching_results(results2);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.max_preds_matching_pos_cached_internal(nl_pred_list, pos, mt, include_specsP)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(nl_pred_list, pos, mt, include_specsP));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject max_preds_matching_pos_cached(final SubLObject nl_pred_list, final SubLObject pos, final SubLObject mt, final SubLObject include_specsP) {
        SubLObject caching_state = $max_preds_matching_pos_cached_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(MAX_PREDS_MATCHING_POS_CACHED, $max_preds_matching_pos_cached_caching_state$, NIL, EQUAL, FOUR_INTEGER, $int$32);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_4(nl_pred_list, pos, mt, include_specsP);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (nl_pred_list.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (pos.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (mt.equal(cached_args.first())) {
                            cached_args = cached_args.rest();
                            if (((NIL != cached_args) && (NIL == cached_args.rest())) && include_specsP.equal(cached_args.first())) {
                                return memoization_state.caching_results(results2);
                            }
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(max_preds_matching_pos_cached_internal(nl_pred_list, pos, mt, include_specsP)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(nl_pred_list, pos, mt, include_specsP));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @return list of all pos preds appropriate for any spec of POS
     */
    @LispMethod(comment = "@return list of all pos preds appropriate for any spec of POS")
    public static final SubLObject all_preds_of_pos_alt(SubLObject pos) {
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        {
            SubLObject ans = NIL;
            SubLObject cdolist_list_var = genls.all_specs(pos, UNPROVIDED, UNPROVIDED);
            SubLObject spec_pos = NIL;
            for (spec_pos = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , spec_pos = cdolist_list_var.first()) {
                {
                    SubLObject cdolist_list_var_1 = lexicon_utilities.preds_of_pos(spec_pos, UNPROVIDED);
                    SubLObject pred = NIL;
                    for (pred = cdolist_list_var_1.first(); NIL != cdolist_list_var_1; cdolist_list_var_1 = cdolist_list_var_1.rest() , pred = cdolist_list_var_1.first()) {
                        {
                            SubLObject item_var = pred;
                            if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                ans = cons(item_var, ans);
                            }
                        }
                    }
                }
            }
            return ans;
        }
    }

    /**
     *
     *
     * @return list of all pos preds appropriate for any spec of POS
     */
    @LispMethod(comment = "@return list of all pos preds appropriate for any spec of POS")
    public static SubLObject all_preds_of_pos(final SubLObject pos) {
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = genls.all_specs(pos, UNPROVIDED, UNPROVIDED);
        SubLObject spec_pos = NIL;
        spec_pos = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$1 = lexicon_utilities.preds_of_pos(spec_pos, UNPROVIDED);
            SubLObject pred = NIL;
            pred = cdolist_list_var_$1.first();
            while (NIL != cdolist_list_var_$1) {
                final SubLObject item_var = pred;
                if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                    ans = cons(item_var, ans);
                }
                cdolist_list_var_$1 = cdolist_list_var_$1.rest();
                pred = cdolist_list_var_$1.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            spec_pos = cdolist_list_var.first();
        } 
        return ans;
    }

    public static final SubLObject clear_max_preds_of_pos_alt() {
        {
            SubLObject cs = $max_preds_of_pos_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_max_preds_of_pos() {
        final SubLObject cs = $max_preds_of_pos_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_max_preds_of_pos_alt(SubLObject pos) {
        return memoization_state.caching_state_remove_function_results_with_args($max_preds_of_pos_caching_state$.getGlobalValue(), list(pos), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_max_preds_of_pos(final SubLObject pos) {
        return memoization_state.caching_state_remove_function_results_with_args($max_preds_of_pos_caching_state$.getGlobalValue(), list(pos), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return list of maximal pos preds appropriate for POS
     */
    @LispMethod(comment = "@return list of maximal pos preds appropriate for POS")
    public static final SubLObject max_preds_of_pos_internal_alt(SubLObject pos) {
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        return com.cyc.cycjava.cycl.lexicon_accessors.lex_remove_spec_preds(lexicon_utilities.preds_of_pos(pos, UNPROVIDED));
    }

    /**
     *
     *
     * @return list of maximal pos preds appropriate for POS
     */
    @LispMethod(comment = "@return list of maximal pos preds appropriate for POS")
    public static SubLObject max_preds_of_pos_internal(final SubLObject pos) {
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        return lex_remove_spec_preds(lexicon_utilities.preds_of_pos(pos, UNPROVIDED));
    }

    public static final SubLObject max_preds_of_pos_alt(SubLObject pos) {
        {
            SubLObject caching_state = $max_preds_of_pos_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(MAX_PREDS_OF_POS, $max_preds_of_pos_caching_state$, NIL, EQL, ONE_INTEGER, ZERO_INTEGER);
                memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_MAX_PREDS_OF_POS);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, pos, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.max_preds_of_pos_internal(pos)));
                    memoization_state.caching_state_put(caching_state, pos, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject max_preds_of_pos(final SubLObject pos) {
        SubLObject caching_state = $max_preds_of_pos_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(MAX_PREDS_OF_POS, $max_preds_of_pos_caching_state$, NIL, EQL, ONE_INTEGER, ZERO_INTEGER);
            memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_MAX_PREDS_OF_POS);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, pos, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(max_preds_of_pos_internal(pos)));
            memoization_state.caching_state_put(caching_state, pos, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    public static final SubLObject clear_max_preds_licensed_by_pos_alt() {
        {
            SubLObject cs = $max_preds_licensed_by_pos_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_max_preds_licensed_by_pos() {
        final SubLObject cs = $max_preds_licensed_by_pos_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_max_preds_licensed_by_pos_alt(SubLObject pos) {
        return memoization_state.caching_state_remove_function_results_with_args($max_preds_licensed_by_pos_caching_state$.getGlobalValue(), list(pos), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_max_preds_licensed_by_pos(final SubLObject pos) {
        return memoization_state.caching_state_remove_function_results_with_args($max_preds_licensed_by_pos_caching_state$.getGlobalValue(), list(pos), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return list of maximal pos preds generatable from POS forms
     */
    @LispMethod(comment = "@return list of maximal pos preds generatable from POS forms")
    public static final SubLObject max_preds_licensed_by_pos_internal_alt(SubLObject pos) {
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        return com.cyc.cycjava.cycl.lexicon_accessors.lex_remove_spec_preds(lexicon_utilities.preds_licensed_by_pos(pos));
    }

    /**
     *
     *
     * @return list of maximal pos preds generatable from POS forms
     */
    @LispMethod(comment = "@return list of maximal pos preds generatable from POS forms")
    public static SubLObject max_preds_licensed_by_pos_internal(final SubLObject pos) {
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        return lex_remove_spec_preds(lexicon_utilities.preds_licensed_by_pos(pos));
    }

    public static final SubLObject max_preds_licensed_by_pos_alt(SubLObject pos) {
        {
            SubLObject caching_state = $max_preds_licensed_by_pos_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(MAX_PREDS_LICENSED_BY_POS, $max_preds_licensed_by_pos_caching_state$, NIL, EQL, ONE_INTEGER, ZERO_INTEGER);
                memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_MAX_PREDS_LICENSED_BY_POS);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, pos, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.max_preds_licensed_by_pos_internal(pos)));
                    memoization_state.caching_state_put(caching_state, pos, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject max_preds_licensed_by_pos(final SubLObject pos) {
        SubLObject caching_state = $max_preds_licensed_by_pos_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(MAX_PREDS_LICENSED_BY_POS, $max_preds_licensed_by_pos_caching_state$, NIL, EQL, ONE_INTEGER, ZERO_INTEGER);
            memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_MAX_PREDS_LICENSED_BY_POS);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, pos, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(max_preds_licensed_by_pos_internal(pos)));
            memoization_state.caching_state_put(caching_state, pos, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     * Remove any items from POS-PREDS that are spec-preds of anything else in POS-PREDS.
     */
    @LispMethod(comment = "Remove any items from POS-PREDS that are spec-preds of anything else in POS-PREDS.")
    public static final SubLObject lex_remove_spec_preds_alt(SubLObject pos_preds) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject state = memoization_state.possibly_new_memoization_state();
                SubLObject local_state = state;
                {
                    SubLObject _prev_bind_0 = memoization_state.$memoization_state$.currentBinding(thread);
                    try {
                        memoization_state.$memoization_state$.bind(local_state, thread);
                        {
                            SubLObject original_memoization_process = NIL;
                            if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                {
                                    SubLObject current_proc = current_process();
                                    if (NIL == original_memoization_process) {
                                        memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                    } else {
                                        if (original_memoization_process != current_proc) {
                                            Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                        }
                                    }
                                }
                            }
                            try {
                                {
                                    SubLObject _prev_bind_0_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                                    try {
                                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                                        mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                                        {
                                            SubLObject remain = NIL;
                                            for (remain = pos_preds; NIL != remain; remain = remain.rest()) {
                                                {
                                                    SubLObject datum = remain;
                                                    SubLObject current = datum;
                                                    SubLObject now = NIL;
                                                    SubLObject later = NIL;
                                                    destructuring_bind_must_consp(current, datum, $list_alt20);
                                                    now = current.first();
                                                    current = current.rest();
                                                    later = current;
                                                    {
                                                        SubLObject removeP = NIL;
                                                        if (NIL == removeP) {
                                                            {
                                                                SubLObject csome_list_var = later;
                                                                SubLObject other = NIL;
                                                                for (other = csome_list_var.first(); !((NIL != removeP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , other = csome_list_var.first()) {
                                                                    if (NIL != subl_promotions.memberP(now, com.cyc.cycjava.cycl.lexicon_accessors.lex_remove_spec_preds_helper(other), UNPROVIDED, UNPROVIDED)) {
                                                                        removeP = T;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if (NIL == removeP) {
                                                            {
                                                                SubLObject csome_list_var = ans;
                                                                SubLObject other = NIL;
                                                                for (other = csome_list_var.first(); !((NIL != removeP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , other = csome_list_var.first()) {
                                                                    if (NIL != subl_promotions.memberP(now, com.cyc.cycjava.cycl.lexicon_accessors.lex_remove_spec_preds_helper(other), UNPROVIDED, UNPROVIDED)) {
                                                                        removeP = T;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if (NIL == removeP) {
                                                            ans = cons(now, ans);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } finally {
                                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0_2, thread);
                                    }
                                }
                            } finally {
                                {
                                    SubLObject _prev_bind_0_3 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                    try {
                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                        if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                            memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                        }
                                    } finally {
                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_3, thread);
                                    }
                                }
                            }
                        }
                    } finally {
                        memoization_state.$memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Remove any items from POS-PREDS that are spec-preds of anything else in POS-PREDS.
     */
    @LispMethod(comment = "Remove any items from POS-PREDS that are spec-preds of anything else in POS-PREDS.")
    public static SubLObject lex_remove_spec_preds(final SubLObject pos_preds) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject local_state;
        final SubLObject state = local_state = memoization_state.possibly_new_memoization_state();
        final SubLObject _prev_bind_0 = memoization_state.$memoization_state$.currentBinding(thread);
        try {
            memoization_state.$memoization_state$.bind(local_state, thread);
            final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
            try {
                final SubLObject _prev_bind_0_$2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    SubLObject remain;
                    SubLObject current;
                    SubLObject datum;
                    SubLObject now;
                    SubLObject later;
                    SubLObject removeP;
                    SubLObject csome_list_var;
                    SubLObject other;
                    for (remain = NIL, remain = pos_preds; NIL != remain; remain = remain.rest()) {
                        datum = current = remain;
                        now = NIL;
                        later = NIL;
                        destructuring_bind_must_consp(current, datum, $list21);
                        now = current.first();
                        current = later = current.rest();
                        removeP = NIL;
                        if (NIL == removeP) {
                            csome_list_var = later;
                            other = NIL;
                            other = csome_list_var.first();
                            while ((NIL == removeP) && (NIL != csome_list_var)) {
                                if (NIL != subl_promotions.memberP(now, lex_remove_spec_preds_helper(other), UNPROVIDED, UNPROVIDED)) {
                                    removeP = T;
                                }
                                csome_list_var = csome_list_var.rest();
                                other = csome_list_var.first();
                            } 
                        }
                        if (NIL == removeP) {
                            csome_list_var = ans;
                            other = NIL;
                            other = csome_list_var.first();
                            while ((NIL == removeP) && (NIL != csome_list_var)) {
                                if (NIL != subl_promotions.memberP(now, lex_remove_spec_preds_helper(other), UNPROVIDED, UNPROVIDED)) {
                                    removeP = T;
                                }
                                csome_list_var = csome_list_var.rest();
                                other = csome_list_var.first();
                            } 
                        }
                        if (NIL == removeP) {
                            ans = cons(now, ans);
                        }
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0_$2, thread);
                }
            } finally {
                final SubLObject _prev_bind_0_$3 = $is_thread_performing_cleanupP$.currentBinding(thread);
                try {
                    $is_thread_performing_cleanupP$.bind(T, thread);
                    final SubLObject _values = getValuesAsVector();
                    memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                    restoreValuesFromVector(_values);
                } finally {
                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$3, thread);
                }
            }
        } finally {
            memoization_state.$memoization_state$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject lex_remove_spec_preds_helper_internal_alt(SubLObject v_term) {
        return genl_predicates.all_spec_preds(v_term, UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject lex_remove_spec_preds_helper_internal(final SubLObject v_term) {
        return genl_predicates.all_spec_preds(v_term, UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject lex_remove_spec_preds_helper_alt(SubLObject v_term) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
                SubLObject caching_state = NIL;
                if (NIL == v_memoization_state) {
                    return com.cyc.cycjava.cycl.lexicon_accessors.lex_remove_spec_preds_helper_internal(v_term);
                }
                caching_state = memoization_state.memoization_state_lookup(v_memoization_state, LEX_REMOVE_SPEC_PREDS_HELPER, UNPROVIDED);
                if (NIL == caching_state) {
                    caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), LEX_REMOVE_SPEC_PREDS_HELPER, ONE_INTEGER, NIL, EQL, UNPROVIDED);
                    memoization_state.memoization_state_put(v_memoization_state, LEX_REMOVE_SPEC_PREDS_HELPER, caching_state);
                }
                {
                    SubLObject results = memoization_state.caching_state_lookup(caching_state, v_term, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                    if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                        results = arg2(thread.resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.lex_remove_spec_preds_helper_internal(v_term)));
                        memoization_state.caching_state_put(caching_state, v_term, results, UNPROVIDED);
                    }
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject lex_remove_spec_preds_helper(final SubLObject v_term) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return lex_remove_spec_preds_helper_internal(v_term);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, LEX_REMOVE_SPEC_PREDS_HELPER, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), LEX_REMOVE_SPEC_PREDS_HELPER, ONE_INTEGER, NIL, EQL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, LEX_REMOVE_SPEC_PREDS_HELPER, caching_state);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, v_term, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(thread.resetMultipleValues(), multiple_value_list(lex_remove_spec_preds_helper_internal(v_term)));
            memoization_state.caching_state_put(caching_state, v_term, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    public static final SubLObject speech_part_pred_min_ceilings_alt(SubLObject preds, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = mt_relevance_macros.$mt$.getDynamicValue();
        }
        return copy_list(com.cyc.cycjava.cycl.lexicon_accessors.speech_part_pred_min_ceilings_int(preds, mt));
    }

    public static SubLObject speech_part_pred_min_ceilings(final SubLObject preds, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = mt_relevance_macros.$mt$.getDynamicValue();
        }
        return copy_list(speech_part_pred_min_ceilings_int(preds, mt));
    }

    public static final SubLObject clear_speech_part_pred_min_ceilings_int_alt() {
        {
            SubLObject cs = $speech_part_pred_min_ceilings_int_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_speech_part_pred_min_ceilings_int() {
        final SubLObject cs = $speech_part_pred_min_ceilings_int_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_speech_part_pred_min_ceilings_int_alt(SubLObject preds, SubLObject mt) {
        return memoization_state.caching_state_remove_function_results_with_args($speech_part_pred_min_ceilings_int_caching_state$.getGlobalValue(), list(preds, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_speech_part_pred_min_ceilings_int(final SubLObject preds, final SubLObject mt) {
        return memoization_state.caching_state_remove_function_results_with_args($speech_part_pred_min_ceilings_int_caching_state$.getGlobalValue(), list(preds, mt), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject speech_part_pred_min_ceilings_int_internal_alt(SubLObject preds, SubLObject mt) {
        return genl_predicates.min_ceiling_predicates(preds, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject speech_part_pred_min_ceilings_int_internal(final SubLObject preds, final SubLObject mt) {
        return genl_predicates.min_ceiling_predicates(preds, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject speech_part_pred_min_ceilings_int_alt(SubLObject preds, SubLObject mt) {
        {
            SubLObject caching_state = $speech_part_pred_min_ceilings_int_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(SPEECH_PART_PRED_MIN_CEILINGS_INT, $speech_part_pred_min_ceilings_int_caching_state$, $int$512, EQUAL, TWO_INTEGER, ZERO_INTEGER);
                memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_SPEECH_PART_PRED_MIN_CEILINGS_INT);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(preds, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (preds.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.speech_part_pred_min_ceilings_int_internal(preds, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(preds, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject speech_part_pred_min_ceilings_int(final SubLObject preds, final SubLObject mt) {
        SubLObject caching_state = $speech_part_pred_min_ceilings_int_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(SPEECH_PART_PRED_MIN_CEILINGS_INT, $speech_part_pred_min_ceilings_int_caching_state$, $int$512, EQUAL, TWO_INTEGER, ZERO_INTEGER);
            memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_SPEECH_PART_PRED_MIN_CEILINGS_INT);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(preds, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (preds.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(speech_part_pred_min_ceilings_int_internal(preds, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(preds, mt));
        return memoization_state.caching_results(results3);
    }

    public static final SubLObject speech_part_pred_max_floors_alt(SubLObject preds, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject ans = com.cyc.cycjava.cycl.lexicon_accessors.speech_part_pred_max_floors_int(preds, mt);
            return copy_list(ans);
        }
    }

    public static SubLObject speech_part_pred_max_floors(final SubLObject preds, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLObject ans = speech_part_pred_max_floors_int(preds, mt);
        return copy_list(ans);
    }

    public static final SubLObject clear_speech_part_pred_max_floors_int_alt() {
        {
            SubLObject cs = $speech_part_pred_max_floors_int_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_speech_part_pred_max_floors_int() {
        final SubLObject cs = $speech_part_pred_max_floors_int_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_speech_part_pred_max_floors_int_alt(SubLObject preds, SubLObject mt) {
        return memoization_state.caching_state_remove_function_results_with_args($speech_part_pred_max_floors_int_caching_state$.getGlobalValue(), list(preds, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_speech_part_pred_max_floors_int(final SubLObject preds, final SubLObject mt) {
        return memoization_state.caching_state_remove_function_results_with_args($speech_part_pred_max_floors_int_caching_state$.getGlobalValue(), list(preds, mt), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject speech_part_pred_max_floors_int_internal_alt(SubLObject preds, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = genl_predicates.max_floor_predicates(preds, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    public static SubLObject speech_part_pred_max_floors_int_internal(final SubLObject preds, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = genl_predicates.max_floor_predicates(preds, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject speech_part_pred_max_floors_int_alt(SubLObject preds, SubLObject mt) {
        {
            SubLObject caching_state = $speech_part_pred_max_floors_int_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(SPEECH_PART_PRED_MAX_FLOORS_INT, $speech_part_pred_max_floors_int_caching_state$, $int$512, EQUAL, TWO_INTEGER, ZERO_INTEGER);
                memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_SPEECH_PART_PRED_MAX_FLOORS_INT);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(preds, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (preds.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.speech_part_pred_max_floors_int_internal(preds, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(preds, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject speech_part_pred_max_floors_int(final SubLObject preds, final SubLObject mt) {
        SubLObject caching_state = $speech_part_pred_max_floors_int_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(SPEECH_PART_PRED_MAX_FLOORS_INT, $speech_part_pred_max_floors_int_caching_state$, $int$512, EQUAL, TWO_INTEGER, ZERO_INTEGER);
            memoization_state.register_genl_preds_dependent_cache_clear_callback(CLEAR_SPEECH_PART_PRED_MAX_FLOORS_INT);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(preds, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (preds.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(speech_part_pred_max_floors_int_internal(preds, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(preds, mt));
        return memoization_state.caching_results(results3);
    }

    public static final SubLObject clear_pos_of_pred_alt() {
        {
            SubLObject cs = $pos_of_pred_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_pos_of_pred() {
        final SubLObject cs = $pos_of_pred_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_pos_of_pred_alt(SubLObject pred) {
        return memoization_state.caching_state_remove_function_results_with_args($pos_of_pred_caching_state$.getGlobalValue(), list(pred), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_pos_of_pred(final SubLObject pred) {
        return memoization_state.caching_state_remove_function_results_with_args($pos_of_pred_caching_state$.getGlobalValue(), list(pred), UNPROVIDED, UNPROVIDED);
    }

    /**
     * Return appropriate part of speech for pred.
     */
    @LispMethod(comment = "Return appropriate part of speech for pred.")
    public static final SubLObject pos_of_pred_internal_alt(SubLObject pred) {
        SubLTrampolineFile.checkType(pred, $sym29$SPEECH_PART_PRED_);
        return (NIL != indexed_term_p(pred)) && (NIL != valid_constantP($$speechPartPreds, UNPROVIDED)) ? ((SubLObject) (Sort.sort(kb_mapping_utilities.pred_values_in_any_mt(pred, $$speechPartPreds, TWO_INTEGER, ONE_INTEGER, UNPROVIDED), $sym31$SPEC_POS_, UNPROVIDED).first())) : NIL;
    }

    /**
     * Return appropriate part of speech for pred.
     */
    @LispMethod(comment = "Return appropriate part of speech for pred.")
    public static SubLObject pos_of_pred_internal(final SubLObject pred) {
        assert NIL != speech_part_predP(pred, UNPROVIDED) : "! lexicon_accessors.speech_part_predP(pred, .UNPROVIDED) " + ("lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) ") + pred;
        return (NIL != indexed_term_p(pred)) && (NIL != valid_constantP($$speechPartPreds, UNPROVIDED)) ? Sort.sort(kb_mapping_utilities.pred_values_in_any_mt(pred, $$speechPartPreds, TWO_INTEGER, ONE_INTEGER, UNPROVIDED), $sym33$SPEC_POS_, UNPROVIDED).first() : NIL;
    }

    public static final SubLObject pos_of_pred_alt(SubLObject pred) {
        {
            SubLObject caching_state = $pos_of_pred_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(POS_OF_PRED, $pos_of_pred_caching_state$, NIL, EQL, ONE_INTEGER, $int$32);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, pred, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.pos_of_pred_internal(pred)));
                    memoization_state.caching_state_put(caching_state, pred, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject pos_of_pred(final SubLObject pred) {
        SubLObject caching_state = $pos_of_pred_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(POS_OF_PRED, $pos_of_pred_caching_state$, $int$128, EQL, ONE_INTEGER, $int$32);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, pred, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(pos_of_pred_internal(pred)));
            memoization_state.caching_state_put(caching_state, pred, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     * Given POS, a #$SpeechPart, return the instance of
     * #$SpeechPartPredicate that represents the singular form of POS.
     */
    @LispMethod(comment = "Given POS, a #$SpeechPart, return the instance of\r\n#$SpeechPartPredicate that represents the singular form of POS.\nGiven POS, a #$SpeechPart, return the instance of\n#$SpeechPartPredicate that represents the singular form of POS.")
    public static final SubLObject singular_pred_alt(SubLObject pos) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            if (!((NIL != valid_constantP($$Noun, UNPROVIDED)) && (NIL != genls.genl_in_any_mtP(pos, $$Noun)))) {
                return NIL;
            }
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                        mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                        if (NIL != valid_constantP($$singular_Generic, UNPROVIDED)) {
                            if (NIL == ans) {
                                {
                                    SubLObject csome_list_var = lexicon_utilities.preds_of_pos(pos, UNPROVIDED);
                                    SubLObject pred = NIL;
                                    for (pred = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pred = csome_list_var.first()) {
                                        if (NIL != genl_predicates.genl_predP(pred, $$singular_Generic, UNPROVIDED, UNPROVIDED)) {
                                            ans = pred;
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Given POS, a #$SpeechPart, return the instance of
     * #$SpeechPartPredicate that represents the singular form of POS.
     */
    @LispMethod(comment = "Given POS, a #$SpeechPart, return the instance of\r\n#$SpeechPartPredicate that represents the singular form of POS.\nGiven POS, a #$SpeechPart, return the instance of\n#$SpeechPartPredicate that represents the singular form of POS.")
    public static SubLObject singular_pred(final SubLObject pos) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        if ((NIL == valid_constantP($$Noun, UNPROVIDED)) || (NIL == genls.genl_in_any_mtP(pos, $$Noun))) {
            return NIL;
        }
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if ((NIL != valid_constantP($$singular_Generic, UNPROVIDED)) && (NIL == ans)) {
                SubLObject csome_list_var = lexicon_utilities.preds_of_pos(pos, UNPROVIDED);
                SubLObject pred = NIL;
                pred = csome_list_var.first();
                while ((NIL == ans) && (NIL != csome_list_var)) {
                    if (NIL != genl_predicates.genl_predP(pred, $$singular_Generic, UNPROVIDED, UNPROVIDED)) {
                        ans = pred;
                    }
                    csome_list_var = csome_list_var.rest();
                    pred = csome_list_var.first();
                } 
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Given POS, a #$SpeechPart, return the instance of
     * #$SpeechPartPredicate that represents the plural form of POS.
     */
    @LispMethod(comment = "Given POS, a #$SpeechPart, return the instance of\r\n#$SpeechPartPredicate that represents the plural form of POS.\nGiven POS, a #$SpeechPart, return the instance of\n#$SpeechPartPredicate that represents the plural form of POS.")
    public static final SubLObject plural_pred_alt(SubLObject pos) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            if (!((NIL != valid_constantP($$Noun, UNPROVIDED)) && (NIL != genls.genl_in_any_mtP(pos, $$Noun)))) {
                return NIL;
            }
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                        mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                        if (NIL != valid_constantP($$plural_Generic, UNPROVIDED)) {
                            if (NIL == ans) {
                                {
                                    SubLObject csome_list_var = lexicon_utilities.preds_of_pos(pos, UNPROVIDED);
                                    SubLObject pred = NIL;
                                    for (pred = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pred = csome_list_var.first()) {
                                        if (NIL != genl_predicates.genl_predP(pred, $$plural_Generic, UNPROVIDED, UNPROVIDED)) {
                                            ans = pred;
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Given POS, a #$SpeechPart, return the instance of
     * #$SpeechPartPredicate that represents the plural form of POS.
     */
    @LispMethod(comment = "Given POS, a #$SpeechPart, return the instance of\r\n#$SpeechPartPredicate that represents the plural form of POS.\nGiven POS, a #$SpeechPart, return the instance of\n#$SpeechPartPredicate that represents the plural form of POS.")
    public static SubLObject plural_pred(final SubLObject pos) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        if ((NIL == valid_constantP($$Noun, UNPROVIDED)) || (NIL == genls.genl_in_any_mtP(pos, $$Noun))) {
            return NIL;
        }
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if ((NIL != valid_constantP($$plural_Generic, UNPROVIDED)) && (NIL == ans)) {
                SubLObject csome_list_var = lexicon_utilities.preds_of_pos(pos, UNPROVIDED);
                SubLObject pred = NIL;
                pred = csome_list_var.first();
                while ((NIL == ans) && (NIL != csome_list_var)) {
                    if (NIL != genl_predicates.genl_predP(pred, $$plural_Generic, UNPROVIDED, UNPROVIDED)) {
                        ans = pred;
                    }
                    csome_list_var = csome_list_var.rest();
                    pred = csome_list_var.first();
                } 
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject derived_preds_alt() {
        return $derived_preds$.getGlobalValue();
    }

    public static SubLObject derived_preds() {
        return $derived_preds$.getGlobalValue();
    }

    public static final SubLObject clear_derived_preds_alt() {
        morphology.clear_pos_preds_derivable_from_pred_int();
        return clrhash($derived_preds$.getGlobalValue());
    }

    public static SubLObject clear_derived_preds() {
        morphology.clear_pos_preds_derivable_from_pred_int();
        return clrhash($derived_preds$.getGlobalValue());
    }

    /**
     * Initialize @xref *DERIVED-PREDS* from the KB.
     */
    @LispMethod(comment = "Initialize @xref *DERIVED-PREDS* from the KB.")
    public static final SubLObject initialize_derived_preds_alt() {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            com.cyc.cycjava.cycl.lexicon_accessors.clear_derived_preds();
            {
                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    if (NIL != valid_constantP($$regularSuffix, UNPROVIDED)) {
                        {
                            SubLObject pred_var = $$regularSuffix;
                            if (NIL != kb_mapping_macros.do_predicate_extent_index_key_validator(pred_var)) {
                                {
                                    SubLObject iterator_var = kb_mapping_macros.new_predicate_extent_final_index_spec_iterator(pred_var);
                                    SubLObject done_var = NIL;
                                    SubLObject token_var = NIL;
                                    while (NIL == done_var) {
                                        {
                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                            if (NIL != valid) {
                                                {
                                                    SubLObject final_index_iterator = NIL;
                                                    try {
                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, NIL, NIL);
                                                        {
                                                            SubLObject done_var_4 = NIL;
                                                            SubLObject token_var_5 = NIL;
                                                            while (NIL == done_var_4) {
                                                                {
                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_5);
                                                                    SubLObject valid_6 = makeBoolean(token_var_5 != as);
                                                                    if (NIL != valid_6) {
                                                                        {
                                                                            SubLObject derived_pred = assertions_high.gaf_arg1(as);
                                                                            SubLObject mt = assertions_high.assertion_mt(as);
                                                                            hash_table_utilities.pushnew_hash(derived_pred, mt, $derived_preds$.getGlobalValue(), UNPROVIDED);
                                                                        }
                                                                    }
                                                                    done_var_4 = makeBoolean(NIL == valid_6);
                                                                }
                                                            } 
                                                        }
                                                    } finally {
                                                        {
                                                            SubLObject _prev_bind_0_7 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_7, thread);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            done_var = makeBoolean(NIL == valid);
                                        }
                                    } 
                                }
                            }
                        }
                    }
                    if ((NIL != valid_constantP($$ProperNoun, UNPROVIDED)) && (NIL != valid_constantP($$speechPartPreds, UNPROVIDED))) {
                        {
                            SubLObject node_var = $$ProperNoun;
                            SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
                            SubLObject recur_deck = deck.create_deck(deck_type);
                            {
                                SubLObject _prev_bind_0_8 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                                try {
                                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                    {
                                        SubLObject tv_var = NIL;
                                        {
                                            SubLObject _prev_bind_0_9 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                            SubLObject _prev_bind_1_10 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                            try {
                                                sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? ((SubLObject) (tv_var)) : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV)) : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                                if (NIL != tv_var) {
                                                    if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
                                                        if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
                                                            {
                                                                SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                                                if (pcase_var.eql($ERROR)) {
                                                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                } else {
                                                                    if (pcase_var.eql($CERROR)) {
                                                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                    } else {
                                                                        if (pcase_var.eql($WARN)) {
                                                                            Errors.warn($str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        } else {
                                                                            Errors.warn($str_alt51$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                                            Errors.cerror($$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    SubLObject _prev_bind_0_11 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                                    SubLObject _prev_bind_1_12 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                                    SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                                    SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                    SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                    try {
                                                        sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                        sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$ProperNoun, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                                            {
                                                                SubLObject _prev_bind_0_13 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_1_14 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_2_15 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                try {
                                                                    sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                                                    while (NIL != node_var) {
                                                                        {
                                                                            SubLObject pos = node_var;
                                                                            SubLObject pred_var = $$speechPartPreds;
                                                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pos, NIL, pred_var)) {
                                                                                {
                                                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pos, NIL, pred_var);
                                                                                    SubLObject done_var = NIL;
                                                                                    SubLObject token_var = NIL;
                                                                                    while (NIL == done_var) {
                                                                                        {
                                                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                                            if (NIL != valid) {
                                                                                                {
                                                                                                    SubLObject final_index_iterator = NIL;
                                                                                                    try {
                                                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                                                        {
                                                                                                            SubLObject done_var_16 = NIL;
                                                                                                            SubLObject token_var_17 = NIL;
                                                                                                            while (NIL == done_var_16) {
                                                                                                                {
                                                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_17);
                                                                                                                    SubLObject valid_18 = makeBoolean(token_var_17 != as);
                                                                                                                    if (NIL != valid_18) {
                                                                                                                        {
                                                                                                                            SubLObject spp = assertions_high.gaf_arg2(as);
                                                                                                                            SubLObject mt = assertions_high.assertion_mt(as);
                                                                                                                            hash_table_utilities.pushnew_hash(spp, mt, $derived_preds$.getGlobalValue(), UNPROVIDED);
                                                                                                                        }
                                                                                                                    }
                                                                                                                    done_var_16 = makeBoolean(NIL == valid_18);
                                                                                                                }
                                                                                                            } 
                                                                                                        }
                                                                                                    } finally {
                                                                                                        {
                                                                                                            SubLObject _prev_bind_0_19 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                                            try {
                                                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                                                if (NIL != final_index_iterator) {
                                                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                                                }
                                                                                                            } finally {
                                                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_19, thread);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            done_var = makeBoolean(NIL == valid);
                                                                                        }
                                                                                    } 
                                                                                }
                                                                            }
                                                                        }
                                                                        {
                                                                            SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                                                            SubLObject cdolist_list_var = accessible_modules;
                                                                            SubLObject module_var = NIL;
                                                                            for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                {
                                                                                    SubLObject _prev_bind_0_20 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                    SubLObject _prev_bind_1_21 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                        {
                                                                                            SubLObject node = function_terms.naut_to_nart(node_var);
                                                                                            if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                {
                                                                                                    SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                    if (NIL != d_link) {
                                                                                                        {
                                                                                                            SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                            if (NIL != mt_links) {
                                                                                                                {
                                                                                                                    SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                    while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                        thread.resetMultipleValues();
                                                                                                                        {
                                                                                                                            SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                            SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                            thread.resetMultipleValues();
                                                                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                {
                                                                                                                                    SubLObject _prev_bind_0_22 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                    try {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                        {
                                                                                                                                            SubLObject iteration_state_23 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                            while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_23)) {
                                                                                                                                                thread.resetMultipleValues();
                                                                                                                                                {
                                                                                                                                                    SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_23);
                                                                                                                                                    SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                                    if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                        {
                                                                                                                                                            SubLObject _prev_bind_0_24 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                            try {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                {
                                                                                                                                                                    SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                    SubLObject cdolist_list_var_25 = new_list;
                                                                                                                                                                    SubLObject node_vars_link_node = NIL;
                                                                                                                                                                    for (node_vars_link_node = cdolist_list_var_25.first(); NIL != cdolist_list_var_25; cdolist_list_var_25 = cdolist_list_var_25.rest() , node_vars_link_node = cdolist_list_var_25.first()) {
                                                                                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                                                            deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            } finally {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_24, thread);
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    iteration_state_23 = dictionary_contents.do_dictionary_contents_next(iteration_state_23);
                                                                                                                                                }
                                                                                                                                            } 
                                                                                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_23);
                                                                                                                                        }
                                                                                                                                    } finally {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_22, thread);
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                        }
                                                                                                                    } 
                                                                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                    {
                                                                                                        SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                        SubLObject cdolist_list_var_26 = new_list;
                                                                                                        SubLObject generating_fn = NIL;
                                                                                                        for (generating_fn = cdolist_list_var_26.first(); NIL != cdolist_list_var_26; cdolist_list_var_26 = cdolist_list_var_26.rest() , generating_fn = cdolist_list_var_26.first()) {
                                                                                                            {
                                                                                                                SubLObject _prev_bind_0_27 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                try {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                    {
                                                                                                                        SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                        SubLObject new_list_28 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                        SubLObject cdolist_list_var_29 = new_list_28;
                                                                                                                        SubLObject node_vars_link_node = NIL;
                                                                                                                        for (node_vars_link_node = cdolist_list_var_29.first(); NIL != cdolist_list_var_29; cdolist_list_var_29 = cdolist_list_var_29.rest() , node_vars_link_node = cdolist_list_var_29.first()) {
                                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } finally {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_27, thread);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } finally {
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_21, thread);
                                                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_20, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        node_var = deck.deck_pop(recur_deck);
                                                                    } 
                                                                } finally {
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_15, thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_14, thread);
                                                                    sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_13, thread);
                                                                }
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str_alt55$Node__a_does_not_pass_sbhl_type_t, $$ProperNoun, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } finally {
                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4, thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_3, thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_2, thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_12, thread);
                                                        sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_11, thread);
                                                    }
                                                }
                                            } finally {
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_10, thread);
                                                sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_9, thread);
                                            }
                                        }
                                        sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                    }
                                } finally {
                                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_8, thread);
                                }
                            }
                        }
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            }
            return $derived_preds$.getGlobalValue();
        }
    }

    /**
     * Initialize @xref *DERIVED-PREDS* from the KB.
     */
    @LispMethod(comment = "Initialize @xref *DERIVED-PREDS* from the KB.")
    public static SubLObject initialize_derived_preds() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        clear_derived_preds();
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if (NIL != valid_constantP($$regularSuffix, UNPROVIDED)) {
                final SubLObject pred_var = $$regularSuffix;
                if (NIL != kb_mapping_macros.do_predicate_extent_index_key_validator(pred_var)) {
                    final SubLObject str = NIL;
                    final SubLObject _prev_bind_0_$4 = $progress_start_time$.currentBinding(thread);
                    final SubLObject _prev_bind_1_$5 = $progress_last_pacification_time$.currentBinding(thread);
                    final SubLObject _prev_bind_3 = $progress_elapsed_seconds_for_notification$.currentBinding(thread);
                    final SubLObject _prev_bind_4 = $progress_notification_count$.currentBinding(thread);
                    final SubLObject _prev_bind_5 = $progress_pacifications_since_last_nl$.currentBinding(thread);
                    final SubLObject _prev_bind_6 = $progress_count$.currentBinding(thread);
                    final SubLObject _prev_bind_7 = $is_noting_progressP$.currentBinding(thread);
                    final SubLObject _prev_bind_8 = $silent_progressP$.currentBinding(thread);
                    try {
                        $progress_start_time$.bind(get_universal_time(), thread);
                        $progress_last_pacification_time$.bind($progress_start_time$.getDynamicValue(thread), thread);
                        $progress_elapsed_seconds_for_notification$.bind($suppress_all_progress_faster_than_seconds$.getDynamicValue(thread), thread);
                        $progress_notification_count$.bind(ZERO_INTEGER, thread);
                        $progress_pacifications_since_last_nl$.bind(ZERO_INTEGER, thread);
                        $progress_count$.bind(ZERO_INTEGER, thread);
                        $is_noting_progressP$.bind(T, thread);
                        $silent_progressP$.bind(NIL != str ? $silent_progressP$.getDynamicValue(thread) : T, thread);
                        noting_progress_preamble(str);
                        final SubLObject iterator_var = kb_mapping_macros.new_predicate_extent_final_index_spec_iterator(pred_var);
                        SubLObject done_var = NIL;
                        final SubLObject token_var = NIL;
                        while (NIL == done_var) {
                            final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                            final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                            if (NIL != valid) {
                                note_progress();
                                SubLObject final_index_iterator = NIL;
                                try {
                                    final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, NIL, NIL);
                                    SubLObject done_var_$6 = NIL;
                                    final SubLObject token_var_$7 = NIL;
                                    while (NIL == done_var_$6) {
                                        final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$7);
                                        final SubLObject valid_$8 = makeBoolean(!token_var_$7.eql(as));
                                        if (NIL != valid_$8) {
                                            final SubLObject derived_pred = assertions_high.gaf_arg1(as);
                                            final SubLObject mt = assertions_high.assertion_mt(as);
                                            hash_table_utilities.pushnew_hash(derived_pred, mt, $derived_preds$.getGlobalValue(), UNPROVIDED);
                                        }
                                        done_var_$6 = makeBoolean(NIL == valid_$8);
                                    } 
                                } finally {
                                    final SubLObject _prev_bind_0_$5 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                    try {
                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                        final SubLObject _values = getValuesAsVector();
                                        if (NIL != final_index_iterator) {
                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                        }
                                        restoreValuesFromVector(_values);
                                    } finally {
                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$5, thread);
                                    }
                                }
                            }
                            done_var = makeBoolean(NIL == valid);
                        } 
                        noting_progress_postamble();
                    } finally {
                        $silent_progressP$.rebind(_prev_bind_8, thread);
                        $is_noting_progressP$.rebind(_prev_bind_7, thread);
                        $progress_count$.rebind(_prev_bind_6, thread);
                        $progress_pacifications_since_last_nl$.rebind(_prev_bind_5, thread);
                        $progress_notification_count$.rebind(_prev_bind_4, thread);
                        $progress_elapsed_seconds_for_notification$.rebind(_prev_bind_3, thread);
                        $progress_last_pacification_time$.rebind(_prev_bind_1_$5, thread);
                        $progress_start_time$.rebind(_prev_bind_0_$4, thread);
                    }
                }
            }
            if ((NIL != valid_constantP($$ProperNoun, UNPROVIDED)) && (NIL != valid_constantP($$speechPartPreds, UNPROVIDED))) {
                SubLObject node_var = $$ProperNoun;
                final SubLObject deck_type = $STACK;
                final SubLObject recur_deck = deck.create_deck(deck_type);
                final SubLObject _prev_bind_0_$6 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                try {
                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                    try {
                        final SubLObject tv_var = NIL;
                        final SubLObject _prev_bind_0_$7 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                        final SubLObject _prev_bind_1_$6 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                        try {
                            sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? tv_var : sbhl_search_vars.get_sbhl_true_tv(), thread);
                            sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? RELEVANT_SBHL_TV_IS_GENERAL_TV : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                            if (((NIL != tv_var) && (NIL != sbhl_paranoia.sbhl_object_type_checking_p())) && (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var))) {
                                final SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                if (pcase_var.eql($ERROR)) {
                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                } else
                                    if (pcase_var.eql($CERROR)) {
                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    } else
                                        if (pcase_var.eql($WARN)) {
                                            Errors.warn($str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        } else {
                                            Errors.warn($str54$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                            Errors.cerror($$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        }


                            }
                            final SubLObject _prev_bind_0_$8 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                            final SubLObject _prev_bind_1_$7 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                            final SubLObject _prev_bind_9 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                            final SubLObject _prev_bind_10 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                            final SubLObject _prev_bind_11 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                            try {
                                sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$ProperNoun, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                    final SubLObject _prev_bind_0_$9 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_1_$8 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_2_$17 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                    try {
                                        sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                        sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                        while (NIL != node_var) {
                                            final SubLObject pos = node_var;
                                            final SubLObject pred_var2 = $$speechPartPreds;
                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pos, NIL, pred_var2)) {
                                                final SubLObject iterator_var2 = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pos, NIL, pred_var2);
                                                SubLObject done_var2 = NIL;
                                                final SubLObject token_var2 = NIL;
                                                while (NIL == done_var2) {
                                                    final SubLObject final_index_spec2 = iteration.iteration_next_without_values_macro_helper(iterator_var2, token_var2);
                                                    final SubLObject valid2 = makeBoolean(!token_var2.eql(final_index_spec2));
                                                    if (NIL != valid2) {
                                                        SubLObject final_index_iterator2 = NIL;
                                                        try {
                                                            final_index_iterator2 = kb_mapping_macros.new_final_index_iterator(final_index_spec2, $GAF, $TRUE, NIL);
                                                            SubLObject done_var_$7 = NIL;
                                                            final SubLObject token_var_$8 = NIL;
                                                            while (NIL == done_var_$7) {
                                                                final SubLObject as2 = iteration.iteration_next_without_values_macro_helper(final_index_iterator2, token_var_$8);
                                                                final SubLObject valid_$9 = makeBoolean(!token_var_$8.eql(as2));
                                                                if (NIL != valid_$9) {
                                                                    final SubLObject spp = assertions_high.gaf_arg2(as2);
                                                                    final SubLObject mt2 = assertions_high.assertion_mt(as2);
                                                                    hash_table_utilities.pushnew_hash(spp, mt2, $derived_preds$.getGlobalValue(), UNPROVIDED);
                                                                }
                                                                done_var_$7 = makeBoolean(NIL == valid_$9);
                                                            } 
                                                        } finally {
                                                            final SubLObject _prev_bind_0_$10 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                final SubLObject _values2 = getValuesAsVector();
                                                                if (NIL != final_index_iterator2) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator2);
                                                                }
                                                                restoreValuesFromVector(_values2);
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$10, thread);
                                                            }
                                                        }
                                                    }
                                                    done_var2 = makeBoolean(NIL == valid2);
                                                } 
                                            }
                                            SubLObject cdolist_list_var;
                                            final SubLObject accessible_modules = cdolist_list_var = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                            SubLObject module_var = NIL;
                                            module_var = cdolist_list_var.first();
                                            while (NIL != cdolist_list_var) {
                                                final SubLObject _prev_bind_0_$11 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                final SubLObject _prev_bind_1_$9 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                try {
                                                    sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                    final SubLObject node = function_terms.naut_to_nart(node_var);
                                                    if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                        final SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                        if (NIL != d_link) {
                                                            final SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            if (NIL != mt_links) {
                                                                SubLObject iteration_state;
                                                                for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                                                                    thread.resetMultipleValues();
                                                                    final SubLObject mt3 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                    final SubLObject tv_links = thread.secondMultipleValue();
                                                                    thread.resetMultipleValues();
                                                                    if (NIL != mt_relevance_macros.relevant_mtP(mt3)) {
                                                                        final SubLObject _prev_bind_0_$12 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                        try {
                                                                            sbhl_link_vars.$sbhl_link_mt$.bind(mt3, thread);
                                                                            SubLObject iteration_state_$25;
                                                                            for (iteration_state_$25 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$25); iteration_state_$25 = dictionary_contents.do_dictionary_contents_next(iteration_state_$25)) {
                                                                                thread.resetMultipleValues();
                                                                                final SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$25);
                                                                                final SubLObject link_nodes = thread.secondMultipleValue();
                                                                                thread.resetMultipleValues();
                                                                                if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                    final SubLObject _prev_bind_0_$13 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                        final SubLObject sol = link_nodes;
                                                                                        if (NIL != set.set_p(sol)) {
                                                                                            final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                            SubLObject basis_object;
                                                                                            SubLObject state;
                                                                                            SubLObject node_vars_link_node;
                                                                                            for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                node_vars_link_node = set_contents.do_set_contents_next(basis_object, state);
                                                                                                if ((NIL != set_contents.do_set_contents_element_validP(state, node_vars_link_node)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED))) {
                                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                    deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                }
                                                                                            }
                                                                                        } else
                                                                                            if (sol.isList()) {
                                                                                                SubLObject csome_list_var = sol;
                                                                                                SubLObject node_vars_link_node2 = NIL;
                                                                                                node_vars_link_node2 = csome_list_var.first();
                                                                                                while (NIL != csome_list_var) {
                                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node2, UNPROVIDED)) {
                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node2, UNPROVIDED);
                                                                                                        deck.deck_push(node_vars_link_node2, recur_deck);
                                                                                                    }
                                                                                                    csome_list_var = csome_list_var.rest();
                                                                                                    node_vars_link_node2 = csome_list_var.first();
                                                                                                } 
                                                                                            } else {
                                                                                                Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                            }

                                                                                    } finally {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$13, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_$25);
                                                                        } finally {
                                                                            sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$12, thread);
                                                                        }
                                                                    }
                                                                }
                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } else
                                                        if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                            SubLObject cdolist_list_var_$27;
                                                            final SubLObject new_list = cdolist_list_var_$27 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            SubLObject generating_fn = NIL;
                                                            generating_fn = cdolist_list_var_$27.first();
                                                            while (NIL != cdolist_list_var_$27) {
                                                                final SubLObject _prev_bind_0_$14 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                try {
                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                    final SubLObject sol2;
                                                                    final SubLObject link_nodes2 = sol2 = funcall(generating_fn, node);
                                                                    if (NIL != set.set_p(sol2)) {
                                                                        final SubLObject set_contents_var2 = set.do_set_internal(sol2);
                                                                        SubLObject basis_object2;
                                                                        SubLObject state2;
                                                                        SubLObject node_vars_link_node3;
                                                                        for (basis_object2 = set_contents.do_set_contents_basis_object(set_contents_var2), state2 = NIL, state2 = set_contents.do_set_contents_initial_state(basis_object2, set_contents_var2); NIL == set_contents.do_set_contents_doneP(basis_object2, state2); state2 = set_contents.do_set_contents_update_state(state2)) {
                                                                            node_vars_link_node3 = set_contents.do_set_contents_next(basis_object2, state2);
                                                                            if ((NIL != set_contents.do_set_contents_element_validP(state2, node_vars_link_node3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node3, UNPROVIDED))) {
                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node3, UNPROVIDED);
                                                                                deck.deck_push(node_vars_link_node3, recur_deck);
                                                                            }
                                                                        }
                                                                    } else
                                                                        if (sol2.isList()) {
                                                                            SubLObject csome_list_var2 = sol2;
                                                                            SubLObject node_vars_link_node4 = NIL;
                                                                            node_vars_link_node4 = csome_list_var2.first();
                                                                            while (NIL != csome_list_var2) {
                                                                                if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node4, UNPROVIDED)) {
                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node4, UNPROVIDED);
                                                                                    deck.deck_push(node_vars_link_node4, recur_deck);
                                                                                }
                                                                                csome_list_var2 = csome_list_var2.rest();
                                                                                node_vars_link_node4 = csome_list_var2.first();
                                                                            } 
                                                                        } else {
                                                                            Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol2);
                                                                        }

                                                                } finally {
                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$14, thread);
                                                                }
                                                                cdolist_list_var_$27 = cdolist_list_var_$27.rest();
                                                                generating_fn = cdolist_list_var_$27.first();
                                                            } 
                                                        }

                                                } finally {
                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$9, thread);
                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$11, thread);
                                                }
                                                cdolist_list_var = cdolist_list_var.rest();
                                                module_var = cdolist_list_var.first();
                                            } 
                                            node_var = deck.deck_pop(recur_deck);
                                        } 
                                    } finally {
                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_$17, thread);
                                        sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_$8, thread);
                                        sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_$9, thread);
                                    }
                                } else {
                                    sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str59$Node__a_does_not_pass_sbhl_type_t, $$ProperNoun, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                }
                            } finally {
                                sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_11, thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_10, thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_9, thread);
                                sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_$7, thread);
                                sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_$8, thread);
                            }
                        } finally {
                            sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_$6, thread);
                            sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_$7, thread);
                        }
                    } finally {
                        final SubLObject _prev_bind_0_$15 = $is_thread_performing_cleanupP$.currentBinding(thread);
                        try {
                            $is_thread_performing_cleanupP$.bind(T, thread);
                            final SubLObject _values3 = getValuesAsVector();
                            sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                            restoreValuesFromVector(_values3);
                        } finally {
                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$15, thread);
                        }
                    }
                } finally {
                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_$6, thread);
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return $derived_preds$.getGlobalValue();
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a derived predicate?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a derived predicate?")
    public static final SubLObject derived_predP_alt(SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        if (!hash_table_count($derived_preds$.getGlobalValue()).isPositive()) {
            com.cyc.cycjava.cycl.lexicon_accessors.initialize_derived_preds();
        }
        {
            SubLObject mts = gethash(obj, $derived_preds$.getGlobalValue(), UNPROVIDED);
            SubLObject mt_okP = eq(mt, $$InferencePSC);
            if (NIL == mt_okP) {
                {
                    SubLObject csome_list_var = mts;
                    SubLObject ok_mt = NIL;
                    for (ok_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
                        mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, ok_mt);
                    }
                }
            }
            return makeBoolean((NIL != mts) && (NIL != mt_okP));
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a derived predicate?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a derived predicate?")
    public static SubLObject derived_predP(final SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        if (!hash_table_count($derived_preds$.getGlobalValue()).isPositive()) {
            initialize_derived_preds();
        }
        final SubLObject mts = gethash(obj, $derived_preds$.getGlobalValue(), UNPROVIDED);
        SubLObject mt_okP = kb_utilities.kbeq(mt, $$InferencePSC);
        if (NIL == mt_okP) {
            SubLObject csome_list_var;
            SubLObject ok_mt;
            for (csome_list_var = mts, ok_mt = NIL, ok_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, ok_mt) , csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
            }
        }
        return makeBoolean((NIL != mts) && (NIL != mt_okP));
    }

    /**
     *
     *
     * @return LISTP of non-derived predicates from which PRED forms can be generated.
     */
    @LispMethod(comment = "@return LISTP of non-derived predicates from which PRED forms can be generated.")
    public static final SubLObject base_preds_of_pred_alt(SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$EnglishMt;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject base_preds = NIL;
                if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.derived_predP(pred, mt)) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                {
                                    SubLObject pred_var = $$regularSuffix;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, ONE_INTEGER, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, ONE_INTEGER, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, NIL, NIL);
                                                                {
                                                                    SubLObject done_var_30 = NIL;
                                                                    SubLObject token_var_31 = NIL;
                                                                    while (NIL == done_var_30) {
                                                                        {
                                                                            SubLObject gaf = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_31);
                                                                            SubLObject valid_32 = makeBoolean(token_var_31 != gaf);
                                                                            if (NIL != valid_32) {
                                                                                {
                                                                                    SubLObject more_basic_pred = assertions_high.gaf_arg2(gaf);
                                                                                    base_preds = union(base_preds, com.cyc.cycjava.cycl.lexicon_accessors.base_preds_of_pred(more_basic_pred, UNPROVIDED), UNPROVIDED, UNPROVIDED);
                                                                                }
                                                                            }
                                                                            done_var_30 = makeBoolean(NIL == valid_32);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_33 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_33, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return NIL != base_preds ? ((SubLObject) (base_preds)) : list(pred);
            }
        }
    }

    /**
     *
     *
     * @return LISTP of non-derived predicates from which PRED forms can be generated.
     */
    @LispMethod(comment = "@return LISTP of non-derived predicates from which PRED forms can be generated.")
    public static SubLObject base_preds_of_pred(final SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$EnglishMt;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject base_preds = NIL;
        if (NIL != derived_predP(pred, mt)) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                final SubLObject pred_var = $$regularSuffix;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, ONE_INTEGER, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, ONE_INTEGER, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, NIL, NIL);
                                SubLObject done_var_$30 = NIL;
                                final SubLObject token_var_$31 = NIL;
                                while (NIL == done_var_$30) {
                                    final SubLObject gaf = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$31);
                                    final SubLObject valid_$32 = makeBoolean(!token_var_$31.eql(gaf));
                                    if (NIL != valid_$32) {
                                        final SubLObject more_basic_pred = assertions_high.gaf_arg2(gaf);
                                        base_preds = union(base_preds, base_preds_of_pred(more_basic_pred, UNPROVIDED), UNPROVIDED, UNPROVIDED);
                                    }
                                    done_var_$30 = makeBoolean(NIL == valid_$32);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$33 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$33, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        }
        return NIL != base_preds ? base_preds : list(pred);
    }

    public static final SubLObject do_speech_part_preds_alt(SubLObject macroform, SubLObject environment) {
        {
            SubLObject datum = macroform.rest();
            SubLObject current = datum;
            destructuring_bind_must_consp(current, datum, $list_alt59);
            {
                SubLObject temp = current.rest();
                current = current.first();
                {
                    SubLObject pred = NIL;
                    destructuring_bind_must_consp(current, datum, $list_alt59);
                    pred = current.first();
                    current = current.rest();
                    {
                        SubLObject allow_other_keys_p = NIL;
                        SubLObject rest = current;
                        SubLObject bad = NIL;
                        SubLObject current_34 = NIL;
                        for (; NIL != rest;) {
                            destructuring_bind_must_consp(rest, datum, $list_alt59);
                            current_34 = rest.first();
                            rest = rest.rest();
                            destructuring_bind_must_consp(rest, datum, $list_alt59);
                            if (NIL == member(current_34, $list_alt60, UNPROVIDED, UNPROVIDED)) {
                                bad = T;
                            }
                            if (current_34 == $ALLOW_OTHER_KEYS) {
                                allow_other_keys_p = rest.first();
                            }
                            rest = rest.rest();
                        }
                        if ((NIL != bad) && (NIL == allow_other_keys_p)) {
                            cdestructuring_bind_error(datum, $list_alt59);
                        }
                        {
                            SubLObject mt_tail = property_list_member($MT, current);
                            SubLObject mt = (NIL != mt_tail) ? ((SubLObject) (cadr(mt_tail))) : $$InferencePSC;
                            SubLObject done_tail = property_list_member($DONE, current);
                            SubLObject done = (NIL != done_tail) ? ((SubLObject) (cadr(done_tail))) : NIL;
                            current = temp;
                            {
                                SubLObject body = current;
                                SubLObject defining_mt = $sym64$DEFINING_MT;
                                return list(PROGN, $list_alt66, list(DO_DICTIONARY, list(pred, defining_mt, $speech_part_preds$, done), listS(PWHEN, list(COR, listS(EQ, mt, $list_alt70), list($sym0$GENL_LEXICON_MT_, mt, defining_mt)), append(body, NIL))));
                            }
                        }
                    }
                }
            }
        }
    }

    public static SubLObject do_speech_part_preds(final SubLObject macroform, final SubLObject environment) {
        SubLObject current;
        final SubLObject datum = current = macroform.rest();
        destructuring_bind_must_consp(current, datum, $list62);
        final SubLObject temp = current.rest();
        current = current.first();
        SubLObject pred = NIL;
        destructuring_bind_must_consp(current, datum, $list62);
        pred = current.first();
        current = current.rest();
        SubLObject allow_other_keys_p = NIL;
        SubLObject rest = current;
        SubLObject bad = NIL;
        SubLObject current_$34 = NIL;
        while (NIL != rest) {
            destructuring_bind_must_consp(rest, datum, $list62);
            current_$34 = rest.first();
            rest = rest.rest();
            destructuring_bind_must_consp(rest, datum, $list62);
            if (NIL == member(current_$34, $list63, UNPROVIDED, UNPROVIDED)) {
                bad = T;
            }
            if (current_$34 == $ALLOW_OTHER_KEYS) {
                allow_other_keys_p = rest.first();
            }
            rest = rest.rest();
        } 
        if ((NIL != bad) && (NIL == allow_other_keys_p)) {
            cdestructuring_bind_error(datum, $list62);
        }
        final SubLObject mt_tail = property_list_member($MT, current);
        final SubLObject mt = (NIL != mt_tail) ? cadr(mt_tail) : $$InferencePSC;
        final SubLObject done_tail = property_list_member($DONE, current);
        final SubLObject done = (NIL != done_tail) ? cadr(done_tail) : NIL;
        final SubLObject body;
        current = body = temp;
        final SubLObject defining_mt = $sym67$DEFINING_MT;
        return list(PROGN, $list69, list(DO_DICTIONARY, list(pred, defining_mt, $speech_part_preds$, done), listS(PWHEN, list(COR, listS(KBEQ, mt, $list74), list($sym75$GENL_LEXICON_MT_, mt, defining_mt)), append(body, NIL))));
    }

    public static final SubLObject speech_part_preds_initializedP_alt() {
        return makeBoolean((NIL != dictionary.dictionary_p($speech_part_preds$.getGlobalValue())) && (NIL == dictionary.dictionary_empty_p($speech_part_preds$.getGlobalValue())));
    }

    public static SubLObject speech_part_preds_initializedP() {
        return makeBoolean((NIL != dictionary.dictionary_p($speech_part_preds$.getGlobalValue())) && (NIL == dictionary.dictionary_empty_p($speech_part_preds$.getGlobalValue())));
    }

    public static final SubLObject clear_speech_part_preds_alt() {
        if (NIL == dictionary.dictionary_p($speech_part_preds$.getGlobalValue())) {
            $speech_part_preds$.setGlobalValue(dictionary.new_dictionary(symbol_function(EQ), $int$256));
        }
        return dictionary.clear_dictionary($speech_part_preds$.getGlobalValue());
    }

    public static SubLObject clear_speech_part_preds() {
        if (NIL == dictionary.dictionary_p($speech_part_preds$.getGlobalValue())) {
            $speech_part_preds$.setGlobalValue(dictionary.new_dictionary(symbol_function(EQL), $int$256));
        }
        return dictionary.clear_dictionary($speech_part_preds$.getGlobalValue());
    }

    public static final SubLObject initialize_speech_part_preds_alt() {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            com.cyc.cycjava.cycl.lexicon_accessors.clear_speech_part_preds();
            {
                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    if (NIL != valid_constantP($$SpeechPartPredicate, UNPROVIDED)) {
                        {
                            SubLObject node_var = $$SpeechPartPredicate;
                            SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
                            SubLObject recur_deck = deck.create_deck(deck_type);
                            {
                                SubLObject _prev_bind_0_35 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                                try {
                                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                    {
                                        SubLObject tv_var = NIL;
                                        {
                                            SubLObject _prev_bind_0_36 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                            SubLObject _prev_bind_1_37 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                            try {
                                                sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? ((SubLObject) (tv_var)) : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV)) : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                                if (NIL != tv_var) {
                                                    if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
                                                        if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
                                                            {
                                                                SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                                                if (pcase_var.eql($ERROR)) {
                                                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                } else {
                                                                    if (pcase_var.eql($CERROR)) {
                                                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                    } else {
                                                                        if (pcase_var.eql($WARN)) {
                                                                            Errors.warn($str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        } else {
                                                                            Errors.warn($str_alt51$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                                            Errors.cerror($$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    SubLObject _prev_bind_0_38 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                                    SubLObject _prev_bind_1_39 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                                    SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                                    SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                    SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                    try {
                                                        sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                        sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$SpeechPartPredicate, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                                            {
                                                                SubLObject _prev_bind_0_40 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_1_41 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_2_42 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                try {
                                                                    sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                                                    while (NIL != node_var) {
                                                                        {
                                                                            SubLObject sp_type = node_var;
                                                                            SubLObject pred_var = $$isa;
                                                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(sp_type, TWO_INTEGER, pred_var)) {
                                                                                {
                                                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(sp_type, TWO_INTEGER, pred_var);
                                                                                    SubLObject done_var = NIL;
                                                                                    SubLObject token_var = NIL;
                                                                                    while (NIL == done_var) {
                                                                                        {
                                                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                                            if (NIL != valid) {
                                                                                                {
                                                                                                    SubLObject final_index_iterator = NIL;
                                                                                                    try {
                                                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                                                        {
                                                                                                            SubLObject done_var_43 = NIL;
                                                                                                            SubLObject token_var_44 = NIL;
                                                                                                            while (NIL == done_var_43) {
                                                                                                                {
                                                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_44);
                                                                                                                    SubLObject valid_45 = makeBoolean(token_var_44 != as);
                                                                                                                    if (NIL != valid_45) {
                                                                                                                        {
                                                                                                                            SubLObject spp = assertions_high.gaf_arg1(as);
                                                                                                                            SubLObject mt = assertions_high.assertion_mt(as);
                                                                                                                            dictionary_utilities.dictionary_push($speech_part_preds$.getGlobalValue(), spp, mt);
                                                                                                                            removal_modules_lexicon.set_up_removal_support_for_speech_part_predicate(spp);
                                                                                                                        }
                                                                                                                    }
                                                                                                                    done_var_43 = makeBoolean(NIL == valid_45);
                                                                                                                }
                                                                                                            } 
                                                                                                        }
                                                                                                    } finally {
                                                                                                        {
                                                                                                            SubLObject _prev_bind_0_46 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                                            try {
                                                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                                                if (NIL != final_index_iterator) {
                                                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                                                }
                                                                                                            } finally {
                                                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_46, thread);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            done_var = makeBoolean(NIL == valid);
                                                                                        }
                                                                                    } 
                                                                                }
                                                                            }
                                                                        }
                                                                        {
                                                                            SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                                                            SubLObject cdolist_list_var = accessible_modules;
                                                                            SubLObject module_var = NIL;
                                                                            for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                {
                                                                                    SubLObject _prev_bind_0_47 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                    SubLObject _prev_bind_1_48 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                        {
                                                                                            SubLObject node = function_terms.naut_to_nart(node_var);
                                                                                            if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                {
                                                                                                    SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                    if (NIL != d_link) {
                                                                                                        {
                                                                                                            SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                            if (NIL != mt_links) {
                                                                                                                {
                                                                                                                    SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                    while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                        thread.resetMultipleValues();
                                                                                                                        {
                                                                                                                            SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                            SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                            thread.resetMultipleValues();
                                                                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                {
                                                                                                                                    SubLObject _prev_bind_0_49 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                    try {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                        {
                                                                                                                                            SubLObject iteration_state_50 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                            while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_50)) {
                                                                                                                                                thread.resetMultipleValues();
                                                                                                                                                {
                                                                                                                                                    SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_50);
                                                                                                                                                    SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                                    if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                        {
                                                                                                                                                            SubLObject _prev_bind_0_51 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                            try {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                {
                                                                                                                                                                    SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                    SubLObject cdolist_list_var_52 = new_list;
                                                                                                                                                                    SubLObject node_vars_link_node = NIL;
                                                                                                                                                                    for (node_vars_link_node = cdolist_list_var_52.first(); NIL != cdolist_list_var_52; cdolist_list_var_52 = cdolist_list_var_52.rest() , node_vars_link_node = cdolist_list_var_52.first()) {
                                                                                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                                                            deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            } finally {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_51, thread);
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    iteration_state_50 = dictionary_contents.do_dictionary_contents_next(iteration_state_50);
                                                                                                                                                }
                                                                                                                                            } 
                                                                                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_50);
                                                                                                                                        }
                                                                                                                                    } finally {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_49, thread);
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                        }
                                                                                                                    } 
                                                                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                    {
                                                                                                        SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                        SubLObject cdolist_list_var_53 = new_list;
                                                                                                        SubLObject generating_fn = NIL;
                                                                                                        for (generating_fn = cdolist_list_var_53.first(); NIL != cdolist_list_var_53; cdolist_list_var_53 = cdolist_list_var_53.rest() , generating_fn = cdolist_list_var_53.first()) {
                                                                                                            {
                                                                                                                SubLObject _prev_bind_0_54 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                try {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                    {
                                                                                                                        SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                        SubLObject new_list_55 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                        SubLObject cdolist_list_var_56 = new_list_55;
                                                                                                                        SubLObject node_vars_link_node = NIL;
                                                                                                                        for (node_vars_link_node = cdolist_list_var_56.first(); NIL != cdolist_list_var_56; cdolist_list_var_56 = cdolist_list_var_56.rest() , node_vars_link_node = cdolist_list_var_56.first()) {
                                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } finally {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_54, thread);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } finally {
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_48, thread);
                                                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_47, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        node_var = deck.deck_pop(recur_deck);
                                                                    } 
                                                                } finally {
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_42, thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_41, thread);
                                                                    sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_40, thread);
                                                                }
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str_alt55$Node__a_does_not_pass_sbhl_type_t, $$SpeechPartPredicate, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } finally {
                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4, thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_3, thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_2, thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_39, thread);
                                                        sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_38, thread);
                                                    }
                                                }
                                            } finally {
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_37, thread);
                                                sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_36, thread);
                                            }
                                        }
                                        sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                    }
                                } finally {
                                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_35, thread);
                                }
                            }
                        }
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            }
            return $speech_part_preds$.getGlobalValue();
        }
    }

    public static SubLObject initialize_speech_part_preds() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        clear_speech_part_preds();
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if (NIL != valid_constantP($$SpeechPartPredicate, UNPROVIDED)) {
                SubLObject node_var = $$SpeechPartPredicate;
                final SubLObject deck_type = $STACK;
                final SubLObject recur_deck = deck.create_deck(deck_type);
                final SubLObject _prev_bind_0_$35 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                try {
                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                    try {
                        final SubLObject tv_var = NIL;
                        final SubLObject _prev_bind_0_$36 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                        final SubLObject _prev_bind_1_$37 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                        try {
                            sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? tv_var : sbhl_search_vars.get_sbhl_true_tv(), thread);
                            sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? RELEVANT_SBHL_TV_IS_GENERAL_TV : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                            if (((NIL != tv_var) && (NIL != sbhl_paranoia.sbhl_object_type_checking_p())) && (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var))) {
                                final SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                if (pcase_var.eql($ERROR)) {
                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                } else
                                    if (pcase_var.eql($CERROR)) {
                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    } else
                                        if (pcase_var.eql($WARN)) {
                                            Errors.warn($str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        } else {
                                            Errors.warn($str54$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                            Errors.cerror($$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        }


                            }
                            final SubLObject _prev_bind_0_$37 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                            final SubLObject _prev_bind_1_$38 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                            final SubLObject _prev_bind_3 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                            final SubLObject _prev_bind_4 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                            final SubLObject _prev_bind_5 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                            try {
                                sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$SpeechPartPredicate, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                    final SubLObject _prev_bind_0_$38 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_1_$39 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_2_$42 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                    try {
                                        sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                        sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                        while (NIL != node_var) {
                                            final SubLObject sp_type = node_var;
                                            final SubLObject pred_var = $$isa;
                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(sp_type, TWO_INTEGER, pred_var)) {
                                                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(sp_type, TWO_INTEGER, pred_var);
                                                SubLObject done_var = NIL;
                                                final SubLObject token_var = NIL;
                                                while (NIL == done_var) {
                                                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                                    if (NIL != valid) {
                                                        SubLObject final_index_iterator = NIL;
                                                        try {
                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                            SubLObject done_var_$43 = NIL;
                                                            final SubLObject token_var_$44 = NIL;
                                                            while (NIL == done_var_$43) {
                                                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$44);
                                                                final SubLObject valid_$45 = makeBoolean(!token_var_$44.eql(as));
                                                                if (NIL != valid_$45) {
                                                                    final SubLObject spp = assertions_high.gaf_arg1(as);
                                                                    final SubLObject mt = assertions_high.assertion_mt(as);
                                                                    dictionary_utilities.dictionary_push($speech_part_preds$.getGlobalValue(), spp, mt);
                                                                    removal_modules_lexicon.set_up_removal_support_for_speech_part_predicate(spp);
                                                                }
                                                                done_var_$43 = makeBoolean(NIL == valid_$45);
                                                            } 
                                                        } finally {
                                                            final SubLObject _prev_bind_0_$39 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                final SubLObject _values = getValuesAsVector();
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                                restoreValuesFromVector(_values);
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$39, thread);
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                } 
                                            }
                                            SubLObject cdolist_list_var;
                                            final SubLObject accessible_modules = cdolist_list_var = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                            SubLObject module_var = NIL;
                                            module_var = cdolist_list_var.first();
                                            while (NIL != cdolist_list_var) {
                                                final SubLObject _prev_bind_0_$40 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                final SubLObject _prev_bind_1_$40 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                try {
                                                    sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                    final SubLObject node = function_terms.naut_to_nart(node_var);
                                                    if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                        final SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                        if (NIL != d_link) {
                                                            final SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            if (NIL != mt_links) {
                                                                SubLObject iteration_state;
                                                                for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                                                                    thread.resetMultipleValues();
                                                                    final SubLObject mt2 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                    final SubLObject tv_links = thread.secondMultipleValue();
                                                                    thread.resetMultipleValues();
                                                                    if (NIL != mt_relevance_macros.relevant_mtP(mt2)) {
                                                                        final SubLObject _prev_bind_0_$41 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                        try {
                                                                            sbhl_link_vars.$sbhl_link_mt$.bind(mt2, thread);
                                                                            SubLObject iteration_state_$50;
                                                                            for (iteration_state_$50 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$50); iteration_state_$50 = dictionary_contents.do_dictionary_contents_next(iteration_state_$50)) {
                                                                                thread.resetMultipleValues();
                                                                                final SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$50);
                                                                                final SubLObject link_nodes = thread.secondMultipleValue();
                                                                                thread.resetMultipleValues();
                                                                                if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                    final SubLObject _prev_bind_0_$42 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                        final SubLObject sol = link_nodes;
                                                                                        if (NIL != set.set_p(sol)) {
                                                                                            final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                            SubLObject basis_object;
                                                                                            SubLObject state;
                                                                                            SubLObject node_vars_link_node;
                                                                                            for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                node_vars_link_node = set_contents.do_set_contents_next(basis_object, state);
                                                                                                if ((NIL != set_contents.do_set_contents_element_validP(state, node_vars_link_node)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED))) {
                                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                    deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                }
                                                                                            }
                                                                                        } else
                                                                                            if (sol.isList()) {
                                                                                                SubLObject csome_list_var = sol;
                                                                                                SubLObject node_vars_link_node2 = NIL;
                                                                                                node_vars_link_node2 = csome_list_var.first();
                                                                                                while (NIL != csome_list_var) {
                                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node2, UNPROVIDED)) {
                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node2, UNPROVIDED);
                                                                                                        deck.deck_push(node_vars_link_node2, recur_deck);
                                                                                                    }
                                                                                                    csome_list_var = csome_list_var.rest();
                                                                                                    node_vars_link_node2 = csome_list_var.first();
                                                                                                } 
                                                                                            } else {
                                                                                                Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                            }

                                                                                    } finally {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$42, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_$50);
                                                                        } finally {
                                                                            sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$41, thread);
                                                                        }
                                                                    }
                                                                }
                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } else
                                                        if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                            SubLObject cdolist_list_var_$52;
                                                            final SubLObject new_list = cdolist_list_var_$52 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            SubLObject generating_fn = NIL;
                                                            generating_fn = cdolist_list_var_$52.first();
                                                            while (NIL != cdolist_list_var_$52) {
                                                                final SubLObject _prev_bind_0_$43 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                try {
                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                    final SubLObject sol2;
                                                                    final SubLObject link_nodes2 = sol2 = funcall(generating_fn, node);
                                                                    if (NIL != set.set_p(sol2)) {
                                                                        final SubLObject set_contents_var2 = set.do_set_internal(sol2);
                                                                        SubLObject basis_object2;
                                                                        SubLObject state2;
                                                                        SubLObject node_vars_link_node3;
                                                                        for (basis_object2 = set_contents.do_set_contents_basis_object(set_contents_var2), state2 = NIL, state2 = set_contents.do_set_contents_initial_state(basis_object2, set_contents_var2); NIL == set_contents.do_set_contents_doneP(basis_object2, state2); state2 = set_contents.do_set_contents_update_state(state2)) {
                                                                            node_vars_link_node3 = set_contents.do_set_contents_next(basis_object2, state2);
                                                                            if ((NIL != set_contents.do_set_contents_element_validP(state2, node_vars_link_node3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node3, UNPROVIDED))) {
                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node3, UNPROVIDED);
                                                                                deck.deck_push(node_vars_link_node3, recur_deck);
                                                                            }
                                                                        }
                                                                    } else
                                                                        if (sol2.isList()) {
                                                                            SubLObject csome_list_var2 = sol2;
                                                                            SubLObject node_vars_link_node4 = NIL;
                                                                            node_vars_link_node4 = csome_list_var2.first();
                                                                            while (NIL != csome_list_var2) {
                                                                                if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node4, UNPROVIDED)) {
                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node4, UNPROVIDED);
                                                                                    deck.deck_push(node_vars_link_node4, recur_deck);
                                                                                }
                                                                                csome_list_var2 = csome_list_var2.rest();
                                                                                node_vars_link_node4 = csome_list_var2.first();
                                                                            } 
                                                                        } else {
                                                                            Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol2);
                                                                        }

                                                                } finally {
                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$43, thread);
                                                                }
                                                                cdolist_list_var_$52 = cdolist_list_var_$52.rest();
                                                                generating_fn = cdolist_list_var_$52.first();
                                                            } 
                                                        }

                                                } finally {
                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$40, thread);
                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$40, thread);
                                                }
                                                cdolist_list_var = cdolist_list_var.rest();
                                                module_var = cdolist_list_var.first();
                                            } 
                                            node_var = deck.deck_pop(recur_deck);
                                        } 
                                    } finally {
                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_$42, thread);
                                        sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_$39, thread);
                                        sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_$38, thread);
                                    }
                                } else {
                                    sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str59$Node__a_does_not_pass_sbhl_type_t, $$SpeechPartPredicate, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                }
                            } finally {
                                sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_5, thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_4, thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_3, thread);
                                sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_$38, thread);
                                sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_$37, thread);
                            }
                        } finally {
                            sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_$37, thread);
                            sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_$36, thread);
                        }
                    } finally {
                        final SubLObject _prev_bind_0_$44 = $is_thread_performing_cleanupP$.currentBinding(thread);
                        try {
                            $is_thread_performing_cleanupP$.bind(T, thread);
                            final SubLObject _values2 = getValuesAsVector();
                            sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                            restoreValuesFromVector(_values2);
                        } finally {
                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$44, thread);
                        }
                    }
                } finally {
                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_$35, thread);
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return $speech_part_preds$.getGlobalValue();
    }

    public static final SubLObject ensure_speech_part_preds_initialized_alt() {
        if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.speech_part_preds_initializedP()) {
            com.cyc.cycjava.cycl.lexicon_accessors.initialize_speech_part_preds();
        }
        return $INITIALIZED;
    }

    public static SubLObject ensure_speech_part_preds_initialized() {
        if (NIL == speech_part_preds_initializedP()) {
            initialize_speech_part_preds();
        }
        return $INITIALIZED;
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a #$SpeechPartPredicate?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a #$SpeechPartPredicate?")
    public static final SubLObject speech_part_predP_alt(SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        com.cyc.cycjava.cycl.lexicon_accessors.ensure_speech_part_preds_initialized();
        {
            SubLObject mts = dictionary.dictionary_lookup_without_values($speech_part_preds$.getGlobalValue(), obj, UNPROVIDED);
            SubLObject mt_okP = eq(mt, $$InferencePSC);
            if (NIL == mt_okP) {
                {
                    SubLObject csome_list_var = mts;
                    SubLObject ok_mt = NIL;
                    for (ok_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
                        mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, ok_mt);
                    }
                }
            }
            return makeBoolean((NIL != mts) && (NIL != mt_okP));
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a #$SpeechPartPredicate?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a #$SpeechPartPredicate?")
    public static SubLObject speech_part_predP(final SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        ensure_speech_part_preds_initialized();
        final SubLObject mts = dictionary.dictionary_lookup_without_values($speech_part_preds$.getGlobalValue(), obj, UNPROVIDED);
        SubLObject mt_okP = kb_utilities.kbeq(mt, $$InferencePSC);
        if (NIL == mt_okP) {
            SubLObject csome_list_var;
            SubLObject ok_mt;
            for (csome_list_var = mts, ok_mt = NIL, ok_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, ok_mt) , csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
            }
        }
        return makeBoolean((NIL != mts) && (NIL != mt_okP));
    }

    /**
     *
     *
     * @return LISTP; of all #$SpeechPartPredicates
     */
    @LispMethod(comment = "@return LISTP; of all #$SpeechPartPredicates")
    public static final SubLObject all_speech_part_preds_alt(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            com.cyc.cycjava.cycl.lexicon_accessors.ensure_speech_part_preds_initialized();
            if (mt == $$InferencePSC) {
                return dictionary.dictionary_keys($speech_part_preds$.getGlobalValue());
            } else {
                {
                    SubLObject ans = NIL;
                    SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents($speech_part_preds$.getGlobalValue()));
                    while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                        thread.resetMultipleValues();
                        {
                            SubLObject sp = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                            SubLObject sp_mts = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            {
                                SubLObject mt_okP = NIL;
                                if (NIL == mt_okP) {
                                    {
                                        SubLObject csome_list_var = sp_mts;
                                        SubLObject sp_mt = NIL;
                                        for (sp_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , sp_mt = csome_list_var.first()) {
                                            mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, sp_mt);
                                        }
                                    }
                                }
                                if (NIL != mt_okP) {
                                    ans = cons(sp, ans);
                                }
                            }
                            iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                        }
                    } 
                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                    return ans;
                }
            }
        }
    }

    /**
     *
     *
     * @return LISTP; of all #$SpeechPartPredicates
     */
    @LispMethod(comment = "@return LISTP; of all #$SpeechPartPredicates")
    public static SubLObject all_speech_part_preds(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        ensure_speech_part_preds_initialized();
        if (NIL != kb_utilities.kbeq(mt, $$InferencePSC)) {
            return dictionary.dictionary_keys($speech_part_preds$.getGlobalValue());
        }
        SubLObject ans = NIL;
        SubLObject iteration_state;
        for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents($speech_part_preds$.getGlobalValue())); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
            thread.resetMultipleValues();
            final SubLObject sp = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
            final SubLObject sp_mts = thread.secondMultipleValue();
            thread.resetMultipleValues();
            SubLObject mt_okP = NIL;
            if (NIL == mt_okP) {
                SubLObject csome_list_var;
                SubLObject sp_mt;
                for (csome_list_var = sp_mts, sp_mt = NIL, sp_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, sp_mt) , csome_list_var = csome_list_var.rest() , sp_mt = csome_list_var.first()) {
                }
            }
            if (NIL != mt_okP) {
                ans = cons(sp, ans);
            }
        }
        dictionary_contents.do_dictionary_contents_finalize(iteration_state);
        return ans;
    }

    /**
     * Inverse of @xref GENL-POS-PRED?
     */
    @LispMethod(comment = "Inverse of @xref GENL-POS-PRED?")
    public static final SubLObject spec_pos_predP_alt(SubLObject pred1, SubLObject pred2, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.genl_pos_predP(pred2, pred1, mt);
    }

    /**
     * Inverse of @xref GENL-POS-PRED?
     */
    @LispMethod(comment = "Inverse of @xref GENL-POS-PRED?")
    public static SubLObject spec_pos_predP(final SubLObject pred1, final SubLObject pred2, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return genl_pos_predP(pred2, pred1, mt);
    }

    public static final SubLObject clear_genl_pos_predP_alt() {
        {
            SubLObject cs = $genl_pos_predP_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_genl_pos_predP() {
        final SubLObject cs = $genl_pos_predP_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_genl_pos_predP_alt(SubLObject pred1, SubLObject pred2, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($genl_pos_predP_caching_state$.getGlobalValue(), list(pred1, pred2, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_genl_pos_predP(final SubLObject pred1, final SubLObject pred2, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($genl_pos_predP_caching_state$.getGlobalValue(), list(pred1, pred2, mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     * Cached version of GENL-PRED? for use with speech-part predicates.
     */
    @LispMethod(comment = "Cached version of GENL-PRED? for use with speech-part predicates.")
    public static final SubLObject genl_pos_predP_internal_alt(SubLObject pred1, SubLObject pred2, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (pred1.equal(pred2)) {
                return T;
            }
            {
                SubLObject result = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        result = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     * Cached version of GENL-PRED? for use with speech-part predicates.
     */
    @LispMethod(comment = "Cached version of GENL-PRED? for use with speech-part predicates.")
    public static SubLObject genl_pos_predP_internal(final SubLObject pred1, final SubLObject pred2, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (pred1.equal(pred2)) {
            return T;
        }
        SubLObject result = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            result = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    public static final SubLObject genl_pos_predP_alt(SubLObject pred1, SubLObject pred2, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject caching_state = $genl_pos_predP_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name($sym73$GENL_POS_PRED_, $sym74$_GENL_POS_PRED__CACHING_STATE_, $int$4096, EQUAL, THREE_INTEGER, $int$128);
                memoization_state.register_genl_preds_dependent_cache_clear_callback($sym77$CLEAR_GENL_POS_PRED_);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_3(pred1, pred2, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (pred1.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (pred2.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                            return memoization_state.caching_results(results2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.genl_pos_predP_internal(pred1, pred2, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(pred1, pred2, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject genl_pos_predP(final SubLObject pred1, final SubLObject pred2, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLObject caching_state = $genl_pos_predP_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym78$GENL_POS_PRED_, $sym79$_GENL_POS_PRED__CACHING_STATE_, $int$4096, EQUAL, THREE_INTEGER, $int$128);
            memoization_state.register_genl_preds_dependent_cache_clear_callback($sym80$CLEAR_GENL_POS_PRED_);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_3(pred1, pred2, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (pred1.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (pred2.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                            return memoization_state.caching_results(results2);
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(genl_pos_predP_internal(pred1, pred2, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(pred1, pred2, mt));
        return memoization_state.caching_results(results3);
    }

    public static final SubLObject clear_genl_pos_pred_from_mt_infoP_alt() {
        {
            SubLObject cs = $genl_pos_pred_from_mt_infoP_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_genl_pos_pred_from_mt_infoP() {
        final SubLObject cs = $genl_pos_pred_from_mt_infoP_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_genl_pos_pred_from_mt_infoP_alt(SubLObject pred1, SubLObject pred2, SubLObject mt_info) {
        if (mt_info == UNPROVIDED) {
            mt_info = lexicon_vars.lexicon_lookup_mt_info();
        }
        return memoization_state.caching_state_remove_function_results_with_args($genl_pos_pred_from_mt_infoP_caching_state$.getGlobalValue(), list(pred1, pred2, mt_info), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_genl_pos_pred_from_mt_infoP(final SubLObject pred1, final SubLObject pred2, SubLObject mt_info) {
        if (mt_info == UNPROVIDED) {
            mt_info = lexicon_vars.lexicon_lookup_mt_info();
        }
        return memoization_state.caching_state_remove_function_results_with_args($genl_pos_pred_from_mt_infoP_caching_state$.getGlobalValue(), list(pred1, pred2, mt_info), UNPROVIDED, UNPROVIDED);
    }

    /**
     * Cached version of GENL-PRED? for use with speech-part predicates.
     */
    @LispMethod(comment = "Cached version of GENL-PRED? for use with speech-part predicates.")
    public static final SubLObject genl_pos_pred_from_mt_infoP_internal_alt(SubLObject pred1, SubLObject pred2, SubLObject mt_info) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                if (NIL != mt_relevance_macros.mt_function_eq(mt_info, RELEVANT_MT_IS_EVERYTHING)) {
                    {
                        SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                        SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                        try {
                            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                            ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                        } finally {
                            mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                        }
                    }
                } else {
                    if (NIL != mt_relevance_macros.mt_function_eq(mt_info, RELEVANT_MT_IS_ANY_MT)) {
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_ANY_MT, thread);
                                mt_relevance_macros.$mt$.bind($$InferencePSC, thread);
                                ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                            } finally {
                                mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                            }
                        }
                    } else {
                        if (NIL != hlmt.mt_union_naut_p(mt_info)) {
                            {
                                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                                try {
                                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_GENL_MT_OF_LIST_MEMBER, thread);
                                    mt_relevance_macros.$relevant_mts$.bind(hlmt.mt_union_mts(mt_info), thread);
                                    ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                                } finally {
                                    mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_1, thread);
                                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                                }
                            }
                        } else {
                            {
                                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                                try {
                                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_GENL_MT, thread);
                                    mt_relevance_macros.$mt$.bind(mt_info, thread);
                                    ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                                } finally {
                                    mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                                }
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Cached version of GENL-PRED? for use with speech-part predicates.
     */
    @LispMethod(comment = "Cached version of GENL-PRED? for use with speech-part predicates.")
    public static SubLObject genl_pos_pred_from_mt_infoP_internal(final SubLObject pred1, final SubLObject pred2, final SubLObject mt_info) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        if (NIL != mt_relevance_macros.mt_function_eq(mt_info, RELEVANT_MT_IS_EVERYTHING)) {
            final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
            try {
                mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
            } finally {
                mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
            }
        } else
            if (NIL != mt_relevance_macros.mt_function_eq(mt_info, RELEVANT_MT_IS_ANY_MT)) {
                final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_ANY_MT, thread);
                    mt_relevance_macros.$mt$.bind($$InferencePSC, thread);
                    ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            } else
                if (NIL != hlmt.mt_union_naut_p(mt_info)) {
                    final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_GENL_MT_OF_LIST_MEMBER, thread);
                        mt_relevance_macros.$relevant_mts$.bind(hlmt.mt_union_mts(mt_info), thread);
                        ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                } else {
                    final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_GENL_MT, thread);
                        mt_relevance_macros.$mt$.bind(mt_info, thread);
                        ans = makeBoolean((NIL != forts.fort_p(pred1)) && (NIL != genl_predicates.genl_predP(pred1, pred2, UNPROVIDED, UNPROVIDED)));
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }


        return ans;
    }

    public static final SubLObject genl_pos_pred_from_mt_infoP_alt(SubLObject pred1, SubLObject pred2, SubLObject mt_info) {
        if (mt_info == UNPROVIDED) {
            mt_info = lexicon_vars.lexicon_lookup_mt_info();
        }
        {
            SubLObject caching_state = $genl_pos_pred_from_mt_infoP_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name($sym78$GENL_POS_PRED_FROM_MT_INFO_, $sym82$_GENL_POS_PRED_FROM_MT_INFO__CACHING_STATE_, NIL, EQUAL, THREE_INTEGER, $int$128);
                memoization_state.register_genl_preds_dependent_cache_clear_callback($sym83$CLEAR_GENL_POS_PRED_FROM_MT_INFO_);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_3(pred1, pred2, mt_info);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (pred1.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (pred2.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt_info.equal(cached_args.first())) {
                                            return memoization_state.caching_results(results2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.genl_pos_pred_from_mt_infoP_internal(pred1, pred2, mt_info)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(pred1, pred2, mt_info));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject genl_pos_pred_from_mt_infoP(final SubLObject pred1, final SubLObject pred2, SubLObject mt_info) {
        if (mt_info == UNPROVIDED) {
            mt_info = lexicon_vars.lexicon_lookup_mt_info();
        }
        SubLObject caching_state = $genl_pos_pred_from_mt_infoP_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym81$GENL_POS_PRED_FROM_MT_INFO_, $sym85$_GENL_POS_PRED_FROM_MT_INFO__CACHING_STATE_, NIL, EQUAL, THREE_INTEGER, $int$128);
            memoization_state.register_genl_preds_dependent_cache_clear_callback($sym86$CLEAR_GENL_POS_PRED_FROM_MT_INFO_);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_3(pred1, pred2, mt_info);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (pred1.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (pred2.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt_info.equal(cached_args.first())) {
                            return memoization_state.caching_results(results2);
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(genl_pos_pred_from_mt_infoP_internal(pred1, pred2, mt_info)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(pred1, pred2, mt_info));
        return memoization_state.caching_results(results3);
    }

    /**
     * Given the #$EnglishWord WORD and the #$SpeechPartPredicate PRED,
     * return T if STRING is the PRED form of WORD predicted by the morphology code.
     *
     * @unknown baxter
     */
    @LispMethod(comment = "Given the #$EnglishWord WORD and the #$SpeechPartPredicate PRED,\r\nreturn T if STRING is the PRED form of WORD predicted by the morphology code.\r\n\r\n@unknown baxter\nGiven the #$EnglishWord WORD and the #$SpeechPartPredicate PRED,\nreturn T if STRING is the PRED form of WORD predicted by the morphology code.")
    public static final SubLObject word_form_predictableP_alt(SubLObject word, SubLObject string, SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLTrampolineFile.checkType(string, STRINGP);
        SubLTrampolineFile.checkType(pred, $sym29$SPEECH_PART_PRED_);
        return subl_promotions.memberP(string, lexicon_cache.generate_regular_strings(word, pred, mt), $sym85$STRING_, UNPROVIDED);
    }

    /**
     * Given the #$EnglishWord WORD and the #$SpeechPartPredicate PRED,
     * return T if STRING is the PRED form of WORD predicted by the morphology code.
     *
     * @unknown baxter
     */
    @LispMethod(comment = "Given the #$EnglishWord WORD and the #$SpeechPartPredicate PRED,\r\nreturn T if STRING is the PRED form of WORD predicted by the morphology code.\r\n\r\n@unknown baxter\nGiven the #$EnglishWord WORD and the #$SpeechPartPredicate PRED,\nreturn T if STRING is the PRED form of WORD predicted by the morphology code.")
    public static SubLObject word_form_predictableP(final SubLObject word, final SubLObject string, final SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != speech_part_predP(pred, UNPROVIDED) : "! lexicon_accessors.speech_part_predP(pred, .UNPROVIDED) " + ("lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) ") + pred;
        return subl_promotions.memberP(string, lexicon_cache.generate_regular_strings(word, pred, mt), $sym88$STRING_, UNPROVIDED);
    }

    /**
     * Return all strings of POS on WORD-UNIT, according to the specifications
     * INCLUDE and EXCEPTIONS.
     *
     * @param MT
     * 		What mt to look from.
     */
    @LispMethod(comment = "Return all strings of POS on WORD-UNIT, according to the specifications\r\nINCLUDE and EXCEPTIONS.\r\n\r\n@param MT\r\n\t\tWhat mt to look from.\nReturn all strings of POS on WORD-UNIT, according to the specifications\nINCLUDE and EXCEPTIONS.")
    public static final SubLObject get_strings_of_type_alt(SubLObject word_unit, SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        if (include == UNPROVIDED) {
            include = $ALL;
        }
        if (exceptions == UNPROVIDED) {
            exceptions = NIL;
        }
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            {
                SubLObject preds = com.cyc.cycjava.cycl.lexicon_accessors.max_preds_matching_pos(include, pos, mt, NIL);
                SubLObject ans = NIL;
                SubLObject mt_var = mt;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.possibly_in_mt_determine_function(mt_var), thread);
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.possibly_in_mt_determine_mt(mt_var), thread);
                        if (NIL != preds) {
                            ans = lexicon_cache.strings_of_word_unit(word_unit, preds, exceptions, UNPROVIDED);
                        }
                        if (((NIL != valid_constantP($$ClosedClassWord, UNPROVIDED)) && (NIL != valid_constantP($$partOfSpeech, UNPROVIDED))) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.closed_lexical_classP(pos, UNPROVIDED))) {
                            {
                                SubLObject cdolist_list_var = kb_mapping.gather_gaf_arg_index(word_unit, ONE_INTEGER, $$partOfSpeech, UNPROVIDED, UNPROVIDED);
                                SubLObject as = NIL;
                                for (as = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , as = cdolist_list_var.first()) {
                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(assertions_high.gaf_arg2(as), pos, UNPROVIDED)) {
                                        {
                                            SubLObject item_var = assertions_high.gaf_arg3(as);
                                            if (NIL == member(item_var, ans, symbol_function(EQUALP), symbol_function(IDENTITY))) {
                                                ans = cons(item_var, ans);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     * Return all strings of POS on WORD-UNIT, according to the specifications
     * INCLUDE and EXCEPTIONS.
     *
     * @param MT
     * 		What mt to look from.
     */
    @LispMethod(comment = "Return all strings of POS on WORD-UNIT, according to the specifications\r\nINCLUDE and EXCEPTIONS.\r\n\r\n@param MT\r\n\t\tWhat mt to look from.\nReturn all strings of POS on WORD-UNIT, according to the specifications\nINCLUDE and EXCEPTIONS.")
    public static SubLObject get_strings_of_type(final SubLObject word_unit, final SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        if (include == UNPROVIDED) {
            include = $ALL;
        }
        if (exceptions == UNPROVIDED) {
            exceptions = NIL;
        }
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        final SubLObject preds = max_preds_matching_pos(include, pos, mt, NIL);
        SubLObject ans = NIL;
        final SubLObject mt_var = mt;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.possibly_in_mt_determine_function(mt_var), thread);
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.possibly_in_mt_determine_mt(mt_var), thread);
            if (NIL != preds) {
                ans = lexicon_cache.strings_of_word_unit(word_unit, preds, exceptions, UNPROVIDED);
            }
            if (((NIL != valid_constantP($$ClosedClassWord, UNPROVIDED)) && (NIL != valid_constantP($$partOfSpeech, UNPROVIDED))) && (NIL != closed_lexical_classP(pos, UNPROVIDED))) {
                SubLObject cdolist_list_var = kb_mapping.gather_gaf_arg_index(word_unit, ONE_INTEGER, $$partOfSpeech, UNPROVIDED, UNPROVIDED);
                SubLObject as = NIL;
                as = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    if (NIL != genl_posP(assertions_high.gaf_arg2(as), pos, UNPROVIDED)) {
                        final SubLObject item_var = assertions_high.gaf_arg3(as);
                        if (NIL == member(item_var, ans, symbol_function(EQUALP), symbol_function(IDENTITY))) {
                            ans = cons(item_var, ans);
                        }
                    }
                    cdolist_list_var = cdolist_list_var.rest();
                    as = cdolist_list_var.first();
                } 
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject clear_get_strings_of_type_cached_alt() {
        {
            SubLObject cs = $get_strings_of_type_cached_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_get_strings_of_type_cached() {
        final SubLObject cs = $get_strings_of_type_cached_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_get_strings_of_type_cached_alt(SubLObject word_unit, SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        if (include == UNPROVIDED) {
            include = $ALL;
        }
        if (exceptions == UNPROVIDED) {
            exceptions = NIL;
        }
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($get_strings_of_type_cached_caching_state$.getGlobalValue(), list(word_unit, pos, include, exceptions, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_get_strings_of_type_cached(final SubLObject word_unit, final SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        if (include == UNPROVIDED) {
            include = $ALL;
        }
        if (exceptions == UNPROVIDED) {
            exceptions = NIL;
        }
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($get_strings_of_type_cached_caching_state$.getGlobalValue(), list(word_unit, pos, include, exceptions, mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     * Cached version of @xref GET-STRINGS-OF-TYPE
     */
    @LispMethod(comment = "Cached version of @xref GET-STRINGS-OF-TYPE")
    public static final SubLObject get_strings_of_type_cached_internal_alt(SubLObject word_unit, SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        return com.cyc.cycjava.cycl.lexicon_accessors.get_strings_of_type(word_unit, pos, include, exceptions, mt);
    }

    /**
     * Cached version of @xref GET-STRINGS-OF-TYPE
     */
    @LispMethod(comment = "Cached version of @xref GET-STRINGS-OF-TYPE")
    public static SubLObject get_strings_of_type_cached_internal(final SubLObject word_unit, final SubLObject pos, final SubLObject include, final SubLObject exceptions, final SubLObject mt) {
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        return get_strings_of_type(word_unit, pos, include, exceptions, mt);
    }

    public static final SubLObject get_strings_of_type_cached_alt(SubLObject word_unit, SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        if (include == UNPROVIDED) {
            include = $ALL;
        }
        if (exceptions == UNPROVIDED) {
            exceptions = NIL;
        }
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject caching_state = $get_strings_of_type_cached_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(GET_STRINGS_OF_TYPE_CACHED, $get_strings_of_type_cached_caching_state$, NIL, EQL, FIVE_INTEGER, $int$256);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_5(word_unit, pos, include, exceptions, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (word_unit.eql(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (pos.eql(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (include.eql(cached_args.first())) {
                                            cached_args = cached_args.rest();
                                            if (exceptions.eql(cached_args.first())) {
                                                cached_args = cached_args.rest();
                                                if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.eql(cached_args.first())) {
                                                    return memoization_state.caching_results(results2);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.get_strings_of_type_cached_internal(word_unit, pos, include, exceptions, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(word_unit, pos, include, exceptions, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject get_strings_of_type_cached(final SubLObject word_unit, final SubLObject pos, SubLObject include, SubLObject exceptions, SubLObject mt) {
        if (include == UNPROVIDED) {
            include = $ALL;
        }
        if (exceptions == UNPROVIDED) {
            exceptions = NIL;
        }
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLObject caching_state = $get_strings_of_type_cached_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(GET_STRINGS_OF_TYPE_CACHED, $get_strings_of_type_cached_caching_state$, $int$512, EQL, FIVE_INTEGER, $int$256);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_5(word_unit, pos, include, exceptions, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (word_unit.eql(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (pos.eql(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (include.eql(cached_args.first())) {
                            cached_args = cached_args.rest();
                            if (exceptions.eql(cached_args.first())) {
                                cached_args = cached_args.rest();
                                if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.eql(cached_args.first())) {
                                    return memoization_state.caching_results(results2);
                                }
                            }
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(get_strings_of_type_cached_internal(word_unit, pos, include, exceptions, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(word_unit, pos, include, exceptions, mt));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return BOOLEAN; Is STRING a form of WORD-UNIT whose part of speech is POS?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return BOOLEAN; Is STRING a form of WORD-UNIT whose part of speech is POS?")
    public static final SubLObject string_is_pos_on_wuP_internal_alt(SubLObject string, SubLObject word_unit, SubLObject pos, SubLObject mt, SubLObject string_lookup_function, SubLObject parse_morphologically) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (string_lookup_function == UNPROVIDED) {
            string_lookup_function = GET_STRINGS_OF_TYPE;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        SubLTrampolineFile.checkType(string, STRINGP);
        SubLTrampolineFile.checkType(word_unit, $sym92$LEXICAL_WORD_);
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
        if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.word_has_posP(word_unit, pos, UNPROVIDED)) {
            return NIL;
        } else {
            if ((NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.string_is_pos_on_wuP_asserted(string, word_unit, pos, mt))) {
                return T;
            } else {
                {
                    SubLObject strings = NIL;
                    if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                        {
                            SubLObject pcase_var = string_lookup_function;
                            if (pcase_var.eql(GET_STRINGS_OF_TYPE)) {
                                strings = com.cyc.cycjava.cycl.lexicon_accessors.get_strings_of_type(word_unit, pos, $ALL, NIL, mt);
                            } else {
                                if (pcase_var.eql(GET_STRINGS_OF_TYPE_CACHED)) {
                                    strings = com.cyc.cycjava.cycl.lexicon_accessors.get_strings_of_type_cached(word_unit, pos, $ALL, NIL, mt);
                                } else {
                                    strings = funcall(string_lookup_function, word_unit, pos, $ALL, NIL, mt);
                                }
                            }
                        }
                    }
                    if (NIL != subl_promotions.memberP(string, strings, symbol_function(EQUALP), UNPROVIDED)) {
                        return T;
                    } else {
                        if (parse_morphologically == $NEVER) {
                            return NIL;
                        } else {
                            {
                                SubLObject words = morphological_word_parser.words_of_complex_word_stringXspeech_part(string, pos);
                                return subl_promotions.memberP(word_unit, words, symbol_function($sym95$EQUALS_EL_), UNPROVIDED);
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return BOOLEAN; Is STRING a form of WORD-UNIT whose part of speech is POS?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return BOOLEAN; Is STRING a form of WORD-UNIT whose part of speech is POS?")
    public static SubLObject string_is_pos_on_wuP_internal(final SubLObject string, final SubLObject word_unit, final SubLObject pos, SubLObject mt, SubLObject string_lookup_function, SubLObject parse_morphologically) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (string_lookup_function == UNPROVIDED) {
            string_lookup_function = GET_STRINGS_OF_TYPE;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexical_wordP(word_unit) : "! lexicon_accessors.lexical_wordP(word_unit) " + ("lexicon_accessors.lexical_wordP(word_unit) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        if (NIL == word_has_posP(word_unit, pos, UNPROVIDED)) {
            return NIL;
        }
        if ((NIL == skip_to_morphological_parsingP(parse_morphologically)) && (NIL != string_is_pos_on_wuP_asserted(string, word_unit, pos, mt))) {
            return T;
        }
        SubLObject strings = NIL;
        if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
            final SubLObject pcase_var = string_lookup_function;
            if (pcase_var.eql(GET_STRINGS_OF_TYPE)) {
                strings = get_strings_of_type(word_unit, pos, $ALL, NIL, mt);
            } else
                if (pcase_var.eql(GET_STRINGS_OF_TYPE_CACHED)) {
                    strings = get_strings_of_type_cached(word_unit, pos, $ALL, NIL, mt);
                } else {
                    strings = funcall(string_lookup_function, word_unit, pos, $ALL, NIL, mt);
                }

        }
        if (NIL != subl_promotions.memberP(string, strings, symbol_function(EQUALP), UNPROVIDED)) {
            return T;
        }
        if (parse_morphologically == $NEVER) {
            return NIL;
        }
        final SubLObject words = morphological_word_parser.words_of_complex_word_stringXspeech_part(string, pos);
        return subl_promotions.memberP(word_unit, words, symbol_function($sym98$EQUALS_EL_), UNPROVIDED);
    }

    public static final SubLObject string_is_pos_on_wuP_alt(SubLObject string, SubLObject word_unit, SubLObject pos, SubLObject mt, SubLObject string_lookup_function, SubLObject parse_morphologically) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (string_lookup_function == UNPROVIDED) {
            string_lookup_function = GET_STRINGS_OF_TYPE;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
                SubLObject caching_state = NIL;
                if (NIL == v_memoization_state) {
                    return com.cyc.cycjava.cycl.lexicon_accessors.string_is_pos_on_wuP_internal(string, word_unit, pos, mt, string_lookup_function, parse_morphologically);
                }
                caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym90$STRING_IS_POS_ON_WU_, UNPROVIDED);
                if (NIL == caching_state) {
                    caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym90$STRING_IS_POS_ON_WU_, SIX_INTEGER, NIL, EQUAL, UNPROVIDED);
                    memoization_state.memoization_state_put(v_memoization_state, $sym90$STRING_IS_POS_ON_WU_, caching_state);
                }
                {
                    SubLObject sxhash = memoization_state.sxhash_calc_6(string, word_unit, pos, mt, string_lookup_function, parse_morphologically);
                    SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                    if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                        {
                            SubLObject cdolist_list_var = collisions;
                            SubLObject collision = NIL;
                            for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                                {
                                    SubLObject cached_args = collision.first();
                                    SubLObject results2 = second(collision);
                                    if (string.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (word_unit.equal(cached_args.first())) {
                                            cached_args = cached_args.rest();
                                            if (pos.equal(cached_args.first())) {
                                                cached_args = cached_args.rest();
                                                if (mt.equal(cached_args.first())) {
                                                    cached_args = cached_args.rest();
                                                    if (string_lookup_function.equal(cached_args.first())) {
                                                        cached_args = cached_args.rest();
                                                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && parse_morphologically.equal(cached_args.first())) {
                                                            return memoization_state.caching_results(results2);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    {
                        SubLObject results = arg2(thread.resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.string_is_pos_on_wuP_internal(string, word_unit, pos, mt, string_lookup_function, parse_morphologically)));
                        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(string, word_unit, pos, mt, string_lookup_function, parse_morphologically));
                        return memoization_state.caching_results(results);
                    }
                }
            }
        }
    }

    public static SubLObject string_is_pos_on_wuP(final SubLObject string, final SubLObject word_unit, final SubLObject pos, SubLObject mt, SubLObject string_lookup_function, SubLObject parse_morphologically) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (string_lookup_function == UNPROVIDED) {
            string_lookup_function = GET_STRINGS_OF_TYPE;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return string_is_pos_on_wuP_internal(string, word_unit, pos, mt, string_lookup_function, parse_morphologically);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym93$STRING_IS_POS_ON_WU_, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym93$STRING_IS_POS_ON_WU_, SIX_INTEGER, NIL, EQUAL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, $sym93$STRING_IS_POS_ON_WU_, caching_state);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_6(string, word_unit, pos, mt, string_lookup_function, parse_morphologically);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (string.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (word_unit.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (pos.equal(cached_args.first())) {
                            cached_args = cached_args.rest();
                            if (mt.equal(cached_args.first())) {
                                cached_args = cached_args.rest();
                                if (string_lookup_function.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && parse_morphologically.equal(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(thread.resetMultipleValues(), multiple_value_list(string_is_pos_on_wuP_internal(string, word_unit, pos, mt, string_lookup_function, parse_morphologically)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(string, word_unit, pos, mt, string_lookup_function, parse_morphologically));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @return BOOLEAN; Is STRING is asserted to be POS on WORD-UNIT?
     */
    @LispMethod(comment = "@return BOOLEAN; Is STRING is asserted to be POS on WORD-UNIT?")
    public static final SubLObject string_is_pos_on_wuP_asserted_alt(SubLObject string, SubLObject word_unit, SubLObject pos, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_57 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            {
                                                SubLObject mt_var = mt;
                                                {
                                                    SubLObject _prev_bind_0_58 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                                                    try {
                                                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.possibly_in_mt_determine_function(mt_var), thread);
                                                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.possibly_in_mt_determine_mt(mt_var), thread);
                                                        com.cyc.cycjava.cycl.lexicon_accessors.ensure_speech_part_preds_initialized();
                                                        {
                                                            SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents($speech_part_preds$.getGlobalValue()));
                                                            while (!((NIL != ans) || (NIL != dictionary_contents.do_dictionary_contents_doneP(iteration_state)))) {
                                                                thread.resetMultipleValues();
                                                                {
                                                                    SubLObject pred = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                    SubLObject defining_mt = thread.secondMultipleValue();
                                                                    thread.resetMultipleValues();
                                                                    if (($$InferencePSC == $$InferencePSC) || (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP($$InferencePSC, defining_mt))) {
                                                                        {
                                                                            SubLObject pred_var = pred;
                                                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                                                                                {
                                                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                                                                                    SubLObject done_var = ans;
                                                                                    SubLObject token_var = NIL;
                                                                                    while (NIL == done_var) {
                                                                                        {
                                                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                                            if (NIL != valid) {
                                                                                                {
                                                                                                    SubLObject final_index_iterator = NIL;
                                                                                                    try {
                                                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, NIL, NIL);
                                                                                                        {
                                                                                                            SubLObject done_var_59 = ans;
                                                                                                            SubLObject token_var_60 = NIL;
                                                                                                            while (NIL == done_var_59) {
                                                                                                                {
                                                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_60);
                                                                                                                    SubLObject valid_61 = makeBoolean(token_var_60 != as);
                                                                                                                    if (NIL != valid_61) {
                                                                                                                        if (assertions_high.gaf_arg2(as).equalp(string)) {
                                                                                                                            {
                                                                                                                                SubLObject curr_pos = com.cyc.cycjava.cycl.lexicon_accessors.pos_of_pred(pred);
                                                                                                                                SubLObject okP = (NIL != pos) ? ((SubLObject) (com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(curr_pos, pos, UNPROVIDED))) : NIL;
                                                                                                                                if (NIL != okP) {
                                                                                                                                    ans = T;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    done_var_59 = makeBoolean((NIL == valid_61) || (NIL != ans));
                                                                                                                }
                                                                                                            } 
                                                                                                        }
                                                                                                    } finally {
                                                                                                        {
                                                                                                            SubLObject _prev_bind_0_62 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                                            try {
                                                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                                                if (NIL != final_index_iterator) {
                                                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                                                }
                                                                                                            } finally {
                                                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_62, thread);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            done_var = makeBoolean((NIL == valid) || (NIL != ans));
                                                                                        }
                                                                                    } 
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                }
                                                            } 
                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                        }
                                                    } finally {
                                                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                                                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0_58, thread);
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_63 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_63, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_57, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is STRING is asserted to be POS on WORD-UNIT?
     */
    @LispMethod(comment = "@return BOOLEAN; Is STRING is asserted to be POS on WORD-UNIT?")
    public static SubLObject string_is_pos_on_wuP_asserted(final SubLObject string, final SubLObject word_unit, final SubLObject pos, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$55 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    final SubLObject _prev_bind_0_$56 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.possibly_in_mt_determine_function(mt), thread);
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.possibly_in_mt_determine_mt(mt), thread);
                        ensure_speech_part_preds_initialized();
                        SubLObject iteration_state;
                        for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents($speech_part_preds$.getGlobalValue())); (NIL == ans) && (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                            thread.resetMultipleValues();
                            final SubLObject pred = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                            final SubLObject defining_mt = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            if ((NIL != kb_utilities.kbeq($$InferencePSC, $$InferencePSC)) || (NIL != genl_lexicon_mtP($$InferencePSC, defining_mt))) {
                                final SubLObject pred_var = pred;
                                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                                    SubLObject done_var = ans;
                                    final SubLObject token_var = NIL;
                                    while (NIL == done_var) {
                                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                        if (NIL != valid) {
                                            SubLObject final_index_iterator = NIL;
                                            try {
                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, NIL, NIL);
                                                SubLObject done_var_$57 = ans;
                                                final SubLObject token_var_$58 = NIL;
                                                while (NIL == done_var_$57) {
                                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$58);
                                                    final SubLObject valid_$59 = makeBoolean(!token_var_$58.eql(as));
                                                    if ((NIL != valid_$59) && assertions_high.gaf_arg2(as).equalp(string)) {
                                                        final SubLObject curr_pos = pos_of_pred(pred);
                                                        final SubLObject okP = (NIL != pos) ? genl_posP(curr_pos, pos, UNPROVIDED) : NIL;
                                                        if (NIL != okP) {
                                                            ans = T;
                                                        }
                                                    }
                                                    done_var_$57 = makeBoolean((NIL == valid_$59) || (NIL != ans));
                                                } 
                                            } finally {
                                                final SubLObject _prev_bind_0_$57 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    final SubLObject _values = getValuesAsVector();
                                                    if (NIL != final_index_iterator) {
                                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                    }
                                                    restoreValuesFromVector(_values);
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$57, thread);
                                                }
                                            }
                                        }
                                        done_var = makeBoolean((NIL == valid) || (NIL != ans));
                                    } 
                                }
                            }
                        }
                        dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0_$56, thread);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$58 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values2 = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values2);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$58, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$55, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return BOOLEAN; is STRING a form of WORD-UNIT whose pos-pred is PRED?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return BOOLEAN; is STRING a form of WORD-UNIT whose pos-pred is PRED?")
    public static final SubLObject string_is_pred_on_wuP_alt(SubLObject string, SubLObject word_unit, SubLObject pred, SubLObject mt, SubLObject parse_morphologically) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(word_unit, $sym92$LEXICAL_WORD_);
            SubLTrampolineFile.checkType(pred, $sym29$SPEECH_PART_PRED_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject successP = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_64 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                {
                                                    SubLObject string_preds = com.cyc.cycjava.cycl.lexicon_accessors.preds_of_stringXword(string, word_unit, lexicon_vars.$misspellingsP$.getDynamicValue(thread), mt, $NEVER);
                                                    if (NIL == successP) {
                                                        {
                                                            SubLObject csome_list_var = string_preds;
                                                            SubLObject string_pred = NIL;
                                                            for (string_pred = csome_list_var.first(); !((NIL != successP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , string_pred = csome_list_var.first()) {
                                                                if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_pos_predP(string_pred, pred, mt)) {
                                                                    successP = T;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_65 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL == successP) && (parse_morphologically != $NEVER)) {
                                                        {
                                                            SubLObject morph_string_preds = morphological_word_parser.preds_of_complex_word_stringXword(string, word_unit);
                                                            if (NIL == successP) {
                                                                {
                                                                    SubLObject csome_list_var = morph_string_preds;
                                                                    SubLObject string_pred = NIL;
                                                                    for (string_pred = csome_list_var.first(); !((NIL != successP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , string_pred = csome_list_var.first()) {
                                                                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_pos_predP(string_pred, pred, mt)) {
                                                                            successP = T;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_65, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_64, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return successP;
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return BOOLEAN; is STRING a form of WORD-UNIT whose pos-pred is PRED?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return BOOLEAN; is STRING a form of WORD-UNIT whose pos-pred is PRED?")
    public static SubLObject string_is_pred_on_wuP(final SubLObject string, final SubLObject word_unit, final SubLObject pred, SubLObject mt, SubLObject parse_morphologically) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexical_wordP(word_unit) : "! lexicon_accessors.lexical_wordP(word_unit) " + ("lexicon_accessors.lexical_wordP(word_unit) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word_unit) ") + word_unit;
        assert NIL != speech_part_predP(pred, UNPROVIDED) : "! lexicon_accessors.speech_part_predP(pred, .UNPROVIDED) " + ("lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) ") + pred;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject successP = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$62 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        final SubLObject string_preds = preds_of_stringXword(string, word_unit, lexicon_vars.$misspellingsP$.getDynamicValue(thread), mt, $NEVER);
                        if (NIL == successP) {
                            SubLObject csome_list_var = string_preds;
                            SubLObject string_pred = NIL;
                            string_pred = csome_list_var.first();
                            while ((NIL == successP) && (NIL != csome_list_var)) {
                                if (NIL != genl_pos_predP(string_pred, pred, mt)) {
                                    successP = T;
                                }
                                csome_list_var = csome_list_var.rest();
                                string_pred = csome_list_var.first();
                            } 
                        }
                    }
                    if ((NIL == successP) && (parse_morphologically != $NEVER)) {
                        final SubLObject morph_string_preds = morphological_word_parser.preds_of_complex_word_stringXword(string, word_unit);
                        if (NIL == successP) {
                            SubLObject csome_list_var = morph_string_preds;
                            SubLObject string_pred = NIL;
                            string_pred = csome_list_var.first();
                            while ((NIL == successP) && (NIL != csome_list_var)) {
                                if (NIL != genl_pos_predP(string_pred, pred, mt)) {
                                    successP = T;
                                }
                                csome_list_var = csome_list_var.rest();
                                string_pred = csome_list_var.first();
                            } 
                        }
                    }
                } finally {
                    final SubLObject _prev_bind_0_$63 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$63, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$62, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return successP;
    }

    /**
     * allow a user or a smart system to figure out the best wu for the string
     *
     * @unknown just a stub for now
     * @unknown daves baxter
     */
    @LispMethod(comment = "allow a user or a smart system to figure out the best wu for the string\r\n\r\n@unknown just a stub for now\r\n@unknown daves baxter")
    public static final SubLObject best_wu_for_string_alt(SubLObject string, SubLObject pos) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject words = NIL;
                {
                    SubLObject _prev_bind_0 = lexicon_vars.$parse_morphologically$.currentBinding(thread);
                    try {
                        lexicon_vars.$parse_morphologically$.bind($AS_FALLBACK, thread);
                        words = com.cyc.cycjava.cycl.lexicon_accessors.words_of_stringXspeech_part(string, pos, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    } finally {
                        lexicon_vars.$parse_morphologically$.rebind(_prev_bind_0, thread);
                    }
                }
                return words.first();
            }
        }
    }

    /**
     * allow a user or a smart system to figure out the best wu for the string
     *
     * @unknown just a stub for now
     * @unknown daves baxter
     */
    @LispMethod(comment = "allow a user or a smart system to figure out the best wu for the string\r\n\r\n@unknown just a stub for now\r\n@unknown daves baxter")
    public static SubLObject best_wu_for_string(final SubLObject string, final SubLObject pos) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject words = NIL;
        final SubLObject _prev_bind_0 = lexicon_vars.$parse_morphologically$.currentBinding(thread);
        try {
            lexicon_vars.$parse_morphologically$.bind($AS_FALLBACK, thread);
            words = words_of_stringXspeech_part(string, pos, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } finally {
            lexicon_vars.$parse_morphologically$.rebind(_prev_bind_0, thread);
        }
        return words.first();
    }/**
     * allow a user or a smart system to figure out the best wu for the string
     *
     * @unknown just a stub for now
     * @unknown daves baxter
     */


    /**
     * find the best pos for the input
     *
     * @unknown presently returns just the first one, but should probably allow for
    user-interaction, pos-taggers,...
     * @unknown daves baxter
     */
    @LispMethod(comment = "find the best pos for the input\r\n\r\n@unknown presently returns just the first one, but should probably allow for\r\nuser-interaction, pos-taggers,...\r\n@unknown daves baxter")
    public static final SubLObject best_pos_for_stringXwuXpos_alt(SubLObject string, SubLObject wu, SubLObject pos) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject poses = com.cyc.cycjava.cycl.lexicon_accessors.pos_of_stringXword(string, wu, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                SubLObject result = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        result = find(pos, poses, $sym97$SPEC_, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     * find the best pos for the input
     *
     * @unknown presently returns just the first one, but should probably allow for
    user-interaction, pos-taggers,...
     * @unknown daves baxter
     */
    @LispMethod(comment = "find the best pos for the input\r\n\r\n@unknown presently returns just the first one, but should probably allow for\r\nuser-interaction, pos-taggers,...\r\n@unknown daves baxter")
    public static SubLObject best_pos_for_stringXwuXpos(final SubLObject string, final SubLObject wu, final SubLObject pos) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject poses = pos_of_stringXword(string, wu, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        SubLObject result = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            result = find(pos, poses, $sym100$SPEC_, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return result;
    }/**
     * find the best pos for the input
     *
     * @unknown presently returns just the first one, but should probably allow for
    user-interaction, pos-taggers,...
     * @unknown daves baxter
     */


    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?")
    public static final SubLObject words_of_stringXpred_alt(SubLObject string, SubLObject pred, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pred, $sym29$SPEECH_PART_PRED_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject result = NIL;
                if (NIL != string_utilities.non_empty_string_p(string)) {
                    {
                        SubLObject current_state = memoization_state.current_memoization_state();
                        {
                            SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                            try {
                                lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                                {
                                    SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                                    {
                                        SubLObject _prev_bind_0_66 = memoization_state.$memoization_state$.currentBinding(thread);
                                        try {
                                            memoization_state.$memoization_state$.bind(local_state, thread);
                                            {
                                                SubLObject original_memoization_process = NIL;
                                                if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                                    original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                                    {
                                                        SubLObject current_proc = current_process();
                                                        if (NIL == original_memoization_process) {
                                                            memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                        } else {
                                                            if (original_memoization_process != current_proc) {
                                                                Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                            }
                                                        }
                                                    }
                                                }
                                                try {
                                                    if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                        result = nl_trie_accessors.nl_trie_words_of_stringXpred(string, pred, misspellingsP, lookup_mt, UNPROVIDED);
                                                    }
                                                } finally {
                                                    {
                                                        SubLObject _prev_bind_0_67 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                        try {
                                                            $is_thread_performing_cleanupP$.bind(T, thread);
                                                            if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(result, parse_morphologically)) {
                                                                result = delete_duplicates(append(result, morphological_word_parser.words_of_complex_word_stringXpred(string, pred)), symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                            }
                                                            if ((NIL != upper_case_p(string_utilities.first_char(string))) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(com.cyc.cycjava.cycl.lexicon_accessors.pos_of_pred(pred), $$ProperNoun, lookup_mt))) {
                                                                result = delete_duplicates(append(result, com.cyc.cycjava.cycl.lexicon_accessors.words_of_stringXpred(Strings.string_downcase(string, UNPROVIDED, UNPROVIDED), lexicon_utilities.common_noun_form_of_pred(pred), UNPROVIDED, UNPROVIDED, UNPROVIDED)), symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                            }
                                                            if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                                memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                            }
                                                        } finally {
                                                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_67, thread);
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            memoization_state.$memoization_state$.rebind(_prev_bind_0_66, thread);
                                        }
                                    }
                                }
                            } finally {
                                lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?")
    public static SubLObject words_of_stringXpred(final SubLObject string, final SubLObject pred, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != speech_part_predP(pred, UNPROVIDED) : "! lexicon_accessors.speech_part_predP(pred, .UNPROVIDED) " + ("lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_part_predP(pred, CommonSymbols.UNPROVIDED) ") + pred;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject result = NIL;
        if (NIL != string_utilities.non_empty_string_p(string)) {
            final SubLObject current_state = memoization_state.current_memoization_state();
            final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
            try {
                lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                final SubLObject _prev_bind_0_$64 = memoization_state.$memoization_state$.currentBinding(thread);
                try {
                    memoization_state.$memoization_state$.bind(local_state, thread);
                    final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                    try {
                        if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                            result = nl_trie_accessors.nl_trie_words_of_stringXpred(string, pred, misspellingsP, lookup_mt, UNPROVIDED);
                        }
                        if (NIL != proceed_with_morphological_parsingP(result, parse_morphologically)) {
                            result = delete_duplicates(append(result, morphological_word_parser.words_of_complex_word_stringXpred(string, pred)), symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        }
                        if ((NIL != upper_case_p(string_utilities.first_char(string))) && (NIL != genl_posP(pos_of_pred(pred), $$ProperNoun, lookup_mt))) {
                            result = delete_duplicates(append(result, words_of_stringXpred(Strings.string_downcase(string, UNPROVIDED, UNPROVIDED), lexicon_utilities.common_noun_form_of_pred(pred), UNPROVIDED, UNPROVIDED, UNPROVIDED)), symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        }
                    } finally {
                        final SubLObject _prev_bind_0_$65 = $is_thread_performing_cleanupP$.currentBinding(thread);
                        try {
                            $is_thread_performing_cleanupP$.bind(T, thread);
                            final SubLObject _values = getValuesAsVector();
                            memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                            restoreValuesFromVector(_values);
                        } finally {
                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$65, thread);
                        }
                    }
                } finally {
                    memoization_state.$memoization_state$.rebind(_prev_bind_0_$64, thread);
                }
            } finally {
                lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
            }
        }
        return result;
    }

    public static final SubLObject clear_pos_for_keyword_alt() {
        {
            SubLObject cs = $pos_for_keyword_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_pos_for_keyword() {
        final SubLObject cs = $pos_for_keyword_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_pos_for_keyword_alt(SubLObject pos_keyword, SubLObject lexical_mt) {
        if (lexical_mt == UNPROVIDED) {
            lexical_mt = $$EnglishLexiconMt;
        }
        return memoization_state.caching_state_remove_function_results_with_args($pos_for_keyword_caching_state$.getGlobalValue(), list(pos_keyword, lexical_mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_pos_for_keyword(final SubLObject pos_keyword, SubLObject lexical_mt) {
        if (lexical_mt == UNPROVIDED) {
            lexical_mt = $$EnglishLexiconMt;
        }
        return memoization_state.caching_state_remove_function_results_with_args($pos_for_keyword_caching_state$.getGlobalValue(), list(pos_keyword, lexical_mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return fort ; Cyc SpeechPart for the part-of-speech keyword
     * @unknown :noun, :mass-noun, and :verb have hand-selected associations since these involve sopeech parts with specs that should be associated with other keywords
     * @unknown AgentiveNoun is returned for :noun because this distinction is not often recognized in external resources (e.g., Penn treebank tag set)
     * @unknown Make sure this is kept in-synch with @xref keyword-for-pos
     * @unknown tom
     */
    @LispMethod(comment = "@return fort ; Cyc SpeechPart for the part-of-speech keyword\r\n@unknown :noun, :mass-noun, and :verb have hand-selected associations since these involve sopeech parts with specs that should be associated with other keywords\r\n@unknown AgentiveNoun is returned for :noun because this distinction is not often recognized in external resources (e.g., Penn treebank tag set)\r\n@unknown Make sure this is kept in-synch with @xref keyword-for-pos\r\n@unknown tom")
    public static final SubLObject pos_for_keyword_internal_alt(SubLObject pos_keyword, SubLObject lexical_mt) {
        SubLTrampolineFile.checkType(pos_keyword, KEYWORDP);
        {
            SubLObject real_pos = NIL;
            SubLObject pcase_var = pos_keyword;
            if (pcase_var.eql($ALL_NOUN_FORMS)) {
                real_pos = genls.all_specs($$Noun, lexical_mt, UNPROVIDED);
            } else {
                if (pcase_var.eql($NOUN)) {
                    real_pos = $list_alt103;
                } else {
                    if (pcase_var.eql($MASS_NOUN)) {
                        real_pos = $list_alt105;
                    } else {
                        if (pcase_var.eql($SIMPLE_NOUN)) {
                            real_pos = genls.all_specs($$CountNoun, lexical_mt, UNPROVIDED);
                        } else {
                            if (pcase_var.eql($DEVERBAL_NOUN)) {
                                real_pos = genls.all_specs($$DeVerbalNoun, lexical_mt, UNPROVIDED);
                            } else {
                                if (pcase_var.eql($AGENTIVE_NOUN)) {
                                    real_pos = genls.all_specs($$AgentiveNoun, lexical_mt, UNPROVIDED);
                                } else {
                                    if (pcase_var.eql($GERUNDIVE_NOUN)) {
                                        real_pos = genls.all_specs($$GerundiveNoun, lexical_mt, UNPROVIDED);
                                    } else {
                                        if (pcase_var.eql($PROPER_NOUN)) {
                                            real_pos = genls.all_specs($$ProperNoun, lexical_mt, UNPROVIDED);
                                        } else {
                                            if (pcase_var.eql($VERB)) {
                                                real_pos = $list_alt116;
                                            } else {
                                                if (pcase_var.eql($AUX)) {
                                                    real_pos = genls.all_specs($$AuxVerb, lexical_mt, UNPROVIDED);
                                                } else {
                                                    if (pcase_var.eql($ADJECTIVE)) {
                                                        real_pos = genls.all_specs($$Adjective, lexical_mt, UNPROVIDED);
                                                    } else {
                                                        if (pcase_var.eql($ADVERB)) {
                                                            real_pos = genls.all_specs($$Adverb, lexical_mt, UNPROVIDED);
                                                        } else {
                                                            if (pcase_var.eql($PREP)) {
                                                                real_pos = genls.all_specs($$Preposition, lexical_mt, UNPROVIDED);
                                                            } else {
                                                                if (pcase_var.eql($DET)) {
                                                                    real_pos = genls.all_specs($$Determiner, lexical_mt, UNPROVIDED);
                                                                } else {
                                                                    if (pcase_var.eql($CONJ)) {
                                                                        real_pos = genls.all_specs($$Conjunction, lexical_mt, UNPROVIDED);
                                                                    } else {
                                                                        if (pcase_var.eql($ANY)) {
                                                                            real_pos = com.cyc.cycjava.cycl.lexicon_accessors.all_speech_parts(lexical_mt);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return real_pos;
        }
    }

    /**
     *
     *
     * @return fort ; Cyc SpeechPart for the part-of-speech keyword
     * @unknown :noun, :mass-noun, and :verb have hand-selected associations since these involve sopeech parts with specs that should be associated with other keywords
     * @unknown AgentiveNoun is returned for :noun because this distinction is not often recognized in external resources (e.g., Penn treebank tag set)
     * @unknown Make sure this is kept in-synch with @xref keyword-for-pos
     * @unknown tom
     */
    @LispMethod(comment = "@return fort ; Cyc SpeechPart for the part-of-speech keyword\r\n@unknown :noun, :mass-noun, and :verb have hand-selected associations since these involve sopeech parts with specs that should be associated with other keywords\r\n@unknown AgentiveNoun is returned for :noun because this distinction is not often recognized in external resources (e.g., Penn treebank tag set)\r\n@unknown Make sure this is kept in-synch with @xref keyword-for-pos\r\n@unknown tom")
    public static SubLObject pos_for_keyword_internal(final SubLObject pos_keyword, final SubLObject lexical_mt) {
        assert NIL != keywordp(pos_keyword) : "! keywordp(pos_keyword) " + ("Types.keywordp(pos_keyword) " + "CommonSymbols.NIL != Types.keywordp(pos_keyword) ") + pos_keyword;
        SubLObject real_pos = NIL;
        if (pos_keyword.eql($ALL_NOUN_FORMS)) {
            real_pos = genls.all_specs($$Noun, lexical_mt, UNPROVIDED);
        } else
            if (pos_keyword.eql($NOUN)) {
                real_pos = $list106;
            } else
                if (pos_keyword.eql($MASS_NOUN)) {
                    real_pos = $list108;
                } else
                    if (pos_keyword.eql($SIMPLE_NOUN)) {
                        real_pos = genls.all_specs($$CountNoun, lexical_mt, UNPROVIDED);
                    } else
                        if (pos_keyword.eql($DEVERBAL_NOUN)) {
                            real_pos = genls.all_specs($$DeVerbalNoun, lexical_mt, UNPROVIDED);
                        } else
                            if (pos_keyword.eql($AGENTIVE_NOUN)) {
                                real_pos = genls.all_specs($$AgentiveNoun, lexical_mt, UNPROVIDED);
                            } else
                                if (pos_keyword.eql($GERUNDIVE_NOUN)) {
                                    real_pos = genls.all_specs($$GerundiveNoun, lexical_mt, UNPROVIDED);
                                } else
                                    if (pos_keyword.eql($PROPER_NOUN)) {
                                        real_pos = genls.all_specs($$ProperNoun, lexical_mt, UNPROVIDED);
                                    } else
                                        if (pos_keyword.eql($VERB)) {
                                            real_pos = $list119;
                                        } else
                                            if (pos_keyword.eql($AUX)) {
                                                real_pos = genls.all_specs($$AuxVerb, lexical_mt, UNPROVIDED);
                                            } else
                                                if (pos_keyword.eql($ADJECTIVE)) {
                                                    real_pos = genls.all_specs($$Adjective, lexical_mt, UNPROVIDED);
                                                } else
                                                    if (pos_keyword.eql($ADVERB)) {
                                                        real_pos = genls.all_specs($$Adverb, lexical_mt, UNPROVIDED);
                                                    } else
                                                        if (pos_keyword.eql($PREP)) {
                                                            real_pos = genls.all_specs($$Preposition, lexical_mt, UNPROVIDED);
                                                        } else
                                                            if (pos_keyword.eql($DET)) {
                                                                real_pos = genls.all_specs($$Determiner, lexical_mt, UNPROVIDED);
                                                            } else
                                                                if (pos_keyword.eql($CONJ)) {
                                                                    real_pos = genls.all_specs($$Conjunction, lexical_mt, UNPROVIDED);
                                                                } else
                                                                    if (pos_keyword.eql($ANY)) {
                                                                        real_pos = all_speech_parts(lexical_mt);
                                                                    }















        return real_pos;
    }

    public static final SubLObject pos_for_keyword_alt(SubLObject pos_keyword, SubLObject lexical_mt) {
        if (lexical_mt == UNPROVIDED) {
            lexical_mt = $$EnglishLexiconMt;
        }
        {
            SubLObject caching_state = $pos_for_keyword_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(POS_FOR_KEYWORD, $pos_for_keyword_caching_state$, NIL, EQL, TWO_INTEGER, TWELVE_INTEGER);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(pos_keyword, lexical_mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (pos_keyword.eql(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && lexical_mt.eql(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.pos_for_keyword_internal(pos_keyword, lexical_mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(pos_keyword, lexical_mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject pos_for_keyword(final SubLObject pos_keyword, SubLObject lexical_mt) {
        if (lexical_mt == UNPROVIDED) {
            lexical_mt = $$EnglishLexiconMt;
        }
        SubLObject caching_state = $pos_for_keyword_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(POS_FOR_KEYWORD, $pos_for_keyword_caching_state$, $int$64, EQL, TWO_INTEGER, TWELVE_INTEGER);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(pos_keyword, lexical_mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (pos_keyword.eql(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && lexical_mt.eql(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(pos_for_keyword_internal(pos_keyword, lexical_mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(pos_keyword, lexical_mt));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return 0. list ; word units matching STRING and POS-KEYWORD
     * @return 1. list ; syntactic predicates used in the mapping
     * @return 2. list ; lexical predicates used for the semantic assertion
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return 0. list ; word units matching STRING and POS-KEYWORD\r\n@return 1. list ; syntactic predicates used in the mapping\r\n@return 2. list ; lexical predicates used for the semantic assertion")
    public static final SubLObject words_of_stringXpos_alt(SubLObject string, SubLObject pos_keyword, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pos_keyword, KEYWORDP);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject word_units = NIL;
                SubLObject preds = NIL;
                SubLObject lex_preds = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_68 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject word_units_69 = nl_trie_accessors.nl_trie_words_of_stringXpos(string, pos_keyword, misspellingsP, lookup_mt, UNPROVIDED);
                                                    SubLObject preds_70 = thread.secondMultipleValue();
                                                    SubLObject lex_preds_71 = thread.thirdMultipleValue();
                                                    thread.resetMultipleValues();
                                                    word_units = word_units_69;
                                                    preds = preds_70;
                                                    lex_preds = lex_preds_71;
                                                }
                                                if (remove_duplicates(lex_preds, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED).equal($list_alt131)) {
                                                    word_units = NIL;
                                                    preds = NIL;
                                                    lex_preds = NIL;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_72 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(word_units, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_word_units = morphological_word_parser.words_of_complex_word_stringXpos(string, pos_keyword, lookup_mt);
                                                            SubLObject morph_preds = thread.secondMultipleValue();
                                                            SubLObject morph_lex_preds = thread.thirdMultipleValue();
                                                            thread.resetMultipleValues();
                                                            word_units = append(word_units, morph_word_units);
                                                            preds = append(preds, morph_preds);
                                                            lex_preds = append(lex_preds, morph_lex_preds);
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_72, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_68, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(word_units, preds, lex_preds);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return 0. list ; word units matching STRING and POS-KEYWORD
     * @return 1. list ; syntactic predicates used in the mapping
     * @return 2. list ; lexical predicates used for the semantic assertion
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return 0. list ; word units matching STRING and POS-KEYWORD\r\n@return 1. list ; syntactic predicates used in the mapping\r\n@return 2. list ; lexical predicates used for the semantic assertion")
    public static SubLObject words_of_stringXpos(final SubLObject string, final SubLObject pos_keyword, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != keywordp(pos_keyword) : "! keywordp(pos_keyword) " + ("Types.keywordp(pos_keyword) " + "CommonSymbols.NIL != Types.keywordp(pos_keyword) ") + pos_keyword;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject word_units = NIL;
        SubLObject preds = NIL;
        SubLObject lex_preds = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$66 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject word_units_$67 = nl_trie_accessors.nl_trie_words_of_stringXpos(string, pos_keyword, misspellingsP, lookup_mt, UNPROVIDED);
                        final SubLObject preds_$68 = thread.secondMultipleValue();
                        final SubLObject lex_preds_$69 = thread.thirdMultipleValue();
                        thread.resetMultipleValues();
                        word_units = word_units_$67;
                        preds = preds_$68;
                        lex_preds = lex_preds_$69;
                        if (remove_duplicates(lex_preds, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED).equal($list135)) {
                            word_units = NIL;
                            preds = NIL;
                            lex_preds = NIL;
                        }
                    }
                    if (NIL != proceed_with_morphological_parsingP(word_units, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_word_units = morphological_word_parser.words_of_complex_word_stringXpos(string, pos_keyword, lookup_mt);
                        final SubLObject morph_preds = thread.secondMultipleValue();
                        final SubLObject morph_lex_preds = thread.thirdMultipleValue();
                        thread.resetMultipleValues();
                        word_units = append(word_units, morph_word_units);
                        preds = append(preds, morph_preds);
                        lex_preds = append(lex_preds, morph_lex_preds);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$67 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$67, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$66, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(word_units, preds, lex_preds);
    }

    /**
     *
     *
     * @param POS;
     * 		Something for which @xref SPEECH-PART? returns T.
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of word units matching STRING and POS
     */
    @LispMethod(comment = "@param POS;\r\n\t\tSomething for which @xref SPEECH-PART? returns T.\r\n@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of word units matching STRING and POS")
    public static final SubLObject words_of_stringXspeech_part_alt(SubLObject string, SubLObject pos, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject word_units = NIL;
                SubLObject preds = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_73 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject word_units_74 = nl_trie_accessors.nl_trie_words_of_stringXspeech_part(string, pos, misspellingsP, lookup_mt, UNPROVIDED);
                                                    SubLObject preds_75 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    word_units = word_units_74;
                                                    preds = preds_75;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_76 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(word_units, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_word_units = morphological_word_parser.words_of_complex_word_stringXspeech_part(string, pos);
                                                            SubLObject morph_preds = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            word_units = append(word_units, morph_word_units);
                                                            preds = append(preds, morph_preds);
                                                        }
                                                    }
                                                    if ((NIL != upper_case_p(string_utilities.first_char(string))) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(pos, $$ProperNoun, lookup_mt))) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject proper_word_units = com.cyc.cycjava.cycl.lexicon_accessors.words_of_stringXspeech_part(Strings.string_downcase(string, UNPROVIDED, UNPROVIDED), lexicon_utilities.common_noun_form_of_pos(pos), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                            SubLObject proper_preds = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            word_units = append(word_units, proper_word_units);
                                                            preds = append(preds, Mapping.mapcar(PROPER_NOUN_FORM_OF_PRED, proper_preds));
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_76, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_73, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(word_units, preds);
            }
        }
    }

    /**
     *
     *
     * @param POS;
     * 		Something for which @xref SPEECH-PART? returns T.
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of word units matching STRING and POS
     */
    @LispMethod(comment = "@param POS;\r\n\t\tSomething for which @xref SPEECH-PART? returns T.\r\n@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of word units matching STRING and POS")
    public static SubLObject words_of_stringXspeech_part(final SubLObject string, final SubLObject pos, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject word_units = NIL;
        SubLObject preds = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$71 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject word_units_$72 = nl_trie_accessors.nl_trie_words_of_stringXspeech_part(string, pos, misspellingsP, lookup_mt, UNPROVIDED);
                        final SubLObject preds_$73 = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        word_units = word_units_$72;
                        preds = preds_$73;
                    }
                    if (NIL != proceed_with_morphological_parsingP(word_units, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_word_units = morphological_word_parser.words_of_complex_word_stringXspeech_part(string, pos);
                        final SubLObject morph_preds = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        word_units = append(word_units, morph_word_units);
                        preds = append(preds, Mapping.mapcan(IDENTITY, morph_preds, EMPTY_SUBL_OBJECT_ARRAY));
                    }
                    if ((NIL != upper_case_p(string_utilities.first_char(string))) && (NIL != genl_posP(pos, $$ProperNoun, lookup_mt))) {
                        thread.resetMultipleValues();
                        final SubLObject proper_word_units = words_of_stringXspeech_part(Strings.string_downcase(string, UNPROVIDED, UNPROVIDED), lexicon_utilities.common_noun_form_of_pos(pos), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        final SubLObject proper_preds = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        word_units = append(word_units, proper_word_units);
                        preds = append(preds, Mapping.mapcar(PROPER_NOUN_FORM_OF_PRED, proper_preds));
                    }
                } finally {
                    final SubLObject _prev_bind_0_$72 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$72, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$71, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(word_units, preds);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of speech-part preds matching STRING and WORD.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of speech-part preds matching STRING and WORD.")
    public static final SubLObject preds_of_stringXword_alt(SubLObject string, SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        return NIL != kb_loaded() ? ((SubLObject) (copy_list(com.cyc.cycjava.cycl.lexicon_accessors.preds_of_stringXword_cached(string, word, misspellingsP, lookup_mt, parse_morphologically)))) : NIL;
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of speech-part preds matching STRING and WORD.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of speech-part preds matching STRING and WORD.")
    public static SubLObject preds_of_stringXword(final SubLObject string, final SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        return NIL != kb_loaded() ? copy_list(preds_of_stringXword_cached(string, word, misspellingsP, lookup_mt, parse_morphologically)) : NIL;
    }

    public static final SubLObject clear_preds_of_stringXword_alt() {
        return com.cyc.cycjava.cycl.lexicon_accessors.clear_preds_of_stringXword_cached();
    }

    public static SubLObject clear_preds_of_stringXword() {
        return clear_preds_of_stringXword_cached();
    }

    public static final SubLObject clear_preds_of_stringXword_cached_alt() {
        {
            SubLObject cs = $preds_of_stringXword_cached_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_preds_of_stringXword_cached() {
        final SubLObject cs = $preds_of_stringXword_cached_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_preds_of_stringXword_cached_alt(SubLObject string, SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        return memoization_state.caching_state_remove_function_results_with_args($preds_of_stringXword_cached_caching_state$.getGlobalValue(), list(string, word, misspellingsP, lookup_mt, parse_morphologically), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_preds_of_stringXword_cached(final SubLObject string, final SubLObject word, final SubLObject misspellingsP, final SubLObject lookup_mt, final SubLObject parse_morphologically) {
        return memoization_state.caching_state_remove_function_results_with_args($preds_of_stringXword_cached_caching_state$.getGlobalValue(), list(string, word, misspellingsP, lookup_mt, parse_morphologically), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject preds_of_stringXword_cached_internal_alt(SubLObject string, SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        SubLTrampolineFile.checkType(string, STRINGP);
        SubLTrampolineFile.checkType(word, $sym92$LEXICAL_WORD_);
        SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
        {
            SubLObject result = NIL;
            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                result = nl_trie_accessors.nl_trie_preds_of_stringXword(string, word, misspellingsP, lookup_mt, UNPROVIDED);
            }
            if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(result, parse_morphologically)) {
                result = delete_duplicates(append(result, morphological_word_parser.preds_of_complex_word_stringXword(string, word)), symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED);
            }
            return result;
        }
    }

    public static SubLObject preds_of_stringXword_cached_internal(final SubLObject string, final SubLObject word, final SubLObject misspellingsP, final SubLObject lookup_mt, final SubLObject parse_morphologically) {
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexical_wordP(word) : "! lexicon_accessors.lexical_wordP(word) " + ("lexicon_accessors.lexical_wordP(word) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word) ") + word;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject result = NIL;
        if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
            result = nl_trie_accessors.nl_trie_preds_of_stringXword(string, word, misspellingsP, lookup_mt, UNPROVIDED);
        }
        if (NIL != proceed_with_morphological_parsingP(result, parse_morphologically)) {
            result = delete_duplicates(append(result, morphological_word_parser.preds_of_complex_word_stringXword(string, word)), symbol_function(EQL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        return result;
    }

    public static final SubLObject preds_of_stringXword_cached_alt(SubLObject string, SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        {
            SubLObject caching_state = $preds_of_stringXword_cached_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name($sym133$PREDS_OF_STRING_WORD_CACHED, $sym134$_PREDS_OF_STRING_WORD_CACHED_CACHING_STATE_, $int$256, EQUAL, FIVE_INTEGER, ZERO_INTEGER);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_5(string, word, misspellingsP, lookup_mt, parse_morphologically);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (string.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (word.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (misspellingsP.equal(cached_args.first())) {
                                            cached_args = cached_args.rest();
                                            if (lookup_mt.equal(cached_args.first())) {
                                                cached_args = cached_args.rest();
                                                if (((NIL != cached_args) && (NIL == cached_args.rest())) && parse_morphologically.equal(cached_args.first())) {
                                                    return memoization_state.caching_results(results2);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.preds_of_stringXword_cached_internal(string, word, misspellingsP, lookup_mt, parse_morphologically)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(string, word, misspellingsP, lookup_mt, parse_morphologically));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject preds_of_stringXword_cached(final SubLObject string, final SubLObject word, final SubLObject misspellingsP, final SubLObject lookup_mt, final SubLObject parse_morphologically) {
        SubLObject caching_state = $preds_of_stringXword_cached_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym137$PREDS_OF_STRING_WORD_CACHED, $sym138$_PREDS_OF_STRING_WORD_CACHED_CACHING_STATE_, $int$256, EQUAL, FIVE_INTEGER, ZERO_INTEGER);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_5(string, word, misspellingsP, lookup_mt, parse_morphologically);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (string.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (word.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (misspellingsP.equal(cached_args.first())) {
                            cached_args = cached_args.rest();
                            if (lookup_mt.equal(cached_args.first())) {
                                cached_args = cached_args.rest();
                                if (((NIL != cached_args) && (NIL == cached_args.rest())) && parse_morphologically.equal(cached_args.first())) {
                                    return memoization_state.caching_results(results2);
                                }
                            }
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(preds_of_stringXword_cached_internal(string, word, misspellingsP, lookup_mt, parse_morphologically)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(string, word, misspellingsP, lookup_mt, parse_morphologically));
        return memoization_state.caching_results(results3);
    }

    /**
     * Return all function-pos strings of WORD-UNIT.  If MISSPELLINGS? is T, return
     * common misspellings as well.
     */
    @LispMethod(comment = "Return all function-pos strings of WORD-UNIT.  If MISSPELLINGS? is T, return\r\ncommon misspellings as well.\nReturn all function-pos strings of WORD-UNIT.  If MISSPELLINGS? is T, return\ncommon misspellings as well.")
    public static final SubLObject other_strings_of_wu_alt(SubLObject word_unit, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, $sym92$LEXICAL_WORD_);
            {
                SubLObject strings = NIL;
                SubLObject string_var = $sym135$_STRING;
                SubLObject v_properties = list($MAX_TRANSFORMATION_DEPTH, ZERO_INTEGER);
                {
                    SubLObject _prev_bind_0 = lexicon_vars.$misspellingsP$.currentBinding(thread);
                    try {
                        lexicon_vars.$misspellingsP$.bind(misspellingsP, thread);
                        if (NIL != valid_constantP($$partOfSpeech, UNPROVIDED)) {
                            strings = ask_utilities.query_variable(string_var, list($$partOfSpeech, word_unit, $sym137$_POS, string_var), lookup_mt, v_properties);
                        }
                    } finally {
                        lexicon_vars.$misspellingsP$.rebind(_prev_bind_0, thread);
                    }
                }
                return remove_duplicates(strings, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
            }
        }
    }

    @LispMethod(comment = "Return all function-pos strings of WORD-UNIT.  If MISSPELLINGS? is T, return\r\ncommon misspellings as well.\nReturn all function-pos strings of WORD-UNIT.  If MISSPELLINGS? is T, return\ncommon misspellings as well.")
    public static SubLObject other_strings_of_wu(final SubLObject word_unit, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != lexical_wordP(word_unit) : "! lexicon_accessors.lexical_wordP(word_unit) " + ("lexicon_accessors.lexical_wordP(word_unit) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word_unit) ") + word_unit;
        SubLObject strings = NIL;
        final SubLObject string_var = $sym139$_STRING;
        final SubLObject v_properties = list($MAX_TRANSFORMATION_DEPTH, ZERO_INTEGER);
        final SubLObject _prev_bind_0 = lexicon_vars.$misspellingsP$.currentBinding(thread);
        try {
            lexicon_vars.$misspellingsP$.bind(misspellingsP, thread);
            if (NIL != valid_constantP($$partOfSpeech, UNPROVIDED)) {
                strings = ask_utilities.query_variable(string_var, list($$partOfSpeech, word_unit, $sym141$_POS, string_var), lookup_mt, v_properties);
            }
        } finally {
            lexicon_vars.$misspellingsP$.rebind(_prev_bind_0, thread);
        }
        return remove_duplicates(strings, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }/**
     * Return all function-pos strings of WORD-UNIT.  If MISSPELLINGS? is T, return
     * common misspellings as well.
     */


    /**
     * Return the subcategorization frames which make sense for POS.
     */
    @LispMethod(comment = "Return the subcategorization frames which make sense for POS.")
    public static final SubLObject right_frames_for_pos_alt(SubLObject pos) {
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        {
            SubLObject pcase_var = pos;
            if (pcase_var.eql($$Verb)) {
                return lexicon_vars.verb_frames($$GeneralEnglishMt);
            } else {
                if (pcase_var.eql($$Adverb)) {
                    return isa.all_fort_instances($$FrameForAdverbs, $$GeneralEnglishMt, UNPROVIDED);
                } else {
                    if (pcase_var.eql($$ProperCountNoun)) {
                        return $list_alt142;
                    } else {
                        if (pcase_var.eql($$ProperMassNoun)) {
                            return $list_alt142;
                        } else {
                            if (pcase_var.eql($$CountNoun)) {
                                return isa.all_fort_instances($$FrameForNouns, $$GeneralEnglishMt, UNPROVIDED);
                            } else {
                                if (pcase_var.eql($$MassNoun)) {
                                    return delete($$ZeroArticleFrame, isa.all_fort_instances($$FrameForNouns, $$GeneralEnglishMt, UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                } else {
                                    if (pcase_var.eql($$Adjective)) {
                                        return delete($$FrameForAdjectives, isa.all_fort_instances($$FrameForAdjectives, $$GeneralEnglishMt, UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return NIL;
    }

    @LispMethod(comment = "Return the subcategorization frames which make sense for POS.")
    public static SubLObject right_frames_for_pos(final SubLObject pos) {
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        if (pos.eql($$Verb)) {
            return lexicon_vars.verb_frames($$GeneralEnglishMt);
        }
        if (pos.eql($$Adverb)) {
            return isa.all_fort_instances($$FrameForAdverbs, $$GeneralEnglishMt, UNPROVIDED);
        }
        if (pos.eql($$ProperCountNoun)) {
            return $list146;
        }
        if (pos.eql($$ProperMassNoun)) {
            return $list146;
        }
        if (pos.eql($$CountNoun)) {
            return isa.all_fort_instances($$FrameForNouns, $$GeneralEnglishMt, UNPROVIDED);
        }
        if (pos.eql($$MassNoun)) {
            return delete($$ZeroArticleFrame, isa.all_fort_instances($$FrameForNouns, $$GeneralEnglishMt, UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        if (pos.eql($$Adjective)) {
            return delete($$FrameForAdjectives, isa.all_fort_instances($$FrameForAdjectives, $$GeneralEnglishMt, UNPROVIDED), UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        return NIL;
    }/**
     * Return the subcategorization frames which make sense for POS.
     */


    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of speech parts associated with STRING.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of speech parts associated with STRING.")
    public static final SubLObject pos_of_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_77 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                result = nl_trie_accessors.nl_trie_pos_of_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_78 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(result, parse_morphologically)) {
                                                        result = delete_duplicates(append(result, morphological_word_parser.pos_of_complex_word_string(string)), symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_78, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_77, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of speech parts associated with STRING.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of speech parts associated with STRING.")
    public static SubLObject pos_of_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$75 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        result = nl_trie_accessors.nl_trie_pos_of_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                    }
                    if (NIL != proceed_with_morphological_parsingP(result, parse_morphologically)) {
                        result = delete_duplicates(append(result, morphological_word_parser.pos_of_complex_word_string(string)), symbol_function(EQL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$76 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$76, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$75, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @param POS;
     * 		Something for which SPEECH-PART? returns T.
     * @return BOOLEAN; Does STRING have the speech-part POS?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@param POS;\r\n\t\tSomething for which SPEECH-PART? returns T.\r\n@return BOOLEAN; Does STRING have the speech-part POS?")
    public static final SubLObject string_is_posP_alt(SubLObject string, SubLObject pos, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_79 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            result = nl_trie_accessors.nl_trie_string_is_posP(string, pos, misspellingsP, lookup_mt);
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_80 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL == result) && (parse_morphologically != $NEVER)) {
                                                        result = morphological_word_parser.complex_word_string_is_speech_partP(string, pos);
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_80, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_79, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @param POS;
     * 		Something for which SPEECH-PART? returns T.
     * @return BOOLEAN; Does STRING have the speech-part POS?
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@param POS;\r\n\t\tSomething for which SPEECH-PART? returns T.\r\n@return BOOLEAN; Does STRING have the speech-part POS?")
    public static SubLObject string_is_posP(final SubLObject string, final SubLObject pos, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$77 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    result = nl_trie_accessors.nl_trie_string_is_posP(string, pos, misspellingsP, lookup_mt);
                    if ((NIL == result) && (parse_morphologically != $NEVER)) {
                        result = morphological_word_parser.complex_word_string_is_speech_partP(string, pos);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$78 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$78, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$77, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    public static final SubLObject string_is_form_of_aux_verbP_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.string_is_posP(string, $$AuxVerb, misspellingsP, lookup_mt, UNPROVIDED);
    }

    public static SubLObject string_is_form_of_aux_verbP(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return string_is_posP(string, $$AuxVerb, misspellingsP, lookup_mt, UNPROVIDED);
    }

    public static final SubLObject clear_closed_lexical_class_hash_alt() {
        clrhash($closed_lexical_class_strings$.getGlobalValue());
        return $closed_lexical_class_strings$.getGlobalValue();
    }

    public static SubLObject clear_closed_lexical_class_hash() {
        clrhash($closed_lexical_class_strings$.getGlobalValue());
        clrhash($closed_lexical_class_strings_case_insensitive$.getGlobalValue());
        return $closed_lexical_class_strings$.getGlobalValue();
    }

    public static final SubLObject initialize_closed_lexical_class_strings_alt() {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            com.cyc.cycjava.cycl.lexicon_accessors.clear_closed_lexical_class_hash();
            {
                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    if (NIL != valid_constantP($$ClosedClassWord, UNPROVIDED)) {
                        {
                            SubLObject node_var = $$ClosedClassWord;
                            SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
                            SubLObject recur_deck = deck.create_deck(deck_type);
                            {
                                SubLObject _prev_bind_0_81 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                                try {
                                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                    {
                                        SubLObject tv_var = NIL;
                                        {
                                            SubLObject _prev_bind_0_82 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                            SubLObject _prev_bind_1_83 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                            try {
                                                sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? ((SubLObject) (tv_var)) : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV)) : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                                if (NIL != tv_var) {
                                                    if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
                                                        if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
                                                            {
                                                                SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                                                if (pcase_var.eql($ERROR)) {
                                                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                } else {
                                                                    if (pcase_var.eql($CERROR)) {
                                                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                    } else {
                                                                        if (pcase_var.eql($WARN)) {
                                                                            Errors.warn($str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        } else {
                                                                            Errors.warn($str_alt51$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                                            Errors.cerror($$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    SubLObject _prev_bind_0_84 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                                    SubLObject _prev_bind_1_85 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                                    SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                                    SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                    SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                    try {
                                                        sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                        sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$ClosedClassWord, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                                            {
                                                                SubLObject _prev_bind_0_86 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_1_87 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_2_88 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                try {
                                                                    sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                                                    while (NIL != node_var) {
                                                                        {
                                                                            SubLObject pos = node_var;
                                                                            SubLObject pred_var = $$partOfSpeech;
                                                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pos, TWO_INTEGER, pred_var)) {
                                                                                {
                                                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pos, TWO_INTEGER, pred_var);
                                                                                    SubLObject done_var = NIL;
                                                                                    SubLObject token_var = NIL;
                                                                                    while (NIL == done_var) {
                                                                                        {
                                                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                                            if (NIL != valid) {
                                                                                                {
                                                                                                    SubLObject final_index_iterator = NIL;
                                                                                                    try {
                                                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                                                        {
                                                                                                            SubLObject done_var_89 = NIL;
                                                                                                            SubLObject token_var_90 = NIL;
                                                                                                            while (NIL == done_var_89) {
                                                                                                                {
                                                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_90);
                                                                                                                    SubLObject valid_91 = makeBoolean(token_var_90 != as);
                                                                                                                    if (NIL != valid_91) {
                                                                                                                        {
                                                                                                                            SubLObject string = assertions_high.gaf_arg3(as);
                                                                                                                            SubLObject mt = assertions_high.assertion_mt(as);
                                                                                                                            hash_table_utilities.pushnew_hash(string, mt, $closed_lexical_class_strings$.getGlobalValue(), UNPROVIDED);
                                                                                                                        }
                                                                                                                    }
                                                                                                                    done_var_89 = makeBoolean(NIL == valid_91);
                                                                                                                }
                                                                                                            } 
                                                                                                        }
                                                                                                    } finally {
                                                                                                        {
                                                                                                            SubLObject _prev_bind_0_92 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                                            try {
                                                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                                                if (NIL != final_index_iterator) {
                                                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                                                }
                                                                                                            } finally {
                                                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_92, thread);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            done_var = makeBoolean(NIL == valid);
                                                                                        }
                                                                                    } 
                                                                                }
                                                                            }
                                                                        }
                                                                        {
                                                                            SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                                                            SubLObject cdolist_list_var = accessible_modules;
                                                                            SubLObject module_var = NIL;
                                                                            for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                {
                                                                                    SubLObject _prev_bind_0_93 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                    SubLObject _prev_bind_1_94 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                        {
                                                                                            SubLObject node = function_terms.naut_to_nart(node_var);
                                                                                            if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                {
                                                                                                    SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                    if (NIL != d_link) {
                                                                                                        {
                                                                                                            SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                            if (NIL != mt_links) {
                                                                                                                {
                                                                                                                    SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                    while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                        thread.resetMultipleValues();
                                                                                                                        {
                                                                                                                            SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                            SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                            thread.resetMultipleValues();
                                                                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                {
                                                                                                                                    SubLObject _prev_bind_0_95 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                    try {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                        {
                                                                                                                                            SubLObject iteration_state_96 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                            while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_96)) {
                                                                                                                                                thread.resetMultipleValues();
                                                                                                                                                {
                                                                                                                                                    SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_96);
                                                                                                                                                    SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                                    if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                        {
                                                                                                                                                            SubLObject _prev_bind_0_97 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                            try {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                {
                                                                                                                                                                    SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                    SubLObject cdolist_list_var_98 = new_list;
                                                                                                                                                                    SubLObject node_vars_link_node = NIL;
                                                                                                                                                                    for (node_vars_link_node = cdolist_list_var_98.first(); NIL != cdolist_list_var_98; cdolist_list_var_98 = cdolist_list_var_98.rest() , node_vars_link_node = cdolist_list_var_98.first()) {
                                                                                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                                                            deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            } finally {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_97, thread);
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    iteration_state_96 = dictionary_contents.do_dictionary_contents_next(iteration_state_96);
                                                                                                                                                }
                                                                                                                                            } 
                                                                                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_96);
                                                                                                                                        }
                                                                                                                                    } finally {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_95, thread);
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                        }
                                                                                                                    } 
                                                                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                    {
                                                                                                        SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                        SubLObject cdolist_list_var_99 = new_list;
                                                                                                        SubLObject generating_fn = NIL;
                                                                                                        for (generating_fn = cdolist_list_var_99.first(); NIL != cdolist_list_var_99; cdolist_list_var_99 = cdolist_list_var_99.rest() , generating_fn = cdolist_list_var_99.first()) {
                                                                                                            {
                                                                                                                SubLObject _prev_bind_0_100 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                try {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                    {
                                                                                                                        SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                        SubLObject new_list_101 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                        SubLObject cdolist_list_var_102 = new_list_101;
                                                                                                                        SubLObject node_vars_link_node = NIL;
                                                                                                                        for (node_vars_link_node = cdolist_list_var_102.first(); NIL != cdolist_list_var_102; cdolist_list_var_102 = cdolist_list_var_102.rest() , node_vars_link_node = cdolist_list_var_102.first()) {
                                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } finally {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_100, thread);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } finally {
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_94, thread);
                                                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_93, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        node_var = deck.deck_pop(recur_deck);
                                                                    } 
                                                                } finally {
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_88, thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_87, thread);
                                                                    sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_86, thread);
                                                                }
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str_alt55$Node__a_does_not_pass_sbhl_type_t, $$ClosedClassWord, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } finally {
                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4, thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_3, thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_2, thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_85, thread);
                                                        sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_84, thread);
                                                    }
                                                }
                                            } finally {
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_83, thread);
                                                sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_82, thread);
                                            }
                                        }
                                        sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                    }
                                } finally {
                                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_81, thread);
                                }
                            }
                        }
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            }
            return $closed_lexical_class_strings$.getGlobalValue();
        }
    }

    public static SubLObject initialize_closed_lexical_class_strings() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        clear_closed_lexical_class_hash();
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if (NIL != valid_constantP($$ClosedClassWord, UNPROVIDED)) {
                SubLObject node_var = $$ClosedClassWord;
                final SubLObject deck_type = $STACK;
                final SubLObject recur_deck = deck.create_deck(deck_type);
                final SubLObject _prev_bind_0_$79 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                try {
                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                    try {
                        final SubLObject tv_var = NIL;
                        final SubLObject _prev_bind_0_$80 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                        final SubLObject _prev_bind_1_$81 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                        try {
                            sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? tv_var : sbhl_search_vars.get_sbhl_true_tv(), thread);
                            sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? RELEVANT_SBHL_TV_IS_GENERAL_TV : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                            if (((NIL != tv_var) && (NIL != sbhl_paranoia.sbhl_object_type_checking_p())) && (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var))) {
                                final SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                if (pcase_var.eql($ERROR)) {
                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                } else
                                    if (pcase_var.eql($CERROR)) {
                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    } else
                                        if (pcase_var.eql($WARN)) {
                                            Errors.warn($str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        } else {
                                            Errors.warn($str54$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                            Errors.cerror($$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        }


                            }
                            final SubLObject _prev_bind_0_$81 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                            final SubLObject _prev_bind_1_$82 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                            final SubLObject _prev_bind_3 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                            final SubLObject _prev_bind_4 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                            final SubLObject _prev_bind_5 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                            try {
                                sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$ClosedClassWord, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                    final SubLObject _prev_bind_0_$82 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_1_$83 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_2_$86 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                    try {
                                        sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                        sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                        while (NIL != node_var) {
                                            final SubLObject pos = node_var;
                                            final SubLObject pred_var = $$partOfSpeech;
                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pos, TWO_INTEGER, pred_var)) {
                                                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pos, TWO_INTEGER, pred_var);
                                                SubLObject done_var = NIL;
                                                final SubLObject token_var = NIL;
                                                while (NIL == done_var) {
                                                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                                    if (NIL != valid) {
                                                        SubLObject final_index_iterator = NIL;
                                                        try {
                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                            SubLObject done_var_$87 = NIL;
                                                            final SubLObject token_var_$88 = NIL;
                                                            while (NIL == done_var_$87) {
                                                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$88);
                                                                final SubLObject valid_$89 = makeBoolean(!token_var_$88.eql(as));
                                                                if (NIL != valid_$89) {
                                                                    final SubLObject string = assertions_high.gaf_arg3(as);
                                                                    final SubLObject mt = assertions_high.assertion_mt(as);
                                                                    hash_table_utilities.pushnew_hash(string, mt, $closed_lexical_class_strings$.getGlobalValue(), UNPROVIDED);
                                                                    hash_table_utilities.pushnew_hash(string, mt, $closed_lexical_class_strings_case_insensitive$.getGlobalValue(), UNPROVIDED);
                                                                }
                                                                done_var_$87 = makeBoolean(NIL == valid_$89);
                                                            } 
                                                        } finally {
                                                            final SubLObject _prev_bind_0_$83 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                final SubLObject _values = getValuesAsVector();
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                                restoreValuesFromVector(_values);
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$83, thread);
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                } 
                                            }
                                            SubLObject cdolist_list_var;
                                            final SubLObject accessible_modules = cdolist_list_var = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                            SubLObject module_var = NIL;
                                            module_var = cdolist_list_var.first();
                                            while (NIL != cdolist_list_var) {
                                                final SubLObject _prev_bind_0_$84 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                final SubLObject _prev_bind_1_$84 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                try {
                                                    sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                    final SubLObject node = function_terms.naut_to_nart(node_var);
                                                    if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                        final SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                        if (NIL != d_link) {
                                                            final SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            if (NIL != mt_links) {
                                                                SubLObject iteration_state;
                                                                for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                                                                    thread.resetMultipleValues();
                                                                    final SubLObject mt2 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                    final SubLObject tv_links = thread.secondMultipleValue();
                                                                    thread.resetMultipleValues();
                                                                    if (NIL != mt_relevance_macros.relevant_mtP(mt2)) {
                                                                        final SubLObject _prev_bind_0_$85 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                        try {
                                                                            sbhl_link_vars.$sbhl_link_mt$.bind(mt2, thread);
                                                                            SubLObject iteration_state_$94;
                                                                            for (iteration_state_$94 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$94); iteration_state_$94 = dictionary_contents.do_dictionary_contents_next(iteration_state_$94)) {
                                                                                thread.resetMultipleValues();
                                                                                final SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$94);
                                                                                final SubLObject link_nodes = thread.secondMultipleValue();
                                                                                thread.resetMultipleValues();
                                                                                if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                    final SubLObject _prev_bind_0_$86 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                        final SubLObject sol = link_nodes;
                                                                                        if (NIL != set.set_p(sol)) {
                                                                                            final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                            SubLObject basis_object;
                                                                                            SubLObject state;
                                                                                            SubLObject node_vars_link_node;
                                                                                            for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                node_vars_link_node = set_contents.do_set_contents_next(basis_object, state);
                                                                                                if ((NIL != set_contents.do_set_contents_element_validP(state, node_vars_link_node)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED))) {
                                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                    deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                }
                                                                                            }
                                                                                        } else
                                                                                            if (sol.isList()) {
                                                                                                SubLObject csome_list_var = sol;
                                                                                                SubLObject node_vars_link_node2 = NIL;
                                                                                                node_vars_link_node2 = csome_list_var.first();
                                                                                                while (NIL != csome_list_var) {
                                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node2, UNPROVIDED)) {
                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node2, UNPROVIDED);
                                                                                                        deck.deck_push(node_vars_link_node2, recur_deck);
                                                                                                    }
                                                                                                    csome_list_var = csome_list_var.rest();
                                                                                                    node_vars_link_node2 = csome_list_var.first();
                                                                                                } 
                                                                                            } else {
                                                                                                Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                            }

                                                                                    } finally {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$86, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_$94);
                                                                        } finally {
                                                                            sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$85, thread);
                                                                        }
                                                                    }
                                                                }
                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } else
                                                        if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                            SubLObject cdolist_list_var_$96;
                                                            final SubLObject new_list = cdolist_list_var_$96 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            SubLObject generating_fn = NIL;
                                                            generating_fn = cdolist_list_var_$96.first();
                                                            while (NIL != cdolist_list_var_$96) {
                                                                final SubLObject _prev_bind_0_$87 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                try {
                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                    final SubLObject sol2;
                                                                    final SubLObject link_nodes2 = sol2 = funcall(generating_fn, node);
                                                                    if (NIL != set.set_p(sol2)) {
                                                                        final SubLObject set_contents_var2 = set.do_set_internal(sol2);
                                                                        SubLObject basis_object2;
                                                                        SubLObject state2;
                                                                        SubLObject node_vars_link_node3;
                                                                        for (basis_object2 = set_contents.do_set_contents_basis_object(set_contents_var2), state2 = NIL, state2 = set_contents.do_set_contents_initial_state(basis_object2, set_contents_var2); NIL == set_contents.do_set_contents_doneP(basis_object2, state2); state2 = set_contents.do_set_contents_update_state(state2)) {
                                                                            node_vars_link_node3 = set_contents.do_set_contents_next(basis_object2, state2);
                                                                            if ((NIL != set_contents.do_set_contents_element_validP(state2, node_vars_link_node3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node3, UNPROVIDED))) {
                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node3, UNPROVIDED);
                                                                                deck.deck_push(node_vars_link_node3, recur_deck);
                                                                            }
                                                                        }
                                                                    } else
                                                                        if (sol2.isList()) {
                                                                            SubLObject csome_list_var2 = sol2;
                                                                            SubLObject node_vars_link_node4 = NIL;
                                                                            node_vars_link_node4 = csome_list_var2.first();
                                                                            while (NIL != csome_list_var2) {
                                                                                if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node4, UNPROVIDED)) {
                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node4, UNPROVIDED);
                                                                                    deck.deck_push(node_vars_link_node4, recur_deck);
                                                                                }
                                                                                csome_list_var2 = csome_list_var2.rest();
                                                                                node_vars_link_node4 = csome_list_var2.first();
                                                                            } 
                                                                        } else {
                                                                            Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol2);
                                                                        }

                                                                } finally {
                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$87, thread);
                                                                }
                                                                cdolist_list_var_$96 = cdolist_list_var_$96.rest();
                                                                generating_fn = cdolist_list_var_$96.first();
                                                            } 
                                                        }

                                                } finally {
                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$84, thread);
                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$84, thread);
                                                }
                                                cdolist_list_var = cdolist_list_var.rest();
                                                module_var = cdolist_list_var.first();
                                            } 
                                            node_var = deck.deck_pop(recur_deck);
                                        } 
                                    } finally {
                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_$86, thread);
                                        sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_$83, thread);
                                        sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_$82, thread);
                                    }
                                } else {
                                    sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str59$Node__a_does_not_pass_sbhl_type_t, $$ClosedClassWord, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                }
                            } finally {
                                sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_5, thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_4, thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_3, thread);
                                sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_$82, thread);
                                sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_$81, thread);
                            }
                        } finally {
                            sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_$81, thread);
                            sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_$80, thread);
                        }
                    } finally {
                        final SubLObject _prev_bind_0_$88 = $is_thread_performing_cleanupP$.currentBinding(thread);
                        try {
                            $is_thread_performing_cleanupP$.bind(T, thread);
                            final SubLObject _values2 = getValuesAsVector();
                            sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                            restoreValuesFromVector(_values2);
                        } finally {
                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$88, thread);
                        }
                    }
                } finally {
                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_$79, thread);
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return $closed_lexical_class_strings$.getGlobalValue();
    }

    public static SubLObject closed_lexical_class_string_intP(final SubLObject string, final SubLObject mt, final SubLObject case_sensitiveP) {
        if (!string.isString()) {
            return NIL;
        }
        if (!hash_table_count($closed_lexical_class_strings$.getGlobalValue()).isPositive()) {
            initialize_closed_lexical_class_strings();
        }
        final SubLObject hash = (NIL != case_sensitiveP) ? $closed_lexical_class_strings$.getGlobalValue() : $closed_lexical_class_strings_case_insensitive$.getGlobalValue();
        final SubLObject ok_mts = gethash(string, hash, UNPROVIDED);
        SubLObject mt_okP = kb_utilities.kbeq(mt, $$InferencePSC);
        if (NIL == mt_okP) {
            SubLObject csome_list_var;
            SubLObject ok_mt;
            for (csome_list_var = ok_mts, ok_mt = NIL, ok_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, ok_mt) , csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
            }
        }
        return makeBoolean((NIL != ok_mts) && (NIL != mt_okP));
    }

    /**
     *
     *
     * @return boolean; Is STRING a member of a closed lexical class?
    Microtheory in which STRING is thus defined must be visible from MT.
     */
    @LispMethod(comment = "@return boolean; Is STRING a member of a closed lexical class?\r\nMicrotheory in which STRING is thus defined must be visible from MT.")
    public static final SubLObject closed_lexical_class_stringP_alt(SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        SubLTrampolineFile.checkType(string, STRINGP);
        if (!hash_table_count($closed_lexical_class_strings$.getGlobalValue()).isPositive()) {
            com.cyc.cycjava.cycl.lexicon_accessors.initialize_closed_lexical_class_strings();
        }
        {
            SubLObject ok_mts = gethash(string, $closed_lexical_class_strings$.getGlobalValue(), UNPROVIDED);
            SubLObject mt_okP = eq(mt, $$InferencePSC);
            if (NIL == mt_okP) {
                {
                    SubLObject csome_list_var = ok_mts;
                    SubLObject ok_mt = NIL;
                    for (ok_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
                        mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, ok_mt);
                    }
                }
            }
            return makeBoolean((NIL != ok_mts) && (NIL != mt_okP));
        }
    }

    /**
     *
     *
     * @return boolean; Is STRING a member of a closed lexical class?
    Microtheory in which STRING is thus defined must be visible from MT.
     */
    @LispMethod(comment = "@return boolean; Is STRING a member of a closed lexical class?\r\nMicrotheory in which STRING is thus defined must be visible from MT.")
    public static SubLObject closed_lexical_class_stringP(final SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        return closed_lexical_class_string_intP(string, mt, T);
    }

    public static SubLObject closed_lexical_class_string_case_insensitiveP(final SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        return closed_lexical_class_string_intP(string, mt, NIL);
    }

    public static final SubLObject non_pronominal_closed_lexical_class_stringP_alt(SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        return makeBoolean((NIL != com.cyc.cycjava.cycl.lexicon_accessors.closed_lexical_class_stringP(string, mt)) && (NIL == com.cyc.cycjava.cycl.lexicon_accessors.string_is_posP(string, $$Pronoun, UNPROVIDED, UNPROVIDED, UNPROVIDED)));
    }

    public static SubLObject non_pronominal_closed_lexical_class_stringP(final SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        return makeBoolean((NIL != closed_lexical_class_stringP(string, mt)) && (NIL == string_is_posP(string, $$Pronoun, UNPROVIDED, UNPROVIDED, UNPROVIDED)));
    }

    /**
     *
     *
     * @return boolean; Does STRING contain any word that is a member of
    a closed lexical class?
     */
    @LispMethod(comment = "@return boolean; Does STRING contain any word that is a member of\r\na closed lexical class?")
    public static final SubLObject contains_closed_lexical_class_wordP_alt(SubLObject string) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject class_member_found = NIL;
                {
                    SubLObject _prev_bind_0 = string_utilities.$test_char$.currentBinding(thread);
                    try {
                        string_utilities.$test_char$.bind(string_utilities.$space_char$.getGlobalValue(), thread);
                        {
                            SubLObject word_list_var = string_utilities.break_words(string, NOT_TEST_CHAR, UNPROVIDED);
                            SubLObject cdolist_list_var = word_list_var;
                            SubLObject word = NIL;
                            for (word = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , word = cdolist_list_var.first()) {
                                if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.closed_lexical_class_stringP(word, UNPROVIDED)) {
                                    class_member_found = T;
                                }
                            }
                        }
                    } finally {
                        string_utilities.$test_char$.rebind(_prev_bind_0, thread);
                    }
                }
                return class_member_found;
            }
        }
    }

    /**
     *
     *
     * @return boolean; Does STRING contain any word that is a member of
    a closed lexical class?
     */
    @LispMethod(comment = "@return boolean; Does STRING contain any word that is a member of\r\na closed lexical class?")
    public static SubLObject contains_closed_lexical_class_wordP(final SubLObject string) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject class_member_found = NIL;
        final SubLObject _prev_bind_0 = string_utilities.$test_char$.currentBinding(thread);
        try {
            string_utilities.$test_char$.bind(string_utilities.$space_char$.getGlobalValue(), thread);
            SubLObject cdolist_list_var;
            final SubLObject word_list_var = cdolist_list_var = string_utilities.break_words(string, NOT_TEST_CHAR, UNPROVIDED);
            SubLObject word = NIL;
            word = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != closed_lexical_class_stringP(word, UNPROVIDED)) {
                    class_member_found = T;
                }
                cdolist_list_var = cdolist_list_var.rest();
                word = cdolist_list_var.first();
            } 
        } finally {
            string_utilities.$test_char$.rebind(_prev_bind_0, thread);
        }
        return class_member_found;
    }

    public static final SubLObject clear_closed_lexical_class_strings_alt() {
        {
            SubLObject cs = $closed_lexical_class_strings_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_closed_lexical_class_strings() {
        final SubLObject cs = $closed_lexical_class_strings_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_closed_lexical_class_strings_alt(SubLObject lookup_mt) {
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($closed_lexical_class_strings_caching_state$.getGlobalValue(), list(lookup_mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_closed_lexical_class_strings(SubLObject lookup_mt) {
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($closed_lexical_class_strings_caching_state$.getGlobalValue(), list(lookup_mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return list : the current set of closed class words visible in LOOKUP-MT
     * @unknown If the lookup MT is :ANY all closed class strings are returned
     */
    @LispMethod(comment = "@return list : the current set of closed class words visible in LOOKUP-MT\r\n@unknown If the lookup MT is :ANY all closed class strings are returned")
    public static final SubLObject closed_lexical_class_strings_internal_alt(SubLObject lookup_mt) {
        {
            SubLObject open_class_strings = NIL;
            SubLObject open_class_string = NIL;
            SubLObject mts = NIL;
            {
                final Iterator cdohash_iterator = getEntrySetIterator($closed_lexical_class_strings$.getGlobalValue());
                try {
                    while (iteratorHasNext(cdohash_iterator)) {
                        final Map.Entry cdohash_entry = iteratorNextEntry(cdohash_iterator);
                        open_class_string = getEntryKey(cdohash_entry);
                        mts = getEntryValue(cdohash_entry);
                        {
                            SubLObject mt_okP = eq(lookup_mt, $$InferencePSC);
                            if (NIL == mt_okP) {
                                {
                                    SubLObject csome_list_var = mts;
                                    SubLObject mt = NIL;
                                    for (mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , mt = csome_list_var.first()) {
                                        mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(lookup_mt, mt);
                                    }
                                }
                            }
                            if (NIL != mt_okP) {
                                open_class_strings = cons(open_class_string, open_class_strings);
                            }
                        }
                    } 
                } finally {
                    releaseEntrySetIterator(cdohash_iterator);
                }
            }
            return open_class_strings;
        }
    }

    /**
     *
     *
     * @return list : the current set of closed class words visible in LOOKUP-MT
     * @unknown If the lookup MT is :ANY all closed class strings are returned
     */
    @LispMethod(comment = "@return list : the current set of closed class words visible in LOOKUP-MT\r\n@unknown If the lookup MT is :ANY all closed class strings are returned")
    public static SubLObject closed_lexical_class_strings_internal(final SubLObject lookup_mt) {
        SubLObject open_class_strings = NIL;
        SubLObject open_class_string = NIL;
        SubLObject mts = NIL;
        final Iterator cdohash_iterator = getEntrySetIterator($closed_lexical_class_strings$.getGlobalValue());
        try {
            while (iteratorHasNext(cdohash_iterator)) {
                final Map.Entry cdohash_entry = iteratorNextEntry(cdohash_iterator);
                open_class_string = getEntryKey(cdohash_entry);
                mts = getEntryValue(cdohash_entry);
                SubLObject mt_okP = kb_utilities.kbeq(lookup_mt, $$InferencePSC);
                if (NIL == mt_okP) {
                    SubLObject csome_list_var;
                    SubLObject mt;
                    for (csome_list_var = mts, mt = NIL, mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(lookup_mt, mt) , csome_list_var = csome_list_var.rest() , mt = csome_list_var.first()) {
                    }
                }
                if (NIL != mt_okP) {
                    open_class_strings = cons(open_class_string, open_class_strings);
                }
            } 
        } finally {
            releaseEntrySetIterator(cdohash_iterator);
        }
        return open_class_strings;
    }

    public static final SubLObject closed_lexical_class_strings_alt(SubLObject lookup_mt) {
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject caching_state = $closed_lexical_class_strings_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(CLOSED_LEXICAL_CLASS_STRINGS, $closed_lexical_class_strings_caching_state$, NIL, EQ, ONE_INTEGER, FOUR_INTEGER);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, lookup_mt, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.closed_lexical_class_strings_internal(lookup_mt)));
                    memoization_state.caching_state_put(caching_state, lookup_mt, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject closed_lexical_class_strings(SubLObject lookup_mt) {
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLObject caching_state = $closed_lexical_class_strings_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(CLOSED_LEXICAL_CLASS_STRINGS, $closed_lexical_class_strings_caching_state$, $int$32, EQL, ONE_INTEGER, FOUR_INTEGER);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, lookup_mt, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(closed_lexical_class_strings_internal(lookup_mt)));
            memoization_state.caching_state_put(caching_state, lookup_mt, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a closed lexical class in MT?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a closed lexical class in MT?")
    public static final SubLObject closed_lexical_classP_alt(SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return subl_promotions.memberP(obj, com.cyc.cycjava.cycl.lexicon_accessors.closed_lexical_classes(mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a closed lexical class in MT?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a closed lexical class in MT?")
    public static SubLObject closed_lexical_classP(final SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return subl_promotions.memberP(obj, closed_lexical_classes(mt), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject clear_closed_lexical_classes_alt() {
        {
            SubLObject cs = $closed_lexical_classes_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_closed_lexical_classes() {
        final SubLObject cs = $closed_lexical_classes_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_closed_lexical_classes_alt(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($closed_lexical_classes_caching_state$.getGlobalValue(), list(mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_closed_lexical_classes(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($closed_lexical_classes_caching_state$.getGlobalValue(), list(mt), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject closed_lexical_classes_internal_alt(SubLObject mt) {
        return genls.all_specs($$ClosedClassWord, mt, UNPROVIDED);
    }

    public static SubLObject closed_lexical_classes_internal(final SubLObject mt) {
        return genls.all_specs($$ClosedClassWord, mt, UNPROVIDED);
    }

    public static final SubLObject closed_lexical_classes_alt(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject caching_state = $closed_lexical_classes_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(CLOSED_LEXICAL_CLASSES, $closed_lexical_classes_caching_state$, NIL, EQL, ONE_INTEGER, EIGHT_INTEGER);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, mt, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.closed_lexical_classes_internal(mt)));
                    memoization_state.caching_state_put(caching_state, mt, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject closed_lexical_classes(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLObject caching_state = $closed_lexical_classes_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(CLOSED_LEXICAL_CLASSES, $closed_lexical_classes_caching_state$, NIL, EQL, ONE_INTEGER, EIGHT_INTEGER);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, mt, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(closed_lexical_classes_internal(mt)));
            memoization_state.caching_state_put(caching_state, mt, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    public static final SubLObject maybe_initialize_prep_strings_alt() {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (!hash_table_count($preposition_strings$.getDynamicValue(thread)).isPositive()) {
                if (NIL != valid_constantP($$Preposition, UNPROVIDED)) {
                    {
                        SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                        SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                        try {
                            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                            {
                                SubLObject node_var = $$Preposition;
                                SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
                                SubLObject recur_deck = deck.create_deck(deck_type);
                                {
                                    SubLObject _prev_bind_0_103 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                                    try {
                                        sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                        {
                                            SubLObject tv_var = NIL;
                                            {
                                                SubLObject _prev_bind_0_104 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                                SubLObject _prev_bind_1_105 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                                try {
                                                    sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? ((SubLObject) (tv_var)) : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                                    sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV)) : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                                    if (NIL != tv_var) {
                                                        if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
                                                            if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
                                                                {
                                                                    SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                                                    if (pcase_var.eql($ERROR)) {
                                                                        sbhl_paranoia.sbhl_error(ONE_INTEGER, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                    } else {
                                                                        if (pcase_var.eql($CERROR)) {
                                                                            sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                        } else {
                                                                            if (pcase_var.eql($WARN)) {
                                                                                Errors.warn($str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                            } else {
                                                                                Errors.warn($str_alt51$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                                                Errors.cerror($$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    {
                                                        SubLObject _prev_bind_0_106 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                                        SubLObject _prev_bind_1_107 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                                        SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                                        SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                        SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                        try {
                                                            sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                            sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                            sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                            sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                            sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                            if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$Preposition, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                                                {
                                                                    SubLObject _prev_bind_0_108 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                                                    SubLObject _prev_bind_1_109 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                                                    SubLObject _prev_bind_2_110 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                    try {
                                                                        sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                                        sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                                                        while (NIL != node_var) {
                                                                            {
                                                                                SubLObject pos = node_var;
                                                                                SubLObject pred_var = $$partOfSpeech;
                                                                                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pos, TWO_INTEGER, pred_var)) {
                                                                                    {
                                                                                        SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pos, TWO_INTEGER, pred_var);
                                                                                        SubLObject done_var = NIL;
                                                                                        SubLObject token_var = NIL;
                                                                                        while (NIL == done_var) {
                                                                                            {
                                                                                                SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                                                SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                                                if (NIL != valid) {
                                                                                                    {
                                                                                                        SubLObject final_index_iterator = NIL;
                                                                                                        try {
                                                                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                                                            {
                                                                                                                SubLObject done_var_111 = NIL;
                                                                                                                SubLObject token_var_112 = NIL;
                                                                                                                while (NIL == done_var_111) {
                                                                                                                    {
                                                                                                                        SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_112);
                                                                                                                        SubLObject valid_113 = makeBoolean(token_var_112 != as);
                                                                                                                        if (NIL != valid_113) {
                                                                                                                            {
                                                                                                                                SubLObject string = assertions_high.gaf_arg3(as);
                                                                                                                                SubLObject mt = assertions_high.assertion_mt(as);
                                                                                                                                hash_table_utilities.pushnew_hash(string, mt, $preposition_strings$.getDynamicValue(thread), UNPROVIDED);
                                                                                                                            }
                                                                                                                        }
                                                                                                                        done_var_111 = makeBoolean(NIL == valid_113);
                                                                                                                    }
                                                                                                                } 
                                                                                                            }
                                                                                                        } finally {
                                                                                                            {
                                                                                                                SubLObject _prev_bind_0_114 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                                                try {
                                                                                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                                                    if (NIL != final_index_iterator) {
                                                                                                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                                                    }
                                                                                                                } finally {
                                                                                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_114, thread);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                done_var = makeBoolean(NIL == valid);
                                                                                            }
                                                                                        } 
                                                                                    }
                                                                                }
                                                                            }
                                                                            {
                                                                                SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                                                                SubLObject cdolist_list_var = accessible_modules;
                                                                                SubLObject module_var = NIL;
                                                                                for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                    {
                                                                                        SubLObject _prev_bind_0_115 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                        SubLObject _prev_bind_1_116 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                        try {
                                                                                            sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                            sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                            {
                                                                                                SubLObject node = function_terms.naut_to_nart(node_var);
                                                                                                if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                    {
                                                                                                        SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                        if (NIL != d_link) {
                                                                                                            {
                                                                                                                SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                if (NIL != mt_links) {
                                                                                                                    {
                                                                                                                        SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                        while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                            thread.resetMultipleValues();
                                                                                                                            {
                                                                                                                                SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                                SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                                thread.resetMultipleValues();
                                                                                                                                if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                    {
                                                                                                                                        SubLObject _prev_bind_0_117 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                        try {
                                                                                                                                            sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                            {
                                                                                                                                                SubLObject iteration_state_118 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                                while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_118)) {
                                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                                    {
                                                                                                                                                        SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_118);
                                                                                                                                                        SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                        thread.resetMultipleValues();
                                                                                                                                                        if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                            {
                                                                                                                                                                SubLObject _prev_bind_0_119 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                                try {
                                                                                                                                                                    sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                    {
                                                                                                                                                                        SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                        SubLObject cdolist_list_var_120 = new_list;
                                                                                                                                                                        SubLObject node_vars_link_node = NIL;
                                                                                                                                                                        for (node_vars_link_node = cdolist_list_var_120.first(); NIL != cdolist_list_var_120; cdolist_list_var_120 = cdolist_list_var_120.rest() , node_vars_link_node = cdolist_list_var_120.first()) {
                                                                                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                                                                deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                } finally {
                                                                                                                                                                    sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_119, thread);
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        iteration_state_118 = dictionary_contents.do_dictionary_contents_next(iteration_state_118);
                                                                                                                                                    }
                                                                                                                                                } 
                                                                                                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state_118);
                                                                                                                                            }
                                                                                                                                        } finally {
                                                                                                                                            sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_117, thread);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                            }
                                                                                                                        } 
                                                                                                                        dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                        {
                                                                                                            SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                            SubLObject cdolist_list_var_121 = new_list;
                                                                                                            SubLObject generating_fn = NIL;
                                                                                                            for (generating_fn = cdolist_list_var_121.first(); NIL != cdolist_list_var_121; cdolist_list_var_121 = cdolist_list_var_121.rest() , generating_fn = cdolist_list_var_121.first()) {
                                                                                                                {
                                                                                                                    SubLObject _prev_bind_0_122 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                    try {
                                                                                                                        sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                        {
                                                                                                                            SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                            SubLObject new_list_123 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                            SubLObject cdolist_list_var_124 = new_list_123;
                                                                                                                            SubLObject node_vars_link_node = NIL;
                                                                                                                            for (node_vars_link_node = cdolist_list_var_124.first(); NIL != cdolist_list_var_124; cdolist_list_var_124 = cdolist_list_var_124.rest() , node_vars_link_node = cdolist_list_var_124.first()) {
                                                                                                                                if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                    deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    } finally {
                                                                                                                        sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_122, thread);
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        } finally {
                                                                                            sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_116, thread);
                                                                                            sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_115, thread);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            node_var = deck.deck_pop(recur_deck);
                                                                        } 
                                                                    } finally {
                                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_110, thread);
                                                                        sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_109, thread);
                                                                        sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_108, thread);
                                                                    }
                                                                }
                                                            } else {
                                                                sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str_alt55$Node__a_does_not_pass_sbhl_type_t, $$Preposition, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                            }
                                                        } finally {
                                                            sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4, thread);
                                                            sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_3, thread);
                                                            sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_2, thread);
                                                            sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_107, thread);
                                                            sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_106, thread);
                                                        }
                                                    }
                                                } finally {
                                                    sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_105, thread);
                                                    sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_104, thread);
                                                }
                                            }
                                            sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                        }
                                    } finally {
                                        sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_103, thread);
                                    }
                                }
                            }
                        } finally {
                            mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                        }
                    }
                }
                return $preposition_strings$.getDynamicValue(thread);
            }
            return NIL;
        }
    }

    public static SubLObject maybe_initialize_prep_strings() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (!hash_table_count($preposition_strings$.getDynamicValue(thread)).isPositive()) {
            if (NIL != valid_constantP($$Preposition, UNPROVIDED)) {
                final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    SubLObject node_var = $$Preposition;
                    final SubLObject deck_type = $STACK;
                    final SubLObject recur_deck = deck.create_deck(deck_type);
                    final SubLObject _prev_bind_0_$99 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                    try {
                        sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                        try {
                            final SubLObject tv_var = NIL;
                            final SubLObject _prev_bind_0_$100 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                            final SubLObject _prev_bind_1_$101 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                            try {
                                sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? tv_var : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? RELEVANT_SBHL_TV_IS_GENERAL_TV : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                if (((NIL != tv_var) && (NIL != sbhl_paranoia.sbhl_object_type_checking_p())) && (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var))) {
                                    final SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                    if (pcase_var.eql($ERROR)) {
                                        sbhl_paranoia.sbhl_error(ONE_INTEGER, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    } else
                                        if (pcase_var.eql($CERROR)) {
                                            sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                        } else
                                            if (pcase_var.eql($WARN)) {
                                                Errors.warn($str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                            } else {
                                                Errors.warn($str54$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                Errors.cerror($$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                            }


                                }
                                final SubLObject _prev_bind_0_$101 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                final SubLObject _prev_bind_1_$102 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                final SubLObject _prev_bind_3 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                final SubLObject _prev_bind_4 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                final SubLObject _prev_bind_5 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                try {
                                    sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                    sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                    sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                    sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                    if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$Preposition, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                        final SubLObject _prev_bind_0_$102 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                        final SubLObject _prev_bind_1_$103 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                        final SubLObject _prev_bind_2_$106 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                        try {
                                            sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                            sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                            sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                            while (NIL != node_var) {
                                                final SubLObject pos = node_var;
                                                final SubLObject pred_var = $$partOfSpeech;
                                                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pos, TWO_INTEGER, pred_var)) {
                                                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pos, TWO_INTEGER, pred_var);
                                                    SubLObject done_var = NIL;
                                                    final SubLObject token_var = NIL;
                                                    while (NIL == done_var) {
                                                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                                        if (NIL != valid) {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                SubLObject done_var_$107 = NIL;
                                                                final SubLObject token_var_$108 = NIL;
                                                                while (NIL == done_var_$107) {
                                                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$108);
                                                                    final SubLObject valid_$109 = makeBoolean(!token_var_$108.eql(as));
                                                                    if (NIL != valid_$109) {
                                                                        final SubLObject string = assertions_high.gaf_arg3(as);
                                                                        final SubLObject mt = assertions_high.assertion_mt(as);
                                                                        hash_table_utilities.pushnew_hash(string, mt, $preposition_strings$.getDynamicValue(thread), UNPROVIDED);
                                                                    }
                                                                    done_var_$107 = makeBoolean(NIL == valid_$109);
                                                                } 
                                                            } finally {
                                                                final SubLObject _prev_bind_0_$103 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                try {
                                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                                    final SubLObject _values = getValuesAsVector();
                                                                    if (NIL != final_index_iterator) {
                                                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                    }
                                                                    restoreValuesFromVector(_values);
                                                                } finally {
                                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$103, thread);
                                                                }
                                                            }
                                                        }
                                                        done_var = makeBoolean(NIL == valid);
                                                    } 
                                                }
                                                SubLObject cdolist_list_var;
                                                final SubLObject accessible_modules = cdolist_list_var = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                                SubLObject module_var = NIL;
                                                module_var = cdolist_list_var.first();
                                                while (NIL != cdolist_list_var) {
                                                    final SubLObject _prev_bind_0_$104 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                    final SubLObject _prev_bind_1_$104 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                    try {
                                                        sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                        final SubLObject node = function_terms.naut_to_nart(node_var);
                                                        if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                            final SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            if (NIL != d_link) {
                                                                final SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                if (NIL != mt_links) {
                                                                    SubLObject iteration_state;
                                                                    for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                                                                        thread.resetMultipleValues();
                                                                        final SubLObject mt2 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                        final SubLObject tv_links = thread.secondMultipleValue();
                                                                        thread.resetMultipleValues();
                                                                        if (NIL != mt_relevance_macros.relevant_mtP(mt2)) {
                                                                            final SubLObject _prev_bind_0_$105 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                            try {
                                                                                sbhl_link_vars.$sbhl_link_mt$.bind(mt2, thread);
                                                                                SubLObject iteration_state_$114;
                                                                                for (iteration_state_$114 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$114); iteration_state_$114 = dictionary_contents.do_dictionary_contents_next(iteration_state_$114)) {
                                                                                    thread.resetMultipleValues();
                                                                                    final SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$114);
                                                                                    final SubLObject link_nodes = thread.secondMultipleValue();
                                                                                    thread.resetMultipleValues();
                                                                                    if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                        final SubLObject _prev_bind_0_$106 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                        try {
                                                                                            sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                            final SubLObject sol = link_nodes;
                                                                                            if (NIL != set.set_p(sol)) {
                                                                                                final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                                SubLObject basis_object;
                                                                                                SubLObject state;
                                                                                                SubLObject node_vars_link_node;
                                                                                                for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                    node_vars_link_node = set_contents.do_set_contents_next(basis_object, state);
                                                                                                    if ((NIL != set_contents.do_set_contents_element_validP(state, node_vars_link_node)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED))) {
                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                        deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                    }
                                                                                                }
                                                                                            } else
                                                                                                if (sol.isList()) {
                                                                                                    SubLObject csome_list_var = sol;
                                                                                                    SubLObject node_vars_link_node2 = NIL;
                                                                                                    node_vars_link_node2 = csome_list_var.first();
                                                                                                    while (NIL != csome_list_var) {
                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node2, UNPROVIDED)) {
                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node2, UNPROVIDED);
                                                                                                            deck.deck_push(node_vars_link_node2, recur_deck);
                                                                                                        }
                                                                                                        csome_list_var = csome_list_var.rest();
                                                                                                        node_vars_link_node2 = csome_list_var.first();
                                                                                                    } 
                                                                                                } else {
                                                                                                    Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                                }

                                                                                        } finally {
                                                                                            sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$106, thread);
                                                                                        }
                                                                                    }
                                                                                }
                                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state_$114);
                                                                            } finally {
                                                                                sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$105, thread);
                                                                            }
                                                                        }
                                                                    }
                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                }
                                                            } else {
                                                                sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                            }
                                                        } else
                                                            if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                SubLObject cdolist_list_var_$116;
                                                                final SubLObject new_list = cdolist_list_var_$116 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                SubLObject generating_fn = NIL;
                                                                generating_fn = cdolist_list_var_$116.first();
                                                                while (NIL != cdolist_list_var_$116) {
                                                                    final SubLObject _prev_bind_0_$107 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                    try {
                                                                        sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                        final SubLObject sol2;
                                                                        final SubLObject link_nodes2 = sol2 = funcall(generating_fn, node);
                                                                        if (NIL != set.set_p(sol2)) {
                                                                            final SubLObject set_contents_var2 = set.do_set_internal(sol2);
                                                                            SubLObject basis_object2;
                                                                            SubLObject state2;
                                                                            SubLObject node_vars_link_node3;
                                                                            for (basis_object2 = set_contents.do_set_contents_basis_object(set_contents_var2), state2 = NIL, state2 = set_contents.do_set_contents_initial_state(basis_object2, set_contents_var2); NIL == set_contents.do_set_contents_doneP(basis_object2, state2); state2 = set_contents.do_set_contents_update_state(state2)) {
                                                                                node_vars_link_node3 = set_contents.do_set_contents_next(basis_object2, state2);
                                                                                if ((NIL != set_contents.do_set_contents_element_validP(state2, node_vars_link_node3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node3, UNPROVIDED))) {
                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node3, UNPROVIDED);
                                                                                    deck.deck_push(node_vars_link_node3, recur_deck);
                                                                                }
                                                                            }
                                                                        } else
                                                                            if (sol2.isList()) {
                                                                                SubLObject csome_list_var2 = sol2;
                                                                                SubLObject node_vars_link_node4 = NIL;
                                                                                node_vars_link_node4 = csome_list_var2.first();
                                                                                while (NIL != csome_list_var2) {
                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node4, UNPROVIDED)) {
                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node4, UNPROVIDED);
                                                                                        deck.deck_push(node_vars_link_node4, recur_deck);
                                                                                    }
                                                                                    csome_list_var2 = csome_list_var2.rest();
                                                                                    node_vars_link_node4 = csome_list_var2.first();
                                                                                } 
                                                                            } else {
                                                                                Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol2);
                                                                            }

                                                                    } finally {
                                                                        sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$107, thread);
                                                                    }
                                                                    cdolist_list_var_$116 = cdolist_list_var_$116.rest();
                                                                    generating_fn = cdolist_list_var_$116.first();
                                                                } 
                                                            }

                                                    } finally {
                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$104, thread);
                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$104, thread);
                                                    }
                                                    cdolist_list_var = cdolist_list_var.rest();
                                                    module_var = cdolist_list_var.first();
                                                } 
                                                node_var = deck.deck_pop(recur_deck);
                                            } 
                                        } finally {
                                            sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_$106, thread);
                                            sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_$103, thread);
                                            sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_$102, thread);
                                        }
                                    } else {
                                        sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str59$Node__a_does_not_pass_sbhl_type_t, $$Preposition, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    }
                                } finally {
                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_5, thread);
                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_4, thread);
                                    sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_3, thread);
                                    sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_$102, thread);
                                    sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_$101, thread);
                                }
                            } finally {
                                sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_$101, thread);
                                sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_$100, thread);
                            }
                        } finally {
                            final SubLObject _prev_bind_0_$108 = $is_thread_performing_cleanupP$.currentBinding(thread);
                            try {
                                $is_thread_performing_cleanupP$.bind(T, thread);
                                final SubLObject _values2 = getValuesAsVector();
                                sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                restoreValuesFromVector(_values2);
                            } finally {
                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$108, thread);
                            }
                        }
                    } finally {
                        sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_$99, thread);
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            }
            return $preposition_strings$.getDynamicValue(thread);
        }
        return NIL;
    }

    /**
     *
     *
     * @return boolean; Is STRING a preposition?
    Microtheory in which STRING is thus defined must be visible from MT.
     */
    @LispMethod(comment = "@return boolean; Is STRING a preposition?\r\nMicrotheory in which STRING is thus defined must be visible from MT.")
    public static final SubLObject preposition_stringP_alt(SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            com.cyc.cycjava.cycl.lexicon_accessors.maybe_initialize_prep_strings();
            {
                SubLObject ok_mts = gethash(string, $preposition_strings$.getDynamicValue(thread), UNPROVIDED);
                SubLObject mt_okP = eq(mt, $$InferencePSC);
                if (NIL == mt_okP) {
                    {
                        SubLObject csome_list_var = ok_mts;
                        SubLObject ok_mt = NIL;
                        for (ok_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
                            mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, ok_mt);
                        }
                    }
                }
                return makeBoolean((NIL != ok_mts) && (NIL != mt_okP));
            }
        }
    }

    /**
     *
     *
     * @return boolean; Is STRING a preposition?
    Microtheory in which STRING is thus defined must be visible from MT.
     */
    @LispMethod(comment = "@return boolean; Is STRING a preposition?\r\nMicrotheory in which STRING is thus defined must be visible from MT.")
    public static SubLObject preposition_stringP(final SubLObject string, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        maybe_initialize_prep_strings();
        final SubLObject ok_mts = gethash(string, $preposition_strings$.getDynamicValue(thread), UNPROVIDED);
        SubLObject mt_okP = kb_utilities.kbeq(mt, $$InferencePSC);
        if (NIL == mt_okP) {
            SubLObject csome_list_var;
            SubLObject ok_mt;
            for (csome_list_var = ok_mts, ok_mt = NIL, ok_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, ok_mt) , csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
            }
        }
        return makeBoolean((NIL != ok_mts) && (NIL != mt_okP));
    }

    /**
     *
     *
     * @return BOOLEAN; Quickly determine if OBJ is a reified #$LexicalWord in MT.
     */
    @LispMethod(comment = "@return BOOLEAN; Quickly determine if OBJ is a reified #$LexicalWord in MT.")
    public static final SubLObject quick_lexical_wordP_alt(SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.quick_lexical_wordP_int(obj, mt);
    }

    /**
     *
     *
     * @return BOOLEAN; Quickly determine if OBJ is a reified #$LexicalWord in MT.
     */
    @LispMethod(comment = "@return BOOLEAN; Quickly determine if OBJ is a reified #$LexicalWord in MT.")
    public static SubLObject quick_lexical_wordP(final SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return quick_lexical_wordP_int(obj, mt);
    }

    public static final SubLObject quick_lexical_wordP_int_alt(SubLObject obj, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject wordP = NIL;
                if (NIL != forts.fort_p(obj)) {
                    {
                        SubLObject mt_var = mt;
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                if (NIL == wordP) {
                                    {
                                        SubLObject csome_list_var = $pos_forms_spec_preds$.getGlobalValue();
                                        SubLObject pred = NIL;
                                        for (pred = csome_list_var.first(); !((NIL != wordP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pred = csome_list_var.first()) {
                                            wordP = makeBoolean((NIL != somewhere_cache.maybe_some_pred_assertion_somewhereP(pred, obj, ONE_INTEGER, UNPROVIDED)) && (NIL != kb_mapping_utilities.some_pred_value(obj, pred, ONE_INTEGER, UNPROVIDED)));
                                        }
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                } else {
                    if (obj.isAtom()) {
                    } else {
                        wordP = com.cyc.cycjava.cycl.lexicon_accessors.quick_word_nautP(obj);
                    }
                }
                return wordP;
            }
        }
    }

    public static SubLObject quick_lexical_wordP_int(final SubLObject obj, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject wordP = NIL;
        if (NIL != forts.fort_p(obj)) {
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt), thread);
                if (NIL == wordP) {
                    SubLObject csome_list_var;
                    SubLObject pred;
                    for (csome_list_var = $pos_forms_spec_preds$.getGlobalValue(), pred = NIL, pred = csome_list_var.first(); (NIL == wordP) && (NIL != csome_list_var); wordP = makeBoolean((NIL != somewhere_cache.maybe_some_pred_assertion_somewhereP(pred, obj, ONE_INTEGER, UNPROVIDED)) && (NIL != kb_mapping_utilities.some_pred_value(obj, pred, ONE_INTEGER, UNPROVIDED))) , csome_list_var = csome_list_var.rest() , pred = csome_list_var.first()) {
                    }
                }
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        } else
            if (!obj.isAtom()) {
                wordP = quick_word_nautP(obj);
            }

        return wordP;
    }

    public static final SubLObject quick_word_nautP_alt(SubLObject obj) {
        return formula_pattern_match.formula_matches_pattern(obj, $list_alt157);
    }

    public static SubLObject quick_word_nautP(final SubLObject obj) {
        return formula_pattern_match.formula_matches_pattern(obj, $list161);
    }

    /**
     *
     *
     * @return booleanp; whether OBJ is a #$LexicalWord.
     */
    @LispMethod(comment = "@return booleanp; whether OBJ is a #$LexicalWord.")
    public static final SubLObject lexical_wordP_internal_alt(SubLObject obj) {
        return isa.isa_in_any_mtP(obj, $$LexicalWord);
    }

    /**
     *
     *
     * @return booleanp; whether OBJ is a #$LexicalWord.
     */
    @LispMethod(comment = "@return booleanp; whether OBJ is a #$LexicalWord.")
    public static SubLObject lexical_wordP_internal(final SubLObject obj) {
        return isa.isa_in_any_mtP(obj, $$LexicalWord);
    }

    public static final SubLObject lexical_wordP_alt(SubLObject obj) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
                SubLObject caching_state = NIL;
                if (NIL == v_memoization_state) {
                    return com.cyc.cycjava.cycl.lexicon_accessors.lexical_wordP_internal(obj);
                }
                caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym92$LEXICAL_WORD_, UNPROVIDED);
                if (NIL == caching_state) {
                    caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym92$LEXICAL_WORD_, ONE_INTEGER, $int$1000, EQUAL, UNPROVIDED);
                    memoization_state.memoization_state_put(v_memoization_state, $sym92$LEXICAL_WORD_, caching_state);
                }
                {
                    SubLObject results = memoization_state.caching_state_lookup(caching_state, obj, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                    if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                        results = arg2(thread.resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.lexical_wordP_internal(obj)));
                        memoization_state.caching_state_put(caching_state, obj, results, UNPROVIDED);
                    }
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject lexical_wordP(final SubLObject obj) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return lexical_wordP_internal(obj);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym95$LEXICAL_WORD_, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym95$LEXICAL_WORD_, ONE_INTEGER, $int$1000, EQUAL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, $sym95$LEXICAL_WORD_, caching_state);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, obj, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(thread.resetMultipleValues(), multiple_value_list(lexical_wordP_internal(obj)));
            memoization_state.caching_state_put(caching_state, obj, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     *
     *
     * @return booleanp; whether OBJ is a #$DerivedWord.
     */
    @LispMethod(comment = "@return booleanp; whether OBJ is a #$DerivedWord.")
    public static final SubLObject derived_wordP_internal_alt(SubLObject obj) {
        return isa.isa_in_any_mtP(obj, $$DerivedWord);
    }

    /**
     *
     *
     * @return booleanp; whether OBJ is a #$DerivedWord.
     */
    @LispMethod(comment = "@return booleanp; whether OBJ is a #$DerivedWord.")
    public static SubLObject derived_wordP_internal(final SubLObject obj) {
        return isa.isa_in_any_mtP(obj, $$DerivedWord);
    }

    public static final SubLObject derived_wordP_alt(SubLObject obj) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
                SubLObject caching_state = NIL;
                if (NIL == v_memoization_state) {
                    return com.cyc.cycjava.cycl.lexicon_accessors.derived_wordP_internal(obj);
                }
                caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym160$DERIVED_WORD_, UNPROVIDED);
                if (NIL == caching_state) {
                    caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym160$DERIVED_WORD_, ONE_INTEGER, NIL, EQUAL, UNPROVIDED);
                    memoization_state.memoization_state_put(v_memoization_state, $sym160$DERIVED_WORD_, caching_state);
                }
                {
                    SubLObject results = memoization_state.caching_state_lookup(caching_state, obj, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                    if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                        results = arg2(thread.resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.derived_wordP_internal(obj)));
                        memoization_state.caching_state_put(caching_state, obj, results, UNPROVIDED);
                    }
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject derived_wordP(final SubLObject obj) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return derived_wordP_internal(obj);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym164$DERIVED_WORD_, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym164$DERIVED_WORD_, ONE_INTEGER, NIL, EQUAL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, $sym164$DERIVED_WORD_, caching_state);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, obj, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(thread.resetMultipleValues(), multiple_value_list(derived_wordP_internal(obj)));
            memoization_state.caching_state_put(caching_state, obj, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    public static final SubLObject initialize_vulgar_words_alt() {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            clear_set($vulgar_words$.getGlobalValue());
            {
                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    if (NIL != valid_constantP($$InherentlyVulgarWord, UNPROVIDED)) {
                        {
                            SubLObject node_var = $$InherentlyVulgarWord;
                            {
                                SubLObject _prev_bind_0_125 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                SubLObject _prev_bind_1_126 = sbhl_marking_vars.$sbhl_gather_space$.currentBinding(thread);
                                try {
                                    sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$isa), thread);
                                    sbhl_marking_vars.$sbhl_gather_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                    {
                                        SubLObject node_var_127 = node_var;
                                        SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
                                        SubLObject recur_deck = deck.create_deck(deck_type);
                                        {
                                            SubLObject _prev_bind_0_128 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                                            try {
                                                sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                                {
                                                    SubLObject tv_var = NIL;
                                                    {
                                                        SubLObject _prev_bind_0_129 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                                        SubLObject _prev_bind_1_130 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                                        try {
                                                            sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? ((SubLObject) (tv_var)) : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                                            sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV)) : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                                            if (NIL != tv_var) {
                                                                if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
                                                                    if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
                                                                        {
                                                                            SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                                                            if (pcase_var.eql($ERROR)) {
                                                                                sbhl_paranoia.sbhl_error(ONE_INTEGER, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                            } else {
                                                                                if (pcase_var.eql($CERROR)) {
                                                                                    sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                } else {
                                                                                    if (pcase_var.eql($WARN)) {
                                                                                        Errors.warn($str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                                    } else {
                                                                                        Errors.warn($str_alt51$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                                                        Errors.cerror($$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            {
                                                                SubLObject _prev_bind_0_131 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                                                SubLObject _prev_bind_1_132 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                                                SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                                                SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                try {
                                                                    sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa)), thread);
                                                                    sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa))), thread);
                                                                    sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa))), thread);
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                    sbhl_module_vars.$sbhl_module$.bind(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa)), thread);
                                                                    if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test(node_var, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                                                        {
                                                                            SubLObject _prev_bind_0_133 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                                                            SubLObject _prev_bind_1_134 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                                                            SubLObject _prev_bind_2_135 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                            try {
                                                                                sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                                                sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa))), thread);
                                                                                sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_var_127, UNPROVIDED);
                                                                                while (NIL != node_var_127) {
                                                                                    {
                                                                                        SubLObject tt_node_var = node_var_127;
                                                                                        SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$isa));
                                                                                        SubLObject cdolist_list_var = accessible_modules;
                                                                                        SubLObject module_var = NIL;
                                                                                        for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                            {
                                                                                                SubLObject _prev_bind_0_136 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                                SubLObject _prev_bind_1_137 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                                try {
                                                                                                    sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                                    {
                                                                                                        SubLObject node = function_terms.naut_to_nart(tt_node_var);
                                                                                                        if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                            {
                                                                                                                SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                if (NIL != d_link) {
                                                                                                                    {
                                                                                                                        SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_module_utilities.get_sbhl_module_backward_direction(sbhl_module_vars.get_sbhl_module($$isa)), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                        if (NIL != mt_links) {
                                                                                                                            {
                                                                                                                                SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                                while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                    {
                                                                                                                                        SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                                        SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                                        thread.resetMultipleValues();
                                                                                                                                        if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                            {
                                                                                                                                                SubLObject _prev_bind_0_138 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                                try {
                                                                                                                                                    sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                                    {
                                                                                                                                                        SubLObject iteration_state_139 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                                        while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_139)) {
                                                                                                                                                            thread.resetMultipleValues();
                                                                                                                                                            {
                                                                                                                                                                SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_139);
                                                                                                                                                                SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                                thread.resetMultipleValues();
                                                                                                                                                                if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                                    {
                                                                                                                                                                        SubLObject _prev_bind_0_140 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                                        try {
                                                                                                                                                                            sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                            {
                                                                                                                                                                                SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                                SubLObject cdolist_list_var_141 = new_list;
                                                                                                                                                                                SubLObject word = NIL;
                                                                                                                                                                                for (word = cdolist_list_var_141.first(); NIL != cdolist_list_var_141; cdolist_list_var_141 = cdolist_list_var_141.rest() , word = cdolist_list_var_141.first()) {
                                                                                                                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread))) {
                                                                                                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                                                                                                        if (NIL != forts.fort_p(word)) {
                                                                                                                                                                                            set_add(word, $vulgar_words$.getGlobalValue());
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        } finally {
                                                                                                                                                                            sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_140, thread);
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                iteration_state_139 = dictionary_contents.do_dictionary_contents_next(iteration_state_139);
                                                                                                                                                            }
                                                                                                                                                        } 
                                                                                                                                                        dictionary_contents.do_dictionary_contents_finalize(iteration_state_139);
                                                                                                                                                    }
                                                                                                                                                } finally {
                                                                                                                                                    sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_138, thread);
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                                    }
                                                                                                                                } 
                                                                                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                                }
                                                                                                            }
                                                                                                            if (NIL != sbhl_macros.do_sbhl_non_fort_linksP(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED))) {
                                                                                                                {
                                                                                                                    SubLObject csome_list_var = sbhl_link_methods.non_fort_instance_table_lookup(node);
                                                                                                                    SubLObject instance_tuple = NIL;
                                                                                                                    for (instance_tuple = csome_list_var.first(); NIL != csome_list_var; csome_list_var = csome_list_var.rest() , instance_tuple = csome_list_var.first()) {
                                                                                                                        {
                                                                                                                            SubLObject datum = instance_tuple;
                                                                                                                            SubLObject current = datum;
                                                                                                                            SubLObject link_node = NIL;
                                                                                                                            SubLObject mt = NIL;
                                                                                                                            SubLObject tv = NIL;
                                                                                                                            destructuring_bind_must_consp(current, datum, $list_alt164);
                                                                                                                            link_node = current.first();
                                                                                                                            current = current.rest();
                                                                                                                            destructuring_bind_must_consp(current, datum, $list_alt164);
                                                                                                                            mt = current.first();
                                                                                                                            current = current.rest();
                                                                                                                            destructuring_bind_must_consp(current, datum, $list_alt164);
                                                                                                                            tv = current.first();
                                                                                                                            current = current.rest();
                                                                                                                            if (NIL == current) {
                                                                                                                                if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                    {
                                                                                                                                        SubLObject _prev_bind_0_142 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                        try {
                                                                                                                                            sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                            if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                {
                                                                                                                                                    SubLObject _prev_bind_0_143 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                    try {
                                                                                                                                                        sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                        {
                                                                                                                                                            SubLObject link_nodes = list(link_node);
                                                                                                                                                            SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                            SubLObject cdolist_list_var_144 = new_list;
                                                                                                                                                            SubLObject word = NIL;
                                                                                                                                                            for (word = cdolist_list_var_144.first(); NIL != cdolist_list_var_144; cdolist_list_var_144 = cdolist_list_var_144.rest() , word = cdolist_list_var_144.first()) {
                                                                                                                                                                if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread))) {
                                                                                                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                                                                                    if (NIL != forts.fort_p(word)) {
                                                                                                                                                                        set_add(word, $vulgar_words$.getGlobalValue());
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    } finally {
                                                                                                                                                        sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_143, thread);
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        } finally {
                                                                                                                                            sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_142, thread);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                cdestructuring_bind_error(datum, $list_alt164);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                                {
                                                                                                                    SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_module_utilities.get_sbhl_module_backward_direction(sbhl_module_vars.get_sbhl_module($$isa)), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_module_utilities.get_sbhl_module_backward_direction(sbhl_module_vars.get_sbhl_module($$isa)), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                    SubLObject cdolist_list_var_145 = new_list;
                                                                                                                    SubLObject generating_fn = NIL;
                                                                                                                    for (generating_fn = cdolist_list_var_145.first(); NIL != cdolist_list_var_145; cdolist_list_var_145 = cdolist_list_var_145.rest() , generating_fn = cdolist_list_var_145.first()) {
                                                                                                                        {
                                                                                                                            SubLObject _prev_bind_0_146 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                            try {
                                                                                                                                sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                                {
                                                                                                                                    SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                                    SubLObject new_list_147 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                    SubLObject cdolist_list_var_148 = new_list_147;
                                                                                                                                    SubLObject word = NIL;
                                                                                                                                    for (word = cdolist_list_var_148.first(); NIL != cdolist_list_var_148; cdolist_list_var_148 = cdolist_list_var_148.rest() , word = cdolist_list_var_148.first()) {
                                                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread))) {
                                                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                                                            if (NIL != forts.fort_p(word)) {
                                                                                                                                                set_add(word, $vulgar_words$.getGlobalValue());
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } finally {
                                                                                                                                sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_146, thread);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                } finally {
                                                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_137, thread);
                                                                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_136, thread);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    {
                                                                                        SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa)));
                                                                                        SubLObject cdolist_list_var = accessible_modules;
                                                                                        SubLObject module_var = NIL;
                                                                                        for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                            {
                                                                                                SubLObject _prev_bind_0_149 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                                SubLObject _prev_bind_1_150 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                                try {
                                                                                                    sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                                    {
                                                                                                        SubLObject node = function_terms.naut_to_nart(node_var_127);
                                                                                                        if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                            {
                                                                                                                SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                if (NIL != d_link) {
                                                                                                                    {
                                                                                                                        SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                        if (NIL != mt_links) {
                                                                                                                            {
                                                                                                                                SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                                while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                    {
                                                                                                                                        SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                                        SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                                        thread.resetMultipleValues();
                                                                                                                                        if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                            {
                                                                                                                                                SubLObject _prev_bind_0_151 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                                try {
                                                                                                                                                    sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                                    {
                                                                                                                                                        SubLObject iteration_state_152 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                                        while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_152)) {
                                                                                                                                                            thread.resetMultipleValues();
                                                                                                                                                            {
                                                                                                                                                                SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_152);
                                                                                                                                                                SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                                thread.resetMultipleValues();
                                                                                                                                                                if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                                    {
                                                                                                                                                                        SubLObject _prev_bind_0_153 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                                        try {
                                                                                                                                                                            sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                            {
                                                                                                                                                                                SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                                SubLObject cdolist_list_var_154 = new_list;
                                                                                                                                                                                SubLObject node_vars_link_node = NIL;
                                                                                                                                                                                for (node_vars_link_node = cdolist_list_var_154.first(); NIL != cdolist_list_var_154; cdolist_list_var_154 = cdolist_list_var_154.rest() , node_vars_link_node = cdolist_list_var_154.first()) {
                                                                                                                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                                                                        deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        } finally {
                                                                                                                                                                            sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_153, thread);
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                iteration_state_152 = dictionary_contents.do_dictionary_contents_next(iteration_state_152);
                                                                                                                                                            }
                                                                                                                                                        } 
                                                                                                                                                        dictionary_contents.do_dictionary_contents_finalize(iteration_state_152);
                                                                                                                                                    }
                                                                                                                                                } finally {
                                                                                                                                                    sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_151, thread);
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                                    }
                                                                                                                                } 
                                                                                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                                {
                                                                                                                    SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                                    SubLObject cdolist_list_var_155 = new_list;
                                                                                                                    SubLObject generating_fn = NIL;
                                                                                                                    for (generating_fn = cdolist_list_var_155.first(); NIL != cdolist_list_var_155; cdolist_list_var_155 = cdolist_list_var_155.rest() , generating_fn = cdolist_list_var_155.first()) {
                                                                                                                        {
                                                                                                                            SubLObject _prev_bind_0_156 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                            try {
                                                                                                                                sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                                {
                                                                                                                                    SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                                    SubLObject new_list_157 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                    SubLObject cdolist_list_var_158 = new_list_157;
                                                                                                                                    SubLObject node_vars_link_node = NIL;
                                                                                                                                    for (node_vars_link_node = cdolist_list_var_158.first(); NIL != cdolist_list_var_158; cdolist_list_var_158 = cdolist_list_var_158.rest() , node_vars_link_node = cdolist_list_var_158.first()) {
                                                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                            deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } finally {
                                                                                                                                sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_156, thread);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                } finally {
                                                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_150, thread);
                                                                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_149, thread);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    node_var_127 = deck.deck_pop(recur_deck);
                                                                                } 
                                                                            } finally {
                                                                                sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_135, thread);
                                                                                sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_134, thread);
                                                                                sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_133, thread);
                                                                            }
                                                                        }
                                                                    } else {
                                                                        sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str_alt55$Node__a_does_not_pass_sbhl_type_t, node_var, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                    }
                                                                } finally {
                                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4, thread);
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_3, thread);
                                                                    sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_2, thread);
                                                                    sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_132, thread);
                                                                    sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_131, thread);
                                                                }
                                                            }
                                                        } finally {
                                                            sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_130, thread);
                                                            sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_129, thread);
                                                        }
                                                    }
                                                    sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                                }
                                            } finally {
                                                sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_128, thread);
                                            }
                                        }
                                        sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                    }
                                } finally {
                                    sbhl_marking_vars.$sbhl_gather_space$.rebind(_prev_bind_1_126, thread);
                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_125, thread);
                                }
                            }
                        }
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            }
            return $INITIALIZED;
        }
    }

    public static SubLObject initialize_vulgar_words() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        set.clear_set($vulgar_words$.getGlobalValue());
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if (NIL != valid_constantP($$InherentlyVulgarWord, UNPROVIDED)) {
                final SubLObject node_var = $$InherentlyVulgarWord;
                final SubLObject _prev_bind_0_$119 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                final SubLObject _prev_bind_1_$120 = sbhl_marking_vars.$sbhl_gather_space$.currentBinding(thread);
                try {
                    sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$isa), thread);
                    sbhl_marking_vars.$sbhl_gather_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                    try {
                        SubLObject node_var_$121 = node_var;
                        final SubLObject deck_type = $STACK;
                        final SubLObject recur_deck = deck.create_deck(deck_type);
                        final SubLObject _prev_bind_0_$120 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                        try {
                            sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                            try {
                                final SubLObject tv_var = NIL;
                                final SubLObject _prev_bind_0_$121 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                final SubLObject _prev_bind_1_$121 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                try {
                                    sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? tv_var : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                    sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? RELEVANT_SBHL_TV_IS_GENERAL_TV : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                    if (((NIL != tv_var) && (NIL != sbhl_paranoia.sbhl_object_type_checking_p())) && (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var))) {
                                        final SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                        if (pcase_var.eql($ERROR)) {
                                            sbhl_paranoia.sbhl_error(ONE_INTEGER, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                        } else
                                            if (pcase_var.eql($CERROR)) {
                                                sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                            } else
                                                if (pcase_var.eql($WARN)) {
                                                    Errors.warn($str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                } else {
                                                    Errors.warn($str54$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                    Errors.cerror($$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                }


                                    }
                                    final SubLObject _prev_bind_0_$122 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                    final SubLObject _prev_bind_1_$122 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                    final SubLObject _prev_bind_3 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                    final SubLObject _prev_bind_4 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                    final SubLObject _prev_bind_5 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                    try {
                                        sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa)), thread);
                                        sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa))), thread);
                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa))), thread);
                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                        sbhl_module_vars.$sbhl_module$.bind(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa)), thread);
                                        if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test(node_var, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                            final SubLObject _prev_bind_0_$123 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                            final SubLObject _prev_bind_1_$123 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                            final SubLObject _prev_bind_2_$129 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                            try {
                                                sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa))), thread);
                                                sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_var_$121, UNPROVIDED);
                                                while (NIL != node_var_$121) {
                                                    final SubLObject tt_node_var = node_var_$121;
                                                    SubLObject cdolist_list_var;
                                                    final SubLObject accessible_modules = cdolist_list_var = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$isa));
                                                    SubLObject module_var = NIL;
                                                    module_var = cdolist_list_var.first();
                                                    while (NIL != cdolist_list_var) {
                                                        final SubLObject _prev_bind_0_$124 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                        final SubLObject _prev_bind_1_$124 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                        try {
                                                            sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                            sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                            final SubLObject node = function_terms.naut_to_nart(tt_node_var);
                                                            if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                final SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                if (NIL != d_link) {
                                                                    final SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_module_utilities.get_sbhl_module_backward_direction(sbhl_module_vars.get_sbhl_module($$isa)), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                    if (NIL != mt_links) {
                                                                        SubLObject iteration_state;
                                                                        for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                                                                            thread.resetMultipleValues();
                                                                            final SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                            final SubLObject tv_links = thread.secondMultipleValue();
                                                                            thread.resetMultipleValues();
                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                final SubLObject _prev_bind_0_$125 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                try {
                                                                                    sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                    SubLObject iteration_state_$133;
                                                                                    for (iteration_state_$133 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$133); iteration_state_$133 = dictionary_contents.do_dictionary_contents_next(iteration_state_$133)) {
                                                                                        thread.resetMultipleValues();
                                                                                        final SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$133);
                                                                                        final SubLObject link_nodes = thread.secondMultipleValue();
                                                                                        thread.resetMultipleValues();
                                                                                        if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                            final SubLObject _prev_bind_0_$126 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                            try {
                                                                                                sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                final SubLObject sol = link_nodes;
                                                                                                if (NIL != set.set_p(sol)) {
                                                                                                    final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                                    SubLObject basis_object;
                                                                                                    SubLObject state;
                                                                                                    SubLObject word;
                                                                                                    for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                        word = set_contents.do_set_contents_next(basis_object, state);
                                                                                                        if ((NIL != set_contents.do_set_contents_element_validP(state, word)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread)))) {
                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                            if (NIL != forts.fort_p(word)) {
                                                                                                                set.set_add(word, $vulgar_words$.getGlobalValue());
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                } else
                                                                                                    if (sol.isList()) {
                                                                                                        SubLObject csome_list_var = sol;
                                                                                                        SubLObject word2 = NIL;
                                                                                                        word2 = csome_list_var.first();
                                                                                                        while (NIL != csome_list_var) {
                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word2, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread))) {
                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(word2, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                                if (NIL != forts.fort_p(word2)) {
                                                                                                                    set.set_add(word2, $vulgar_words$.getGlobalValue());
                                                                                                                }
                                                                                                            }
                                                                                                            csome_list_var = csome_list_var.rest();
                                                                                                            word2 = csome_list_var.first();
                                                                                                        } 
                                                                                                    } else {
                                                                                                        Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                                    }

                                                                                            } finally {
                                                                                                sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$126, thread);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state_$133);
                                                                                } finally {
                                                                                    sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$125, thread);
                                                                                }
                                                                            }
                                                                        }
                                                                        dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                    }
                                                                } else {
                                                                    sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                }
                                                                if (NIL != sbhl_macros.do_sbhl_non_fort_linksP(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED))) {
                                                                    SubLObject csome_list_var2 = sbhl_link_methods.non_fort_instance_table_lookup(node);
                                                                    SubLObject instance_tuple = NIL;
                                                                    instance_tuple = csome_list_var2.first();
                                                                    while (NIL != csome_list_var2) {
                                                                        SubLObject current;
                                                                        final SubLObject datum = current = instance_tuple;
                                                                        SubLObject link_node = NIL;
                                                                        SubLObject mt2 = NIL;
                                                                        SubLObject tv2 = NIL;
                                                                        destructuring_bind_must_consp(current, datum, $list168);
                                                                        link_node = current.first();
                                                                        current = current.rest();
                                                                        destructuring_bind_must_consp(current, datum, $list168);
                                                                        mt2 = current.first();
                                                                        current = current.rest();
                                                                        destructuring_bind_must_consp(current, datum, $list168);
                                                                        tv2 = current.first();
                                                                        current = current.rest();
                                                                        if (NIL == current) {
                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt2)) {
                                                                                final SubLObject _prev_bind_0_$127 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                try {
                                                                                    sbhl_link_vars.$sbhl_link_mt$.bind(mt2, thread);
                                                                                    if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv2)) {
                                                                                        final SubLObject _prev_bind_0_$128 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                        try {
                                                                                            sbhl_link_vars.$sbhl_link_tv$.bind(tv2, thread);
                                                                                            final SubLObject sol;
                                                                                            final SubLObject link_nodes2 = sol = list(link_node);
                                                                                            if (NIL != set.set_p(sol)) {
                                                                                                final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                                SubLObject basis_object;
                                                                                                SubLObject state;
                                                                                                SubLObject word;
                                                                                                for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                    word = set_contents.do_set_contents_next(basis_object, state);
                                                                                                    if ((NIL != set_contents.do_set_contents_element_validP(state, word)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread)))) {
                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(word, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                        if (NIL != forts.fort_p(word)) {
                                                                                                            set.set_add(word, $vulgar_words$.getGlobalValue());
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            } else
                                                                                                if (sol.isList()) {
                                                                                                    SubLObject csome_list_var_$137 = sol;
                                                                                                    SubLObject word2 = NIL;
                                                                                                    word2 = csome_list_var_$137.first();
                                                                                                    while (NIL != csome_list_var_$137) {
                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word2, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread))) {
                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(word2, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                                            if (NIL != forts.fort_p(word2)) {
                                                                                                                set.set_add(word2, $vulgar_words$.getGlobalValue());
                                                                                                            }
                                                                                                        }
                                                                                                        csome_list_var_$137 = csome_list_var_$137.rest();
                                                                                                        word2 = csome_list_var_$137.first();
                                                                                                    } 
                                                                                                } else {
                                                                                                    Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                                }

                                                                                        } finally {
                                                                                            sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$128, thread);
                                                                                        }
                                                                                    }
                                                                                } finally {
                                                                                    sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$127, thread);
                                                                                }
                                                                            }
                                                                        } else {
                                                                            cdestructuring_bind_error(datum, $list168);
                                                                        }
                                                                        csome_list_var2 = csome_list_var2.rest();
                                                                        instance_tuple = csome_list_var2.first();
                                                                    } 
                                                                }
                                                            } else
                                                                if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                    SubLObject cdolist_list_var_$138;
                                                                    final SubLObject new_list = cdolist_list_var_$138 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_module_utilities.get_sbhl_module_backward_direction(sbhl_module_vars.get_sbhl_module($$isa)), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_module_utilities.get_sbhl_module_backward_direction(sbhl_module_vars.get_sbhl_module($$isa)), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                    SubLObject generating_fn = NIL;
                                                                    generating_fn = cdolist_list_var_$138.first();
                                                                    while (NIL != cdolist_list_var_$138) {
                                                                        final SubLObject _prev_bind_0_$129 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                        try {
                                                                            sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                            final SubLObject sol2;
                                                                            final SubLObject link_nodes3 = sol2 = funcall(generating_fn, node);
                                                                            if (NIL != set.set_p(sol2)) {
                                                                                final SubLObject set_contents_var2 = set.do_set_internal(sol2);
                                                                                SubLObject basis_object2;
                                                                                SubLObject state2;
                                                                                SubLObject word3;
                                                                                for (basis_object2 = set_contents.do_set_contents_basis_object(set_contents_var2), state2 = NIL, state2 = set_contents.do_set_contents_initial_state(basis_object2, set_contents_var2); NIL == set_contents.do_set_contents_doneP(basis_object2, state2); state2 = set_contents.do_set_contents_update_state(state2)) {
                                                                                    word3 = set_contents.do_set_contents_next(basis_object2, state2);
                                                                                    if ((NIL != set_contents.do_set_contents_element_validP(state2, word3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word3, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread)))) {
                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(word3, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                        if (NIL != forts.fort_p(word3)) {
                                                                                            set.set_add(word3, $vulgar_words$.getGlobalValue());
                                                                                        }
                                                                                    }
                                                                                }
                                                                            } else
                                                                                if (sol2.isList()) {
                                                                                    SubLObject csome_list_var3 = sol2;
                                                                                    SubLObject word4 = NIL;
                                                                                    word4 = csome_list_var3.first();
                                                                                    while (NIL != csome_list_var3) {
                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(word4, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread))) {
                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(word4, sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                                                                                            if (NIL != forts.fort_p(word4)) {
                                                                                                set.set_add(word4, $vulgar_words$.getGlobalValue());
                                                                                            }
                                                                                        }
                                                                                        csome_list_var3 = csome_list_var3.rest();
                                                                                        word4 = csome_list_var3.first();
                                                                                    } 
                                                                                } else {
                                                                                    Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol2);
                                                                                }

                                                                        } finally {
                                                                            sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$129, thread);
                                                                        }
                                                                        cdolist_list_var_$138 = cdolist_list_var_$138.rest();
                                                                        generating_fn = cdolist_list_var_$138.first();
                                                                    } 
                                                                }

                                                        } finally {
                                                            sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$124, thread);
                                                            sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$124, thread);
                                                        }
                                                        cdolist_list_var = cdolist_list_var.rest();
                                                        module_var = cdolist_list_var.first();
                                                    } 
                                                    SubLObject cdolist_list_var2;
                                                    final SubLObject accessible_modules2 = cdolist_list_var2 = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_utilities.get_sbhl_transfers_through_module(sbhl_module_vars.get_sbhl_module($$isa)));
                                                    SubLObject module_var2 = NIL;
                                                    module_var2 = cdolist_list_var2.first();
                                                    while (NIL != cdolist_list_var2) {
                                                        final SubLObject _prev_bind_0_$130 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                        final SubLObject _prev_bind_1_$125 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                        try {
                                                            sbhl_module_vars.$sbhl_module$.bind(module_var2, thread);
                                                            sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                            final SubLObject node2 = function_terms.naut_to_nart(node_var_$121);
                                                            if (NIL != sbhl_link_vars.sbhl_node_object_p(node2)) {
                                                                final SubLObject d_link2 = sbhl_graphs.get_sbhl_graph_link(node2, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                if (NIL != d_link2) {
                                                                    final SubLObject mt_links2 = sbhl_links.get_sbhl_mt_links(d_link2, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                    if (NIL != mt_links2) {
                                                                        SubLObject iteration_state2;
                                                                        for (iteration_state2 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links2)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state2); iteration_state2 = dictionary_contents.do_dictionary_contents_next(iteration_state2)) {
                                                                            thread.resetMultipleValues();
                                                                            final SubLObject mt3 = dictionary_contents.do_dictionary_contents_key_value(iteration_state2);
                                                                            final SubLObject tv_links2 = thread.secondMultipleValue();
                                                                            thread.resetMultipleValues();
                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt3)) {
                                                                                final SubLObject _prev_bind_0_$131 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                try {
                                                                                    sbhl_link_vars.$sbhl_link_mt$.bind(mt3, thread);
                                                                                    SubLObject iteration_state_$134;
                                                                                    for (iteration_state_$134 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links2)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$134); iteration_state_$134 = dictionary_contents.do_dictionary_contents_next(iteration_state_$134)) {
                                                                                        thread.resetMultipleValues();
                                                                                        final SubLObject tv2 = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$134);
                                                                                        final SubLObject link_nodes4 = thread.secondMultipleValue();
                                                                                        thread.resetMultipleValues();
                                                                                        if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv2)) {
                                                                                            final SubLObject _prev_bind_0_$132 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                            try {
                                                                                                sbhl_link_vars.$sbhl_link_tv$.bind(tv2, thread);
                                                                                                final SubLObject sol3 = link_nodes4;
                                                                                                if (NIL != set.set_p(sol3)) {
                                                                                                    final SubLObject set_contents_var3 = set.do_set_internal(sol3);
                                                                                                    SubLObject basis_object3;
                                                                                                    SubLObject state3;
                                                                                                    SubLObject node_vars_link_node;
                                                                                                    for (basis_object3 = set_contents.do_set_contents_basis_object(set_contents_var3), state3 = NIL, state3 = set_contents.do_set_contents_initial_state(basis_object3, set_contents_var3); NIL == set_contents.do_set_contents_doneP(basis_object3, state3); state3 = set_contents.do_set_contents_update_state(state3)) {
                                                                                                        node_vars_link_node = set_contents.do_set_contents_next(basis_object3, state3);
                                                                                                        if ((NIL != set_contents.do_set_contents_element_validP(state3, node_vars_link_node)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED))) {
                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                            deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                        }
                                                                                                    }
                                                                                                } else
                                                                                                    if (sol3.isList()) {
                                                                                                        SubLObject csome_list_var4 = sol3;
                                                                                                        SubLObject node_vars_link_node2 = NIL;
                                                                                                        node_vars_link_node2 = csome_list_var4.first();
                                                                                                        while (NIL != csome_list_var4) {
                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node2, UNPROVIDED)) {
                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node2, UNPROVIDED);
                                                                                                                deck.deck_push(node_vars_link_node2, recur_deck);
                                                                                                            }
                                                                                                            csome_list_var4 = csome_list_var4.rest();
                                                                                                            node_vars_link_node2 = csome_list_var4.first();
                                                                                                        } 
                                                                                                    } else {
                                                                                                        Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol3);
                                                                                                    }

                                                                                            } finally {
                                                                                                sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$132, thread);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state_$134);
                                                                                } finally {
                                                                                    sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$131, thread);
                                                                                }
                                                                            }
                                                                        }
                                                                        dictionary_contents.do_dictionary_contents_finalize(iteration_state2);
                                                                    }
                                                                } else {
                                                                    sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                }
                                                            } else
                                                                if (NIL != obsolete.cnat_p(node2, UNPROVIDED)) {
                                                                    SubLObject cdolist_list_var_$139;
                                                                    final SubLObject new_list2 = cdolist_list_var_$139 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                    SubLObject generating_fn2 = NIL;
                                                                    generating_fn2 = cdolist_list_var_$139.first();
                                                                    while (NIL != cdolist_list_var_$139) {
                                                                        final SubLObject _prev_bind_0_$133 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                        try {
                                                                            sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn2, thread);
                                                                            final SubLObject sol4;
                                                                            final SubLObject link_nodes5 = sol4 = funcall(generating_fn2, node2);
                                                                            if (NIL != set.set_p(sol4)) {
                                                                                final SubLObject set_contents_var4 = set.do_set_internal(sol4);
                                                                                SubLObject basis_object4;
                                                                                SubLObject state4;
                                                                                SubLObject node_vars_link_node3;
                                                                                for (basis_object4 = set_contents.do_set_contents_basis_object(set_contents_var4), state4 = NIL, state4 = set_contents.do_set_contents_initial_state(basis_object4, set_contents_var4); NIL == set_contents.do_set_contents_doneP(basis_object4, state4); state4 = set_contents.do_set_contents_update_state(state4)) {
                                                                                    node_vars_link_node3 = set_contents.do_set_contents_next(basis_object4, state4);
                                                                                    if ((NIL != set_contents.do_set_contents_element_validP(state4, node_vars_link_node3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node3, UNPROVIDED))) {
                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node3, UNPROVIDED);
                                                                                        deck.deck_push(node_vars_link_node3, recur_deck);
                                                                                    }
                                                                                }
                                                                            } else
                                                                                if (sol4.isList()) {
                                                                                    SubLObject csome_list_var5 = sol4;
                                                                                    SubLObject node_vars_link_node4 = NIL;
                                                                                    node_vars_link_node4 = csome_list_var5.first();
                                                                                    while (NIL != csome_list_var5) {
                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node4, UNPROVIDED)) {
                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node4, UNPROVIDED);
                                                                                            deck.deck_push(node_vars_link_node4, recur_deck);
                                                                                        }
                                                                                        csome_list_var5 = csome_list_var5.rest();
                                                                                        node_vars_link_node4 = csome_list_var5.first();
                                                                                    } 
                                                                                } else {
                                                                                    Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol4);
                                                                                }

                                                                        } finally {
                                                                            sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$133, thread);
                                                                        }
                                                                        cdolist_list_var_$139 = cdolist_list_var_$139.rest();
                                                                        generating_fn2 = cdolist_list_var_$139.first();
                                                                    } 
                                                                }

                                                        } finally {
                                                            sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$125, thread);
                                                            sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$130, thread);
                                                        }
                                                        cdolist_list_var2 = cdolist_list_var2.rest();
                                                        module_var2 = cdolist_list_var2.first();
                                                    } 
                                                    node_var_$121 = deck.deck_pop(recur_deck);
                                                } 
                                            } finally {
                                                sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_$129, thread);
                                                sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_$123, thread);
                                                sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_$123, thread);
                                            }
                                        } else {
                                            sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str59$Node__a_does_not_pass_sbhl_type_t, node_var, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                        }
                                    } finally {
                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_5, thread);
                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_4, thread);
                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_3, thread);
                                        sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_$122, thread);
                                        sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_$122, thread);
                                    }
                                } finally {
                                    sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_$121, thread);
                                    sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_$121, thread);
                                }
                            } finally {
                                final SubLObject _prev_bind_0_$134 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$134, thread);
                                }
                            }
                        } finally {
                            sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_$120, thread);
                        }
                    } finally {
                        final SubLObject _prev_bind_0_$135 = $is_thread_performing_cleanupP$.currentBinding(thread);
                        try {
                            $is_thread_performing_cleanupP$.bind(T, thread);
                            final SubLObject _values2 = getValuesAsVector();
                            sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_gather_space$.getDynamicValue(thread));
                            restoreValuesFromVector(_values2);
                        } finally {
                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$135, thread);
                        }
                    }
                } finally {
                    sbhl_marking_vars.$sbhl_gather_space$.rebind(_prev_bind_1_$120, thread);
                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$119, thread);
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return $INITIALIZED;
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a vulgar word?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a vulgar word?")
    public static final SubLObject vulgar_wordP_alt(SubLObject obj) {
        if (NIL != set_emptyP($vulgar_words$.getGlobalValue())) {
            com.cyc.cycjava.cycl.lexicon_accessors.initialize_vulgar_words();
        }
        return set_memberP(obj, $vulgar_words$.getGlobalValue());
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a vulgar word?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a vulgar word?")
    public static SubLObject vulgar_wordP(final SubLObject obj) {
        if (NIL != set.set_emptyP($vulgar_words$.getGlobalValue())) {
            initialize_vulgar_words();
        }
        return set.set_memberP(obj, $vulgar_words$.getGlobalValue());
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of speech-parts STRING is known to be a spelling of for WORD.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of speech-parts STRING is known to be a spelling of for WORD.")
    public static final SubLObject pos_of_stringXword_alt(SubLObject string, SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(word, $sym92$LEXICAL_WORD_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_159 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                result = nl_trie_accessors.nl_trie_pos_of_stringXword(string, word, misspellingsP, lookup_mt, UNPROVIDED);
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_160 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(result, parse_morphologically)) {
                                                        result = delete_duplicates(append(result, morphological_word_parser.pos_of_complex_word_stringXword(string, word)), symbol_function(EQ), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_160, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_159, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of speech-parts STRING is known to be a spelling of for WORD.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of speech-parts STRING is known to be a spelling of for WORD.")
    public static SubLObject pos_of_stringXword(final SubLObject string, final SubLObject word, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexical_wordP(word) : "! lexicon_accessors.lexical_wordP(word) " + ("lexicon_accessors.lexical_wordP(word) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word) ") + word;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$149 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        result = nl_trie_accessors.nl_trie_pos_of_stringXword(string, word, misspellingsP, lookup_mt, UNPROVIDED);
                    }
                    if (NIL != proceed_with_morphological_parsingP(result, parse_morphologically)) {
                        result = delete_duplicates(append(result, morphological_word_parser.pos_of_complex_word_stringXword(string, word)), symbol_function(EQL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$150 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$150, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$149, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    /**
     * Clear cached lexicon, parsing, and paraphrase functions.
     */
    @LispMethod(comment = "Clear cached lexicon, parsing, and paraphrase functions.")
    public static final SubLObject clear_nl_caches_alt() {
        com.cyc.cycjava.cycl.lexicon_accessors.clear_cached_lexical_access_functions();
        pph_main.clear_paraphrase_caches(UNPROVIDED, UNPROVIDED);
        com.cyc.cycjava.cycl.lexicon_accessors.clear_nl_parsing_caches();
        return NIL;
    }

    @LispMethod(comment = "Clear cached lexicon, parsing, and paraphrase functions.")
    public static SubLObject clear_nl_caches() {
        clear_cached_lexical_access_functions();
        pph_main.clear_paraphrase_caches(UNPROVIDED, UNPROVIDED);
        clear_nl_parsing_caches();
        return NIL;
    }/**
     * Clear cached lexicon, parsing, and paraphrase functions.
     */


    /**
     * Clear cached NL parsing functions.
     */
    @LispMethod(comment = "Clear cached NL parsing functions.")
    public static final SubLObject clear_nl_parsing_caches_alt() {
        psp_main.clear_psp_caches();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_cached_lexical_access_functions();
        return NIL;
    }

    @LispMethod(comment = "Clear cached NL parsing functions.")
    public static SubLObject clear_nl_parsing_caches() {
        psp_main.clear_psp_caches();
        clear_cached_lexical_access_functions();
        return NIL;
    }/**
     * Clear cached NL parsing functions.
     */


    public static final SubLObject clear_cached_lexical_access_functions_alt() {
        lexicon_vars.clear_cached_lexical_vars();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_agr_of_det_string();
        lexicon_utilities.clear_preds_licensed_by_pos_cached();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_genl_pos_pred_from_mt_infoP();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_pos_of_pred();
        lexicon_utilities.clear_preds_of_pos_cached();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_closed_lexical_classes();
        rkf_string_weeders.clear_all_rkf_stringP_caches();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_verb_only_stringP();
        lexicon_utilities.clear_bar_level_cached();
        lexicon_utilities.clear_pos_of_cat_cached();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_genl_posP();
        com.cyc.cycjava.cycl.lexicon_accessors.clear_preds_of_stringXword_cached();
        nl_trie.clear_nl_trie_caches();
        return NIL;
    }

    public static SubLObject clear_cached_lexical_access_functions() {
        lexicon_vars.clear_cached_lexical_vars();
        clear_agr_of_det_string();
        lexicon_utilities.clear_preds_licensed_by_pos_cached();
        clear_genl_pos_pred_from_mt_infoP();
        clear_pos_of_pred();
        lexicon_utilities.clear_preds_of_pos_cached();
        clear_closed_lexical_classes();
        rkf_string_weeders.clear_all_rkf_stringP_caches();
        clear_verb_only_stringP();
        lexicon_utilities.clear_bar_level_cached();
        lexicon_utilities.clear_pos_of_cat_cached();
        clear_genl_posP();
        clear_preds_of_stringXword_cached();
        nl_trie.clear_nl_trie_caches();
        return NIL;
    }

    /**
     * Return all parts of speech for WORD-UNIT.
     */
    @LispMethod(comment = "Return all parts of speech for WORD-UNIT.")
    public static final SubLObject pos_of_word_alt(SubLObject word_unit, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, $sym92$LEXICAL_WORD_);
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_161 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL != forts.fort_p(word_unit)) {
                                                {
                                                    SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                                                    {
                                                        SubLObject _prev_bind_0_162 = mt_relevance_macros.$mt$.currentBinding(thread);
                                                        SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                                        SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                                                        try {
                                                            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                                            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                                            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                                            {
                                                                SubLObject cdolist_list_var = $pos_forms_spec_preds$.getGlobalValue();
                                                                SubLObject pred = NIL;
                                                                for (pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pred = cdolist_list_var.first()) {
                                                                    if (NIL != indexed_term_p(pred)) {
                                                                        result = append(result, kb_mapping_utilities.pred_values(word_unit, pred, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                                                                    }
                                                                }
                                                            }
                                                        } finally {
                                                            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                                            mt_relevance_macros.$mt$.rebind(_prev_bind_0_162, thread);
                                                        }
                                                    }
                                                }
                                            } else {
                                                if (NIL != narts_high.naut_p(word_unit)) {
                                                    {
                                                        SubLObject affix = lexicon_utilities.derived_word_affix(word_unit, UNPROVIDED);
                                                        result = mwp_rule.mwp_result_poses_for_reified_affix(affix, UNPROVIDED);
                                                    }
                                                } else {
                                                    Errors.warn($str_alt165$The_word_unit__S_is_neither_a_FOR, word_unit);
                                                    result = NIL;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_163 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_163, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_161, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    @LispMethod(comment = "Return all parts of speech for WORD-UNIT.")
    public static SubLObject pos_of_word(final SubLObject word_unit, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != lexical_wordP(word_unit) : "! lexicon_accessors.lexical_wordP(word_unit) " + ("lexicon_accessors.lexical_wordP(word_unit) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word_unit) ") + word_unit;
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$151 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL != forts.fort_p(word_unit)) {
                        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                        final SubLObject _prev_bind_0_$152 = mt_relevance_macros.$mt$.currentBinding(thread);
                        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                        try {
                            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                            SubLObject cdolist_list_var = $pos_forms_spec_preds$.getGlobalValue();
                            SubLObject pred = NIL;
                            pred = cdolist_list_var.first();
                            while (NIL != cdolist_list_var) {
                                if (NIL != indexed_term_p(pred)) {
                                    result = append(result, kb_mapping_utilities.pred_values(word_unit, pred, UNPROVIDED, UNPROVIDED, UNPROVIDED));
                                }
                                cdolist_list_var = cdolist_list_var.rest();
                                pred = cdolist_list_var.first();
                            } 
                        } finally {
                            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                            mt_relevance_macros.$mt$.rebind(_prev_bind_0_$152, thread);
                        }
                    } else
                        if (NIL != narts_high.naut_p(word_unit)) {
                            final SubLObject affix = lexicon_utilities.derived_word_affix(word_unit, UNPROVIDED);
                            result = mwp_rule.mwp_result_poses_for_reified_affix(affix, UNPROVIDED);
                        } else {
                            Errors.warn($str169$The_word_unit__S_is_neither_a_FOR, word_unit);
                            result = NIL;
                        }

                } finally {
                    final SubLObject _prev_bind_0_$153 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$153, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$151, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }/**
     * Return all parts of speech for WORD-UNIT.
     */


    /**
     *
     *
     * @return BOOLEAN; Does WORD-UNIT have the speech-part POS?
     */
    @LispMethod(comment = "@return BOOLEAN; Does WORD-UNIT have the speech-part POS?")
    public static final SubLObject word_has_posP_alt(SubLObject word_unit, SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, $sym92$LEXICAL_WORD_);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.possibly_in_mt_determine_function(mt_var), thread);
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.possibly_in_mt_determine_mt(mt_var), thread);
                        if (NIL == ans) {
                            {
                                SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.pos_of_word(word_unit, mt);
                                SubLObject word_pos = NIL;
                                for (word_pos = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , word_pos = csome_list_var.first()) {
                                    ans = (NIL != mt) ? ((SubLObject) (com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(word_pos, pos, mt))) : com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(word_pos, pos, mt_relevance_macros.$mt$.getDynamicValue(thread));
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Does WORD-UNIT have the speech-part POS?
     */
    @LispMethod(comment = "@return BOOLEAN; Does WORD-UNIT have the speech-part POS?")
    public static SubLObject word_has_posP(final SubLObject word_unit, final SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != lexical_wordP(word_unit) : "! lexicon_accessors.lexical_wordP(word_unit) " + ("lexicon_accessors.lexical_wordP(word_unit) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        SubLObject ans = NIL;
        final SubLObject mt_var = mt;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.possibly_in_mt_determine_function(mt_var), thread);
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.possibly_in_mt_determine_mt(mt_var), thread);
            if (NIL == ans) {
                SubLObject csome_list_var;
                SubLObject word_pos;
                for (csome_list_var = pos_of_word(word_unit, mt), word_pos = NIL, word_pos = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = (NIL != mt) ? genl_posP(word_pos, pos, mt) : genl_posP(word_pos, pos, mt_relevance_macros.$mt$.getDynamicValue(thread)) , csome_list_var = csome_list_var.rest() , word_pos = csome_list_var.first()) {
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject clear_verb_only_stringP_alt() {
        {
            SubLObject cs = $verb_only_stringP_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_verb_only_stringP() {
        final SubLObject cs = $verb_only_stringP_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_verb_only_stringP_alt(SubLObject string) {
        return memoization_state.caching_state_remove_function_results_with_args($verb_only_stringP_caching_state$.getGlobalValue(), list(string), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_verb_only_stringP(final SubLObject string) {
        return memoization_state.caching_state_remove_function_results_with_args($verb_only_stringP_caching_state$.getGlobalValue(), list(string), UNPROVIDED, UNPROVIDED);
    }

    /**
     * can STRING be just a verb?
     */
    @LispMethod(comment = "can STRING be just a verb?")
    public static final SubLObject verb_only_stringP_internal_alt(SubLObject string) {
        {
            SubLObject poses = com.cyc.cycjava.cycl.lexicon_accessors.pos_of_string(string, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            if (NIL == poses) {
                return NIL;
            }
            {
                SubLObject cdolist_list_var = poses;
                SubLObject pos = NIL;
                for (pos = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pos = cdolist_list_var.first()) {
                    if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(pos, $$Verb, UNPROVIDED)) {
                        return NIL;
                    }
                }
            }
            return T;
        }
    }

    @LispMethod(comment = "can STRING be just a verb?")
    public static SubLObject verb_only_stringP_internal(final SubLObject string) {
        final SubLObject poses = pos_of_string(string, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        if (NIL == poses) {
            return NIL;
        }
        SubLObject cdolist_list_var = poses;
        SubLObject pos = NIL;
        pos = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == genl_posP(pos, $$Verb, UNPROVIDED)) {
                return NIL;
            }
            cdolist_list_var = cdolist_list_var.rest();
            pos = cdolist_list_var.first();
        } 
        return T;
    }/**
     * can STRING be just a verb?
     */


    public static final SubLObject verb_only_stringP_alt(SubLObject string) {
        {
            SubLObject caching_state = $verb_only_stringP_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name($sym166$VERB_ONLY_STRING_, $sym167$_VERB_ONLY_STRING__CACHING_STATE_, NIL, EQUAL, ONE_INTEGER, $int$256);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, string, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.verb_only_stringP_internal(string)));
                    memoization_state.caching_state_put(caching_state, string, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject verb_only_stringP(final SubLObject string) {
        SubLObject caching_state = $verb_only_stringP_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym170$VERB_ONLY_STRING_, $sym171$_VERB_ONLY_STRING__CACHING_STATE_, $int$512, EQUAL, ONE_INTEGER, $int$256);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, string, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(verb_only_stringP_internal(string)));
            memoization_state.caching_state_put(caching_state, string, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     *
     *
     * @param STRING
    string
     * 		
     * @param TYPE
    collection
     * 		
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return list; a list of denotata for STRING that are instances of TYPE
    note that this function does some parsing, if the type sent in is appropriate
     */
    @LispMethod(comment = "@param STRING\nstring\r\n\t\t\r\n@param TYPE\ncollection\r\n\t\t\r\n@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return list; a list of denotata for STRING that are instances of TYPE\r\nnote that this function does some parsing, if the type sent in is appropriate")
    public static final SubLObject typed_denots_of_string_alt(SubLObject string, SubLObject type, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject semantic_mt, SubLObject parse_morphologically, SubLObject excluded_predicates) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (semantic_mt == UNPROVIDED) {
            semantic_mt = $$InferencePSC;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        if (excluded_predicates == UNPROVIDED) {
            excluded_predicates = lexicon_vars.$semantic_predicates_excluded_from_lexical_lookup$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(type, EL_FORT_P);
            SubLTrampolineFile.checkType(abbrev_types, LISTP);
            SubLTrampolineFile.checkType(denot_type, KEYWORDP);
            SubLTrampolineFile.checkType(misspellingsP, BOOLEANP);
            SubLTrampolineFile.checkType(skip_namestringsP, BOOLEANP);
            SubLTrampolineFile.checkType(lookup_mt, $sym172$HLMT_);
            SubLTrampolineFile.checkType(semantic_mt, $sym172$HLMT_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            SubLTrampolineFile.checkType(excluded_predicates, SET_P);
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_164 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots = com.cyc.cycjava.cycl.lexicon_accessors.denots_of_string(string, abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, parse_morphologically, UNPROVIDED, UNPROVIDED);
                                                SubLObject pred_lists = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denot = NIL;
                                                    SubLObject denot_165 = NIL;
                                                    SubLObject preds = NIL;
                                                    SubLObject preds_166 = NIL;
                                                    for (denot = denots, denot_165 = denot.first(), preds = pred_lists, preds_166 = preds.first(); !((NIL == preds) && (NIL == denot)); denot = denot.rest() , denot_165 = denot.first() , preds = preds.rest() , preds_166 = preds.first()) {
                                                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.typed_denots_of_string_preds_okP(preds_166, excluded_predicates)) {
                                                            {
                                                                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(semantic_mt);
                                                                {
                                                                    SubLObject _prev_bind_0_167 = mt_relevance_macros.$mt$.currentBinding(thread);
                                                                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                                                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                                                                    try {
                                                                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                                                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                                                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                                                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.denot_has_typeP(denot_165, type, UNPROVIDED)) {
                                                                            {
                                                                                SubLObject item_var = denot_165;
                                                                                if (NIL == member(item_var, result, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                                                                                    result = cons(item_var, result);
                                                                                }
                                                                            }
                                                                        }
                                                                    } finally {
                                                                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                                                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                                                        mt_relevance_macros.$mt$.rebind(_prev_bind_0_167, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_168 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_168, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_164, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param STRING
    string
     * 		
     * @param TYPE
    collection
     * 		
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return list; a list of denotata for STRING that are instances of TYPE
    note that this function does some parsing, if the type sent in is appropriate
     */
    @LispMethod(comment = "@param STRING\nstring\r\n\t\t\r\n@param TYPE\ncollection\r\n\t\t\r\n@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return list; a list of denotata for STRING that are instances of TYPE\r\nnote that this function does some parsing, if the type sent in is appropriate")
    public static SubLObject typed_denots_of_string(final SubLObject string, final SubLObject type, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject semantic_mt, SubLObject parse_morphologically, SubLObject excluded_predicates) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (semantic_mt == UNPROVIDED) {
            semantic_mt = $$InferencePSC;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        if (excluded_predicates == UNPROVIDED) {
            excluded_predicates = lexicon_vars.$semantic_predicates_excluded_from_lexical_lookup$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLTrampolineFile.enforceType(string, STRINGP);
        SubLTrampolineFile.enforceType(type, EL_FORT_P);
        SubLTrampolineFile.enforceType(abbrev_types, LISTP);
        SubLTrampolineFile.enforceType(denot_type, KEYWORDP);
        SubLTrampolineFile.enforceType(misspellingsP, BOOLEANP);
        SubLTrampolineFile.enforceType(skip_namestringsP, BOOLEANP);
        SubLTrampolineFile.enforceType(lookup_mt, $sym176$HLMT_);
        SubLTrampolineFile.enforceType(semantic_mt, $sym176$HLMT_);
        SubLTrampolineFile.enforceType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
        SubLTrampolineFile.enforceType(excluded_predicates, SET_P);
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$154 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots = denots_of_string(string, abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, parse_morphologically, UNPROVIDED, UNPROVIDED);
                    final SubLObject pred_lists = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    SubLObject denot = NIL;
                    SubLObject denot_$155 = NIL;
                    SubLObject preds = NIL;
                    SubLObject preds_$156 = NIL;
                    denot = denots;
                    denot_$155 = denot.first();
                    preds = pred_lists;
                    preds_$156 = preds.first();
                    while ((NIL != preds) || (NIL != denot)) {
                        if (NIL != typed_denots_of_string_preds_okP(preds_$156, excluded_predicates)) {
                            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(semantic_mt);
                            final SubLObject _prev_bind_0_$155 = mt_relevance_macros.$mt$.currentBinding(thread);
                            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                if (NIL != denot_has_typeP(denot_$155, type, UNPROVIDED)) {
                                    final SubLObject item_var = denot_$155;
                                    if (NIL == member(item_var, result, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                                        result = cons(item_var, result);
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0_$155, thread);
                            }
                        }
                        denot = denot.rest();
                        denot_$155 = denot.first();
                        preds = preds.rest();
                        preds_$156 = preds.first();
                    } 
                } finally {
                    final SubLObject _prev_bind_0_$156 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$156, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$154, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    public static final SubLObject typed_denots_of_string_preds_okP_alt(SubLObject preds, SubLObject excluded_predicates) {
        {
            SubLObject okP = NIL;
            if (NIL == okP) {
                {
                    SubLObject csome_list_var = preds;
                    SubLObject pred = NIL;
                    for (pred = csome_list_var.first(); !((NIL != okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pred = csome_list_var.first()) {
                        if (NIL == set_memberP(pred, excluded_predicates)) {
                            okP = T;
                        }
                    }
                }
            }
            return okP;
        }
    }

    public static SubLObject typed_denots_of_string_preds_okP(final SubLObject preds, final SubLObject excluded_predicates) {
        SubLObject okP = NIL;
        if (NIL == okP) {
            SubLObject csome_list_var = preds;
            SubLObject pred = NIL;
            pred = csome_list_var.first();
            while ((NIL == okP) && (NIL != csome_list_var)) {
                if (NIL == set.set_memberP(pred, excluded_predicates)) {
                    okP = T;
                }
                csome_list_var = csome_list_var.rest();
                pred = csome_list_var.first();
            } 
        }
        return okP;
    }

    /**
     *
     *
     * @return BOOLEANP; Is DENOT an instance of TYPE?
     */
    @LispMethod(comment = "@return BOOLEANP; Is DENOT an instance of TYPE?")
    public static final SubLObject denot_has_typeP_internal_alt(SubLObject denot, SubLObject type, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = mt_relevance_macros.$mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        if (NIL != at_defns.quick_quiet_has_typeP(denot, type, mt)) {
                            ans = T;
                        } else {
                            if ((NIL != forts.fort_p(denot)) && (NIL != isa.instantiationP(denot, type, UNPROVIDED))) {
                                ans = T;
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEANP; Is DENOT an instance of TYPE?
     */
    @LispMethod(comment = "@return BOOLEANP; Is DENOT an instance of TYPE?")
    public static SubLObject denot_has_typeP_internal(final SubLObject denot, final SubLObject type, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = mt_relevance_macros.$mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            if (NIL != at_defns.quick_quiet_has_typeP(denot, type, mt)) {
                ans = T;
            } else
                if ((NIL != forts.fort_p(denot)) && (NIL != isa.instantiationP(denot, type, UNPROVIDED))) {
                    ans = T;
                }

        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject denot_has_typeP_alt(SubLObject denot, SubLObject type, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = mt_relevance_macros.$mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
                SubLObject caching_state = NIL;
                if (NIL == v_memoization_state) {
                    return com.cyc.cycjava.cycl.lexicon_accessors.denot_has_typeP_internal(denot, type, mt);
                }
                caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym179$DENOT_HAS_TYPE_, UNPROVIDED);
                if (NIL == caching_state) {
                    caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym179$DENOT_HAS_TYPE_, THREE_INTEGER, NIL, EQUAL, UNPROVIDED);
                    memoization_state.memoization_state_put(v_memoization_state, $sym179$DENOT_HAS_TYPE_, caching_state);
                }
                {
                    SubLObject sxhash = memoization_state.sxhash_calc_3(denot, type, mt);
                    SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                    if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                        {
                            SubLObject cdolist_list_var = collisions;
                            SubLObject collision = NIL;
                            for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                                {
                                    SubLObject cached_args = collision.first();
                                    SubLObject results2 = second(collision);
                                    if (denot.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (type.equal(cached_args.first())) {
                                            cached_args = cached_args.rest();
                                            if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                                return memoization_state.caching_results(results2);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    {
                        SubLObject results = arg2(thread.resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.denot_has_typeP_internal(denot, type, mt)));
                        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(denot, type, mt));
                        return memoization_state.caching_results(results);
                    }
                }
            }
        }
    }

    public static SubLObject denot_has_typeP(final SubLObject denot, final SubLObject type, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = mt_relevance_macros.$mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return denot_has_typeP_internal(denot, type, mt);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym183$DENOT_HAS_TYPE_, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym183$DENOT_HAS_TYPE_, THREE_INTEGER, NIL, EQUAL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, $sym183$DENOT_HAS_TYPE_, caching_state);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_3(denot, type, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (denot.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (type.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                            return memoization_state.caching_results(results2);
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(thread.resetMultipleValues(), multiple_value_list(denot_has_typeP_internal(denot, type, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(denot, type, mt));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @return BOOLEANP; Is DENOT not known to not be an instance of TYPE?
     * @unknown mt is set from outside
     */
    @LispMethod(comment = "@return BOOLEANP; Is DENOT not known to not be an instance of TYPE?\r\n@unknown mt is set from outside")
    public static final SubLObject denot_might_have_typeP_internal_alt(SubLObject denot, SubLObject type) {
        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.denot_has_typeP(denot, type, UNPROVIDED)) {
            return T;
        }
        {
            SubLObject badP = NIL;
            if (NIL == badP) {
                {
                    SubLObject csome_list_var = isa.isa(denot, UNPROVIDED, UNPROVIDED);
                    SubLObject v_isa = NIL;
                    for (v_isa = csome_list_var.first(); !((NIL != badP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , v_isa = csome_list_var.first()) {
                        badP = disjoint_with.disjoint_withP(v_isa, type, UNPROVIDED, UNPROVIDED);
                    }
                }
            }
            return makeBoolean(NIL == badP);
        }
    }

    /**
     *
     *
     * @return BOOLEANP; Is DENOT not known to not be an instance of TYPE?
     * @unknown mt is set from outside
     */
    @LispMethod(comment = "@return BOOLEANP; Is DENOT not known to not be an instance of TYPE?\r\n@unknown mt is set from outside")
    public static SubLObject denot_might_have_typeP_internal(final SubLObject denot, final SubLObject type) {
        if (NIL != denot_has_typeP(denot, type, UNPROVIDED)) {
            return T;
        }
        SubLObject badP = NIL;
        if (NIL == badP) {
            SubLObject csome_list_var;
            SubLObject v_isa;
            for (csome_list_var = isa.isa(denot, UNPROVIDED, UNPROVIDED), v_isa = NIL, v_isa = csome_list_var.first(); (NIL == badP) && (NIL != csome_list_var); badP = disjoint_with.disjoint_withP(v_isa, type, UNPROVIDED, UNPROVIDED) , csome_list_var = csome_list_var.rest() , v_isa = csome_list_var.first()) {
            }
        }
        return makeBoolean(NIL == badP);
    }

    public static final SubLObject denot_might_have_typeP_alt(SubLObject denot, SubLObject type) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
                SubLObject caching_state = NIL;
                if (NIL == v_memoization_state) {
                    return com.cyc.cycjava.cycl.lexicon_accessors.denot_might_have_typeP_internal(denot, type);
                }
                caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym180$DENOT_MIGHT_HAVE_TYPE_, UNPROVIDED);
                if (NIL == caching_state) {
                    caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym180$DENOT_MIGHT_HAVE_TYPE_, TWO_INTEGER, NIL, EQUAL, UNPROVIDED);
                    memoization_state.memoization_state_put(v_memoization_state, $sym180$DENOT_MIGHT_HAVE_TYPE_, caching_state);
                }
                {
                    SubLObject sxhash = memoization_state.sxhash_calc_2(denot, type);
                    SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                    if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                        {
                            SubLObject cdolist_list_var = collisions;
                            SubLObject collision = NIL;
                            for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                                {
                                    SubLObject cached_args = collision.first();
                                    SubLObject results2 = second(collision);
                                    if (denot.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && type.equal(cached_args.first())) {
                                            return memoization_state.caching_results(results2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    {
                        SubLObject results = arg2(thread.resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.denot_might_have_typeP_internal(denot, type)));
                        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(denot, type));
                        return memoization_state.caching_results(results);
                    }
                }
            }
        }
    }

    public static SubLObject denot_might_have_typeP(final SubLObject denot, final SubLObject type) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject v_memoization_state = memoization_state.$memoization_state$.getDynamicValue(thread);
        SubLObject caching_state = NIL;
        if (NIL == v_memoization_state) {
            return denot_might_have_typeP_internal(denot, type);
        }
        caching_state = memoization_state.memoization_state_lookup(v_memoization_state, $sym184$DENOT_MIGHT_HAVE_TYPE_, UNPROVIDED);
        if (NIL == caching_state) {
            caching_state = memoization_state.create_caching_state(memoization_state.memoization_state_lock(v_memoization_state), $sym184$DENOT_MIGHT_HAVE_TYPE_, TWO_INTEGER, NIL, EQUAL, UNPROVIDED);
            memoization_state.memoization_state_put(v_memoization_state, $sym184$DENOT_MIGHT_HAVE_TYPE_, caching_state);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(denot, type);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (denot.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && type.equal(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(thread.resetMultipleValues(), multiple_value_list(denot_might_have_typeP_internal(denot, type)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(denot, type));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @param STRING
    string
     * 		
     * @param POS-TYPES
    collection
     * 		
     * @param NEG-TYPES
    collection
     * 		
     * @return list; a list of denotata for STRING that are instances of each of the collections in POS-TYPES
    and are not instances of any of the collections in NEG-TYPES. The meaning of the optional parameter INCLUDE-GENL?
    is as follows. If set to its default value of NIL, the function will only return denotations of STRING which
    are *instances* of all of the collections in POS-TYPES and none of the collections in NEG-TYPES. If it is set
    to T, however, it will include all denotations of STRING that are either *instances* OR *specs* of every collection
    in POS-TYPES and will exclude any denotation of STRING that is either an *instance* OR a *spec* of any collection
    in NEG-TYPES
    note that this function does some parsing, if the type sent in is appropriate
     * @unknown bertolo
     */
    @LispMethod(comment = "@param STRING\nstring\r\n\t\t\r\n@param POS-TYPES\ncollection\r\n\t\t\r\n@param NEG-TYPES\ncollection\r\n\t\t\r\n@return list; a list of denotata for STRING that are instances of each of the collections in POS-TYPES\r\nand are not instances of any of the collections in NEG-TYPES. The meaning of the optional parameter INCLUDE-GENL?\r\nis as follows. If set to its default value of NIL, the function will only return denotations of STRING which\r\nare *instances* of all of the collections in POS-TYPES and none of the collections in NEG-TYPES. If it is set\r\nto T, however, it will include all denotations of STRING that are either *instances* OR *specs* of every collection\r\nin POS-TYPES and will exclude any denotation of STRING that is either an *instance* OR a *spec* of any collection\r\nin NEG-TYPES\r\nnote that this function does some parsing, if the type sent in is appropriate\r\n@unknown bertolo")
    public static final SubLObject multi_typed_denots_of_string_alt(SubLObject string, SubLObject pos_types, SubLObject neg_types, SubLObject include_genlP, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject semantic_mt, SubLObject excluded_predicates) {
        if (include_genlP == UNPROVIDED) {
            include_genlP = NIL;
        }
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (semantic_mt == UNPROVIDED) {
            semantic_mt = $$InferencePSC;
        }
        if (excluded_predicates == UNPROVIDED) {
            excluded_predicates = lexicon_vars.$semantic_predicates_excluded_from_lexical_lookup$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_169 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots = com.cyc.cycjava.cycl.lexicon_accessors.denots_of_string(string, abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                SubLObject pred_lists = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denot = NIL;
                                                    SubLObject denot_170 = NIL;
                                                    SubLObject preds = NIL;
                                                    SubLObject preds_171 = NIL;
                                                    for (denot = denots, denot_170 = denot.first(), preds = pred_lists, preds_171 = preds.first(); !((NIL == preds) && (NIL == denot)); denot = denot.rest() , denot_170 = denot.first() , preds = preds.rest() , preds_171 = preds.first()) {
                                                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.typed_denots_of_string_preds_okP(preds_171, excluded_predicates)) {
                                                            {
                                                                SubLObject fn = (NIL != include_genlP) ? ((SubLObject) (symbol_function(MORE_SPECIFIC_P))) : symbol_function($sym179$DENOT_HAS_TYPE_);
                                                                SubLObject fail_pos = NIL;
                                                                SubLObject fail_neg = NIL;
                                                                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(semantic_mt);
                                                                {
                                                                    SubLObject _prev_bind_0_172 = mt_relevance_macros.$mt$.currentBinding(thread);
                                                                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                                                                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                                                                    try {
                                                                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                                                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                                                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                                                        if (NIL == fail_pos) {
                                                                            {
                                                                                SubLObject csome_list_var = pos_types;
                                                                                SubLObject pos_type = NIL;
                                                                                for (pos_type = csome_list_var.first(); !((NIL != fail_pos) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pos_type = csome_list_var.first()) {
                                                                                    if (NIL == funcall(fn, denot_170, pos_type)) {
                                                                                        fail_pos = T;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        if (NIL == fail_pos) {
                                                                            if (NIL == fail_neg) {
                                                                                {
                                                                                    SubLObject csome_list_var = neg_types;
                                                                                    SubLObject neg_type = NIL;
                                                                                    for (neg_type = csome_list_var.first(); !((NIL != fail_neg) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , neg_type = csome_list_var.first()) {
                                                                                        if (NIL != funcall(fn, denot_170, neg_type)) {
                                                                                            fail_neg = T;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    } finally {
                                                                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                                                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                                                        mt_relevance_macros.$mt$.rebind(_prev_bind_0_172, thread);
                                                                    }
                                                                }
                                                                if (!((NIL != fail_pos) || (NIL != fail_neg))) {
                                                                    result = cons(denot_170, result);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_173 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_173, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_169, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param STRING
    string
     * 		
     * @param POS-TYPES
    collection
     * 		
     * @param NEG-TYPES
    collection
     * 		
     * @return list; a list of denotata for STRING that are instances of each of the collections in POS-TYPES
    and are not instances of any of the collections in NEG-TYPES. The meaning of the optional parameter INCLUDE-GENL?
    is as follows. If set to its default value of NIL, the function will only return denotations of STRING which
    are *instances* of all of the collections in POS-TYPES and none of the collections in NEG-TYPES. If it is set
    to T, however, it will include all denotations of STRING that are either *instances* OR *specs* of every collection
    in POS-TYPES and will exclude any denotation of STRING that is either an *instance* OR a *spec* of any collection
    in NEG-TYPES
    note that this function does some parsing, if the type sent in is appropriate
     * @unknown bertolo
     */
    @LispMethod(comment = "@param STRING\nstring\r\n\t\t\r\n@param POS-TYPES\ncollection\r\n\t\t\r\n@param NEG-TYPES\ncollection\r\n\t\t\r\n@return list; a list of denotata for STRING that are instances of each of the collections in POS-TYPES\r\nand are not instances of any of the collections in NEG-TYPES. The meaning of the optional parameter INCLUDE-GENL?\r\nis as follows. If set to its default value of NIL, the function will only return denotations of STRING which\r\nare *instances* of all of the collections in POS-TYPES and none of the collections in NEG-TYPES. If it is set\r\nto T, however, it will include all denotations of STRING that are either *instances* OR *specs* of every collection\r\nin POS-TYPES and will exclude any denotation of STRING that is either an *instance* OR a *spec* of any collection\r\nin NEG-TYPES\r\nnote that this function does some parsing, if the type sent in is appropriate\r\n@unknown bertolo")
    public static SubLObject multi_typed_denots_of_string(final SubLObject string, final SubLObject pos_types, final SubLObject neg_types, SubLObject include_genlP, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject semantic_mt, SubLObject excluded_predicates) {
        if (include_genlP == UNPROVIDED) {
            include_genlP = NIL;
        }
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (semantic_mt == UNPROVIDED) {
            semantic_mt = $$InferencePSC;
        }
        if (excluded_predicates == UNPROVIDED) {
            excluded_predicates = lexicon_vars.$semantic_predicates_excluded_from_lexical_lookup$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$159 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots = denots_of_string(string, abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    final SubLObject pred_lists = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    SubLObject denot = NIL;
                    SubLObject denot_$160 = NIL;
                    SubLObject preds = NIL;
                    SubLObject preds_$161 = NIL;
                    denot = denots;
                    denot_$160 = denot.first();
                    preds = pred_lists;
                    preds_$161 = preds.first();
                    while ((NIL != preds) || (NIL != denot)) {
                        if (NIL != typed_denots_of_string_preds_okP(preds_$161, excluded_predicates)) {
                            final SubLObject fn = (NIL != include_genlP) ? symbol_function(MORE_SPECIFIC_P) : symbol_function($sym183$DENOT_HAS_TYPE_);
                            SubLObject fail_pos = NIL;
                            SubLObject fail_neg = NIL;
                            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(semantic_mt);
                            final SubLObject _prev_bind_0_$160 = mt_relevance_macros.$mt$.currentBinding(thread);
                            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                if (NIL == fail_pos) {
                                    SubLObject csome_list_var = pos_types;
                                    SubLObject pos_type = NIL;
                                    pos_type = csome_list_var.first();
                                    while ((NIL == fail_pos) && (NIL != csome_list_var)) {
                                        if (NIL == funcall(fn, denot_$160, pos_type)) {
                                            fail_pos = T;
                                        }
                                        csome_list_var = csome_list_var.rest();
                                        pos_type = csome_list_var.first();
                                    } 
                                }
                                if ((NIL == fail_pos) && (NIL == fail_neg)) {
                                    SubLObject csome_list_var = neg_types;
                                    SubLObject neg_type = NIL;
                                    neg_type = csome_list_var.first();
                                    while ((NIL == fail_neg) && (NIL != csome_list_var)) {
                                        if (NIL != funcall(fn, denot_$160, neg_type)) {
                                            fail_neg = T;
                                        }
                                        csome_list_var = csome_list_var.rest();
                                        neg_type = csome_list_var.first();
                                    } 
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0_$160, thread);
                            }
                            if ((NIL == fail_pos) && (NIL == fail_neg)) {
                                result = cons(denot_$160, result);
                            }
                        }
                        denot = denot.rest();
                        denot_$160 = denot.first();
                        preds = preds.rest();
                        preds_$161 = preds.first();
                    } 
                } finally {
                    final SubLObject _prev_bind_0_$161 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$161, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$159, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    /**
     * This function is intended to run very quickly so that it can be used for SKSI decodings.  Thus, adding things that would
     * slow it down is to be avoided.
     */
    @LispMethod(comment = "This function is intended to run very quickly so that it can be used for SKSI decodings.  Thus, adding things that would\r\nslow it down is to be avoided.\nThis function is intended to run very quickly so that it can be used for SKSI decodings.  Thus, adding things that would\nslow it down is to be avoided.")
    public static final SubLObject typed_denots_of_string_at_place_alt(SubLObject string, SubLObject type, SubLObject place, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject semantic_mt) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (semantic_mt == UNPROVIDED) {
            semantic_mt = $$InferencePSC;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_174 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            {
                                                SubLObject typed_denots = com.cyc.cycjava.cycl.lexicon_accessors.typed_denots_of_string(string, type, abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, semantic_mt, UNPROVIDED, UNPROVIDED);
                                                SubLObject cdolist_list_var = typed_denots;
                                                SubLObject denot = NIL;
                                                for (denot = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , denot = cdolist_list_var.first()) {
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.in_region_p(denot, place, semantic_mt)) {
                                                        result = cons(denot, result);
                                                    }
                                                }
                                                if (((NIL == result) && type.equal($$City)) && (NIL != genls.genlsP(type, $$GeopoliticalEntity, semantic_mt, UNPROVIDED))) {
                                                    result = cons(list($$CityNamedFn, string, place), result);
                                                }
                                                if (NIL == result) {
                                                    result = cons(list($$InstanceNamedFn, string, list($$SubcollectionOfWithRelationToFn, type, $$inRegion, place)), result);
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_175 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_175, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_174, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    @LispMethod(comment = "This function is intended to run very quickly so that it can be used for SKSI decodings.  Thus, adding things that would\r\nslow it down is to be avoided.\nThis function is intended to run very quickly so that it can be used for SKSI decodings.  Thus, adding things that would\nslow it down is to be avoided.")
    public static SubLObject typed_denots_of_string_at_place(final SubLObject string, final SubLObject type, final SubLObject place, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject semantic_mt) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (semantic_mt == UNPROVIDED) {
            semantic_mt = $$InferencePSC;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$164 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    SubLObject cdolist_list_var;
                    final SubLObject typed_denots = cdolist_list_var = typed_denots_of_string(string, type, abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, semantic_mt, UNPROVIDED, UNPROVIDED);
                    SubLObject denot = NIL;
                    denot = cdolist_list_var.first();
                    while (NIL != cdolist_list_var) {
                        if (NIL != in_region_p(denot, place, semantic_mt)) {
                            result = cons(denot, result);
                        }
                        cdolist_list_var = cdolist_list_var.rest();
                        denot = cdolist_list_var.first();
                    } 
                    if (((NIL == result) && type.equal($$City)) && (NIL != genls.genlsP(type, $$GeopoliticalEntity, semantic_mt, UNPROVIDED))) {
                        result = cons(list($$CityNamedFn, string, place), result);
                    }
                    if (NIL == result) {
                        result = cons(list($$InstanceNamedFn, string, list($$SubcollectionOfWithRelationToFn, type, $$inRegion, place)), result);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$165 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$165, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$164, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }/**
     * This function is intended to run very quickly so that it can be used for SKSI decodings.  Thus, adding things that would
     * slow it down is to be avoided.
     */


    public static final SubLObject in_region_p_alt(SubLObject place, SubLObject region, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                SubLObject mt_var = mt;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject is_place_a_gpeP = isa.isaP(place, $$GeopoliticalEntity, UNPROVIDED, UNPROVIDED);
                            SubLObject is_region_a_gpeP = isa.isaP(region, $$GeopoliticalEntity, UNPROVIDED, UNPROVIDED);
                            SubLObject is_place_a_geo_regionP = isa.isaP(place, $$GeographicalRegion, UNPROVIDED, UNPROVIDED);
                            SubLObject is_region_a_geo_regionP = isa.isaP(region, $$GeographicalRegion, UNPROVIDED, UNPROVIDED);
                            if (((NIL != is_region_a_gpeP) && (NIL != is_place_a_gpeP)) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.geopolitical_subdivisionP(region, place, mt))) {
                                result = T;
                            } else {
                                if (((NIL != is_place_a_geo_regionP) && (NIL != is_region_a_geo_regionP)) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.geographical_subregionP(region, place, mt))) {
                                    result = T;
                                } else {
                                    if ((NIL != is_region_a_gpeP) && (NIL != is_place_a_geo_regionP)) {
                                        if (NIL == result) {
                                            {
                                                SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.territories_for_gpe(region);
                                                SubLObject region_territory = NIL;
                                                for (region_territory = csome_list_var.first(); !((NIL != result) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , region_territory = csome_list_var.first()) {
                                                    result = com.cyc.cycjava.cycl.lexicon_accessors.geographical_subregionP(region_territory, place, mt);
                                                }
                                            }
                                        }
                                        if (NIL == result) {
                                            if (NIL == result) {
                                                {
                                                    SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.gpe_for_territory(place);
                                                    SubLObject place_gpe = NIL;
                                                    for (place_gpe = csome_list_var.first(); !((NIL != result) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , place_gpe = csome_list_var.first()) {
                                                        result = com.cyc.cycjava.cycl.lexicon_accessors.geopolitical_subdivisionP(region, place_gpe, mt);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (((NIL != is_region_a_geo_regionP) && (NIL != is_place_a_gpeP)) && (NIL == result)) {
                                        if (NIL == result) {
                                            {
                                                SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.gpe_for_territory(region);
                                                SubLObject region_territory = NIL;
                                                for (region_territory = csome_list_var.first(); !((NIL != result) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , region_territory = csome_list_var.first()) {
                                                    result = com.cyc.cycjava.cycl.lexicon_accessors.geographical_subregionP(region_territory, place, mt);
                                                }
                                            }
                                        }
                                        if (NIL == result) {
                                            if (NIL == result) {
                                                {
                                                    SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.gpe_for_territory(region);
                                                    SubLObject region_gpe = NIL;
                                                    for (region_gpe = csome_list_var.first(); !((NIL != result) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , region_gpe = csome_list_var.first()) {
                                                        result = com.cyc.cycjava.cycl.lexicon_accessors.geopolitical_subdivisionP(region_gpe, place, mt);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    public static SubLObject in_region_p(final SubLObject place, final SubLObject region, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt), thread);
            final SubLObject is_place_a_gpeP = isa.isaP(place, $$GeopoliticalEntity, UNPROVIDED, UNPROVIDED);
            final SubLObject is_region_a_gpeP = isa.isaP(region, $$GeopoliticalEntity, UNPROVIDED, UNPROVIDED);
            final SubLObject is_place_a_geo_regionP = isa.isaP(place, $$GeographicalRegion, UNPROVIDED, UNPROVIDED);
            final SubLObject is_region_a_geo_regionP = isa.isaP(region, $$GeographicalRegion, UNPROVIDED, UNPROVIDED);
            if (((NIL != is_region_a_gpeP) && (NIL != is_place_a_gpeP)) && (NIL != geopolitical_subdivisionP(region, place, mt))) {
                result = T;
            } else
                if (((NIL != is_place_a_geo_regionP) && (NIL != is_region_a_geo_regionP)) && (NIL != geographical_subregionP(region, place, mt))) {
                    result = T;
                } else {
                    if ((NIL != is_region_a_gpeP) && (NIL != is_place_a_geo_regionP)) {
                        if (NIL == result) {
                            SubLObject csome_list_var;
                            SubLObject region_territory;
                            for (csome_list_var = territories_for_gpe(region), region_territory = NIL, region_territory = csome_list_var.first(); (NIL == result) && (NIL != csome_list_var); result = geographical_subregionP(region_territory, place, mt) , csome_list_var = csome_list_var.rest() , region_territory = csome_list_var.first()) {
                            }
                        }
                        if ((NIL == result) && (NIL == result)) {
                            SubLObject csome_list_var;
                            SubLObject place_gpe;
                            for (csome_list_var = gpe_for_territory(place), place_gpe = NIL, place_gpe = csome_list_var.first(); (NIL == result) && (NIL != csome_list_var); result = geopolitical_subdivisionP(region, place_gpe, mt) , csome_list_var = csome_list_var.rest() , place_gpe = csome_list_var.first()) {
                            }
                        }
                    }
                    if (((NIL != is_region_a_geo_regionP) && (NIL != is_place_a_gpeP)) && (NIL == result)) {
                        if (NIL == result) {
                            SubLObject csome_list_var;
                            SubLObject region_territory;
                            for (csome_list_var = gpe_for_territory(region), region_territory = NIL, region_territory = csome_list_var.first(); (NIL == result) && (NIL != csome_list_var); result = geographical_subregionP(region_territory, place, mt) , csome_list_var = csome_list_var.rest() , region_territory = csome_list_var.first()) {
                            }
                        }
                        if ((NIL == result) && (NIL == result)) {
                            SubLObject csome_list_var;
                            SubLObject region_gpe;
                            for (csome_list_var = gpe_for_territory(region), region_gpe = NIL, region_gpe = csome_list_var.first(); (NIL == result) && (NIL != csome_list_var); result = geopolitical_subdivisionP(region_gpe, place, mt) , csome_list_var = csome_list_var.rest() , region_gpe = csome_list_var.first()) {
                            }
                        }
                    }
                }

        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    public static final SubLObject geopolitical_subdivisionP_alt(SubLObject big_place, SubLObject small_place, SubLObject mt) {
        return cyc_kernel.closed_query_success_result_p(inference_kernel.new_cyc_query(list($$geopoliticalSubdivision, big_place, small_place), mt, UNPROVIDED));
    }

    public static SubLObject geopolitical_subdivisionP(final SubLObject big_place, final SubLObject small_place, final SubLObject mt) {
        return cyc_kernel.closed_query_success_result_p(inference_kernel.new_cyc_query(list($$geopoliticalSubdivision, big_place, small_place), mt, UNPROVIDED));
    }

    public static final SubLObject geographical_subregionP_alt(SubLObject big_place, SubLObject small_place, SubLObject mt) {
        return cyc_kernel.closed_query_success_result_p(inference_kernel.new_cyc_query(list($$geographicalSubRegions, big_place, small_place), mt, UNPROVIDED));
    }

    public static SubLObject geographical_subregionP(final SubLObject big_place, final SubLObject small_place, final SubLObject mt) {
        return cyc_kernel.closed_query_success_result_p(inference_kernel.new_cyc_query(list($$geographicalSubRegions, big_place, small_place), mt, UNPROVIDED));
    }

    public static final SubLObject territories_for_gpe_alt(SubLObject region) {
        return kb_mapping_utilities.pred_values(region, $$territoryOf, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject territories_for_gpe(final SubLObject region) {
        return kb_mapping_utilities.pred_values(region, $$territoryOf, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject gpe_for_territory_alt(SubLObject territory) {
        return kb_mapping_utilities.pred_values(narts_high.nart_substitute(territory), $$territoryOf, TWO_INTEGER, ONE_INTEGER, UNPROVIDED);
    }

    public static SubLObject gpe_for_territory(final SubLObject territory) {
        return kb_mapping_utilities.pred_values(narts_high.nart_substitute(territory), $$territoryOf, TWO_INTEGER, ONE_INTEGER, UNPROVIDED);
    }

    /**
     *
     *
     * @param STRING
     * 		stringp; a string that can include the wildcards '*'
     * @param LOOKUP-MT
    hlmt-p
     * 		
     * @param PERMISSIVE?
     * 		boolean; should the search be thought of as an infix search (e.g. allow other stuff at the end)
     * @param TEST
    function-spec-p;
     * 		
     * @return listp; a list of all terms known to Cyc that match STRING
     */
    @LispMethod(comment = "@param STRING\r\n\t\tstringp; a string that can include the wildcards \'*\'\r\n@param LOOKUP-MT\nhlmt-p\r\n\t\t\r\n@param PERMISSIVE?\r\n\t\tboolean; should the search be thought of as an infix search (e.g. allow other stuff at the end)\r\n@param TEST\nfunction-spec-p;\r\n\t\t\r\n@return listp; a list of all terms known to Cyc that match STRING")
    public static final SubLObject denots_of_partial_string_alt(SubLObject string, SubLObject lookup_mt, SubLObject permissiveP, SubLObject test) {
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (permissiveP == UNPROVIDED) {
            permissiveP = T;
        }
        if (test == UNPROVIDED) {
            test = EQUALP;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if ((NIL != permissiveP) && (!string_utilities.string_last_n(ONE_INTEGER, string).equal($str_alt192$_))) {
                string = cconcatenate(string, $str_alt192$_);
            }
            {
                SubLObject result = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_176 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            {
                                                SubLObject cleaned_string = Strings.string_left_trim($list_alt193, string);
                                                SubLObject tokenized_string = string_utilities.string_tokenize(cleaned_string, $list_alt194, NIL, T, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                SubLObject initial_matches = nl_trie_accessors.nl_trie_matching_phrases(tokenized_string.first(), $INFIX);
                                                SubLObject first_token = tokenized_string.first();
                                                SubLObject first_token_length = length(tokenized_string.first());
                                                SubLObject token_count = NIL;
                                                tokenized_string = tokenized_string.rest();
                                                if (list_utilities.last_one(tokenized_string).equal($str_alt196$)) {
                                                    tokenized_string = butlast(tokenized_string, UNPROVIDED);
                                                }
                                                token_count = length(tokenized_string);
                                                {
                                                    SubLObject cdolist_list_var = initial_matches;
                                                    SubLObject item = NIL;
                                                    for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                                                        {
                                                            SubLObject phrase = nl_trie_accessors.nl_trie_index_item_phrase(item);
                                                            SubLObject v_term = nl_trie_accessors.nl_trie_index_item_term(item);
                                                            SubLObject first_token_location = search(first_token, phrase, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                            SubLObject current_token_number = ZERO_INTEGER;
                                                            SubLObject string_offset = NIL;
                                                            SubLObject next_token = NIL;
                                                            SubLObject fail = NIL;
                                                            if (NIL != first_token_location) {
                                                                string_offset = add(first_token_location, first_token_length);
                                                            } else {
                                                                fail = T;
                                                            }
                                                            while (current_token_number.numL(token_count) && (NIL == fail)) {
                                                                next_token = nth(current_token_number, tokenized_string);
                                                                if (next_token.equal($str_alt196$)) {
                                                                    current_token_number = add(current_token_number, ONE_INTEGER);
                                                                } else {
                                                                    if ((NIL != next_token) && (!next_token.equal($str_alt192$_))) {
                                                                        {
                                                                            SubLObject location = search(next_token, phrase, test, IDENTITY, ZERO_INTEGER, NIL, string_offset, UNPROVIDED);
                                                                            if (NIL != location) {
                                                                                string_offset = add(location, length(next_token));
                                                                                current_token_number = add(current_token_number, ONE_INTEGER);
                                                                            }
                                                                        }
                                                                    } else {
                                                                        if (next_token.equal($str_alt192$_)) {
                                                                            current_token_number = add(current_token_number, ONE_INTEGER);
                                                                            next_token = nth(current_token_number, tokenized_string);
                                                                            if (NIL == next_token) {
                                                                                result = cons(v_term, result);
                                                                            } else {
                                                                                {
                                                                                    SubLObject location = search(next_token, phrase, test, IDENTITY, ZERO_INTEGER, NIL, string_offset, UNPROVIDED);
                                                                                    if (NIL != location) {
                                                                                        string_offset = add(location, length(next_token));
                                                                                        current_token_number = add(current_token_number, ONE_INTEGER);
                                                                                    } else {
                                                                                        fail = T;
                                                                                    }
                                                                                }
                                                                            }
                                                                        } else {
                                                                            if (string_offset != length(phrase)) {
                                                                                fail = T;
                                                                                Errors.warn($str_alt197$I_should_never_be_called___);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            } 
                                                            if ((token_count == current_token_number) && (string_offset == length(phrase))) {
                                                                result = cons(v_term, result);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_177 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_177, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_176, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return delete_duplicates(result, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            }
        }
    }

    /**
     *
     *
     * @param STRING
     * 		stringp; a string that can include the wildcards '*'
     * @param LOOKUP-MT
    hlmt-p
     * 		
     * @param PERMISSIVE?
     * 		boolean; should the search be thought of as an infix search (e.g. allow other stuff at the end)
     * @param TEST
    function-spec-p;
     * 		
     * @return listp; a list of all terms known to Cyc that match STRING
     */
    @LispMethod(comment = "@param STRING\r\n\t\tstringp; a string that can include the wildcards \'*\'\r\n@param LOOKUP-MT\nhlmt-p\r\n\t\t\r\n@param PERMISSIVE?\r\n\t\tboolean; should the search be thought of as an infix search (e.g. allow other stuff at the end)\r\n@param TEST\nfunction-spec-p;\r\n\t\t\r\n@return listp; a list of all terms known to Cyc that match STRING")
    public static SubLObject denots_of_partial_string(SubLObject string, SubLObject lookup_mt, SubLObject permissiveP, SubLObject test) {
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (permissiveP == UNPROVIDED) {
            permissiveP = T;
        }
        if (test == UNPROVIDED) {
            test = EQUALP;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL != permissiveP) && (!string_utilities.string_last_n(ONE_INTEGER, string).equal($str196$_))) {
            string = cconcatenate(string, $str196$_);
        }
        SubLObject result = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$166 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    final SubLObject cleaned_string = Strings.string_left_trim($list197, string);
                    SubLObject tokenized_string = string_utilities.string_tokenize(cleaned_string, $list198, NIL, T, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    final SubLObject initial_matches = nl_trie_accessors.nl_trie_matching_phrases(tokenized_string.first(), $INFIX);
                    final SubLObject first_token = tokenized_string.first();
                    final SubLObject first_token_length = length(tokenized_string.first());
                    SubLObject token_count = NIL;
                    tokenized_string = tokenized_string.rest();
                    if (list_utilities.last_one(tokenized_string).equal($str200$)) {
                        tokenized_string = butlast(tokenized_string, UNPROVIDED);
                    }
                    token_count = length(tokenized_string);
                    SubLObject cdolist_list_var = initial_matches;
                    SubLObject item = NIL;
                    item = cdolist_list_var.first();
                    while (NIL != cdolist_list_var) {
                        final SubLObject phrase = nl_trie_accessors.nl_trie_index_item_phrase(item);
                        final SubLObject v_term = nl_trie_accessors.nl_trie_index_item_term(item);
                        final SubLObject first_token_location = search(first_token, phrase, test, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        SubLObject current_token_number = ZERO_INTEGER;
                        SubLObject string_offset = NIL;
                        SubLObject next_token = NIL;
                        SubLObject fail = NIL;
                        if (NIL != first_token_location) {
                            string_offset = add(first_token_location, first_token_length);
                        } else {
                            fail = T;
                        }
                        while (current_token_number.numL(token_count) && (NIL == fail)) {
                            next_token = nth(current_token_number, tokenized_string);
                            if (next_token.equal($str200$)) {
                                current_token_number = add(current_token_number, ONE_INTEGER);
                            } else
                                if ((NIL != next_token) && (!next_token.equal($str196$_))) {
                                    final SubLObject location = search(next_token, phrase, test, IDENTITY, ZERO_INTEGER, NIL, string_offset, UNPROVIDED);
                                    if (NIL == location) {
                                        continue;
                                    }
                                    string_offset = add(location, length(next_token));
                                    current_token_number = add(current_token_number, ONE_INTEGER);
                                } else
                                    if (next_token.equal($str196$_)) {
                                        current_token_number = add(current_token_number, ONE_INTEGER);
                                        next_token = nth(current_token_number, tokenized_string);
                                        if (NIL == next_token) {
                                            result = cons(v_term, result);
                                        } else {
                                            final SubLObject location = search(next_token, phrase, test, IDENTITY, ZERO_INTEGER, NIL, string_offset, UNPROVIDED);
                                            if (NIL != location) {
                                                string_offset = add(location, length(next_token));
                                                current_token_number = add(current_token_number, ONE_INTEGER);
                                            } else {
                                                fail = T;
                                            }
                                        }
                                    } else {
                                        if (string_offset.eql(length(phrase))) {
                                            continue;
                                        }
                                        fail = T;
                                        Errors.warn($str201$I_should_never_be_called___);
                                    }


                        } 
                        if (token_count.eql(current_token_number) && string_offset.eql(length(phrase))) {
                            result = cons(v_term, result);
                        }
                        cdolist_list_var = cdolist_list_var.rest();
                        item = cdolist_list_var.first();
                    } 
                } finally {
                    final SubLObject _prev_bind_0_$167 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$167, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$166, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return delete_duplicates(result, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @param STRING
     * 		string; the string to map to its denotations
     * @param EXCLUDED-PREDS
     * 		list; a list of semantic predicates which should be ignored when computing mappings
     * @param MODE
     * 		keyword; :greedy or :diligent
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return 0 LISTP; a list of STRING-TOKENs, each of which contains as its STRING-TOKEN-STRING some substring
    of STRING and as its STRING-TOKEN-VALUE a denotatum for that string
     * @return 1 LISTP; a list of STRING-TOKENS for which no denotatum could be found
     */
    @LispMethod(comment = "@param STRING\r\n\t\tstring; the string to map to its denotations\r\n@param EXCLUDED-PREDS\r\n\t\tlist; a list of semantic predicates which should be ignored when computing mappings\r\n@param MODE\r\n\t\tkeyword; :greedy or :diligent\r\n@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return 0 LISTP; a list of STRING-TOKENs, each of which contains as its STRING-TOKEN-STRING some substring\r\nof STRING and as its STRING-TOKEN-VALUE a denotatum for that string\r\n@return 1 LISTP; a list of STRING-TOKENS for which no denotatum could be found")
    public static final SubLObject denotation_mapper_alt(SubLObject string, SubLObject excluded_preds, SubLObject mode, SubLObject parse_morphologically) {
        if (excluded_preds == UNPROVIDED) {
            excluded_preds = NIL;
        }
        if (mode == UNPROVIDED) {
            mode = $GREEDY;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(excluded_preds, LIST_OF_PREDICATES_P);
            SubLTrampolineFile.checkType(mode, KEYWORDP);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject result = NIL;
                SubLObject failures = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_178 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            {
                                                SubLObject raw_mapping = nl_trie_accessors.nl_trie_denotation_mapper(string, excluded_preds, mode, parse_morphologically);
                                                SubLObject cdolist_list_var = raw_mapping;
                                                SubLObject token = NIL;
                                                for (token = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , token = cdolist_list_var.first()) {
                                                    if (NIL != standard_tokenization.string_token_value(token)) {
                                                        result = cons(token, result);
                                                    } else {
                                                        {
                                                            SubLObject number = string_utilities.string_to_number(standard_tokenization.string_token_string(token));
                                                            if (NIL != number) {
                                                                result = cons(standard_tokenization.new_string_token(standard_tokenization.string_token_string(token), number), result);
                                                            } else {
                                                                failures = cons(token, failures);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_179 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_179, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_178, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(nreverse(result), nreverse(failures));
            }
        }
    }

    /**
     *
     *
     * @param STRING
     * 		string; the string to map to its denotations
     * @param EXCLUDED-PREDS
     * 		list; a list of semantic predicates which should be ignored when computing mappings
     * @param MODE
     * 		keyword; :greedy or :diligent
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return 0 LISTP; a list of STRING-TOKENs, each of which contains as its STRING-TOKEN-STRING some substring
    of STRING and as its STRING-TOKEN-VALUE a denotatum for that string
     * @return 1 LISTP; a list of STRING-TOKENS for which no denotatum could be found
     */
    @LispMethod(comment = "@param STRING\r\n\t\tstring; the string to map to its denotations\r\n@param EXCLUDED-PREDS\r\n\t\tlist; a list of semantic predicates which should be ignored when computing mappings\r\n@param MODE\r\n\t\tkeyword; :greedy or :diligent\r\n@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return 0 LISTP; a list of STRING-TOKENs, each of which contains as its STRING-TOKEN-STRING some substring\r\nof STRING and as its STRING-TOKEN-VALUE a denotatum for that string\r\n@return 1 LISTP; a list of STRING-TOKENS for which no denotatum could be found")
    public static SubLObject denotation_mapper(final SubLObject string, SubLObject excluded_preds, SubLObject mode, SubLObject parse_morphologically) {
        if (excluded_preds == UNPROVIDED) {
            excluded_preds = NIL;
        }
        if (mode == UNPROVIDED) {
            mode = $GREEDY;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLTrampolineFile.enforceType(string, STRINGP);
        SubLTrampolineFile.enforceType(excluded_preds, LIST_OF_PREDICATES_P);
        SubLTrampolineFile.enforceType(mode, KEYWORDP);
        SubLTrampolineFile.enforceType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
        SubLObject result = NIL;
        SubLObject failures = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$168 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    SubLObject cdolist_list_var;
                    final SubLObject raw_mapping = cdolist_list_var = nl_trie_accessors.nl_trie_denotation_mapper(string, excluded_preds, mode, parse_morphologically);
                    SubLObject token = NIL;
                    token = cdolist_list_var.first();
                    while (NIL != cdolist_list_var) {
                        if (NIL != standard_tokenization.string_token_value(token)) {
                            result = cons(token, result);
                        } else {
                            final SubLObject number = string_utilities.string_to_number(standard_tokenization.string_token_string(token));
                            if (NIL != number) {
                                result = cons(standard_tokenization.new_string_token(standard_tokenization.string_token_string(token), number), result);
                            } else {
                                failures = cons(token, failures);
                            }
                        }
                        cdolist_list_var = cdolist_list_var.rest();
                        token = cdolist_list_var.first();
                    } 
                } finally {
                    final SubLObject _prev_bind_0_$169 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$169, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$168, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(nreverse(result), nreverse(failures));
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP; all denotations for STRING in LOOKUP-MT
     * @unknown This will include denotationPlaceholder, provided they are visible to the lexicon lookup MT, which doesn't hold by default
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP; all denotations for STRING in LOOKUP-MT\r\n@unknown This will include denotationPlaceholder, provided they are visible to the lexicon lookup MT, which doesn\'t hold by default")
    public static final SubLObject all_denots_of_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject denots = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_180 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots_181 = nl_trie_accessors.nl_trie_all_denots_of_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                                                    SubLObject predicate_lists_182 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    denots = denots_181;
                                                    predicate_lists = predicate_lists_182;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_183 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED);
                                                            SubLObject morph_predicate_lists = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            denots = append(denots, morph_denots);
                                                            predicate_lists = append(predicate_lists, morph_predicate_lists);
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_183, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_180, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, predicate_lists);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP; all denotations for STRING in LOOKUP-MT
     * @unknown This will include denotationPlaceholder, provided they are visible to the lexicon lookup MT, which doesn't hold by default
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP; all denotations for STRING in LOOKUP-MT\r\n@unknown This will include denotationPlaceholder, provided they are visible to the lexicon lookup MT, which doesn\'t hold by default")
    public static SubLObject all_denots_of_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject denots = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$170 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject denots_$171 = nl_trie_accessors.nl_trie_all_denots_of_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                        final SubLObject predicate_lists_$172 = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = denots_$171;
                        predicate_lists = predicate_lists_$172;
                    }
                    if (NIL != proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED);
                        final SubLObject morph_predicate_lists = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = append(denots, morph_denots);
                        predicate_lists = append(predicate_lists, morph_predicate_lists);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$171 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$171, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$170, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, predicate_lists);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP; all usable denotations for STRING in LOOKUP-MT. This excludes denotationPlaceholder's and other bookkeeping-type denotations.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP; all usable denotations for STRING in LOOKUP-MT. This excludes denotationPlaceholder\'s and other bookkeeping-type denotations.")
    public static final SubLObject most_denots_of_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject denots = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_184 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots_185 = nl_trie_accessors.nl_trie_denots_of_string(string, $list_alt205, $RELATED, misspellingsP, NIL, lookup_mt, UNPROVIDED);
                                                    SubLObject predicate_lists_186 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    denots = denots_185;
                                                    predicate_lists = predicate_lists_186;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_187 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED);
                                                            SubLObject morph_predicate_lists = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            denots = append(denots, morph_denots);
                                                            predicate_lists = append(predicate_lists, morph_predicate_lists);
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_187, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_184, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, predicate_lists);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP; all usable denotations for STRING in LOOKUP-MT. This excludes denotationPlaceholder's and other bookkeeping-type denotations.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP; all usable denotations for STRING in LOOKUP-MT. This excludes denotationPlaceholder\'s and other bookkeeping-type denotations.")
    public static SubLObject most_denots_of_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject denots = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$174 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject denots_$175 = nl_trie_accessors.nl_trie_denots_of_string(string, $list209, $RELATED, misspellingsP, NIL, lookup_mt, UNPROVIDED);
                        final SubLObject predicate_lists_$176 = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = denots_$175;
                        predicate_lists = predicate_lists_$176;
                    }
                    if (NIL != proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED);
                        final SubLObject morph_predicate_lists = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = append(denots, morph_denots);
                        predicate_lists = append(predicate_lists, morph_predicate_lists);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$175 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$175, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$174, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, predicate_lists);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return list ; denotations for STRING in LOOKUP-MT including abbreviations but excluding denotationRelatedTo's, and certain name-string preds (@see NPP-EXCLUDED-NAME-PRED?)
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return list ; denotations for STRING in LOOKUP-MT including abbreviations but excluding denotationRelatedTo\'s, and certain name-string preds (@see NPP-EXCLUDED-NAME-PRED?)")
    public static final SubLObject all_parsing_denots_of_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject ans = NIL;
                SubLObject skip_namesP = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_188 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots = nl_trie_accessors.nl_trie_denots_of_string(string, $list_alt205, $DENOT, misspellingsP, skip_namesP, lookup_mt, UNPROVIDED);
                                                    SubLObject pred_lists = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    {
                                                        SubLObject denot = NIL;
                                                        SubLObject denot_189 = NIL;
                                                        SubLObject pred_list = NIL;
                                                        SubLObject pred_list_190 = NIL;
                                                        for (denot = denots, denot_189 = denot.first(), pred_list = pred_lists, pred_list_190 = pred_list.first(); !((NIL == pred_list) && (NIL == denot)); denot = denot.rest() , denot_189 = denot.first() , pred_list = pred_list.rest() , pred_list_190 = pred_list.first()) {
                                                            {
                                                                SubLObject okP = NIL;
                                                                if (NIL == okP) {
                                                                    {
                                                                        SubLObject csome_list_var = pred_list_190;
                                                                        SubLObject pred = NIL;
                                                                        for (pred = csome_list_var.first(); !((NIL != okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pred = csome_list_var.first()) {
                                                                            if (NIL == parsing_utilities.npp_excluded_name_predP(pred)) {
                                                                                okP = T;
                                                                                ans = cons(denot_189, ans);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    SubLObject result = read_from_string_ignoring_errors(string, NIL, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                    if (NIL != collection_defns.cyc_real_number(result)) {
                                                        ans = cons(result, ans);
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_191 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(ans, parse_morphologically)) {
                                                        ans = czer_utilities.delete_el_duplicates(append(ans, morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED)));
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_191, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_188, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return list ; denotations for STRING in LOOKUP-MT including abbreviations but excluding denotationRelatedTo's, and certain name-string preds (@see NPP-EXCLUDED-NAME-PRED?)
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return list ; denotations for STRING in LOOKUP-MT including abbreviations but excluding denotationRelatedTo\'s, and certain name-string preds (@see NPP-EXCLUDED-NAME-PRED?)")
    public static SubLObject all_parsing_denots_of_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject ans = NIL;
        final SubLObject skip_namesP = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$178 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject denots = nl_trie_accessors.nl_trie_denots_of_string(string, $list209, $DENOT, misspellingsP, skip_namesP, lookup_mt, UNPROVIDED);
                        final SubLObject pred_lists = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        SubLObject denot = NIL;
                        SubLObject denot_$179 = NIL;
                        SubLObject pred_list = NIL;
                        SubLObject pred_list_$180 = NIL;
                        denot = denots;
                        denot_$179 = denot.first();
                        pred_list = pred_lists;
                        pred_list_$180 = pred_list.first();
                        while ((NIL != pred_list) || (NIL != denot)) {
                            SubLObject okP = NIL;
                            if (NIL == okP) {
                                SubLObject csome_list_var = pred_list_$180;
                                SubLObject pred = NIL;
                                pred = csome_list_var.first();
                                while ((NIL == okP) && (NIL != csome_list_var)) {
                                    if (NIL == parsing_utilities.npp_excluded_name_predP(pred)) {
                                        okP = T;
                                        ans = cons(denot_$179, ans);
                                    }
                                    csome_list_var = csome_list_var.rest();
                                    pred = csome_list_var.first();
                                } 
                            }
                            denot = denot.rest();
                            denot_$179 = denot.first();
                            pred_list = pred_list.rest();
                            pred_list_$180 = pred_list.first();
                        } 
                        final SubLObject result = read_from_string_ignoring_errors(string, NIL, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        if (NIL != collection_defns.cyc_real_number(result)) {
                            ans = cons(result, ans);
                        }
                    }
                    if (NIL != proceed_with_morphological_parsingP(ans, parse_morphologically)) {
                        ans = czer_utilities.delete_el_duplicates(append(ans, morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED)));
                    }
                } finally {
                    final SubLObject _prev_bind_0_$179 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$179, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$178, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @param abbrev-types;
     * 		listp: if it includes :abbrevs, include abbreviations;
     * 		if it includes :acronyms, include acronyms
     * @param denot-type;
     * 		keywordp:
     * 		:denot =  #$denotation assertions  (parsing)
     * 		:related = #$denotation and #$denotationRelatedTo (generation)
     * 		:any = #$denotation, #$denotationRelatedTo, and #$denotationPlaceholder
     * @param PARSE-DATES-AND-NUMBERS?
     * 		booleanp; if set to NIL, DENOTS-OF-STRING will only perform lexical lookup, and
     * 		not try to parse any dates or numbers
     * @param LEXICON
     * 		term-lexicon-p; if present, LOOKUP-MT will be ignored and LEXICON will be used instead.
     * @return 0. LISTP ; CycL denotational terms serving as denotations for the phrase
     * @return 1. LISTP ; list of predicate lists for each denotation
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@param abbrev-types;\r\n\t\tlistp: if it includes :abbrevs, include abbreviations;\r\n\t\tif it includes :acronyms, include acronyms\r\n@param denot-type;\r\n\t\tkeywordp:\r\n\t\t:denot =  #$denotation assertions  (parsing)\r\n\t\t:related = #$denotation and #$denotationRelatedTo (generation)\r\n\t\t:any = #$denotation, #$denotationRelatedTo, and #$denotationPlaceholder\r\n@param PARSE-DATES-AND-NUMBERS?\r\n\t\tbooleanp; if set to NIL, DENOTS-OF-STRING will only perform lexical lookup, and\r\n\t\tnot try to parse any dates or numbers\r\n@param LEXICON\r\n\t\tterm-lexicon-p; if present, LOOKUP-MT will be ignored and LEXICON will be used instead.\r\n@return 0. LISTP ; CycL denotational terms serving as denotations for the phrase\r\n@return 1. LISTP ; list of predicate lists for each denotation")
    public static final SubLObject denots_of_string_alt(SubLObject string, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject parse_morphologically, SubLObject parse_dates_and_numbersP, SubLObject lexicon) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        if (parse_dates_and_numbersP == UNPROVIDED) {
            parse_dates_and_numbersP = T;
        }
        if (lexicon == UNPROVIDED) {
            lexicon = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(abbrev_types, LISTP);
            SubLTrampolineFile.checkType(denot_type, KEYWORDP);
            SubLTrampolineFile.checkType(misspellingsP, BOOLEANP);
            SubLTrampolineFile.checkType(skip_namestringsP, BOOLEANP);
            SubLTrampolineFile.checkType(lookup_mt, HLMT_P);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject denots = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_192 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                if (NIL == lexicon) {
                                                    lexicon = denots_of_string_lexicon.lexicon_for_denots_of_string(abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, UNPROVIDED);
                                                }
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots_193 = denots_of_string_lexicon.lexicon_denots_of_string(string, lexicon);
                                                    SubLObject predicate_lists_194 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    denots = denots_193;
                                                    predicate_lists = predicate_lists_194;
                                                }
                                                if (NIL != parse_dates_and_numbersP) {
                                                    {
                                                        SubLObject date_and_number_denots = com.cyc.cycjava.cycl.lexicon_accessors.date_and_number_denots_of_string(string);
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject denots_195 = com.cyc.cycjava.cycl.lexicon_accessors.add_denots_of_string_results(denots, predicate_lists, date_and_number_denots, make_list(length(date_and_number_denots), $list_alt208));
                                                            SubLObject predicate_lists_196 = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            denots = denots_195;
                                                            predicate_lists = predicate_lists_196;
                                                        }
                                                    }
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_197 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED);
                                                            SubLObject morph_predicate_lists = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            thread.resetMultipleValues();
                                                            {
                                                                SubLObject denots_198 = com.cyc.cycjava.cycl.lexicon_accessors.add_denots_of_string_results(denots, predicate_lists, morph_denots, morph_predicate_lists);
                                                                SubLObject predicate_lists_199 = thread.secondMultipleValue();
                                                                thread.resetMultipleValues();
                                                                denots = denots_198;
                                                                predicate_lists = predicate_lists_199;
                                                            }
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_197, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_192, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, predicate_lists);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @param abbrev-types;
     * 		listp: if it includes :abbrevs, include abbreviations;
     * 		if it includes :acronyms, include acronyms
     * @param denot-type;
     * 		keywordp:
     * 		:denot =  #$denotation assertions  (parsing)
     * 		:related = #$denotation and #$denotationRelatedTo (generation)
     * 		:any = #$denotation, #$denotationRelatedTo, and #$denotationPlaceholder
     * @param PARSE-DATES-AND-NUMBERS?
     * 		booleanp; if set to NIL, DENOTS-OF-STRING will only perform lexical lookup, and
     * 		not try to parse any dates or numbers
     * @param LEXICON
     * 		term-lexicon-p; if present, LOOKUP-MT will be ignored and LEXICON will be used instead.
     * @return 0. LISTP ; CycL denotational terms serving as denotations for the phrase
     * @return 1. LISTP ; list of predicate lists for each denotation
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@param abbrev-types;\r\n\t\tlistp: if it includes :abbrevs, include abbreviations;\r\n\t\tif it includes :acronyms, include acronyms\r\n@param denot-type;\r\n\t\tkeywordp:\r\n\t\t:denot =  #$denotation assertions  (parsing)\r\n\t\t:related = #$denotation and #$denotationRelatedTo (generation)\r\n\t\t:any = #$denotation, #$denotationRelatedTo, and #$denotationPlaceholder\r\n@param PARSE-DATES-AND-NUMBERS?\r\n\t\tbooleanp; if set to NIL, DENOTS-OF-STRING will only perform lexical lookup, and\r\n\t\tnot try to parse any dates or numbers\r\n@param LEXICON\r\n\t\tterm-lexicon-p; if present, LOOKUP-MT will be ignored and LEXICON will be used instead.\r\n@return 0. LISTP ; CycL denotational terms serving as denotations for the phrase\r\n@return 1. LISTP ; list of predicate lists for each denotation")
    public static SubLObject denots_of_string(final SubLObject string, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject skip_namestringsP, SubLObject lookup_mt, SubLObject parse_morphologically, SubLObject parse_dates_and_numbersP, SubLObject lexicon) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (skip_namestringsP == UNPROVIDED) {
            skip_namestringsP = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        if (parse_dates_and_numbersP == UNPROVIDED) {
            parse_dates_and_numbersP = T;
        }
        if (lexicon == UNPROVIDED) {
            lexicon = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLTrampolineFile.enforceType(string, CYCL_STRING_P);
        SubLTrampolineFile.enforceType(abbrev_types, LISTP);
        SubLTrampolineFile.enforceType(denot_type, KEYWORDP);
        SubLTrampolineFile.enforceType(misspellingsP, BOOLEANP);
        SubLTrampolineFile.enforceType(skip_namestringsP, BOOLEANP);
        SubLTrampolineFile.enforceType(lookup_mt, $sym212$VALID_DENOTS_OF_STRING_LOOKUP_MT_SPECIFICATION_);
        SubLTrampolineFile.enforceType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
        SubLObject denots = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$182 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (lookup_mt.isString()) {
                        lookup_mt = denots_mt_for_language(lexicon_utilities.get_language_for_code(lookup_mt));
                    }
                    final SubLObject _prev_bind_0_$183 = lexicon_vars.$lexicon_lookup_mt$.currentBinding(thread);
                    try {
                        lexicon_vars.$lexicon_lookup_mt$.bind(lookup_mt, thread);
                        if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                            if (NIL == lexicon) {
                                lexicon = denots_of_string_lexicon.lexicon_for_denots_of_string(abbrev_types, denot_type, misspellingsP, skip_namestringsP, lookup_mt, lexicon_macros.$nl_trie_accessor_default_case_sensitivity$.getDynamicValue(thread));
                            }
                            thread.resetMultipleValues();
                            final SubLObject denots_$184 = denots_of_string_lexicon.lexicon_denots_of_string(string, lexicon);
                            final SubLObject predicate_lists_$185 = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            denots = denots_$184;
                            predicate_lists = predicate_lists_$185;
                            if ((NIL != parse_dates_and_numbersP) && string.isString()) {
                                final SubLObject date_and_number_denots = date_and_number_denots_of_string(string);
                                thread.resetMultipleValues();
                                final SubLObject denots_$185 = add_denots_of_string_results(denots, predicate_lists, date_and_number_denots, make_list(length(date_and_number_denots), $list213));
                                final SubLObject predicate_lists_$186 = thread.secondMultipleValue();
                                thread.resetMultipleValues();
                                denots = denots_$185;
                                predicate_lists = predicate_lists_$186;
                            }
                        }
                        if (string.isString() && (NIL != proceed_with_morphological_parsingP(denots, parse_morphologically))) {
                            thread.resetMultipleValues();
                            final SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_string(string, UNPROVIDED);
                            final SubLObject morph_predicate_lists = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            thread.resetMultipleValues();
                            final SubLObject denots_$186 = add_denots_of_string_results(denots, predicate_lists, morph_denots, morph_predicate_lists);
                            final SubLObject predicate_lists_$187 = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            denots = denots_$186;
                            predicate_lists = predicate_lists_$187;
                        }
                    } finally {
                        lexicon_vars.$lexicon_lookup_mt$.rebind(_prev_bind_0_$183, thread);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$184 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$184, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$182, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, predicate_lists);
    }

    public static SubLObject valid_denots_of_string_lookup_mt_specificationP(final SubLObject obj) {
        return makeBoolean((NIL != hlmt.hlmt_p(obj)) || (obj.isString() && (NIL != lexicon_utilities.get_language_for_code(obj))));
    }

    public static SubLObject denots_mt_for_language(final SubLObject language) {
        final SubLObject validated_psc = kb_mapping_utilities.fpred_value_in_any_mt(language, $$validatedLexicalPSCForLanguage, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        final SubLObject monad = (NIL != validated_psc) ? validated_psc : lexicon_utilities.lexical_mt_for_language(language);
        return hlmt_czer.canonicalize_hlmt(make_binary_formula($$MtSpace, monad, $$AnytimePSC));
    }

    public static final SubLObject add_denots_of_string_results_alt(SubLObject denots, SubLObject predicate_lists, SubLObject new_denots, SubLObject new_predicate_lists) {
        {
            SubLObject all_denots = denots;
            SubLObject all_predicate_lists = predicate_lists;
            SubLObject denot = NIL;
            SubLObject denot_200 = NIL;
            SubLObject predicate_list = NIL;
            SubLObject predicate_list_201 = NIL;
            for (denot = new_denots, denot_200 = denot.first(), predicate_list = new_predicate_lists, predicate_list_201 = predicate_list.first(); !((NIL == predicate_list) && (NIL == denot)); denot = denot.rest() , denot_200 = denot.first() , predicate_list = predicate_list.rest() , predicate_list_201 = predicate_list.first()) {
                {
                    SubLObject position = position(denot_200, all_denots, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    if (NIL == position) {
                        all_denots = list_utilities.add_to_end(denot_200, all_denots);
                        all_predicate_lists = list_utilities.add_to_end(predicate_list_201, all_predicate_lists);
                    } else {
                        set_nth(position, all_predicate_lists, union(nth(position, all_predicate_lists), predicate_list_201, symbol_function(EQUAL), UNPROVIDED));
                    }
                }
            }
            return values(all_denots, all_predicate_lists);
        }
    }

    public static SubLObject add_denots_of_string_results(final SubLObject denots, final SubLObject predicate_lists, final SubLObject new_denots, final SubLObject new_predicate_lists) {
        SubLObject all_denots = denots;
        SubLObject all_predicate_lists = predicate_lists;
        SubLObject denot = NIL;
        SubLObject denot_$191 = NIL;
        SubLObject predicate_list = NIL;
        SubLObject predicate_list_$192 = NIL;
        denot = new_denots;
        denot_$191 = denot.first();
        predicate_list = new_predicate_lists;
        predicate_list_$192 = predicate_list.first();
        while ((NIL != predicate_list) || (NIL != denot)) {
            final SubLObject position = position(denot_$191, all_denots, symbol_function(EQUAL), UNPROVIDED, UNPROVIDED, UNPROVIDED);
            if (NIL == position) {
                all_denots = list_utilities.add_to_end(denot_$191, all_denots);
                all_predicate_lists = list_utilities.add_to_end(predicate_list_$192, all_predicate_lists);
            } else {
                set_nth(position, all_predicate_lists, union(nth(position, all_predicate_lists), predicate_list_$192, symbol_function(EQUAL), UNPROVIDED));
            }
            denot = denot.rest();
            denot_$191 = denot.first();
            predicate_list = predicate_list.rest();
            predicate_list_$192 = predicate_list.first();
        } 
        return values(all_denots, all_predicate_lists);
    }

    public static final SubLObject date_and_number_denots_of_string_alt(SubLObject string) {
        {
            SubLObject date_parses = date_utilities.parse_date_from_string_fast(string, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            SubLObject number_parse = numeral_parser.string_to_interval(string);
            return list_utilities.cons_if(number_parse, date_parses);
        }
    }

    public static SubLObject date_and_number_denots_of_string(final SubLObject string) {
        final SubLObject date_parses = date_utilities.parse_date_from_string_fast(string, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        final SubLObject number_parse = numeral_parser.string_to_interval(string);
        return list_utilities.cons_if(number_parse, date_parses);
    }

    public static final SubLObject denots_of_stringXpred_alt(SubLObject string, SubLObject pred, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject precise_with_theP, SubLObject parse_morphologically) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (precise_with_theP == UNPROVIDED) {
            precise_with_theP = NIL;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.speech_part_predP(pred, UNPROVIDED)) {
            return com.cyc.cycjava.cycl.lexicon_accessors.denots_of_stringXpos_pred(string, pred, abbrev_types, denot_type, misspellingsP, lookup_mt, parse_morphologically);
        } else {
            if (NIL != lexicon_vars.name_string_predP(pred)) {
                return com.cyc.cycjava.cycl.lexicon_accessors.denots_of_stringXnamestring_pred(string, pred, misspellingsP, lookup_mt, precise_with_theP);
            } else {
                Errors.error($str_alt213$_S_passes_neither_SPEECH_PART_PRE, pred);
            }
        }
        return NIL;
    }

    public static SubLObject denots_of_stringXpred(final SubLObject string, final SubLObject pred, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject precise_with_theP, SubLObject parse_morphologically) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (precise_with_theP == UNPROVIDED) {
            precise_with_theP = NIL;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        if (NIL != speech_part_predP(pred, UNPROVIDED)) {
            return denots_of_stringXpos_pred(string, pred, abbrev_types, denot_type, misspellingsP, lookup_mt, parse_morphologically);
        }
        if (NIL != lexicon_vars.name_string_predP(pred)) {
            return denots_of_stringXnamestring_pred(string, pred, misspellingsP, lookup_mt, precise_with_theP);
        }
        Errors.error($str222$_S_passes_neither_SPEECH_PART_PRE, pred);
        return NIL;
    }

    /**
     *
     *
     * @return LISTP of CycL expressions denoted by STRING with the namestring-pred NAMESTRING-PRED.
     */
    @LispMethod(comment = "@return LISTP of CycL expressions denoted by STRING with the namestring-pred NAMESTRING-PRED.")
    public static final SubLObject denots_of_stringXnamestring_pred_alt(SubLObject string, SubLObject namestring_pred, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject precise_with_theP) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (precise_with_theP == UNPROVIDED) {
            precise_with_theP = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(namestring_pred, $sym214$NAME_STRING_PRED_);
            {
                SubLObject result_denots = NIL;
                SubLObject result_preds = NIL;
                thread.resetMultipleValues();
                {
                    SubLObject denots = com.cyc.cycjava.cycl.lexicon_accessors.denots_of_name_string(string, misspellingsP, lookup_mt, precise_with_theP);
                    SubLObject preds = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    {
                        SubLObject denot = NIL;
                        SubLObject denot_202 = NIL;
                        SubLObject pred_list = NIL;
                        SubLObject pred_list_203 = NIL;
                        for (denot = denots, denot_202 = denot.first(), pred_list = preds, pred_list_203 = pred_list.first(); !((NIL == pred_list) && (NIL == denot)); denot = denot.rest() , denot_202 = denot.first() , pred_list = pred_list.rest() , pred_list_203 = pred_list.first()) {
                            {
                                SubLObject cdolist_list_var = pred_list_203;
                                SubLObject pred = NIL;
                                for (pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pred = cdolist_list_var.first()) {
                                    {
                                        SubLObject result_pred_list = NIL;
                                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_pos_predP(pred, namestring_pred, UNPROVIDED)) {
                                            result_pred_list = cons(pred, result_pred_list);
                                        }
                                        if (NIL != result_pred_list) {
                                            result_preds = cons(result_pred_list, result_preds);
                                            result_denots = cons(denot_202, result_denots);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return values(nreverse(result_denots), nreverse(result_preds));
            }
        }
    }

    /**
     *
     *
     * @return LISTP of CycL expressions denoted by STRING with the namestring-pred NAMESTRING-PRED.
     */
    @LispMethod(comment = "@return LISTP of CycL expressions denoted by STRING with the namestring-pred NAMESTRING-PRED.")
    public static SubLObject denots_of_stringXnamestring_pred(final SubLObject string, final SubLObject namestring_pred, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject precise_with_theP) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (precise_with_theP == UNPROVIDED) {
            precise_with_theP = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != lexicon_vars.name_string_predP(namestring_pred) : "! lexicon_vars.name_string_predP(namestring_pred) " + ("lexicon_vars.name_string_predP(namestring_pred) " + "CommonSymbols.NIL != lexicon_vars.name_string_predP(namestring_pred) ") + namestring_pred;
        SubLObject result_denots = NIL;
        SubLObject result_preds = NIL;
        thread.resetMultipleValues();
        final SubLObject denots = denots_of_name_string(string, misspellingsP, lookup_mt, precise_with_theP);
        final SubLObject preds = thread.secondMultipleValue();
        thread.resetMultipleValues();
        SubLObject denot = NIL;
        SubLObject denot_$193 = NIL;
        SubLObject pred_list = NIL;
        SubLObject pred_list_$194 = NIL;
        denot = denots;
        denot_$193 = denot.first();
        pred_list = preds;
        pred_list_$194 = pred_list.first();
        while ((NIL != pred_list) || (NIL != denot)) {
            SubLObject cdolist_list_var = pred_list_$194;
            SubLObject pred = NIL;
            pred = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject result_pred_list = NIL;
                if (NIL != genl_pos_predP(pred, namestring_pred, UNPROVIDED)) {
                    result_pred_list = cons(pred, result_pred_list);
                }
                if (NIL != result_pred_list) {
                    result_preds = cons(result_pred_list, result_preds);
                    result_denots = cons(denot_$193, result_denots);
                }
                cdolist_list_var = cdolist_list_var.rest();
                pred = cdolist_list_var.first();
            } 
            denot = denot.rest();
            denot_$193 = denot.first();
            pred_list = pred_list.rest();
            pred_list_$194 = pred_list.first();
        } 
        return values(nreverse(result_denots), nreverse(result_preds));
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of CycL expressions denoted by STRING with the speech-part pred POS-PRED.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of CycL expressions denoted by STRING with the speech-part pred POS-PRED.")
    public static final SubLObject denots_of_stringXpos_pred_alt(SubLObject string, SubLObject pos_pred, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pos_pred, $sym29$SPEECH_PART_PRED_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject denots = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_204 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots_205 = nl_trie_accessors.nl_trie_denots_of_stringXpred(string, pos_pred, abbrev_types, denot_type, misspellingsP, lookup_mt, UNPROVIDED);
                                                    SubLObject predicate_lists_206 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    denots = denots_205;
                                                    predicate_lists = predicate_lists_206;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_207 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_stringXpos_pred(string, pos_pred, lookup_mt, UNPROVIDED);
                                                            SubLObject morph_predicate_lists = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            denots = append(denots, morph_denots);
                                                            predicate_lists = append(predicate_lists, morph_predicate_lists);
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_207, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_204, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, predicate_lists);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of CycL expressions denoted by STRING with the speech-part pred POS-PRED.
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of CycL expressions denoted by STRING with the speech-part pred POS-PRED.")
    public static SubLObject denots_of_stringXpos_pred(final SubLObject string, final SubLObject pos_pred, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != speech_part_predP(pos_pred, UNPROVIDED) : "! lexicon_accessors.speech_part_predP(pos_pred, .UNPROVIDED) " + ("lexicon_accessors.speech_part_predP(pos_pred, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_part_predP(pos_pred, CommonSymbols.UNPROVIDED) ") + pos_pred;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject denots = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$195 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject denots_$196 = nl_trie_accessors.nl_trie_denots_of_stringXpred(string, pos_pred, abbrev_types, denot_type, misspellingsP, lookup_mt, UNPROVIDED);
                        final SubLObject predicate_lists_$197 = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = denots_$196;
                        predicate_lists = predicate_lists_$197;
                    }
                    if (NIL != proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_stringXpos_pred(string, pos_pred, lookup_mt, UNPROVIDED);
                        final SubLObject morph_predicate_lists = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = append(denots, morph_denots);
                        predicate_lists = append(predicate_lists, morph_predicate_lists);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$196 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$196, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$195, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, predicate_lists);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of CycL expressions denoted by STRING with the speech-part POS
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of CycL expressions denoted by STRING with the speech-part POS")
    public static final SubLObject denots_of_stringXspeech_part_alt(SubLObject string, SubLObject pos, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject denots = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_208 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots_209 = nl_trie_accessors.nl_trie_denots_of_stringXspeech_part(string, pos, abbrev_types, denot_type, misspellingsP, lookup_mt, UNPROVIDED);
                                                    SubLObject predicate_lists_210 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    denots = denots_209;
                                                    predicate_lists = predicate_lists_210;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_211 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_stringXspeech_part(string, pos, UNPROVIDED);
                                                            SubLObject morph_predicate_lists = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            denots = append(denots, morph_denots);
                                                            predicate_lists = append(predicate_lists, morph_predicate_lists);
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_211, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_208, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, predicate_lists);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of CycL expressions denoted by STRING with the speech-part POS
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of CycL expressions denoted by STRING with the speech-part POS")
    public static SubLObject denots_of_stringXspeech_part(final SubLObject string, final SubLObject pos, SubLObject abbrev_types, SubLObject denot_type, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject denots = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$199 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject denots_$200 = nl_trie_accessors.nl_trie_denots_of_stringXspeech_part(string, pos, abbrev_types, denot_type, misspellingsP, lookup_mt, UNPROVIDED);
                        final SubLObject predicate_lists_$201 = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = denots_$200;
                        predicate_lists = predicate_lists_$201;
                    }
                    if (NIL != proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_stringXspeech_part(string, pos, UNPROVIDED);
                        final SubLObject morph_predicate_lists = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = append(denots, morph_denots);
                        predicate_lists = append(predicate_lists, morph_predicate_lists);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$200 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$200, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$199, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, predicate_lists);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of CycL expressions denoted by STRING with the speech-part keyword POS-KEYWORD
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of CycL expressions denoted by STRING with the speech-part keyword POS-KEYWORD")
    public static final SubLObject denots_of_stringXpos_alt(SubLObject string, SubLObject pos_keyword, SubLObject denot_type, SubLObject misspellingsP, SubLObject abbrev_types, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(string, STRINGP);
            SubLTrampolineFile.checkType(pos_keyword, KEYWORDP);
            SubLTrampolineFile.checkType(parse_morphologically, PARSE_MORPHOLOGICALLY_OPTION_P);
            {
                SubLObject denots = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_212 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.skip_to_morphological_parsingP(parse_morphologically)) {
                                                thread.resetMultipleValues();
                                                {
                                                    SubLObject denots_213 = nl_trie_accessors.nl_trie_denots_of_stringXpos(string, pos_keyword, abbrev_types, denot_type, misspellingsP, lookup_mt, UNPROVIDED);
                                                    SubLObject predicate_lists_214 = thread.secondMultipleValue();
                                                    thread.resetMultipleValues();
                                                    denots = denots_213;
                                                    predicate_lists = predicate_lists_214;
                                                }
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_215 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                                                        thread.resetMultipleValues();
                                                        {
                                                            SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_stringXpos(string, pos_keyword, lookup_mt, UNPROVIDED);
                                                            SubLObject morph_predicate_lists = thread.secondMultipleValue();
                                                            thread.resetMultipleValues();
                                                            denots = append(denots, morph_denots);
                                                            predicate_lists = append(predicate_lists, morph_predicate_lists);
                                                        }
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_215, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_212, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, predicate_lists);
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY:
     * 		PARSE-MORPHOLOGICALLY-OPTION-P
     * 		Do we attempt to parse STRING as a complex (multi-morpheme) word?
     * @return LISTP of CycL expressions denoted by STRING with the speech-part keyword POS-KEYWORD
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY:\r\n\t\tPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\tDo we attempt to parse STRING as a complex (multi-morpheme) word?\r\n@return LISTP of CycL expressions denoted by STRING with the speech-part keyword POS-KEYWORD")
    public static SubLObject denots_of_stringXpos(final SubLObject string, final SubLObject pos_keyword, SubLObject denot_type, SubLObject misspellingsP, SubLObject abbrev_types, SubLObject lookup_mt, SubLObject parse_morphologically) {
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = T;
        }
        if (abbrev_types == UNPROVIDED) {
            abbrev_types = NIL;
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(string) : "! stringp(string) " + ("Types.stringp(string) " + "CommonSymbols.NIL != Types.stringp(string) ") + string;
        assert NIL != keywordp(pos_keyword) : "! keywordp(pos_keyword) " + ("Types.keywordp(pos_keyword) " + "CommonSymbols.NIL != Types.keywordp(pos_keyword) ") + pos_keyword;
        assert NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) : "! lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + ("lexicon_vars.parse_morphologically_option_p(parse_morphologically) " + "CommonSymbols.NIL != lexicon_vars.parse_morphologically_option_p(parse_morphologically) ") + parse_morphologically;
        SubLObject denots = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$203 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    if (NIL == skip_to_morphological_parsingP(parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject denots_$204 = nl_trie_accessors.nl_trie_denots_of_stringXpos(string, pos_keyword, abbrev_types, denot_type, misspellingsP, lookup_mt, UNPROVIDED);
                        final SubLObject predicate_lists_$205 = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = denots_$204;
                        predicate_lists = predicate_lists_$205;
                    }
                    if (NIL != proceed_with_morphological_parsingP(denots, parse_morphologically)) {
                        thread.resetMultipleValues();
                        final SubLObject morph_denots = morphological_word_parser.denots_of_complex_word_stringXpos(string, pos_keyword, lookup_mt, UNPROVIDED);
                        final SubLObject morph_predicate_lists = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        denots = append(denots, morph_denots);
                        predicate_lists = append(predicate_lists, morph_predicate_lists);
                    }
                } finally {
                    final SubLObject _prev_bind_0_$204 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$204, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$203, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, predicate_lists);
    }

    /**
     *
     *
     * @return 0 LISTP of CycL terms denoted by the name STRING (qua name).
     * @return 1 LISTP of lists of denotation preds.
     * @param PRECISE-WITH-THE?
     * 		boolean; Should we return terms denoted by "the STRING"
     * 		as well as by STRING itself?
     */
    @LispMethod(comment = "@return 0 LISTP of CycL terms denoted by the name STRING (qua name).\r\n@return 1 LISTP of lists of denotation preds.\r\n@param PRECISE-WITH-THE?\r\n\t\tboolean; Should we return terms denoted by \"the STRING\"\r\n\t\tas well as by STRING itself?")
    public static final SubLObject denots_of_name_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject precise_with_theP) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (precise_with_theP == UNPROVIDED) {
            precise_with_theP = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denots = NIL;
                SubLObject pred_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_216 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots_217 = nl_trie_accessors.nl_trie_denots_of_name_string(string, misspellingsP, lookup_mt, precise_with_theP, UNPROVIDED);
                                                SubLObject pred_lists_218 = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                denots = denots_217;
                                                pred_lists = pred_lists_218;
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_219 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_219, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_216, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, pred_lists);
            }
        }
    }

    /**
     *
     *
     * @return 0 LISTP of CycL terms denoted by the name STRING (qua name).
     * @return 1 LISTP of lists of denotation preds.
     * @param PRECISE-WITH-THE?
     * 		boolean; Should we return terms denoted by "the STRING"
     * 		as well as by STRING itself?
     */
    @LispMethod(comment = "@return 0 LISTP of CycL terms denoted by the name STRING (qua name).\r\n@return 1 LISTP of lists of denotation preds.\r\n@param PRECISE-WITH-THE?\r\n\t\tboolean; Should we return terms denoted by \"the STRING\"\r\n\t\tas well as by STRING itself?")
    public static SubLObject denots_of_name_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt, SubLObject precise_with_theP) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (precise_with_theP == UNPROVIDED) {
            precise_with_theP = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denots = NIL;
        SubLObject pred_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$207 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots_$208 = nl_trie_accessors.nl_trie_denots_of_name_string(string, misspellingsP, lookup_mt, precise_with_theP, UNPROVIDED);
                    final SubLObject pred_lists_$209 = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    denots = denots_$208;
                    pred_lists = pred_lists_$209;
                } finally {
                    final SubLObject _prev_bind_0_$208 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$208, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$207, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, pred_lists);
    }

    /**
     *
     *
     * @return 0 LISTP of CycL terms denoted by the name STRING (qua name).
     * @return 1 LISTP of lists of denotation preds.
    Do not allow terms denoted by "the STRING".
     */
    @LispMethod(comment = "@return 0 LISTP of CycL terms denoted by the name STRING (qua name).\r\n@return 1 LISTP of lists of denotation preds.\r\nDo not allow terms denoted by \"the STRING\".")
    public static final SubLObject denots_of_name_string_precise_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.denots_of_name_string(string, misspellingsP, lookup_mt, T);
    }

    /**
     *
     *
     * @return 0 LISTP of CycL terms denoted by the name STRING (qua name).
     * @return 1 LISTP of lists of denotation preds.
    Do not allow terms denoted by "the STRING".
     */
    @LispMethod(comment = "@return 0 LISTP of CycL terms denoted by the name STRING (qua name).\r\n@return 1 LISTP of lists of denotation preds.\r\nDo not allow terms denoted by \"the STRING\".")
    public static SubLObject denots_of_name_string_precise(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return denots_of_name_string(string, misspellingsP, lookup_mt, T);
    }

    /**
     *
     *
     * @return LISTP of CycL terms denoted by the word WU.
     */
    @LispMethod(comment = "@return LISTP of CycL terms denoted by the word WU.")
    public static final SubLObject denots_of_wu_alt(SubLObject wu, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denotations = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject denot_preds = nl_trie.nl_trie_denotation_predicates();
                            SubLObject cdolist_list_var = denot_preds;
                            SubLObject pred = NIL;
                            for (pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pred = cdolist_list_var.first()) {
                                if (NIL == lexicon_utilities.stringlist_args_of_pred_cached(pred)) {
                                    {
                                        SubLObject word_index = lexicon_utilities.wu_arg_of_pred_cached(pred);
                                        SubLObject denot_index = lexicon_utilities.denotatum_arg_of_pred_cached(pred);
                                        SubLObject cdolist_list_var_220 = kb_mapping.gather_gaf_arg_index(wu, word_index, pred, UNPROVIDED, UNPROVIDED);
                                        SubLObject v_assert = NIL;
                                        for (v_assert = cdolist_list_var_220.first(); NIL != cdolist_list_var_220; cdolist_list_var_220 = cdolist_list_var_220.rest() , v_assert = cdolist_list_var_220.first()) {
                                            denotations = cons(cycl_utilities.formula_arg(v_assert, denot_index, UNPROVIDED), denotations);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return denotations;
            }
        }
    }

    /**
     *
     *
     * @return LISTP of CycL terms denoted by the word WU.
     */
    @LispMethod(comment = "@return LISTP of CycL terms denoted by the word WU.")
    public static SubLObject denots_of_wu(final SubLObject wu, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denotations = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            SubLObject cdolist_list_var;
            final SubLObject denot_preds = cdolist_list_var = nl_trie.nl_trie_denotation_predicates();
            SubLObject pred = NIL;
            pred = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL == lexicon_utilities.stringlist_args_of_pred_cached(pred)) {
                    final SubLObject word_index = lexicon_utilities.wu_arg_of_pred_cached(pred);
                    final SubLObject denot_index = lexicon_utilities.denotatum_arg_of_pred_cached(pred);
                    SubLObject cdolist_list_var_$211 = kb_mapping.gather_gaf_arg_index(wu, word_index, pred, UNPROVIDED, UNPROVIDED);
                    SubLObject v_assert = NIL;
                    v_assert = cdolist_list_var_$211.first();
                    while (NIL != cdolist_list_var_$211) {
                        denotations = cons(cycl_utilities.formula_arg(v_assert, denot_index, UNPROVIDED), denotations);
                        cdolist_list_var_$211 = cdolist_list_var_$211.rest();
                        v_assert = cdolist_list_var_$211.first();
                    } 
                }
                cdolist_list_var = cdolist_list_var.rest();
                pred = cdolist_list_var.first();
            } 
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return denotations;
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY-OPTION;
    PARSE-MORPHOLOGICALLY-OPTION-P
     * 		
     * @return booleanp; whether we should proceed with morphological parsing
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY-OPTION;\nPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\t\r\n@return booleanp; whether we should proceed with morphological parsing")
    public static final SubLObject proceed_with_morphological_parsingP_alt(SubLObject results_so_far, SubLObject parse_morphologically_option) {
        {
            SubLObject pcase_var = parse_morphologically_option;
            if (pcase_var.eql($ONLY) || pcase_var.eql($ALWAYS)) {
                return T;
            } else {
                if (pcase_var.eql($AS_FALLBACK)) {
                    return sublisp_null(results_so_far);
                } else {
                    return NIL;
                }
            }
        }
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY-OPTION;
    PARSE-MORPHOLOGICALLY-OPTION-P
     * 		
     * @return booleanp; whether we should proceed with morphological parsing
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY-OPTION;\nPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\t\r\n@return booleanp; whether we should proceed with morphological parsing")
    public static SubLObject proceed_with_morphological_parsingP(final SubLObject results_so_far, final SubLObject parse_morphologically_option) {
        if (parse_morphologically_option.eql($ONLY) || parse_morphologically_option.eql($ALWAYS)) {
            return T;
        }
        if (parse_morphologically_option.eql($AS_FALLBACK)) {
            return sublisp_null(results_so_far);
        }
        return NIL;
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY-OPTION;
    PARSE-MORPHOLOGICALLY-OPTION-P
     * 		
     * @return booleanp; whether we should skip to morphological parsing
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY-OPTION;\nPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\t\r\n@return booleanp; whether we should skip to morphological parsing")
    public static final SubLObject skip_to_morphological_parsingP_alt(SubLObject parse_morphologically_option) {
        return eq(parse_morphologically_option, $ONLY);
    }

    /**
     *
     *
     * @param PARSE-MORPHOLOGICALLY-OPTION;
    PARSE-MORPHOLOGICALLY-OPTION-P
     * 		
     * @return booleanp; whether we should skip to morphological parsing
     */
    @LispMethod(comment = "@param PARSE-MORPHOLOGICALLY-OPTION;\nPARSE-MORPHOLOGICALLY-OPTION-P\r\n\t\t\r\n@return booleanp; whether we should skip to morphological parsing")
    public static SubLObject skip_to_morphological_parsingP(final SubLObject parse_morphologically_option) {
        return eq(parse_morphologically_option, $ONLY);
    }

    /**
     *
     *
     * @return 0 LISTP of terms denoted by STRING as an acronym.
     * @return 1 LISTP of lists of preds.
     */
    @LispMethod(comment = "@return 0 LISTP of terms denoted by STRING as an acronym.\r\n@return 1 LISTP of lists of preds.")
    public static final SubLObject denots_of_acronym_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denots = NIL;
                SubLObject pred_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_221 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots_222 = nl_trie_accessors.nl_trie_denots_of_acronym_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                                                SubLObject pred_lists_223 = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                denots = denots_222;
                                                pred_lists = pred_lists_223;
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_224 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_224, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_221, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, pred_lists);
            }
        }
    }

    /**
     *
     *
     * @return 0 LISTP of terms denoted by STRING as an acronym.
     * @return 1 LISTP of lists of preds.
     */
    @LispMethod(comment = "@return 0 LISTP of terms denoted by STRING as an acronym.\r\n@return 1 LISTP of lists of preds.")
    public static SubLObject denots_of_acronym_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denots = NIL;
        SubLObject pred_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$212 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots_$213 = nl_trie_accessors.nl_trie_denots_of_acronym_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                    final SubLObject pred_lists_$214 = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    denots = denots_$213;
                    pred_lists = pred_lists_$214;
                } finally {
                    final SubLObject _prev_bind_0_$213 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$213, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$212, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, pred_lists);
    }

    /**
     *
     *
     * @return 0 listp; denotations mapped to STRING
     * @return 1 listp; list of list of semantic predicate(s) used for each mapping
     */
    @LispMethod(comment = "@return 0 listp; denotations mapped to STRING\r\n@return 1 listp; list of list of semantic predicate(s) used for each mapping")
    public static final SubLObject names_from_spelling_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denots = NIL;
                SubLObject pred_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_225 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots_226 = nl_trie_accessors.nl_trie_names_from_spelling(string, misspellingsP, lookup_mt, UNPROVIDED);
                                                SubLObject pred_lists_227 = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                denots = denots_226;
                                                pred_lists = pred_lists_227;
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_228 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_228, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_225, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, pred_lists);
            }
        }
    }

    /**
     *
     *
     * @return 0 listp; denotations mapped to STRING
     * @return 1 listp; list of list of semantic predicate(s) used for each mapping
     */
    @LispMethod(comment = "@return 0 listp; denotations mapped to STRING\r\n@return 1 listp; list of list of semantic predicate(s) used for each mapping")
    public static SubLObject names_from_spelling(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denots = NIL;
        SubLObject pred_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$216 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots_$217 = nl_trie_accessors.nl_trie_names_from_spelling(string, misspellingsP, lookup_mt, UNPROVIDED);
                    final SubLObject pred_lists_$218 = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    denots = denots_$217;
                    pred_lists = pred_lists_$218;
                } finally {
                    final SubLObject _prev_bind_0_$217 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$217, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$216, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, pred_lists);
    }

    /**
     *
     *
     * @return 0 listp; denotations mapped to STRING
     * @return 1 listp; list of list of semantic predicate(s) used for each mapping
     */
    @LispMethod(comment = "@return 0 listp; denotations mapped to STRING\r\n@return 1 listp; list of list of semantic predicate(s) used for each mapping")
    public static final SubLObject names_from_nickname_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denots = NIL;
                SubLObject pred_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_229 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots_230 = nl_trie_accessors.nl_trie_names_from_nickname(string, misspellingsP, lookup_mt, UNPROVIDED);
                                                SubLObject pred_lists_231 = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                denots = denots_230;
                                                pred_lists = pred_lists_231;
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_232 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_232, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_229, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, pred_lists);
            }
        }
    }

    /**
     *
     *
     * @return 0 listp; denotations mapped to STRING
     * @return 1 listp; list of list of semantic predicate(s) used for each mapping
     */
    @LispMethod(comment = "@return 0 listp; denotations mapped to STRING\r\n@return 1 listp; list of list of semantic predicate(s) used for each mapping")
    public static SubLObject names_from_nickname(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denots = NIL;
        SubLObject pred_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$220 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots_$221 = nl_trie_accessors.nl_trie_names_from_nickname(string, misspellingsP, lookup_mt, UNPROVIDED);
                    final SubLObject pred_lists_$222 = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    denots = denots_$221;
                    pred_lists = pred_lists_$222;
                } finally {
                    final SubLObject _prev_bind_0_$221 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$221, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$220, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, pred_lists);
    }

    /**
     *
     *
     * @return 0 listp; denotations mapped to STRING as an abbreviation.
     * @return 1 listp; list of list of semantic predicate(s) used for each mapping
     */
    @LispMethod(comment = "@return 0 listp; denotations mapped to STRING as an abbreviation.\r\n@return 1 listp; list of list of semantic predicate(s) used for each mapping")
    public static final SubLObject denots_of_abbreviation_string_alt(SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denots = NIL;
                SubLObject pred_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_233 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots_234 = nl_trie_accessors.nl_trie_denots_of_abbreviation_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                                                SubLObject pred_lists_235 = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                denots = denots_234;
                                                pred_lists = pred_lists_235;
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_236 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_236, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_233, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(denots, pred_lists);
            }
        }
    }

    /**
     *
     *
     * @return 0 listp; denotations mapped to STRING as an abbreviation.
     * @return 1 listp; list of list of semantic predicate(s) used for each mapping
     */
    @LispMethod(comment = "@return 0 listp; denotations mapped to STRING as an abbreviation.\r\n@return 1 listp; list of list of semantic predicate(s) used for each mapping")
    public static SubLObject denots_of_abbreviation_string(final SubLObject string, SubLObject misspellingsP, SubLObject lookup_mt) {
        if (misspellingsP == UNPROVIDED) {
            misspellingsP = lexicon_vars.$misspellingsP$.getDynamicValue();
        }
        if (lookup_mt == UNPROVIDED) {
            lookup_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denots = NIL;
        SubLObject pred_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$224 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots_$225 = nl_trie_accessors.nl_trie_denots_of_abbreviation_string(string, misspellingsP, lookup_mt, UNPROVIDED);
                    final SubLObject pred_lists_$226 = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    denots = denots_$225;
                    pred_lists = pred_lists_$226;
                } finally {
                    final SubLObject _prev_bind_0_$225 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$225, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$224, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return values(denots, pred_lists);
    }

    /**
     *
     *
     * @return boolean ; T iff PHRASE only maps into the lexicon via nameString assertions (i.e., no denotational mappings)
     */
    @LispMethod(comment = "@return boolean ; T iff PHRASE only maps into the lexicon via nameString assertions (i.e., no denotational mappings)")
    public static final SubLObject known_proper_noun_phraseP_alt(SubLObject phrase) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(phrase, STRINGP);
            {
                SubLObject proper_name_preds = isa.all_fort_instances($$ProperNamePredicate_Strict, UNPROVIDED, UNPROVIDED);
                SubLObject result = NIL;
                SubLObject denots = NIL;
                SubLObject predicates = NIL;
                SubLObject predicate_lists = NIL;
                SubLObject current_state = memoization_state.current_memoization_state();
                {
                    SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
                    try {
                        lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? ((SubLObject) (current_state)) : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
                        {
                            SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
                            {
                                SubLObject _prev_bind_0_237 = memoization_state.$memoization_state$.currentBinding(thread);
                                try {
                                    memoization_state.$memoization_state$.bind(local_state, thread);
                                    {
                                        SubLObject original_memoization_process = NIL;
                                        if ((NIL != local_state) && (NIL == memoization_state.memoization_state_lock(local_state))) {
                                            original_memoization_process = memoization_state.memoization_state_get_current_process_internal(local_state);
                                            {
                                                SubLObject current_proc = current_process();
                                                if (NIL == original_memoization_process) {
                                                    memoization_state.memoization_state_set_current_process_internal(local_state, current_proc);
                                                } else {
                                                    if (original_memoization_process != current_proc) {
                                                        Errors.error($str_alt17$Invalid_attempt_to_reuse_memoizat);
                                                    }
                                                }
                                            }
                                        }
                                        try {
                                            thread.resetMultipleValues();
                                            {
                                                SubLObject denots_238 = com.cyc.cycjava.cycl.lexicon_accessors.denots_of_string(phrase, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                SubLObject predicate_lists_239 = thread.secondMultipleValue();
                                                thread.resetMultipleValues();
                                                denots = denots_238;
                                                predicate_lists = predicate_lists_239;
                                            }
                                        } finally {
                                            {
                                                SubLObject _prev_bind_0_240 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                try {
                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                    predicates = list_utilities.flatten(predicate_lists);
                                                    if ((NIL != denots) && (NIL == set_difference(predicates, proper_name_preds, UNPROVIDED, UNPROVIDED))) {
                                                        result = T;
                                                    }
                                                    if ((NIL != local_state) && (NIL == original_memoization_process)) {
                                                        memoization_state.memoization_state_set_current_process_internal(local_state, NIL);
                                                    }
                                                } finally {
                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_240, thread);
                                                }
                                            }
                                        }
                                    }
                                } finally {
                                    memoization_state.$memoization_state$.rebind(_prev_bind_0_237, thread);
                                }
                            }
                        }
                    } finally {
                        lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @return boolean ; T iff PHRASE only maps into the lexicon via nameString assertions (i.e., no denotational mappings)
     */
    @LispMethod(comment = "@return boolean ; T iff PHRASE only maps into the lexicon via nameString assertions (i.e., no denotational mappings)")
    public static SubLObject known_proper_noun_phraseP(final SubLObject phrase) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != stringp(phrase) : "! stringp(phrase) " + ("Types.stringp(phrase) " + "CommonSymbols.NIL != Types.stringp(phrase) ") + phrase;
        final SubLObject proper_name_preds = isa.all_fort_instances($$ProperNamePredicate_Strict, UNPROVIDED, UNPROVIDED);
        SubLObject result = NIL;
        SubLObject denots = NIL;
        SubLObject predicates = NIL;
        SubLObject predicate_lists = NIL;
        final SubLObject current_state = memoization_state.current_memoization_state();
        final SubLObject _prev_bind_0 = lexicon_macros.$lexicon_memoization_state$.currentBinding(thread);
        try {
            lexicon_macros.$lexicon_memoization_state$.bind(NIL != current_state ? current_state : lexicon_macros.find_or_create_lexicon_memoization_state(), thread);
            final SubLObject local_state = lexicon_macros.$lexicon_memoization_state$.getDynamicValue(thread);
            final SubLObject _prev_bind_0_$228 = memoization_state.$memoization_state$.currentBinding(thread);
            try {
                memoization_state.$memoization_state$.bind(local_state, thread);
                final SubLObject original_memoization_process = memoization_state.memoization_state_original_process(local_state);
                try {
                    thread.resetMultipleValues();
                    final SubLObject denots_$229 = denots_of_string(phrase, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    final SubLObject predicate_lists_$230 = thread.secondMultipleValue();
                    thread.resetMultipleValues();
                    denots = denots_$229;
                    predicate_lists = predicate_lists_$230;
                    predicates = list_utilities.flatten(predicate_lists);
                    if ((NIL != denots) && (NIL == set_difference(predicates, proper_name_preds, UNPROVIDED, UNPROVIDED))) {
                        result = T;
                    }
                } finally {
                    final SubLObject _prev_bind_0_$229 = $is_thread_performing_cleanupP$.currentBinding(thread);
                    try {
                        $is_thread_performing_cleanupP$.bind(T, thread);
                        final SubLObject _values = getValuesAsVector();
                        memoization_state.memoization_state_possibly_clear_original_process(local_state, original_memoization_process);
                        restoreValuesFromVector(_values);
                    } finally {
                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$229, thread);
                    }
                }
            } finally {
                memoization_state.$memoization_state$.rebind(_prev_bind_0_$228, thread);
            }
        } finally {
            lexicon_macros.$lexicon_memoization_state$.rebind(_prev_bind_0, thread);
        }
        return result;
    }

    /**
     *
     *
     * @return list : denotations predicates to use for the type of denotation
    If DENOT-TYPE is :DENOT, use only #$denotation assertions;
    if DENOT-TYPE is :RELATED, use #$denotationRelatedTo as well;
    if DENOT-TYPE is :ANY, includes every denotation-type predicate, including #$denotationPlaceholder.
     * @unknown use a simple table lookup for this
     * @unknown tom
     */
    @LispMethod(comment = "@return list : denotations predicates to use for the type of denotation\r\nIf DENOT-TYPE is :DENOT, use only #$denotation assertions;\r\nif DENOT-TYPE is :RELATED, use #$denotationRelatedTo as well;\r\nif DENOT-TYPE is :ANY, includes every denotation-type predicate, including #$denotationPlaceholder.\r\n@unknown use a simple table lookup for this\r\n@unknown tom")
    public static final SubLObject determine_denotation_preds_alt(SubLObject denot_type) {
        {
            SubLObject pcase_var = denot_type;
            if (pcase_var.eql($JUST_RELATED)) {
                return $list_alt219;
            } else {
                if (pcase_var.eql($JUST_PLACEHOLDER)) {
                    return $list_alt221;
                } else {
                    if (pcase_var.eql($RELATED)) {
                        return $list_alt222;
                    } else {
                        if (pcase_var.eql($ANY)) {
                            return $list_alt223;
                        } else {
                            return $list_alt224;
                        }
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return list : denotations predicates to use for the type of denotation
    If DENOT-TYPE is :DENOT, use only #$denotation assertions;
    if DENOT-TYPE is :RELATED, use #$denotationRelatedTo as well;
    if DENOT-TYPE is :ANY, includes every denotation-type predicate, including #$denotationPlaceholder.
     * @unknown use a simple table lookup for this
     * @unknown tom
     */
    @LispMethod(comment = "@return list : denotations predicates to use for the type of denotation\r\nIf DENOT-TYPE is :DENOT, use only #$denotation assertions;\r\nif DENOT-TYPE is :RELATED, use #$denotationRelatedTo as well;\r\nif DENOT-TYPE is :ANY, includes every denotation-type predicate, including #$denotationPlaceholder.\r\n@unknown use a simple table lookup for this\r\n@unknown tom")
    public static SubLObject determine_denotation_preds(final SubLObject denot_type) {
        if (denot_type.eql($JUST_RELATED)) {
            return $list228;
        }
        if (denot_type.eql($JUST_PLACEHOLDER)) {
            return $list230;
        }
        if (denot_type.eql($RELATED)) {
            return $list231;
        }
        if (denot_type.eql($ANY)) {
            return $list232;
        }
        return $list233;
    }

    /**
     *
     *
     * @return fort : denotation predicate for the given type @see determine-denotation-preds
     * @unknown tom
     */
    @LispMethod(comment = "@return fort : denotation predicate for the given type @see determine-denotation-preds\r\n@unknown tom")
    public static final SubLObject determine_denotation_pred_alt(SubLObject denot_type) {
        {
            SubLObject pcase_var = denot_type;
            if (pcase_var.eql($DENOT)) {
                return $$denotation;
            } else {
                if (pcase_var.eql($PLACEHOLDER)) {
                    return $$denotationPlaceholder;
                } else {
                    if (pcase_var.eql($RELATED)) {
                        return $$denotationRelatedTo;
                    } else {
                        return NIL;
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return fort : denotation predicate for the given type @see determine-denotation-preds
     * @unknown tom
     */
    @LispMethod(comment = "@return fort : denotation predicate for the given type @see determine-denotation-preds\r\n@unknown tom")
    public static SubLObject determine_denotation_pred(final SubLObject denot_type) {
        if (denot_type.eql($DENOT)) {
            return $$denotation;
        }
        if (denot_type.eql($PLACEHOLDER)) {
            return $$denotationPlaceholder;
        }
        if (denot_type.eql($RELATED)) {
            return $$denotationRelatedTo;
        }
        return NIL;
    }

    /**
     *
     *
     * @return denotation of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return denotation of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static final SubLObject meanings_of_sense_alt(SubLObject denot_type, SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denot_preds = com.cyc.cycjava.cycl.lexicon_accessors.determine_denotation_preds(denot_type);
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject cdolist_list_var = denot_preds;
                            SubLObject denot_pred = NIL;
                            for (denot_pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , denot_pred = cdolist_list_var.first()) {
                                {
                                    SubLObject pred_var = denot_pred;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                {
                                                                    SubLObject done_var_241 = NIL;
                                                                    SubLObject token_var_242 = NIL;
                                                                    while (NIL == done_var_241) {
                                                                        {
                                                                            SubLObject gaf = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_242);
                                                                            SubLObject valid_243 = makeBoolean(token_var_242 != gaf);
                                                                            if (NIL != valid_243) {
                                                                                if ((assertions_high.gaf_arg2(gaf) == pos) && (assertions_high.gaf_arg3(gaf) == v_int)) {
                                                                                    {
                                                                                        SubLObject item_var = assertions_high.gaf_arg4(gaf);
                                                                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                            ans = cons(item_var, ans);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            done_var_241 = makeBoolean(NIL == valid_243);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_244 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_244, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return denotation of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return denotation of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static SubLObject meanings_of_sense(final SubLObject denot_type, final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject denot_preds = determine_denotation_preds(denot_type);
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            SubLObject cdolist_list_var = denot_preds;
            SubLObject denot_pred = NIL;
            denot_pred = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                final SubLObject pred_var = denot_pred;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$232 = NIL;
                                final SubLObject token_var_$233 = NIL;
                                while (NIL == done_var_$232) {
                                    final SubLObject gaf = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$233);
                                    final SubLObject valid_$234 = makeBoolean(!token_var_$233.eql(gaf));
                                    if (((NIL != valid_$234) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg2(gaf), pos))) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg3(gaf), v_int))) {
                                        final SubLObject item_var = assertions_high.gaf_arg4(gaf);
                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var, ans);
                                        }
                                    }
                                    done_var_$232 = makeBoolean(NIL == valid_$234);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$235 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$235, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
                cdolist_list_var = cdolist_list_var.rest();
                denot_pred = cdolist_list_var.first();
            } 
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @return BOOLEANP; Is MEANING a denotation of word sense INT of part of speech POS on WORD-UNIT?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEANP; Is MEANING a denotation of word sense INT of part of speech POS on WORD-UNIT?\r\n@unknown baxter")
    public static final SubLObject meaning_has_senseP_alt(SubLObject meaning, SubLObject denot_type, SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denot_preds = com.cyc.cycjava.cycl.lexicon_accessors.determine_denotation_preds(denot_type);
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        if (NIL == ans) {
                            {
                                SubLObject csome_list_var = denot_preds;
                                SubLObject denot_pred = NIL;
                                for (denot_pred = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , denot_pred = csome_list_var.first()) {
                                    {
                                        SubLObject pred_var = denot_pred;
                                        if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                            {
                                                SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                                SubLObject done_var = ans;
                                                SubLObject token_var = NIL;
                                                while (NIL == done_var) {
                                                    {
                                                        SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                        SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                        if (NIL != valid) {
                                                            {
                                                                SubLObject final_index_iterator = NIL;
                                                                try {
                                                                    final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                    {
                                                                        SubLObject done_var_245 = ans;
                                                                        SubLObject token_var_246 = NIL;
                                                                        while (NIL == done_var_245) {
                                                                            {
                                                                                SubLObject gaf = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_246);
                                                                                SubLObject valid_247 = makeBoolean(token_var_246 != gaf);
                                                                                if (NIL != valid_247) {
                                                                                    if (((assertions_high.gaf_arg2(gaf) == pos) && (assertions_high.gaf_arg3(gaf) == v_int)) && assertions_high.gaf_arg4(gaf).equal(meaning)) {
                                                                                        ans = T;
                                                                                    }
                                                                                }
                                                                                done_var_245 = makeBoolean((NIL == valid_247) || (NIL != ans));
                                                                            }
                                                                        } 
                                                                    }
                                                                } finally {
                                                                    {
                                                                        SubLObject _prev_bind_0_248 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                        try {
                                                                            $is_thread_performing_cleanupP$.bind(T, thread);
                                                                            if (NIL != final_index_iterator) {
                                                                                kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                            }
                                                                        } finally {
                                                                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_248, thread);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        done_var = makeBoolean((NIL == valid) || (NIL != ans));
                                                    }
                                                } 
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEANP; Is MEANING a denotation of word sense INT of part of speech POS on WORD-UNIT?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEANP; Is MEANING a denotation of word sense INT of part of speech POS on WORD-UNIT?\r\n@unknown baxter")
    public static SubLObject meaning_has_senseP(final SubLObject meaning, final SubLObject denot_type, final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject denot_preds = determine_denotation_preds(denot_type);
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            if (NIL == ans) {
                SubLObject csome_list_var = denot_preds;
                SubLObject denot_pred = NIL;
                denot_pred = csome_list_var.first();
                while ((NIL == ans) && (NIL != csome_list_var)) {
                    final SubLObject pred_var = denot_pred;
                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                        final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                        SubLObject done_var = ans;
                        final SubLObject token_var = NIL;
                        while (NIL == done_var) {
                            final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                            final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                            if (NIL != valid) {
                                SubLObject final_index_iterator = NIL;
                                try {
                                    final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                    SubLObject done_var_$236 = ans;
                                    final SubLObject token_var_$237 = NIL;
                                    while (NIL == done_var_$236) {
                                        final SubLObject gaf = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$237);
                                        final SubLObject valid_$238 = makeBoolean(!token_var_$237.eql(gaf));
                                        if ((((NIL != valid_$238) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg2(gaf), pos))) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg3(gaf), v_int))) && assertions_high.gaf_arg4(gaf).equal(meaning)) {
                                            ans = T;
                                        }
                                        done_var_$236 = makeBoolean((NIL == valid_$238) || (NIL != ans));
                                    } 
                                } finally {
                                    final SubLObject _prev_bind_0_$239 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                    try {
                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                        final SubLObject _values = getValuesAsVector();
                                        if (NIL != final_index_iterator) {
                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                        }
                                        restoreValuesFromVector(_values);
                                    } finally {
                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$239, thread);
                                    }
                                }
                            }
                            done_var = makeBoolean((NIL == valid) || (NIL != ans));
                        } 
                    }
                    csome_list_var = csome_list_var.rest();
                    denot_pred = csome_list_var.first();
                } 
            }
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @return BOOLEANP; Is DENOT one of #$denotation's of word sense INT of part of speech POS on WORD-UNIT?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEANP; Is DENOT one of #$denotation\'s of word sense INT of part of speech POS on WORD-UNIT?\r\n@unknown baxter")
    public static final SubLObject denot_has_senseP_alt(SubLObject denot, SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.meaning_has_senseP(denot, $DENOT, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return BOOLEANP; Is DENOT one of #$denotation's of word sense INT of part of speech POS on WORD-UNIT?
     * @unknown baxter
     */
    @LispMethod(comment = "@return BOOLEANP; Is DENOT one of #$denotation\'s of word sense INT of part of speech POS on WORD-UNIT?\r\n@unknown baxter")
    public static SubLObject denot_has_senseP(final SubLObject denot, final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return meaning_has_senseP(denot, $DENOT, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotation's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotation\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static final SubLObject denots_of_sense_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.meanings_of_sense($DENOT, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotation's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotation\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static SubLObject denots_of_sense(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return meanings_of_sense($DENOT, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotation's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotation\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static final SubLObject proper_denots_of_sense_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.denots_of_sense(word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotation's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotation\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static SubLObject proper_denots_of_sense(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return denots_of_sense(word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotationRelatedTo's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotationRelatedTo\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static final SubLObject related_denots_of_sense_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.meanings_of_sense($JUST_RELATED, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotationRelatedTo's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotationRelatedTo\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static SubLObject related_denots_of_sense(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return meanings_of_sense($JUST_RELATED, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotationPlaceholder's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotationPlaceholder\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static final SubLObject placeholder_denots_of_sense_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.meanings_of_sense($JUST_PLACEHOLDER, word_unit, pos, v_int, mt);
    }

    /**
     *
     *
     * @return #$denotationPlaceholder's of word sense INT of part of speech POS on WORD-UNIT.
     * @unknown tom
     */
    @LispMethod(comment = "@return #$denotationPlaceholder\'s of word sense INT of part of speech POS on WORD-UNIT.\r\n@unknown tom")
    public static SubLObject placeholder_denots_of_sense(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return meanings_of_sense($JUST_PLACEHOLDER, word_unit, pos, v_int, mt);
    }

    /**
     * Given WORD-UNIT, POS, and sense number INT, return denotations by mt.
     */
    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, return denotations by mt.")
    public static final SubLObject denots_of_sense_by_mt_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject denot_type) {
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denot_preds = com.cyc.cycjava.cycl.lexicon_accessors.determine_denotation_preds(denot_type);
                SubLObject ans = NIL;
                SubLObject cdolist_list_var = denot_preds;
                SubLObject denot_pred = NIL;
                for (denot_pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , denot_pred = cdolist_list_var.first()) {
                    {
                        SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                        SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                        try {
                            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                            {
                                SubLObject pred_var = denot_pred;
                                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                    {
                                        SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                        SubLObject done_var = NIL;
                                        SubLObject token_var = NIL;
                                        while (NIL == done_var) {
                                            {
                                                SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                if (NIL != valid) {
                                                    {
                                                        SubLObject final_index_iterator = NIL;
                                                        try {
                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                            {
                                                                SubLObject done_var_249 = NIL;
                                                                SubLObject token_var_250 = NIL;
                                                                while (NIL == done_var_249) {
                                                                    {
                                                                        SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_250);
                                                                        SubLObject valid_251 = makeBoolean(token_var_250 != as);
                                                                        if (NIL != valid_251) {
                                                                            if ((assertions_high.gaf_arg2(as) == pos) && (assertions_high.gaf_arg3(as) == v_int)) {
                                                                                {
                                                                                    SubLObject item_var = cons(assertions_high.gaf_arg4(as), assertions_high.assertion_mt(as));
                                                                                    if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                        ans = cons(item_var, ans);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        done_var_249 = makeBoolean(NIL == valid_251);
                                                                    }
                                                                } 
                                                            }
                                                        } finally {
                                                            {
                                                                SubLObject _prev_bind_0_252 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                try {
                                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                                    if (NIL != final_index_iterator) {
                                                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                    }
                                                                } finally {
                                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_252, thread);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                done_var = makeBoolean(NIL == valid);
                                            }
                                        } 
                                    }
                                }
                            }
                        } finally {
                            mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                        }
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, return denotations by mt.")
    public static SubLObject denots_of_sense_by_mt(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject denot_type) {
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject denot_preds = determine_denotation_preds(denot_type);
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = denot_preds;
        SubLObject denot_pred = NIL;
        denot_pred = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
            try {
                mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                final SubLObject pred_var = denot_pred;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$240 = NIL;
                                final SubLObject token_var_$241 = NIL;
                                while (NIL == done_var_$240) {
                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$241);
                                    final SubLObject valid_$242 = makeBoolean(!token_var_$241.eql(as));
                                    if (((NIL != valid_$242) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg2(as), pos))) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg3(as), v_int))) {
                                        final SubLObject item_var = cons(assertions_high.gaf_arg4(as), assertions_high.assertion_mt(as));
                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var, ans);
                                        }
                                    }
                                    done_var_$240 = makeBoolean(NIL == valid_$242);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$243 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$243, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
            } finally {
                mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
            }
            cdolist_list_var = cdolist_list_var.rest();
            denot_pred = cdolist_list_var.first();
        } 
        return ans;
    }/**
     * Given WORD-UNIT, POS, and sense number INT, return denotations by mt.
     */


    /**
     *
     *
     * @return List of sense numbers for WORD and POS, optionally restricted to assertions from any microtheory visible from MT, by checking denotation and semantic translation assertions for the pair.
     * @unknown tom
     */
    @LispMethod(comment = "@return List of sense numbers for WORD and POS, optionally restricted to assertions from any microtheory visible from MT, by checking denotation and semantic translation assertions for the pair.\r\n@unknown tom")
    public static final SubLObject senses_of_wuXpos_alt(SubLObject word_unit, SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                        mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                        {
                            SubLObject cdolist_list_var = cons($$subcatFrame, com.cyc.cycjava.cycl.lexicon_accessors.determine_denotation_preds($ANY));
                            SubLObject predicate = NIL;
                            for (predicate = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , predicate = cdolist_list_var.first()) {
                                {
                                    SubLObject pred_var = predicate;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                {
                                                                    SubLObject done_var_253 = NIL;
                                                                    SubLObject token_var_254 = NIL;
                                                                    while (NIL == done_var_253) {
                                                                        {
                                                                            SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_254);
                                                                            SubLObject valid_255 = makeBoolean(token_var_254 != as);
                                                                            if (NIL != valid_255) {
                                                                                if (!((NIL != mt) && (NIL == com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, assertions_high.assertion_mt(as))))) {
                                                                                    if (assertions_high.gaf_arg2(as) == pos) {
                                                                                        {
                                                                                            SubLObject item_var = assertions_high.gaf_arg3(as);
                                                                                            if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                                ans = cons(item_var, ans);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            done_var_253 = makeBoolean(NIL == valid_255);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_256 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_256, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                            }
                            {
                                SubLObject semtrans_pred = com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred(pos, UNPROVIDED);
                                if (NIL != semtrans_pred) {
                                    {
                                        SubLObject pred_var = semtrans_pred;
                                        if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                            {
                                                SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                                SubLObject done_var = NIL;
                                                SubLObject token_var = NIL;
                                                while (NIL == done_var) {
                                                    {
                                                        SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                        SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                        if (NIL != valid) {
                                                            {
                                                                SubLObject final_index_iterator = NIL;
                                                                try {
                                                                    final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                    {
                                                                        SubLObject done_var_257 = NIL;
                                                                        SubLObject token_var_258 = NIL;
                                                                        while (NIL == done_var_257) {
                                                                            {
                                                                                SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_258);
                                                                                SubLObject valid_259 = makeBoolean(token_var_258 != as);
                                                                                if (NIL != valid_259) {
                                                                                    if (!((NIL != mt) && (NIL == com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, assertions_high.assertion_mt(as))))) {
                                                                                        {
                                                                                            SubLObject item_var = assertions_high.gaf_arg2(as);
                                                                                            if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                                ans = cons(item_var, ans);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                done_var_257 = makeBoolean(NIL == valid_259);
                                                                            }
                                                                        } 
                                                                    }
                                                                } finally {
                                                                    {
                                                                        SubLObject _prev_bind_0_260 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                        try {
                                                                            $is_thread_performing_cleanupP$.bind(T, thread);
                                                                            if (NIL != final_index_iterator) {
                                                                                kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                            }
                                                                        } finally {
                                                                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_260, thread);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        done_var = makeBoolean(NIL == valid);
                                                    }
                                                } 
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return Sort.sort(ans, $sym230$_, UNPROVIDED);
            }
        }
    }

    /**
     *
     *
     * @return List of sense numbers for WORD and POS, optionally restricted to assertions from any microtheory visible from MT, by checking denotation and semantic translation assertions for the pair.
     * @unknown tom
     */
    @LispMethod(comment = "@return List of sense numbers for WORD and POS, optionally restricted to assertions from any microtheory visible from MT, by checking denotation and semantic translation assertions for the pair.\r\n@unknown tom")
    public static SubLObject senses_of_wuXpos(final SubLObject word_unit, final SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            SubLObject cdolist_list_var = cons($$subcatFrame, determine_denotation_preds($ANY));
            SubLObject predicate = NIL;
            predicate = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                final SubLObject pred_var = predicate;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$244 = NIL;
                                final SubLObject token_var_$245 = NIL;
                                while (NIL == done_var_$244) {
                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$245);
                                    final SubLObject valid_$246 = makeBoolean(!token_var_$245.eql(as));
                                    if (((NIL != valid_$246) && ((NIL == mt) || (NIL != genl_lexicon_mtP(mt, assertions_high.assertion_mt(as))))) && (NIL != kb_utilities.kbeq(assertions_high.gaf_arg2(as), pos))) {
                                        final SubLObject item_var = assertions_high.gaf_arg3(as);
                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var, ans);
                                        }
                                    }
                                    done_var_$244 = makeBoolean(NIL == valid_$246);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$247 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$247, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
                cdolist_list_var = cdolist_list_var.rest();
                predicate = cdolist_list_var.first();
            } 
            final SubLObject semtrans_pred = pos_to_semtrans_pred(pos, UNPROVIDED);
            if (NIL != semtrans_pred) {
                final SubLObject pred_var2 = semtrans_pred;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var2)) {
                    final SubLObject iterator_var2 = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var2);
                    SubLObject done_var2 = NIL;
                    final SubLObject token_var2 = NIL;
                    while (NIL == done_var2) {
                        final SubLObject final_index_spec2 = iteration.iteration_next_without_values_macro_helper(iterator_var2, token_var2);
                        final SubLObject valid2 = makeBoolean(!token_var2.eql(final_index_spec2));
                        if (NIL != valid2) {
                            SubLObject final_index_iterator2 = NIL;
                            try {
                                final_index_iterator2 = kb_mapping_macros.new_final_index_iterator(final_index_spec2, $GAF, $TRUE, NIL);
                                SubLObject done_var_$245 = NIL;
                                final SubLObject token_var_$246 = NIL;
                                while (NIL == done_var_$245) {
                                    final SubLObject as2 = iteration.iteration_next_without_values_macro_helper(final_index_iterator2, token_var_$246);
                                    final SubLObject valid_$247 = makeBoolean(!token_var_$246.eql(as2));
                                    if ((NIL != valid_$247) && ((NIL == mt) || (NIL != genl_lexicon_mtP(mt, assertions_high.assertion_mt(as2))))) {
                                        final SubLObject item_var2 = assertions_high.gaf_arg2(as2);
                                        if (NIL == member(item_var2, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var2, ans);
                                        }
                                    }
                                    done_var_$245 = makeBoolean(NIL == valid_$247);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$248 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values2 = getValuesAsVector();
                                    if (NIL != final_index_iterator2) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator2);
                                    }
                                    restoreValuesFromVector(_values2);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$248, thread);
                                }
                            }
                        }
                        done_var2 = makeBoolean(NIL == valid2);
                    } 
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return Sort.sort(ans, $sym239$_, UNPROVIDED);
    }

    /**
     *
     *
     * @return INTEGERP or NIL, the number of dependents for FRAME, if known.
     * @unknown baxter
     */
    @LispMethod(comment = "@return INTEGERP or NIL, the number of dependents for FRAME, if known.\r\n@unknown baxter")
    public static final SubLObject subcat_frame_arity_alt(SubLObject frame) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(frame, FORT_P);
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = kb_mapping_utilities.fpred_value(frame, $$subcatFrameArity, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return INTEGERP or NIL, the number of dependents for FRAME, if known.
     * @unknown baxter
     */
    @LispMethod(comment = "@return INTEGERP or NIL, the number of dependents for FRAME, if known.\r\n@unknown baxter")
    public static SubLObject subcat_frame_arity(final SubLObject frame) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != forts.fort_p(frame) : "! forts.fort_p(frame) " + ("forts.fort_p(frame) " + "CommonSymbols.NIL != forts.fort_p(frame) ") + frame;
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = kb_mapping_utilities.fpred_value(frame, $$subcatFrameArity, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     * Return all subcat frames on WORD-UNIT.
     */
    @LispMethod(comment = "Return all subcat frames on WORD-UNIT.")
    public static final SubLObject frames_of_word_alt(SubLObject word_unit) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, FORT_P);
            {
                SubLObject ans = NIL;
                if (NIL != kb_mapping_utilities.some_pred_value_in_any_mt(word_unit, $$subcatFrame, UNPROVIDED, UNPROVIDED)) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                ans = kb_mapping_utilities.pred_values(word_unit, $$subcatFrame, ONE_INTEGER, FOUR_INTEGER, UNPROVIDED);
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Return all subcat frames on WORD-UNIT.")
    public static SubLObject frames_of_word(final SubLObject word_unit) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        SubLObject ans = NIL;
        if (NIL != kb_mapping_utilities.some_pred_value_in_any_mt(word_unit, $$subcatFrame, UNPROVIDED, UNPROVIDED)) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                ans = kb_mapping_utilities.pred_values(word_unit, $$subcatFrame, ONE_INTEGER, FOUR_INTEGER, UNPROVIDED);
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        }
        return ans;
    }/**
     * Return all subcat frames on WORD-UNIT.
     */


    /**
     * Return all subcat frames for part of speech POS on WORD-UNIT.
     */
    @LispMethod(comment = "Return all subcat frames for part of speech POS on WORD-UNIT.")
    public static final SubLObject frames_of_wordXpos_alt(SubLObject word_unit, SubLObject pos) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, FORT_P);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            {
                SubLObject ans = NIL;
                if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.frames_of_word(word_unit)) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                {
                                    SubLObject pred_var = $$subcatFrame;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                {
                                                                    SubLObject done_var_261 = NIL;
                                                                    SubLObject token_var_262 = NIL;
                                                                    while (NIL == done_var_261) {
                                                                        {
                                                                            SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_262);
                                                                            SubLObject valid_263 = makeBoolean(token_var_262 != as);
                                                                            if (NIL != valid_263) {
                                                                                if (assertions_high.gaf_arg2(as).equal(pos)) {
                                                                                    {
                                                                                        SubLObject item_var = assertions_high.gaf_arg4(as);
                                                                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                            ans = cons(item_var, ans);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            done_var_261 = makeBoolean(NIL == valid_263);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_264 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_264, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                                {
                                    SubLObject semtrans_pred = com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred(pos, UNPROVIDED);
                                    if (NIL != semtrans_pred) {
                                        {
                                            SubLObject pred_var = semtrans_pred;
                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                                                {
                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                                                    SubLObject done_var = NIL;
                                                    SubLObject token_var = NIL;
                                                    while (NIL == done_var) {
                                                        {
                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                            if (NIL != valid) {
                                                                {
                                                                    SubLObject final_index_iterator = NIL;
                                                                    try {
                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                        {
                                                                            SubLObject done_var_265 = NIL;
                                                                            SubLObject token_var_266 = NIL;
                                                                            while (NIL == done_var_265) {
                                                                                {
                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_266);
                                                                                    SubLObject valid_267 = makeBoolean(token_var_266 != as);
                                                                                    if (NIL != valid_267) {
                                                                                        {
                                                                                            SubLObject item_var = assertions_high.gaf_arg3(as);
                                                                                            if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                                ans = cons(item_var, ans);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    done_var_265 = makeBoolean(NIL == valid_267);
                                                                                }
                                                                            } 
                                                                        }
                                                                    } finally {
                                                                        {
                                                                            SubLObject _prev_bind_0_268 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                            try {
                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                if (NIL != final_index_iterator) {
                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                }
                                                                            } finally {
                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_268, thread);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            done_var = makeBoolean(NIL == valid);
                                                        }
                                                    } 
                                                }
                                            }
                                        }
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Return all subcat frames for part of speech POS on WORD-UNIT.")
    public static SubLObject frames_of_wordXpos(final SubLObject word_unit, final SubLObject pos) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        SubLObject ans = NIL;
        if (NIL != frames_of_word(word_unit)) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                final SubLObject pred_var = $$subcatFrame;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$252 = NIL;
                                final SubLObject token_var_$253 = NIL;
                                while (NIL == done_var_$252) {
                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$253);
                                    final SubLObject valid_$254 = makeBoolean(!token_var_$253.eql(as));
                                    if ((NIL != valid_$254) && assertions_high.gaf_arg2(as).equal(pos)) {
                                        final SubLObject item_var = assertions_high.gaf_arg4(as);
                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var, ans);
                                        }
                                    }
                                    done_var_$252 = makeBoolean(NIL == valid_$254);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$255 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$255, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
                final SubLObject semtrans_pred = pos_to_semtrans_pred(pos, UNPROVIDED);
                if (NIL != semtrans_pred) {
                    final SubLObject pred_var2 = semtrans_pred;
                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var2)) {
                        final SubLObject iterator_var2 = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var2);
                        SubLObject done_var2 = NIL;
                        final SubLObject token_var2 = NIL;
                        while (NIL == done_var2) {
                            final SubLObject final_index_spec2 = iteration.iteration_next_without_values_macro_helper(iterator_var2, token_var2);
                            final SubLObject valid2 = makeBoolean(!token_var2.eql(final_index_spec2));
                            if (NIL != valid2) {
                                SubLObject final_index_iterator2 = NIL;
                                try {
                                    final_index_iterator2 = kb_mapping_macros.new_final_index_iterator(final_index_spec2, $GAF, $TRUE, NIL);
                                    SubLObject done_var_$253 = NIL;
                                    final SubLObject token_var_$254 = NIL;
                                    while (NIL == done_var_$253) {
                                        final SubLObject as2 = iteration.iteration_next_without_values_macro_helper(final_index_iterator2, token_var_$254);
                                        final SubLObject valid_$255 = makeBoolean(!token_var_$254.eql(as2));
                                        if (NIL != valid_$255) {
                                            final SubLObject item_var2 = assertions_high.gaf_arg3(as2);
                                            if (NIL == member(item_var2, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                ans = cons(item_var2, ans);
                                            }
                                        }
                                        done_var_$253 = makeBoolean(NIL == valid_$255);
                                    } 
                                } finally {
                                    final SubLObject _prev_bind_0_$256 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                    try {
                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                        final SubLObject _values2 = getValuesAsVector();
                                        if (NIL != final_index_iterator2) {
                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator2);
                                        }
                                        restoreValuesFromVector(_values2);
                                    } finally {
                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$256, thread);
                                    }
                                }
                            }
                            done_var2 = makeBoolean(NIL == valid2);
                        } 
                    }
                }
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        }
        return ans;
    }/**
     * Return all subcat frames for part of speech POS on WORD-UNIT.
     */


    /**
     * Return all subcat frames for part of speech POS on WORD-UNIT when it denotes DENOT.
     */
    @LispMethod(comment = "Return all subcat frames for part of speech POS on WORD-UNIT when it denotes DENOT.")
    public static final SubLObject frames_of_word_posXdenot_alt(SubLObject word_unit, SubLObject pos, SubLObject denot) {
        SubLTrampolineFile.checkType(word_unit, FORT_P);
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        {
            SubLObject ans = NIL;
            if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.frames_of_word(word_unit)) {
                {
                    SubLObject cdolist_list_var = com.cyc.cycjava.cycl.lexicon_accessors.senses_of_wuXpos(word_unit, pos, UNPROVIDED);
                    SubLObject sense = NIL;
                    for (sense = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , sense = cdolist_list_var.first()) {
                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.denot_has_senseP(denot, word_unit, pos, sense, UNPROVIDED)) {
                            {
                                SubLObject cdolist_list_var_269 = com.cyc.cycjava.cycl.lexicon_accessors.frames_of_sense(word_unit, pos, sense, UNPROVIDED);
                                SubLObject frame = NIL;
                                for (frame = cdolist_list_var_269.first(); NIL != cdolist_list_var_269; cdolist_list_var_269 = cdolist_list_var_269.rest() , frame = cdolist_list_var_269.first()) {
                                    {
                                        SubLObject item_var = frame;
                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var, ans);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return ans;
        }
    }

    @LispMethod(comment = "Return all subcat frames for part of speech POS on WORD-UNIT when it denotes DENOT.")
    public static SubLObject frames_of_word_posXdenot(final SubLObject word_unit, final SubLObject pos, final SubLObject denot) {
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        SubLObject ans = NIL;
        if (NIL != frames_of_word(word_unit)) {
            SubLObject cdolist_list_var = senses_of_wuXpos(word_unit, pos, UNPROVIDED);
            SubLObject sense = NIL;
            sense = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != denot_has_senseP(denot, word_unit, pos, sense, UNPROVIDED)) {
                    SubLObject cdolist_list_var_$260 = frames_of_sense(word_unit, pos, sense, UNPROVIDED);
                    SubLObject frame = NIL;
                    frame = cdolist_list_var_$260.first();
                    while (NIL != cdolist_list_var_$260) {
                        final SubLObject item_var = frame;
                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                            ans = cons(item_var, ans);
                        }
                        cdolist_list_var_$260 = cdolist_list_var_$260.rest();
                        frame = cdolist_list_var_$260.first();
                    } 
                }
                cdolist_list_var = cdolist_list_var.rest();
                sense = cdolist_list_var.first();
            } 
        }
        return ans;
    }/**
     * Return all subcat frames for part of speech POS on WORD-UNIT when it denotes DENOT.
     */


    /**
     * Given WORD-UNIT, POS, and sense number INT, return the subcat frames.
     */
    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, return the subcat frames.")
    public static final SubLObject frames_of_sense_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, FORT_P);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject pred_var = $$subcatFrame;
                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                                {
                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                                    SubLObject done_var = NIL;
                                    SubLObject token_var = NIL;
                                    while (NIL == done_var) {
                                        {
                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                            if (NIL != valid) {
                                                {
                                                    SubLObject final_index_iterator = NIL;
                                                    try {
                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                        {
                                                            SubLObject done_var_270 = NIL;
                                                            SubLObject token_var_271 = NIL;
                                                            while (NIL == done_var_270) {
                                                                {
                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_271);
                                                                    SubLObject valid_272 = makeBoolean(token_var_271 != as);
                                                                    if (NIL != valid_272) {
                                                                        if (assertions_high.gaf_arg2(as).equal(pos) && assertions_high.gaf_arg3(as).equal(v_int)) {
                                                                            {
                                                                                SubLObject item_var = assertions_high.gaf_arg4(as);
                                                                                if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                    ans = cons(item_var, ans);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    done_var_270 = makeBoolean(NIL == valid_272);
                                                                }
                                                            } 
                                                        }
                                                    } finally {
                                                        {
                                                            SubLObject _prev_bind_0_273 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_273, thread);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            done_var = makeBoolean(NIL == valid);
                                        }
                                    } 
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, return the subcat frames.")
    public static SubLObject frames_of_sense(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            final SubLObject pred_var = $$subcatFrame;
            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                SubLObject done_var = NIL;
                final SubLObject token_var = NIL;
                while (NIL == done_var) {
                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                    if (NIL != valid) {
                        SubLObject final_index_iterator = NIL;
                        try {
                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                            SubLObject done_var_$261 = NIL;
                            final SubLObject token_var_$262 = NIL;
                            while (NIL == done_var_$261) {
                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$262);
                                final SubLObject valid_$263 = makeBoolean(!token_var_$262.eql(as));
                                if (((NIL != valid_$263) && assertions_high.gaf_arg2(as).equal(pos)) && assertions_high.gaf_arg3(as).equal(v_int)) {
                                    final SubLObject item_var = assertions_high.gaf_arg4(as);
                                    if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                        ans = cons(item_var, ans);
                                    }
                                }
                                done_var_$261 = makeBoolean(NIL == valid_$263);
                            } 
                        } finally {
                            final SubLObject _prev_bind_0_$264 = $is_thread_performing_cleanupP$.currentBinding(thread);
                            try {
                                $is_thread_performing_cleanupP$.bind(T, thread);
                                final SubLObject _values = getValuesAsVector();
                                if (NIL != final_index_iterator) {
                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                }
                                restoreValuesFromVector(_values);
                            } finally {
                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$264, thread);
                            }
                        }
                    }
                    done_var = makeBoolean(NIL == valid);
                } 
            }
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }/**
     * Given WORD-UNIT, POS, and sense number INT, return the subcat frames.
     */


    /**
     * Given WORD-UNIT, POS, and sense number INT, return the subcat frames by mt.
     */
    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, return the subcat frames by mt.")
    public static final SubLObject frames_of_sense_by_mt_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject pred_var = $$subcatFrame;
                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                                {
                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                                    SubLObject done_var = NIL;
                                    SubLObject token_var = NIL;
                                    while (NIL == done_var) {
                                        {
                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                            if (NIL != valid) {
                                                {
                                                    SubLObject final_index_iterator = NIL;
                                                    try {
                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                        {
                                                            SubLObject done_var_274 = NIL;
                                                            SubLObject token_var_275 = NIL;
                                                            while (NIL == done_var_274) {
                                                                {
                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_275);
                                                                    SubLObject valid_276 = makeBoolean(token_var_275 != as);
                                                                    if (NIL != valid_276) {
                                                                        if (assertions_high.gaf_arg2(as).equal(pos) && assertions_high.gaf_arg3(as).equal(v_int)) {
                                                                            {
                                                                                SubLObject item_var = cons(assertions_high.gaf_arg4(as), assertions_high.assertion_mt(as));
                                                                                if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                    ans = cons(item_var, ans);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    done_var_274 = makeBoolean(NIL == valid_276);
                                                                }
                                                            } 
                                                        }
                                                    } finally {
                                                        {
                                                            SubLObject _prev_bind_0_277 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_277, thread);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            done_var = makeBoolean(NIL == valid);
                                        }
                                    } 
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, return the subcat frames by mt.")
    public static SubLObject frames_of_sense_by_mt(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            final SubLObject pred_var = $$subcatFrame;
            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, ONE_INTEGER, pred_var)) {
                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, ONE_INTEGER, pred_var);
                SubLObject done_var = NIL;
                final SubLObject token_var = NIL;
                while (NIL == done_var) {
                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                    if (NIL != valid) {
                        SubLObject final_index_iterator = NIL;
                        try {
                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                            SubLObject done_var_$265 = NIL;
                            final SubLObject token_var_$266 = NIL;
                            while (NIL == done_var_$265) {
                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$266);
                                final SubLObject valid_$267 = makeBoolean(!token_var_$266.eql(as));
                                if (((NIL != valid_$267) && assertions_high.gaf_arg2(as).equal(pos)) && assertions_high.gaf_arg3(as).equal(v_int)) {
                                    final SubLObject item_var = cons(assertions_high.gaf_arg4(as), assertions_high.assertion_mt(as));
                                    if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                        ans = cons(item_var, ans);
                                    }
                                }
                                done_var_$265 = makeBoolean(NIL == valid_$267);
                            } 
                        } finally {
                            final SubLObject _prev_bind_0_$268 = $is_thread_performing_cleanupP$.currentBinding(thread);
                            try {
                                $is_thread_performing_cleanupP$.bind(T, thread);
                                final SubLObject _values = getValuesAsVector();
                                if (NIL != final_index_iterator) {
                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                }
                                restoreValuesFromVector(_values);
                            } finally {
                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$268, thread);
                            }
                        }
                    }
                    done_var = makeBoolean(NIL == valid);
                } 
            }
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }/**
     * Given WORD-UNIT, POS, and sense number INT, return the subcat frames by mt.
     */


    public static final SubLObject politeness_of_ws_pred_alt() {
        return $$politenessOfWS;
    }

    public static SubLObject politeness_of_ws_pred() {
        return $$politenessOfWS;
    }

    public static final SubLObject formality_of_ws_pred_alt() {
        return $$formalityOfWS;
    }

    public static SubLObject formality_of_ws_pred() {
        return $$formalityOfWS;
    }

    /**
     *
     *
     * @return LISTP of politeness levels.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of politeness levels.\r\n@unknown baxter")
    public static final SubLObject politeness_levels_of_assertion_alt(SubLObject assertion, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = assertions_high.assertion_mt(assertion);
        }
        return NIL != assertion_utilities.assertion_has_meta_assertionsP(assertion) ? ((SubLObject) (backward.removal_ask_variable($sym235$_LEVEL, listS(com.cyc.cycjava.cycl.lexicon_accessors.politeness_of_ws_pred(), assertion, $list_alt236), mt, UNPROVIDED, UNPROVIDED))) : NIL;
    }

    /**
     *
     *
     * @return LISTP of politeness levels.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of politeness levels.\r\n@unknown baxter")
    public static SubLObject politeness_levels_of_assertion(final SubLObject assertion, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = assertions_high.assertion_mt(assertion);
        }
        return NIL != assertion_utilities.assertion_has_meta_assertionsP(assertion) ? backward.removal_ask_variable($sym244$_LEVEL, listS(politeness_of_ws_pred(), assertion, $list245), mt, UNPROVIDED, UNPROVIDED) : NIL;
    }

    /**
     *
     *
     * @return LISTP of formality levels.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of formality levels.\r\n@unknown baxter")
    public static final SubLObject formality_levels_of_assertion_alt(SubLObject assertion, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = assertions_high.assertion_mt(assertion);
        }
        return NIL != assertion_utilities.assertion_has_meta_assertionsP(assertion) ? ((SubLObject) (backward.removal_ask_variable($sym235$_LEVEL, listS(com.cyc.cycjava.cycl.lexicon_accessors.formality_of_ws_pred(), assertion, $list_alt236), mt, UNPROVIDED, UNPROVIDED))) : NIL;
    }

    /**
     *
     *
     * @return LISTP of formality levels.
     * @unknown baxter
     */
    @LispMethod(comment = "@return LISTP of formality levels.\r\n@unknown baxter")
    public static SubLObject formality_levels_of_assertion(final SubLObject assertion, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = assertions_high.assertion_mt(assertion);
        }
        return NIL != assertion_utilities.assertion_has_meta_assertionsP(assertion) ? backward.removal_ask_variable($sym244$_LEVEL, listS(formality_of_ws_pred(), assertion, $list245), mt, UNPROVIDED, UNPROVIDED) : NIL;
    }

    /**
     *
     *
     * @return boolean ; T iff politness LEVEL is one of those considered generally offensive (e.g, RudeSpeech or VulgarSpeech)
     * @unknown tom
     */
    @LispMethod(comment = "@return boolean ; T iff politness LEVEL is one of those considered generally offensive (e.g, RudeSpeech or VulgarSpeech)\r\n@unknown tom")
    public static final SubLObject potentially_offensive_politeness_levelP_alt(SubLObject level) {
        return subl_promotions.memberP(level, $list_alt237, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return boolean ; T iff politness LEVEL is one of those considered generally offensive (e.g, RudeSpeech or VulgarSpeech)
     * @unknown tom
     */
    @LispMethod(comment = "@return boolean ; T iff politness LEVEL is one of those considered generally offensive (e.g, RudeSpeech or VulgarSpeech)\r\n@unknown tom")
    public static SubLObject potentially_offensive_politeness_levelP(final SubLObject level) {
        return subl_promotions.memberP(level, $list246, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return boolean ; T iff any of the politeness levels in the list are potentially offensive
     * @unknown tom
     */
    @LispMethod(comment = "@return boolean ; T iff any of the politeness levels in the list are potentially offensive\r\n@unknown tom")
    public static final SubLObject includes_potentially_offensive_politeness_levelP_alt(SubLObject politeness_levels) {
        return list_utilities.sublisp_boolean(find_if($sym238$POTENTIALLY_OFFENSIVE_POLITENESS_LEVEL_, politeness_levels, UNPROVIDED, UNPROVIDED, UNPROVIDED));
    }

    /**
     *
     *
     * @return boolean ; T iff any of the politeness levels in the list are potentially offensive
     * @unknown tom
     */
    @LispMethod(comment = "@return boolean ; T iff any of the politeness levels in the list are potentially offensive\r\n@unknown tom")
    public static SubLObject includes_potentially_offensive_politeness_levelP(final SubLObject politeness_levels) {
        return list_utilities.sublisp_boolean(find_if($sym247$POTENTIALLY_OFFENSIVE_POLITENESS_LEVEL_, politeness_levels, UNPROVIDED, UNPROVIDED, UNPROVIDED));
    }

    /**
     *
     *
     * @return boolean ; T iff assertion has an associated politeness level that is considered as being offensive (e.g., VulgarSpeech)
     * @unknown This is a generalization to @xref rude-lexical-assertion
     * @unknown tom
     */
    @LispMethod(comment = "@return boolean ; T iff assertion has an associated politeness level that is considered as being offensive (e.g., VulgarSpeech)\r\n@unknown This is a generalization to @xref rude-lexical-assertion\r\n@unknown tom")
    public static final SubLObject potentially_offensive_lexical_assertionP_alt(SubLObject assertion) {
        {
            SubLObject politeness_levels = com.cyc.cycjava.cycl.lexicon_accessors.politeness_levels_of_assertion(assertion, UNPROVIDED);
            return com.cyc.cycjava.cycl.lexicon_accessors.includes_potentially_offensive_politeness_levelP(politeness_levels);
        }
    }

    /**
     *
     *
     * @return boolean ; T iff assertion has an associated politeness level that is considered as being offensive (e.g., VulgarSpeech)
     * @unknown This is a generalization to @xref rude-lexical-assertion
     * @unknown tom
     */
    @LispMethod(comment = "@return boolean ; T iff assertion has an associated politeness level that is considered as being offensive (e.g., VulgarSpeech)\r\n@unknown This is a generalization to @xref rude-lexical-assertion\r\n@unknown tom")
    public static SubLObject potentially_offensive_lexical_assertionP(final SubLObject assertion) {
        final SubLObject politeness_levels = politeness_levels_of_assertion(assertion, UNPROVIDED);
        return includes_potentially_offensive_politeness_levelP(politeness_levels);
    }

    /**
     *
     *
     * @return boolean ; T iff ASSERTION is marked as slang.
     * @unknown baxter
     */
    @LispMethod(comment = "@return boolean ; T iff ASSERTION is marked as slang.\r\n@unknown baxter")
    public static final SubLObject slang_lexical_assertionP_alt(SubLObject assertion) {
        return subl_promotions.memberP($$SlangSpeech, com.cyc.cycjava.cycl.lexicon_accessors.formality_levels_of_assertion(assertion, UNPROVIDED), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return boolean ; T iff ASSERTION is marked as slang.
     * @unknown baxter
     */
    @LispMethod(comment = "@return boolean ; T iff ASSERTION is marked as slang.\r\n@unknown baxter")
    public static SubLObject slang_lexical_assertionP(final SubLObject assertion) {
        return subl_promotions.memberP($$SlangSpeech, formality_levels_of_assertion(assertion, UNPROVIDED), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return boolean ; T iff ASSERTION is marked as archaic
     * @unknown baxter
     */
    @LispMethod(comment = "@return boolean ; T iff ASSERTION is marked as archaic\r\n@unknown baxter")
    public static final SubLObject archaic_lexical_assertionP_alt(SubLObject assertion) {
        return subl_promotions.memberP($$ArchaicSpeech, com.cyc.cycjava.cycl.lexicon_accessors.formality_levels_of_assertion(assertion, UNPROVIDED), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return boolean ; T iff ASSERTION is marked as archaic
     * @unknown baxter
     */
    @LispMethod(comment = "@return boolean ; T iff ASSERTION is marked as archaic\r\n@unknown baxter")
    public static SubLObject archaic_lexical_assertionP(final SubLObject assertion) {
        return subl_promotions.memberP($$ArchaicSpeech, formality_levels_of_assertion(assertion, UNPROVIDED), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject clear_indirect_lexical_assertionP() {
        final SubLObject cs = $indirect_lexical_assertionP_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static SubLObject remove_indirect_lexical_assertionP(final SubLObject assertion) {
        return memoization_state.caching_state_remove_function_results_with_args($indirect_lexical_assertionP_caching_state$.getGlobalValue(), list(assertion), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject indirect_lexical_assertionP_internal(final SubLObject assertion) {
        return isa.isaP(cycl_utilities.formula_arg0(assertion), $const251$DenotationPredicate_ExcludedFromN, UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject indirect_lexical_assertionP(final SubLObject assertion) {
        SubLObject caching_state = $indirect_lexical_assertionP_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym250$INDIRECT_LEXICAL_ASSERTION_, $sym252$_INDIRECT_LEXICAL_ASSERTION__CACHING_STATE_, NIL, EQL, ONE_INTEGER, ZERO_INTEGER);
            memoization_state.register_hl_store_cache_clear_callback($sym253$CLEAR_INDIRECT_LEXICAL_ASSERTION_);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, assertion, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(indirect_lexical_assertionP_internal(assertion)));
            memoization_state.caching_state_put(caching_state, assertion, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     *
     *
     * @return boolean ; T iff ASSERTION is inappropriate for current parameters.
     * @unknown baxter
     */
    @LispMethod(comment = "@return boolean ; T iff ASSERTION is inappropriate for current parameters.\r\n@unknown baxter")
    public static final SubLObject inappropriate_lexical_assertionP_alt(SubLObject assertion) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if ((NIL != lexicon_vars.$exclude_vulgaritiesP$.getDynamicValue(thread)) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.potentially_offensive_lexical_assertionP(assertion))) {
                return T;
            } else {
                if ((NIL != lexicon_vars.$exclude_slangP$.getDynamicValue(thread)) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.slang_lexical_assertionP(assertion))) {
                    return T;
                } else {
                    if ((NIL != lexicon_vars.$exclude_archaic_speechP$.getDynamicValue(thread)) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.archaic_lexical_assertionP(assertion))) {
                        return T;
                    } else {
                        return NIL;
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @return boolean ; T iff ASSERTION is inappropriate for current parameters.
     * @unknown baxter
     */
    @LispMethod(comment = "@return boolean ; T iff ASSERTION is inappropriate for current parameters.\r\n@unknown baxter")
    public static SubLObject inappropriate_lexical_assertionP(final SubLObject assertion) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if ((NIL != lexicon_vars.$exclude_vulgaritiesP$.getDynamicValue(thread)) && (NIL != potentially_offensive_lexical_assertionP(assertion))) {
            return T;
        }
        if ((NIL != lexicon_vars.$exclude_slangP$.getDynamicValue(thread)) && (NIL != slang_lexical_assertionP(assertion))) {
            return T;
        }
        if ((NIL != lexicon_vars.$exclude_archaic_speechP$.getDynamicValue(thread)) && (NIL != archaic_lexical_assertionP(assertion))) {
            return T;
        }
        if ((NIL != lexicon_vars.$exclude_indirect_relationsP$.getDynamicValue(thread)) && (NIL != indirect_lexical_assertionP(assertion))) {
            return T;
        }
        return NIL;
    }

    /**
     *
     *
     * @return list ; denotation assertions for SENSE-NUM of WORD used as SPEECH-PART
     */
    @LispMethod(comment = "@return list ; denotation assertions for SENSE-NUM of WORD used as SPEECH-PART")
    public static final SubLObject gather_denotation_assertions_alt(SubLObject word, SubLObject speech_part, SubLObject sense_num) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denot_assertions = NIL;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                        mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                        {
                            SubLObject cdolist_list_var = com.cyc.cycjava.cycl.lexicon_accessors.determine_denotation_preds($ANY);
                            SubLObject pred = NIL;
                            for (pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , pred = cdolist_list_var.first()) {
                                {
                                    SubLObject cdolist_list_var_278 = kb_mapping.gather_gaf_arg_index(word, ONE_INTEGER, pred, UNPROVIDED, UNPROVIDED);
                                    SubLObject assertion = NIL;
                                    for (assertion = cdolist_list_var_278.first(); NIL != cdolist_list_var_278; cdolist_list_var_278 = cdolist_list_var_278.rest() , assertion = cdolist_list_var_278.first()) {
                                        if (((NIL != assertions_high.gaf_assertionP(assertion)) && (com.cyc.cycjava.cycl.lexicon_accessors.assertion_pos(assertion) == speech_part)) && (com.cyc.cycjava.cycl.lexicon_accessors.assertion_sense_num(assertion) == sense_num)) {
                                            denot_assertions = cons(assertion, denot_assertions);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return denot_assertions;
            }
        }
    }

    /**
     *
     *
     * @return list ; denotation assertions for SENSE-NUM of WORD used as SPEECH-PART
     */
    @LispMethod(comment = "@return list ; denotation assertions for SENSE-NUM of WORD used as SPEECH-PART")
    public static SubLObject gather_denotation_assertions(final SubLObject word, final SubLObject speech_part, final SubLObject sense_num) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denot_assertions = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            SubLObject cdolist_list_var = determine_denotation_preds($ANY);
            SubLObject pred = NIL;
            pred = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cdolist_list_var_$269 = kb_mapping.gather_gaf_arg_index(word, ONE_INTEGER, pred, UNPROVIDED, UNPROVIDED);
                SubLObject assertion = NIL;
                assertion = cdolist_list_var_$269.first();
                while (NIL != cdolist_list_var_$269) {
                    if (((NIL != assertions_high.gaf_assertionP(assertion)) && (NIL != kb_utilities.kbeq(assertion_pos(assertion), speech_part))) && (NIL != kb_utilities.kbeq(assertion_sense_num(assertion), sense_num))) {
                        denot_assertions = cons(assertion, denot_assertions);
                    }
                    cdolist_list_var_$269 = cdolist_list_var_$269.rest();
                    assertion = cdolist_list_var_$269.first();
                } 
                cdolist_list_var = cdolist_list_var.rest();
                pred = cdolist_list_var.first();
            } 
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return denot_assertions;
    }

    /**
     *
     *
     * @return boolean ; T iff SENSE of WORD used in SPEECH-PART is potentially offensive (e.g., vulgar)
     */
    @LispMethod(comment = "@return boolean ; T iff SENSE of WORD used in SPEECH-PART is potentially offensive (e.g., vulgar)")
    public static final SubLObject potentially_offensive_senseP_alt(SubLObject word, SubLObject speech_part, SubLObject sense) {
        SubLTrampolineFile.checkType(word, FORT_P);
        SubLTrampolineFile.checkType(speech_part, $sym5$SPEECH_PART_);
        SubLTrampolineFile.checkType(sense, INTEGERP);
        {
            SubLObject offensiveP = NIL;
            if (NIL == offensiveP) {
                {
                    SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.gather_denotation_assertions(word, speech_part, sense);
                    SubLObject assertion = NIL;
                    for (assertion = csome_list_var.first(); !((NIL != offensiveP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , assertion = csome_list_var.first()) {
                        offensiveP = com.cyc.cycjava.cycl.lexicon_accessors.potentially_offensive_lexical_assertionP(assertion);
                    }
                }
            }
            return offensiveP;
        }
    }

    /**
     *
     *
     * @return boolean ; T iff SENSE of WORD used in SPEECH-PART is potentially offensive (e.g., vulgar)
     */
    @LispMethod(comment = "@return boolean ; T iff SENSE of WORD used in SPEECH-PART is potentially offensive (e.g., vulgar)")
    public static SubLObject potentially_offensive_senseP(final SubLObject word, final SubLObject speech_part, final SubLObject sense) {
        assert NIL != forts.fort_p(word) : "! forts.fort_p(word) " + ("forts.fort_p(word) " + "CommonSymbols.NIL != forts.fort_p(word) ") + word;
        assert NIL != speech_partP(speech_part, UNPROVIDED) : "! lexicon_accessors.speech_partP(speech_part, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(speech_part, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(speech_part, CommonSymbols.UNPROVIDED) ") + speech_part;
        assert NIL != integerp(sense) : "! integerp(sense) " + ("Types.integerp(sense) " + "CommonSymbols.NIL != Types.integerp(sense) ") + sense;
        SubLObject offensiveP = NIL;
        if (NIL == offensiveP) {
            SubLObject csome_list_var;
            SubLObject assertion;
            for (csome_list_var = gather_denotation_assertions(word, speech_part, sense), assertion = NIL, assertion = csome_list_var.first(); (NIL == offensiveP) && (NIL != csome_list_var); offensiveP = potentially_offensive_lexical_assertionP(assertion) , csome_list_var = csome_list_var.rest() , assertion = csome_list_var.first()) {
            }
        }
        return offensiveP;
    }

    /**
     *
     *
     * @return boolean ; T iff SENSE of WORD used in SPEECH-PART is inappropriate for the current context
     */
    @LispMethod(comment = "@return boolean ; T iff SENSE of WORD used in SPEECH-PART is inappropriate for the current context")
    public static final SubLObject inappropriate_senseP_alt(SubLObject word, SubLObject speech_part, SubLObject sense) {
        SubLTrampolineFile.checkType(word, FORT_P);
        SubLTrampolineFile.checkType(speech_part, $sym5$SPEECH_PART_);
        SubLTrampolineFile.checkType(sense, INTEGERP);
        if (NIL == lexicon_vars.pragmatic_filters()) {
            return NIL;
        }
        {
            SubLObject inappropriateP = NIL;
            if (NIL == inappropriateP) {
                {
                    SubLObject csome_list_var = com.cyc.cycjava.cycl.lexicon_accessors.gather_denotation_assertions(word, speech_part, sense);
                    SubLObject assertion = NIL;
                    for (assertion = csome_list_var.first(); !((NIL != inappropriateP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , assertion = csome_list_var.first()) {
                        inappropriateP = com.cyc.cycjava.cycl.lexicon_accessors.inappropriate_lexical_assertionP(assertion);
                    }
                }
            }
            return inappropriateP;
        }
    }

    /**
     *
     *
     * @return boolean ; T iff SENSE of WORD used in SPEECH-PART is inappropriate for the current context
     */
    @LispMethod(comment = "@return boolean ; T iff SENSE of WORD used in SPEECH-PART is inappropriate for the current context")
    public static SubLObject inappropriate_senseP(final SubLObject word, final SubLObject speech_part, final SubLObject sense) {
        assert NIL != forts.fort_p(word) : "! forts.fort_p(word) " + ("forts.fort_p(word) " + "CommonSymbols.NIL != forts.fort_p(word) ") + word;
        assert NIL != speech_partP(speech_part, UNPROVIDED) : "! lexicon_accessors.speech_partP(speech_part, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(speech_part, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(speech_part, CommonSymbols.UNPROVIDED) ") + speech_part;
        assert NIL != integerp(sense) : "! integerp(sense) " + ("Types.integerp(sense) " + "CommonSymbols.NIL != Types.integerp(sense) ") + sense;
        if (NIL == lexicon_vars.lexicon_filters()) {
            return NIL;
        }
        SubLObject inappropriateP = NIL;
        if (NIL == inappropriateP) {
            SubLObject csome_list_var;
            SubLObject assertion;
            for (csome_list_var = gather_denotation_assertions(word, speech_part, sense), assertion = NIL, assertion = csome_list_var.first(); (NIL == inappropriateP) && (NIL != csome_list_var); inappropriateP = inappropriate_lexical_assertionP(assertion) , csome_list_var = csome_list_var.rest() , assertion = csome_list_var.first()) {
            }
        }
        return inappropriateP;
    }

    /**
     * Given WORD-UNIT, POS, and sense number INT, look up semTrans. Returns just the NL
     * template part of the assertion.
     */
    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, look up semTrans. Returns just the NL\r\ntemplate part of the assertion.\nGiven WORD-UNIT, POS, and sense number INT, look up semTrans. Returns just the NL\ntemplate part of the assertion.")
    public static final SubLObject semtrans_of_ws_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int) {
        SubLTrampolineFile.checkType(word_unit, FORT_P);
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        SubLTrampolineFile.checkType(v_int, INTEGERP);
        return com.cyc.cycjava.cycl.lexicon_accessors.semtrans_lookup_int(word_unit, pos, v_int, UNPROVIDED);
    }

    @LispMethod(comment = "Given WORD-UNIT, POS, and sense number INT, look up semTrans. Returns just the NL\r\ntemplate part of the assertion.\nGiven WORD-UNIT, POS, and sense number INT, look up semTrans. Returns just the NL\ntemplate part of the assertion.")
    public static SubLObject semtrans_of_ws(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int) {
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        assert NIL != integerp(v_int) : "! integerp(v_int) " + ("Types.integerp(v_int) " + "CommonSymbols.NIL != Types.integerp(v_int) ") + v_int;
        return semtrans_lookup_int(word_unit, pos, v_int, UNPROVIDED);
    }/**
     * Given WORD-UNIT, POS, and sense number INT, look up semTrans. Returns just the NL
     * template part of the assertion.
     */


    /**
     * Given WORD-UNIT and POS, look up semTrans. Returns just the NL
     * template part of the assertion.
     */
    @LispMethod(comment = "Given WORD-UNIT and POS, look up semTrans. Returns just the NL\r\ntemplate part of the assertion.\nGiven WORD-UNIT and POS, look up semTrans. Returns just the NL\ntemplate part of the assertion.")
    public static final SubLObject semtrans_of_wuXpos_alt(SubLObject word_unit, SubLObject pos, SubLObject frame) {
        if (frame == UNPROVIDED) {
            frame = NIL;
        }
        SubLTrampolineFile.checkType(word_unit, FORT_P);
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        return com.cyc.cycjava.cycl.lexicon_accessors.semtrans_lookup_int(word_unit, pos, NIL, frame);
    }

    @LispMethod(comment = "Given WORD-UNIT and POS, look up semTrans. Returns just the NL\r\ntemplate part of the assertion.\nGiven WORD-UNIT and POS, look up semTrans. Returns just the NL\ntemplate part of the assertion.")
    public static SubLObject semtrans_of_wuXpos(final SubLObject word_unit, final SubLObject pos, SubLObject frame) {
        if (frame == UNPROVIDED) {
            frame = NIL;
        }
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        return semtrans_lookup_int(word_unit, pos, NIL, frame);
    }/**
     * Given WORD-UNIT and POS, look up semTrans. Returns just the NL
     * template part of the assertion.
     */


    /**
     * Given WORD-UNIT and POS, look up all semTrans.
     * Returns just the NL template part of the assertion.
     * If INT is NIL, return all, otherwise return only those for word sense INT.
     *
     * @unknown When *exclude-vulgarities?* is set, vulgar semTrans assertions are filtered
    out. Since the semTrans assertions are not reflected in the trie, politeness assertions
    are checked for the semTrans assertion itself as well as for any corresponding denotations.
     */
    @LispMethod(comment = "Given WORD-UNIT and POS, look up all semTrans.\r\nReturns just the NL template part of the assertion.\r\nIf INT is NIL, return all, otherwise return only those for word sense INT.\r\n\r\n@unknown When *exclude-vulgarities?* is set, vulgar semTrans assertions are filtered\r\nout. Since the semTrans assertions are not reflected in the trie, politeness assertions\r\nare checked for the semTrans assertion itself as well as for any corresponding denotations.\nGiven WORD-UNIT and POS, look up all semTrans.\nReturns just the NL template part of the assertion.\nIf INT is NIL, return all, otherwise return only those for word sense INT.")
    public static final SubLObject semtrans_lookup_int_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int, SubLObject frame) {
        if (frame == UNPROVIDED) {
            frame = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject pred = com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred(pos, UNPROVIDED);
                SubLObject ans = NIL;
                if (NIL != pred) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                {
                                    SubLObject pred_var = pred;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                {
                                                                    SubLObject done_var_279 = NIL;
                                                                    SubLObject token_var_280 = NIL;
                                                                    while (NIL == done_var_279) {
                                                                        {
                                                                            SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_280);
                                                                            SubLObject valid_281 = makeBoolean(token_var_280 != as);
                                                                            if (NIL != valid_281) {
                                                                                {
                                                                                    SubLObject as_sense = assertions_high.gaf_arg2(as);
                                                                                    SubLObject as_frame = assertions_high.gaf_arg3(as);
                                                                                    if (((NIL == v_int) || (as_sense == v_int)) && ((NIL == frame) || (as_frame == frame))) {
                                                                                        if (!((NIL != com.cyc.cycjava.cycl.lexicon_accessors.inappropriate_lexical_assertionP(as)) || (NIL != com.cyc.cycjava.cycl.lexicon_accessors.inappropriate_senseP(word_unit, pos, as_sense)))) {
                                                                                            {
                                                                                                SubLObject semtransarg = lexicon_utilities.semtrans_arg_of_pred_cached(pred);
                                                                                                SubLObject template = com.cyc.cycjava.cycl.lexicon_accessors.semtrans_template_from_assertion(as, semtransarg);
                                                                                                SubLObject item_var = narts_high.nart_substitute(template);
                                                                                                if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                                    ans = cons(item_var, ans);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            done_var_279 = makeBoolean(NIL == valid_281);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_282 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_282, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Given WORD-UNIT and POS, look up all semTrans.\r\nReturns just the NL template part of the assertion.\r\nIf INT is NIL, return all, otherwise return only those for word sense INT.\r\n\r\n@unknown When *exclude-vulgarities?* is set, vulgar semTrans assertions are filtered\r\nout. Since the semTrans assertions are not reflected in the trie, politeness assertions\r\nare checked for the semTrans assertion itself as well as for any corresponding denotations.\nGiven WORD-UNIT and POS, look up all semTrans.\nReturns just the NL template part of the assertion.\nIf INT is NIL, return all, otherwise return only those for word sense INT.")
    public static SubLObject semtrans_lookup_int(final SubLObject word_unit, final SubLObject pos, final SubLObject v_int, SubLObject frame) {
        if (frame == UNPROVIDED) {
            frame = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject pred = pos_to_semtrans_pred(pos, UNPROVIDED);
        SubLObject ans = NIL;
        if (NIL != pred) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                final SubLObject pred_var = pred;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$270 = NIL;
                                final SubLObject token_var_$271 = NIL;
                                while (NIL == done_var_$270) {
                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$271);
                                    final SubLObject valid_$272 = makeBoolean(!token_var_$271.eql(as));
                                    if (NIL != valid_$272) {
                                        final SubLObject as_sense = assertions_high.gaf_arg2(as);
                                        final SubLObject as_frame = assertions_high.gaf_arg3(as);
                                        if (((((NIL == v_int) || (NIL != kb_utilities.kbeq(as_sense, v_int))) && ((NIL == frame) || (NIL != kb_utilities.kbeq(as_frame, frame)))) && (NIL == inappropriate_lexical_assertionP(as))) && (NIL == inappropriate_senseP(word_unit, pos, as_sense))) {
                                            final SubLObject semtransarg = lexicon_utilities.semtrans_arg_of_pred_cached(pred);
                                            final SubLObject template = semtrans_template_from_assertion(as, semtransarg);
                                            final SubLObject item_var = narts_high.nart_substitute(template);
                                            if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                ans = cons(item_var, ans);
                                            }
                                        }
                                    }
                                    done_var_$270 = makeBoolean(NIL == valid_$272);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$273 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$273, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        }
        return ans;
    }/**
     * Given WORD-UNIT and POS, look up all semTrans.
     * Returns just the NL template part of the assertion.
     * If INT is NIL, return all, otherwise return only those for word sense INT.
     *
     * @unknown When *exclude-vulgarities?* is set, vulgar semTrans assertions are filtered
    out. Since the semTrans assertions are not reflected in the trie, politeness assertions
    are checked for the semTrans assertion itself as well as for any corresponding denotations.
     */


    /**
     *
     *
     * @return the semtrans template from AS, unquoting it if applicable.
     * @param SEMTRANS-ARG;
     * 		The argnum in which to find the template, so we don't have
     * 		to compute it here.
     */
    @LispMethod(comment = "@return the semtrans template from AS, unquoting it if applicable.\r\n@param SEMTRANS-ARG;\r\n\t\tThe argnum in which to find the template, so we don\'t have\r\n\t\tto compute it here.")
    public static final SubLObject semtrans_template_from_assertion_alt(SubLObject as, SubLObject semtrans_arg) {
        if (semtrans_arg == UNPROVIDED) {
            semtrans_arg = NIL;
        }
        SubLTrampolineFile.checkType(as, $sym242$GAF_ASSERTION_);
        if (NIL == semtrans_arg) {
            {
                SubLObject pred = assertions_high.gaf_arg0(as);
                semtrans_arg = lexicon_utilities.semtrans_arg_of_pred_cached(pred);
            }
        }
        {
            SubLObject raw_template = assertions_high.gaf_arg(as, semtrans_arg);
            return NIL != el_formula_with_operator_p(raw_template, $$Quote) ? ((SubLObject) (cycl_utilities.formula_arg1(raw_template, UNPROVIDED))) : raw_template;
        }
    }

    /**
     *
     *
     * @return the semtrans template from AS, unquoting it if applicable.
     * @param SEMTRANS-ARG;
     * 		The argnum in which to find the template, so we don't have
     * 		to compute it here.
     */
    @LispMethod(comment = "@return the semtrans template from AS, unquoting it if applicable.\r\n@param SEMTRANS-ARG;\r\n\t\tThe argnum in which to find the template, so we don\'t have\r\n\t\tto compute it here.")
    public static SubLObject semtrans_template_from_assertion(final SubLObject as, SubLObject semtrans_arg) {
        if (semtrans_arg == UNPROVIDED) {
            semtrans_arg = NIL;
        }
        assert NIL != assertions_high.gaf_assertionP(as) : "! assertions_high.gaf_assertionP(as) " + ("assertions_high.gaf_assertionP(as) " + "CommonSymbols.NIL != assertions_high.gaf_assertionP(as) ") + as;
        if (NIL == semtrans_arg) {
            final SubLObject pred = assertions_high.gaf_arg0(as);
            semtrans_arg = lexicon_utilities.semtrans_arg_of_pred_cached(pred);
        }
        final SubLObject raw_template = assertions_high.gaf_arg(as, semtrans_arg);
        return NIL != el_formula_with_operator_p(raw_template, $$Quote) ? cycl_utilities.formula_arg1(raw_template, UNPROVIDED) : raw_template;
    }

    /**
     *
     *
     * @return LISTP of inferred CycL semtrans sentences for WORD-UNIT and POS, such
    as would be used for parsing.
     * @unknown if WORD-UNIT and POS have asserted semtrans templates, this function returns NIL.
     */
    @LispMethod(comment = "@return LISTP of inferred CycL semtrans sentences for WORD-UNIT and POS, such\r\nas would be used for parsing.\r\n@unknown if WORD-UNIT and POS have asserted semtrans templates, this function returns NIL.")
    public static final SubLObject semtrans_sentence_infer_alt(SubLObject word_unit, SubLObject pos) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject templates = NIL;
                SubLObject semtrans_pred = com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred(pos, UNPROVIDED);
                if (!((NIL == indexed_term_p(semtrans_pred)) || (NIL != com.cyc.cycjava.cycl.lexicon_accessors.semtrans_assertion_lookup(word_unit, pos, UNPROVIDED)))) {
                    thread.resetMultipleValues();
                    {
                        SubLObject denots = com.cyc.cycjava.cycl.lexicon_accessors.denots_of_word(word_unit, pos);
                        SubLObject senses = thread.secondMultipleValue();
                        thread.resetMultipleValues();
                        {
                            SubLObject denot = NIL;
                            SubLObject denot_283 = NIL;
                            SubLObject sense = NIL;
                            SubLObject sense_284 = NIL;
                            for (denot = denots, denot_283 = denot.first(), sense = senses, sense_284 = sense.first(); !((NIL == sense) && (NIL == denot)); denot = denot.rest() , denot_283 = denot.first() , sense = sense.rest() , sense_284 = sense.first()) {
                                {
                                    SubLObject cdolist_list_var = com.cyc.cycjava.cycl.lexicon_accessors.frames_of_sense(word_unit, pos, sense_284, UNPROVIDED);
                                    SubLObject frame = NIL;
                                    for (frame = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , frame = cdolist_list_var.first()) {
                                        {
                                            SubLObject cdolist_list_var_285 = psp_semantics.psp_devise_word_templates(word_unit, pos, list(denot_283), list(frame));
                                            SubLObject template = NIL;
                                            for (template = cdolist_list_var_285.first(); NIL != cdolist_list_var_285; cdolist_list_var_285 = cdolist_list_var_285.rest() , template = cdolist_list_var_285.first()) {
                                                {
                                                    SubLObject args = list(word_unit, sense_284, frame, template);
                                                    SubLObject semtrans_sentence = make_el_formula(semtrans_pred, args, UNPROVIDED);
                                                    SubLObject item_var = semtrans_sentence;
                                                    if (NIL == member(item_var, templates, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                                                        templates = cons(item_var, templates);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return templates;
            }
        }
    }

    /**
     *
     *
     * @return LISTP of inferred CycL semtrans sentences for WORD-UNIT and POS, such
    as would be used for parsing.
     * @unknown if WORD-UNIT and POS have asserted semtrans templates, this function returns NIL.
     */
    @LispMethod(comment = "@return LISTP of inferred CycL semtrans sentences for WORD-UNIT and POS, such\r\nas would be used for parsing.\r\n@unknown if WORD-UNIT and POS have asserted semtrans templates, this function returns NIL.")
    public static SubLObject semtrans_sentence_infer(final SubLObject word_unit, final SubLObject pos) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject templates = NIL;
        final SubLObject semtrans_pred = pos_to_semtrans_pred(pos, UNPROVIDED);
        if ((NIL != indexed_term_p(semtrans_pred)) && (NIL == semtrans_assertion_lookup(word_unit, pos, UNPROVIDED))) {
            thread.resetMultipleValues();
            final SubLObject denots = denots_of_word(word_unit, pos);
            final SubLObject senses = thread.secondMultipleValue();
            thread.resetMultipleValues();
            SubLObject denot = NIL;
            SubLObject denot_$274 = NIL;
            SubLObject sense = NIL;
            SubLObject sense_$275 = NIL;
            denot = denots;
            denot_$274 = denot.first();
            sense = senses;
            sense_$275 = sense.first();
            while ((NIL != sense) || (NIL != denot)) {
                SubLObject cdolist_list_var = frames_of_sense(word_unit, pos, sense_$275, UNPROVIDED);
                SubLObject frame = NIL;
                frame = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    SubLObject cdolist_list_var_$276 = psp_semantics.psp_devise_word_templates(word_unit, pos, list(denot_$274), list(frame));
                    SubLObject template = NIL;
                    template = cdolist_list_var_$276.first();
                    while (NIL != cdolist_list_var_$276) {
                        final SubLObject args = list(word_unit, sense_$275, frame, template);
                        final SubLObject item_var;
                        final SubLObject semtrans_sentence = item_var = make_el_formula(semtrans_pred, args, UNPROVIDED);
                        if (NIL == member(item_var, templates, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                            templates = cons(item_var, templates);
                        }
                        cdolist_list_var_$276 = cdolist_list_var_$276.rest();
                        template = cdolist_list_var_$276.first();
                    } 
                    cdolist_list_var = cdolist_list_var.rest();
                    frame = cdolist_list_var.first();
                } 
                denot = denot.rest();
                denot_$274 = denot.first();
                sense = sense.rest();
                sense_$275 = sense.first();
            } 
        }
        return templates;
    }

    public static final SubLObject denots_of_word_alt(SubLObject word_unit, SubLObject pos) {
        if (pos == UNPROVIDED) {
            pos = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denots = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        {
                            SubLObject pred_var = $$denotation;
                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                {
                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                    SubLObject done_var = NIL;
                                    SubLObject token_var = NIL;
                                    while (NIL == done_var) {
                                        {
                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                            if (NIL != valid) {
                                                {
                                                    SubLObject final_index_iterator = NIL;
                                                    try {
                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                        {
                                                            SubLObject done_var_286 = NIL;
                                                            SubLObject token_var_287 = NIL;
                                                            while (NIL == done_var_286) {
                                                                {
                                                                    SubLObject denot_as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_287);
                                                                    SubLObject valid_288 = makeBoolean(token_var_287 != denot_as);
                                                                    if (NIL != valid_288) {
                                                                        if ((NIL == pos) || (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(assertions_high.gaf_arg2(denot_as), pos, UNPROVIDED))) {
                                                                            {
                                                                                SubLObject item_var = cons(assertions_high.gaf_arg4(denot_as), assertions_high.gaf_arg3(denot_as));
                                                                                if (NIL == member(item_var, denots, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                                                                                    denots = cons(item_var, denots);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    done_var_286 = makeBoolean(NIL == valid_288);
                                                                }
                                                            } 
                                                        }
                                                    } finally {
                                                        {
                                                            SubLObject _prev_bind_0_289 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_289, thread);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            done_var = makeBoolean(NIL == valid);
                                        }
                                    } 
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return values(Mapping.mapcar(symbol_function(CAR), denots), Mapping.mapcar(symbol_function(CDR), denots));
            }
        }
    }

    public static SubLObject denots_of_word(final SubLObject word_unit, SubLObject pos) {
        if (pos == UNPROVIDED) {
            pos = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject denots = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            final SubLObject pred_var = $$denotation;
            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                SubLObject done_var = NIL;
                final SubLObject token_var = NIL;
                while (NIL == done_var) {
                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                    if (NIL != valid) {
                        SubLObject final_index_iterator = NIL;
                        try {
                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                            SubLObject done_var_$277 = NIL;
                            final SubLObject token_var_$278 = NIL;
                            while (NIL == done_var_$277) {
                                final SubLObject denot_as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$278);
                                final SubLObject valid_$279 = makeBoolean(!token_var_$278.eql(denot_as));
                                if ((NIL != valid_$279) && ((NIL == pos) || (NIL != genl_posP(assertions_high.gaf_arg2(denot_as), pos, UNPROVIDED)))) {
                                    final SubLObject item_var = cons(assertions_high.gaf_arg4(denot_as), assertions_high.gaf_arg3(denot_as));
                                    if (NIL == member(item_var, denots, symbol_function(EQUAL), symbol_function(IDENTITY))) {
                                        denots = cons(item_var, denots);
                                    }
                                }
                                done_var_$277 = makeBoolean(NIL == valid_$279);
                            } 
                        } finally {
                            final SubLObject _prev_bind_0_$280 = $is_thread_performing_cleanupP$.currentBinding(thread);
                            try {
                                $is_thread_performing_cleanupP$.bind(T, thread);
                                final SubLObject _values = getValuesAsVector();
                                if (NIL != final_index_iterator) {
                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                }
                                restoreValuesFromVector(_values);
                            } finally {
                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$280, thread);
                            }
                        }
                    }
                    done_var = makeBoolean(NIL == valid);
                } 
            }
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return values(Mapping.mapcar(symbol_function(CAR), denots), Mapping.mapcar(symbol_function(CDR), denots));
    }

    /**
     *
     *
     * @return list ; semTrans assertions for WORD-UNIT and POS;
    if INT is specified, returns only those for word sense INT.
     * @unknown tom
     */
    @LispMethod(comment = "@return list ; semTrans assertions for WORD-UNIT and POS;\r\nif INT is specified, returns only those for word sense INT.\r\n@unknown tom")
    public static final SubLObject semtrans_assertion_lookup_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int) {
        if (v_int == UNPROVIDED) {
            v_int = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, $sym92$LEXICAL_WORD_);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            {
                SubLObject pred = com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred(pos, UNPROVIDED);
                SubLObject ans = NIL;
                if ((NIL != pred) && (NIL != indexed_term_p(word_unit))) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                {
                                    SubLObject pred_var = pred;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                {
                                                                    SubLObject done_var_290 = NIL;
                                                                    SubLObject token_var_291 = NIL;
                                                                    while (NIL == done_var_290) {
                                                                        {
                                                                            SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_291);
                                                                            SubLObject valid_292 = makeBoolean(token_var_291 != as);
                                                                            if (NIL != valid_292) {
                                                                                {
                                                                                    SubLObject as_sense = assertions_high.gaf_arg2(as);
                                                                                    if ((NIL == v_int) || (as_sense == v_int)) {
                                                                                        if (!((NIL != com.cyc.cycjava.cycl.lexicon_accessors.inappropriate_lexical_assertionP(as)) || (NIL != com.cyc.cycjava.cycl.lexicon_accessors.inappropriate_senseP(word_unit, pos, as_sense)))) {
                                                                                            {
                                                                                                SubLObject item_var = as;
                                                                                                if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                                    ans = cons(item_var, ans);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            done_var_290 = makeBoolean(NIL == valid_292);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_293 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_293, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return list ; semTrans assertions for WORD-UNIT and POS;
    if INT is specified, returns only those for word sense INT.
     * @unknown tom
     */
    @LispMethod(comment = "@return list ; semTrans assertions for WORD-UNIT and POS;\r\nif INT is specified, returns only those for word sense INT.\r\n@unknown tom")
    public static SubLObject semtrans_assertion_lookup(final SubLObject word_unit, final SubLObject pos, SubLObject v_int) {
        if (v_int == UNPROVIDED) {
            v_int = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != lexical_wordP(word_unit) : "! lexicon_accessors.lexical_wordP(word_unit) " + ("lexicon_accessors.lexical_wordP(word_unit) " + "CommonSymbols.NIL != lexicon_accessors.lexical_wordP(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        final SubLObject pred = pos_to_semtrans_pred(pos, UNPROVIDED);
        SubLObject ans = NIL;
        if ((NIL != pred) && (NIL != indexed_term_p(word_unit))) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                final SubLObject pred_var = pred;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$281 = NIL;
                                final SubLObject token_var_$282 = NIL;
                                while (NIL == done_var_$281) {
                                    final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$282);
                                    final SubLObject valid_$283 = makeBoolean(!token_var_$282.eql(as));
                                    if (NIL != valid_$283) {
                                        final SubLObject as_sense = assertions_high.gaf_arg2(as);
                                        if ((((NIL == v_int) || (NIL != kb_utilities.kbeq(as_sense, v_int))) && (NIL == inappropriate_lexical_assertionP(as))) && (NIL == inappropriate_senseP(word_unit, pos, as_sense))) {
                                            final SubLObject item_var = as;
                                            if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                ans = cons(item_var, ans);
                                            }
                                        }
                                    }
                                    done_var_$281 = makeBoolean(NIL == valid_$283);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$284 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$284, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        }
        return ans;
    }

    /**
     *
     *
     * @return list ; like @xref semtrans-assertion-lookup but not filtering based on politeness or formality
     */
    @LispMethod(comment = "@return list ; like @xref semtrans-assertion-lookup but not filtering based on politeness or formality")
    public static final SubLObject all_semtrans_assertions_alt(SubLObject word_unit, SubLObject pos, SubLObject v_int) {
        if (v_int == UNPROVIDED) {
            v_int = NIL;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            SubLTrampolineFile.checkType(word_unit, FORT_P);
            SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
            {
                SubLObject assertions = NIL;
                {
                    SubLObject _prev_bind_0 = lexicon_vars.$exclude_vulgaritiesP$.currentBinding(thread);
                    SubLObject _prev_bind_1 = lexicon_vars.$exclude_slangP$.currentBinding(thread);
                    try {
                        lexicon_vars.$exclude_vulgaritiesP$.bind(NIL, thread);
                        lexicon_vars.$exclude_slangP$.bind(NIL, thread);
                        assertions = com.cyc.cycjava.cycl.lexicon_accessors.semtrans_assertion_lookup(word_unit, pos, v_int);
                    } finally {
                        lexicon_vars.$exclude_slangP$.rebind(_prev_bind_1, thread);
                        lexicon_vars.$exclude_vulgaritiesP$.rebind(_prev_bind_0, thread);
                    }
                }
                return assertions;
            }
        }
    }

    /**
     *
     *
     * @return list ; like @xref semtrans-assertion-lookup but not filtering based on politeness or formality
     */
    @LispMethod(comment = "@return list ; like @xref semtrans-assertion-lookup but not filtering based on politeness or formality")
    public static SubLObject all_semtrans_assertions(final SubLObject word_unit, final SubLObject pos, SubLObject v_int) {
        if (v_int == UNPROVIDED) {
            v_int = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != forts.fort_p(word_unit) : "! forts.fort_p(word_unit) " + ("forts.fort_p(word_unit) " + "CommonSymbols.NIL != forts.fort_p(word_unit) ") + word_unit;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        SubLObject assertions = NIL;
        final SubLObject _prev_bind_0 = lexicon_vars.$exclude_vulgaritiesP$.currentBinding(thread);
        final SubLObject _prev_bind_2 = lexicon_vars.$exclude_slangP$.currentBinding(thread);
        try {
            lexicon_vars.$exclude_vulgaritiesP$.bind(NIL, thread);
            lexicon_vars.$exclude_slangP$.bind(NIL, thread);
            assertions = semtrans_assertion_lookup(word_unit, pos, v_int);
        } finally {
            lexicon_vars.$exclude_slangP$.rebind(_prev_bind_2, thread);
            lexicon_vars.$exclude_vulgaritiesP$.rebind(_prev_bind_0, thread);
        }
        return assertions;
    }

    /**
     * Retrieve the preposition corresponding with PREP-FRAME in a list
     */
    @LispMethod(comment = "Retrieve the preposition corresponding with PREP-FRAME in a list")
    public static final SubLObject preposition_of_frame_alt(SubLObject prep_frame) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = ((NIL != isa.isaP(prep_frame, $$TransitivePPFrameType, UNPROVIDED, UNPROVIDED)) || (NIL != isa.isaP(prep_frame, $$DitransitivePPFrameType, UNPROVIDED, UNPROVIDED))) ? ((SubLObject) (lexicon_cache.words_of_string(string_utilities.string_after(constants_high.constant_name(prep_frame), CHAR_hyphen), UNPROVIDED, UNPROVIDED, UNPROVIDED))) : NIL;
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Retrieve the preposition corresponding with PREP-FRAME in a list")
    public static SubLObject preposition_of_frame(final SubLObject prep_frame) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = ((NIL != isa.isaP(prep_frame, $$TransitivePPFrameType, UNPROVIDED, UNPROVIDED)) || (NIL != isa.isaP(prep_frame, $$DitransitivePPFrameType, UNPROVIDED, UNPROVIDED))) ? lexicon_cache.words_of_string(string_utilities.string_after(constants_high.constant_name(prep_frame), CHAR_hyphen), UNPROVIDED, UNPROVIDED, UNPROVIDED) : NIL;
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }/**
     * Retrieve the preposition corresponding with PREP-FRAME in a list
     */


    /**
     *
     *
     * @param ASSERTION;
     * 		an #$CycLNLSemanticAssertion
     * @return denotatum; the denotatum of the assertion
     */
    @LispMethod(comment = "@param ASSERTION;\r\n\t\tan #$CycLNLSemanticAssertion\r\n@return denotatum; the denotatum of the assertion")
    public static final SubLObject assertion_denotation_alt(SubLObject as) {
        {
            SubLObject pred = assertions_high.gaf_arg0(as);
            SubLObject denot_arg = lexicon_utilities.denotatum_arg_of_pred_cached(pred);
            return NIL != denot_arg ? ((SubLObject) (assertions_high.gaf_arg(as, denot_arg))) : NIL;
        }
    }

    /**
     *
     *
     * @param ASSERTION;
     * 		an #$CycLNLSemanticAssertion
     * @return denotatum; the denotatum of the assertion
     */
    @LispMethod(comment = "@param ASSERTION;\r\n\t\tan #$CycLNLSemanticAssertion\r\n@return denotatum; the denotatum of the assertion")
    public static SubLObject assertion_denotation(final SubLObject as) {
        final SubLObject pred = assertions_high.gaf_arg0(as);
        final SubLObject denot_arg = lexicon_utilities.denotatum_arg_of_pred_cached(pred);
        return NIL != denot_arg ? assertions_high.gaf_arg(as, denot_arg) : NIL;
    }

    /**
     *
     *
     * @param ASSERTION;
     * 		an #$CycLNLSemanticAssertion
     * @return fort; the SpeechPart from the semantic assertion
     */
    @LispMethod(comment = "@param ASSERTION;\r\n\t\tan #$CycLNLSemanticAssertion\r\n@return fort; the SpeechPart from the semantic assertion")
    public static final SubLObject assertion_pos_alt(SubLObject as) {
        {
            SubLObject pred = assertions_high.gaf_arg0(as);
            SubLObject pos_arg = lexicon_utilities.pos_arg_of_pred_cached(pred);
            return NIL != pos_arg ? ((SubLObject) (assertions_high.gaf_arg(as, pos_arg))) : NIL;
        }
    }

    /**
     *
     *
     * @param ASSERTION;
     * 		an #$CycLNLSemanticAssertion
     * @return fort; the SpeechPart from the semantic assertion
     */
    @LispMethod(comment = "@param ASSERTION;\r\n\t\tan #$CycLNLSemanticAssertion\r\n@return fort; the SpeechPart from the semantic assertion")
    public static SubLObject assertion_pos(final SubLObject as) {
        final SubLObject pred = assertions_high.gaf_arg0(as);
        final SubLObject pos_arg = lexicon_utilities.pos_arg_of_pred_cached(pred);
        return NIL != pos_arg ? assertions_high.gaf_arg(as, pos_arg) : NIL;
    }

    /**
     *
     *
     * @return integer ; sense number from the lexical assertion or nil
     * @unknown By convention the sense number always follows the SpeechPart, so a separate assertion akin in denotatumArg is not necessary
     * @unknown tom
     */
    @LispMethod(comment = "@return integer ; sense number from the lexical assertion or nil\r\n@unknown By convention the sense number always follows the SpeechPart, so a separate assertion akin in denotatumArg is not necessary\r\n@unknown tom")
    public static final SubLObject assertion_sense_num_alt(SubLObject assertion) {
        {
            SubLObject pred = assertions_high.gaf_arg0(assertion);
            SubLObject pos_arg = lexicon_utilities.pos_arg_of_pred_cached(pred);
            SubLObject sense_arg = (NIL != pos_arg) ? ((SubLObject) (number_utilities.f_1X(pos_arg))) : NIL;
            SubLObject sense_num = (NIL != sense_arg) ? ((SubLObject) (assertions_high.gaf_arg(assertion, sense_arg))) : NIL;
            return sense_num.isInteger() ? ((SubLObject) (sense_num)) : NIL;
        }
    }

    /**
     *
     *
     * @return integer ; sense number from the lexical assertion or nil
     * @unknown By convention the sense number always follows the SpeechPart, so a separate assertion akin in denotatumArg is not necessary
     * @unknown tom
     */
    @LispMethod(comment = "@return integer ; sense number from the lexical assertion or nil\r\n@unknown By convention the sense number always follows the SpeechPart, so a separate assertion akin in denotatumArg is not necessary\r\n@unknown tom")
    public static SubLObject assertion_sense_num(final SubLObject assertion) {
        final SubLObject pred = assertions_high.gaf_arg0(assertion);
        final SubLObject pos_arg = lexicon_utilities.pos_arg_of_pred_cached(pred);
        final SubLObject sense_arg = (NIL != pos_arg) ? number_utilities.f_1X(pos_arg) : NIL;
        final SubLObject sense_num = (NIL != sense_arg) ? assertions_high.gaf_arg(assertion, sense_arg) : NIL;
        return sense_num.isInteger() ? sense_num : NIL;
    }

    public static final SubLObject clear_agr_of_det_string_alt() {
        {
            SubLObject cs = $agr_of_det_string_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_agr_of_det_string() {
        final SubLObject cs = $agr_of_det_string_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_agr_of_det_string_alt(SubLObject string) {
        return memoization_state.caching_state_remove_function_results_with_args($agr_of_det_string_caching_state$.getGlobalValue(), list(string), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_agr_of_det_string(final SubLObject string) {
        return memoization_state.caching_state_remove_function_results_with_args($agr_of_det_string_caching_state$.getGlobalValue(), list(string), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return LISTP of pos preds that agree with the determiner STRING
     */
    @LispMethod(comment = "@return LISTP of pos preds that agree with the determiner STRING")
    public static final SubLObject agr_of_det_string_internal_alt(SubLObject string) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            if (string.equal($str_alt196$)) {
                return $list_alt249;
            }
            {
                SubLObject ans = NIL;
                SubLObject cdolist_list_var = lexicon_cache.words_of_string(string, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                SubLObject word = NIL;
                for (word = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , word = cdolist_list_var.first()) {
                    {
                        SubLObject cdolist_list_var_294 = com.cyc.cycjava.cycl.lexicon_accessors.agreement_lookup(word);
                        SubLObject pos_pred = NIL;
                        for (pos_pred = cdolist_list_var_294.first(); NIL != cdolist_list_var_294; cdolist_list_var_294 = cdolist_list_var_294.rest() , pos_pred = cdolist_list_var_294.first()) {
                            ans = cons(pos_pred, ans);
                        }
                    }
                }
                {
                    SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                    {
                        SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                        SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                        SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                        try {
                            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                            {
                                SubLObject nearest_common_genl_preds = com.cyc.cycjava.cycl.lexicon_accessors.speech_part_pred_min_ceilings(ans, UNPROVIDED);
                                ans = (NIL != nearest_common_genl_preds) ? ((SubLObject) (nearest_common_genl_preds)) : ans;
                            }
                        } finally {
                            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                        }
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return LISTP of pos preds that agree with the determiner STRING
     */
    @LispMethod(comment = "@return LISTP of pos preds that agree with the determiner STRING")
    public static SubLObject agr_of_det_string_internal(final SubLObject string) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        if (string.equal($str200$)) {
            return $list262;
        }
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = lexicon_cache.words_of_string(string, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        SubLObject word = NIL;
        word = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            SubLObject cdolist_list_var_$285 = agreement_lookup(word);
            SubLObject pos_pred = NIL;
            pos_pred = cdolist_list_var_$285.first();
            while (NIL != cdolist_list_var_$285) {
                ans = cons(pos_pred, ans);
                cdolist_list_var_$285 = cdolist_list_var_$285.rest();
                pos_pred = cdolist_list_var_$285.first();
            } 
            cdolist_list_var = cdolist_list_var.rest();
            word = cdolist_list_var.first();
        } 
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            final SubLObject nearest_common_genl_preds = speech_part_pred_min_ceilings(ans, UNPROVIDED);
            ans = (NIL != nearest_common_genl_preds) ? nearest_common_genl_preds : ans;
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject agr_of_det_string_alt(SubLObject string) {
        {
            SubLObject caching_state = $agr_of_det_string_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(AGR_OF_DET_STRING, $agr_of_det_string_caching_state$, NIL, EQUALP, ONE_INTEGER, SIXTEEN_INTEGER);
            }
            {
                SubLObject results = memoization_state.caching_state_lookup(caching_state, string, $kw3$_MEMOIZED_ITEM_NOT_FOUND_);
                if (results == $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.agr_of_det_string_internal(string)));
                    memoization_state.caching_state_put(caching_state, string, results, UNPROVIDED);
                }
                return memoization_state.caching_results(results);
            }
        }
    }

    public static SubLObject agr_of_det_string(final SubLObject string) {
        SubLObject caching_state = $agr_of_det_string_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(AGR_OF_DET_STRING, $agr_of_det_string_caching_state$, $int$64, EQUALP, ONE_INTEGER, SIXTEEN_INTEGER);
        }
        SubLObject results = memoization_state.caching_state_lookup(caching_state, string, memoization_state.$memoized_item_not_found$.getGlobalValue());
        if (results.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            results = arg2(resetMultipleValues(), multiple_value_list(agr_of_det_string_internal(string)));
            memoization_state.caching_state_put(caching_state, string, results, UNPROVIDED);
        }
        return memoization_state.caching_results(results);
    }

    /**
     * Given a determiner WORD-UNIT, look up #$determinerAgreement features.
     *
     * @return LISTP of speech-part preds.
     */
    @LispMethod(comment = "Given a determiner WORD-UNIT, look up #$determinerAgreement features.\r\n\r\n@return LISTP of speech-part preds.")
    public static final SubLObject agreement_lookup_alt(SubLObject word_unit) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                if (NIL != indexed_term_p(word_unit)) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                ans = kb_mapping_utilities.pred_values(word_unit, $$determinerAgreement, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Given a determiner WORD-UNIT, look up #$determinerAgreement features.\r\n\r\n@return LISTP of speech-part preds.")
    public static SubLObject agreement_lookup(final SubLObject word_unit) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        if (NIL != indexed_term_p(word_unit)) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                ans = kb_mapping_utilities.pred_values(word_unit, $$determinerAgreement, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        }
        return ans;
    }/**
     * Given a determiner WORD-UNIT, look up #$determinerAgreement features.
     *
     * @return LISTP of speech-part preds.
     */


    /**
     * Given WORD-UNIT and SPEECH-PART, return a list of word sense numbers from
     * denotation assertions (by default just #$denotation).
     *
     * @return list : integers for the sense numbers that have been assigned
     */
    @LispMethod(comment = "Given WORD-UNIT and SPEECH-PART, return a list of word sense numbers from\r\ndenotation assertions (by default just #$denotation).\r\n\r\n@return list : integers for the sense numbers that have been assigned\nGiven WORD-UNIT and SPEECH-PART, return a list of word sense numbers from\ndenotation assertions (by default just #$denotation).")
    public static final SubLObject denot_ws_lookup_alt(SubLObject word_unit, SubLObject speech_part, SubLObject denot_type) {
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject denot_preds = com.cyc.cycjava.cycl.lexicon_accessors.determine_denotation_preds(denot_type);
                SubLObject ans = NIL;
                SubLObject cdolist_list_var = denot_preds;
                SubLObject denot_pred = NIL;
                for (denot_pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , denot_pred = cdolist_list_var.first()) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                {
                                    SubLObject pred_var = denot_pred;
                                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                                        {
                                            SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                                            SubLObject done_var = NIL;
                                            SubLObject token_var = NIL;
                                            while (NIL == done_var) {
                                                {
                                                    SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                    if (NIL != valid) {
                                                        {
                                                            SubLObject final_index_iterator = NIL;
                                                            try {
                                                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                {
                                                                    SubLObject done_var_295 = NIL;
                                                                    SubLObject token_var_296 = NIL;
                                                                    while (NIL == done_var_295) {
                                                                        {
                                                                            SubLObject ass = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_296);
                                                                            SubLObject valid_297 = makeBoolean(token_var_296 != ass);
                                                                            if (NIL != valid_297) {
                                                                                if (speech_part == assertions_high.gaf_arg2(ass)) {
                                                                                    {
                                                                                        SubLObject item_var = assertions_high.gaf_arg3(ass);
                                                                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                                                                            ans = cons(item_var, ans);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            done_var_295 = makeBoolean(NIL == valid_297);
                                                                        }
                                                                    } 
                                                                }
                                                            } finally {
                                                                {
                                                                    SubLObject _prev_bind_0_298 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                    try {
                                                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                                                        if (NIL != final_index_iterator) {
                                                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                        }
                                                                    } finally {
                                                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_298, thread);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                }
                                            } 
                                        }
                                    }
                                }
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                }
                return ans;
            }
        }
    }

    @LispMethod(comment = "Given WORD-UNIT and SPEECH-PART, return a list of word sense numbers from\r\ndenotation assertions (by default just #$denotation).\r\n\r\n@return list : integers for the sense numbers that have been assigned\nGiven WORD-UNIT and SPEECH-PART, return a list of word sense numbers from\ndenotation assertions (by default just #$denotation).")
    public static SubLObject denot_ws_lookup(final SubLObject word_unit, final SubLObject speech_part, SubLObject denot_type) {
        if (denot_type == UNPROVIDED) {
            denot_type = $DENOT;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject denot_preds = determine_denotation_preds(denot_type);
        SubLObject ans = NIL;
        SubLObject cdolist_list_var = denot_preds;
        SubLObject denot_pred = NIL;
        denot_pred = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                final SubLObject pred_var = denot_pred;
                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(word_unit, NIL, pred_var)) {
                    final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(word_unit, NIL, pred_var);
                    SubLObject done_var = NIL;
                    final SubLObject token_var = NIL;
                    while (NIL == done_var) {
                        final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                        final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                        if (NIL != valid) {
                            SubLObject final_index_iterator = NIL;
                            try {
                                final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                SubLObject done_var_$286 = NIL;
                                final SubLObject token_var_$287 = NIL;
                                while (NIL == done_var_$286) {
                                    final SubLObject ass = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$287);
                                    final SubLObject valid_$288 = makeBoolean(!token_var_$287.eql(ass));
                                    if ((NIL != valid_$288) && (NIL != kb_utilities.kbeq(speech_part, assertions_high.gaf_arg2(ass)))) {
                                        final SubLObject item_var = assertions_high.gaf_arg3(ass);
                                        if (NIL == member(item_var, ans, symbol_function(EQL), symbol_function(IDENTITY))) {
                                            ans = cons(item_var, ans);
                                        }
                                    }
                                    done_var_$286 = makeBoolean(NIL == valid_$288);
                                } 
                            } finally {
                                final SubLObject _prev_bind_0_$289 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                try {
                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                    final SubLObject _values = getValuesAsVector();
                                    if (NIL != final_index_iterator) {
                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                    }
                                    restoreValuesFromVector(_values);
                                } finally {
                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$289, thread);
                                }
                            }
                        }
                        done_var = makeBoolean(NIL == valid);
                    } 
                }
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
            cdolist_list_var = cdolist_list_var.rest();
            denot_pred = cdolist_list_var.first();
        } 
        return ans;
    }/**
     * Given WORD-UNIT and SPEECH-PART, return a list of word sense numbers from
     * denotation assertions (by default just #$denotation).
     *
     * @return list : integers for the sense numbers that have been assigned
     */


    /**
     *
     *
     * @return fort; The appropriate semTrans predicate for Cyc part-of-speech POS
     */
    @LispMethod(comment = "@return fort; The appropriate semTrans predicate for Cyc part-of-speech POS")
    public static final SubLObject pos_to_semtrans_pred_alt(SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.speech_partP(pos, UNPROVIDED)) {
            return NIL;
        }
        return com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred_cached(pos, mt);
    }

    /**
     *
     *
     * @return fort; The appropriate semTrans predicate for Cyc part-of-speech POS
     */
    @LispMethod(comment = "@return fort; The appropriate semTrans predicate for Cyc part-of-speech POS")
    public static SubLObject pos_to_semtrans_pred(final SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (NIL == speech_partP(pos, UNPROVIDED)) {
            return NIL;
        }
        return pos_to_semtrans_pred_cached(pos, mt);
    }

    public static final SubLObject clear_pos_to_semtrans_pred_cached_alt() {
        {
            SubLObject cs = $pos_to_semtrans_pred_cached_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_pos_to_semtrans_pred_cached() {
        final SubLObject cs = $pos_to_semtrans_pred_cached_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_pos_to_semtrans_pred_cached_alt(SubLObject pos, SubLObject mt) {
        return memoization_state.caching_state_remove_function_results_with_args($pos_to_semtrans_pred_cached_caching_state$.getGlobalValue(), list(pos, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_pos_to_semtrans_pred_cached(final SubLObject pos, final SubLObject mt) {
        return memoization_state.caching_state_remove_function_results_with_args($pos_to_semtrans_pred_cached_caching_state$.getGlobalValue(), list(pos, mt), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject pos_to_semtrans_pred_cached_internal_alt(SubLObject pos, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = kb_mapping_utilities.fpred_value(pos, $$semTransPredForPOS, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        if (NIL == ans) {
                            {
                                SubLObject csome_list_var = kb_mapping_utilities.pred_values(pos, $$genls, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                SubLObject genl_pos = NIL;
                                for (genl_pos = csome_list_var.first(); !((NIL != ans) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , genl_pos = csome_list_var.first()) {
                                    ans = com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred(genl_pos, mt);
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    public static SubLObject pos_to_semtrans_pred_cached_internal(final SubLObject pos, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = kb_mapping_utilities.fpred_value(pos, $$semTransPredForPOS, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            if (NIL == ans) {
                SubLObject csome_list_var;
                SubLObject genl_pos;
                for (csome_list_var = kb_mapping_utilities.pred_values(pos, $$genls, UNPROVIDED, UNPROVIDED, UNPROVIDED), genl_pos = NIL, genl_pos = csome_list_var.first(); (NIL == ans) && (NIL != csome_list_var); ans = pos_to_semtrans_pred(genl_pos, mt) , csome_list_var = csome_list_var.rest() , genl_pos = csome_list_var.first()) {
                }
            }
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject pos_to_semtrans_pred_cached_alt(SubLObject pos, SubLObject mt) {
        {
            SubLObject caching_state = $pos_to_semtrans_pred_cached_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(POS_TO_SEMTRANS_PRED_CACHED, $pos_to_semtrans_pred_cached_caching_state$, $int$64, EQUAL, TWO_INTEGER, ZERO_INTEGER);
                memoization_state.register_hl_store_cache_clear_callback(CLEAR_POS_TO_SEMTRANS_PRED_CACHED);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(pos, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (pos.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.pos_to_semtrans_pred_cached_internal(pos, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(pos, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject pos_to_semtrans_pred_cached(final SubLObject pos, final SubLObject mt) {
        SubLObject caching_state = $pos_to_semtrans_pred_cached_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(POS_TO_SEMTRANS_PRED_CACHED, $pos_to_semtrans_pred_cached_caching_state$, $int$64, EQUAL, TWO_INTEGER, ZERO_INTEGER);
            memoization_state.register_hl_store_cache_clear_callback(CLEAR_POS_TO_SEMTRANS_PRED_CACHED);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(pos, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (pos.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(pos_to_semtrans_pred_cached_internal(pos, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(pos, mt));
        return memoization_state.caching_results(results3);
    }

    public static final SubLObject clear_semtrans_pred_to_pos_alt() {
        {
            SubLObject cs = $semtrans_pred_to_pos_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_semtrans_pred_to_pos() {
        final SubLObject cs = $semtrans_pred_to_pos_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_semtrans_pred_to_pos_alt(SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($semtrans_pred_to_pos_caching_state$.getGlobalValue(), list(pred, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_semtrans_pred_to_pos(final SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        return memoization_state.caching_state_remove_function_results_with_args($semtrans_pred_to_pos_caching_state$.getGlobalValue(), list(pred, mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return fort; The most general Cyc part-of-speech appropriate for semTrans predicate PRED
     */
    @LispMethod(comment = "@return fort; The most general Cyc part-of-speech appropriate for semTrans predicate PRED")
    public static final SubLObject semtrans_pred_to_pos_internal_alt(SubLObject pred, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = Sort.sort(kb_mapping_utilities.pred_values(pred, $$semTransPredForPOS, TWO_INTEGER, ONE_INTEGER, UNPROVIDED), symbol_function($sym97$SPEC_), UNPROVIDED).first();
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return fort; The most general Cyc part-of-speech appropriate for semTrans predicate PRED
     */
    @LispMethod(comment = "@return fort; The most general Cyc part-of-speech appropriate for semTrans predicate PRED")
    public static SubLObject semtrans_pred_to_pos_internal(final SubLObject pred, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = Sort.sort(kb_mapping_utilities.pred_values(pred, $$semTransPredForPOS, TWO_INTEGER, ONE_INTEGER, UNPROVIDED), symbol_function($sym100$SPEC_), UNPROVIDED).first();
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject semtrans_pred_to_pos_alt(SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject caching_state = $semtrans_pred_to_pos_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(SEMTRANS_PRED_TO_POS, $semtrans_pred_to_pos_caching_state$, $int$128, EQUAL, TWO_INTEGER, ZERO_INTEGER);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(pred, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (pred.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.semtrans_pred_to_pos_internal(pred, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(pred, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject semtrans_pred_to_pos(final SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLObject caching_state = $semtrans_pred_to_pos_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(SEMTRANS_PRED_TO_POS, $semtrans_pred_to_pos_caching_state$, $int$128, EQUAL, TWO_INTEGER, ZERO_INTEGER);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(pred, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (pred.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(semtrans_pred_to_pos_internal(pred, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(pred, mt));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @return list ; strings from commonNickname assertions for the name word-unit
     */
    @LispMethod(comment = "@return list ; strings from commonNickname assertions for the name word-unit")
    public static final SubLObject nicknames_of_name_alt(SubLObject name) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = kb_mapping_utilities.pred_values(name, $$commonNickname, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return list ; strings from commonNickname assertions for the name word-unit
     */
    @LispMethod(comment = "@return list ; strings from commonNickname assertions for the name word-unit")
    public static SubLObject nicknames_of_name(final SubLObject name) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = kb_mapping_utilities.pred_values(name, $$commonNickname, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @return list ; strings from nameSpelling assertions for the name word-unit
     */
    @LispMethod(comment = "@return list ; strings from nameSpelling assertions for the name word-unit")
    public static final SubLObject spellings_of_name_alt(SubLObject name) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        ans = kb_mapping_utilities.pred_values(name, $$nameSpelling, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return list ; strings from nameSpelling assertions for the name word-unit
     */
    @LispMethod(comment = "@return list ; strings from nameSpelling assertions for the name word-unit")
    public static SubLObject spellings_of_name(final SubLObject name) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(lexicon_vars.$lexicon_lookup_mt$.getDynamicValue(thread));
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            ans = kb_mapping_utilities.pred_values(name, $$nameSpelling, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    /**
     *
     *
     * @return BOOLEAN; Is Arg N of RELN required to be a #$SpeechPart?
     */
    @LispMethod(comment = "@return BOOLEAN; Is Arg N of RELN required to be a #$SpeechPart?")
    public static final SubLObject argn_is_speech_partP_alt(SubLObject reln, SubLObject n) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                        mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                        ans = subl_promotions.memberP($$SpeechPart, kb_accessors.argn_isa(reln, n, UNPROVIDED), UNPROVIDED, UNPROVIDED);
                    } finally {
                        mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                    }
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is Arg N of RELN required to be a #$SpeechPart?
     */
    @LispMethod(comment = "@return BOOLEAN; Is Arg N of RELN required to be a #$SpeechPart?")
    public static SubLObject argn_is_speech_partP(final SubLObject reln, final SubLObject n) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            ans = subl_promotions.memberP($$SpeechPart, kb_accessors.argn_isa(reln, n, UNPROVIDED), UNPROVIDED, UNPROVIDED);
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return ans;
    }

    public static final SubLObject speech_parts_initializedP_alt() {
        return makeBoolean((NIL != dictionary.dictionary_p($speech_parts$.getGlobalValue())) && (NIL == dictionary.dictionary_empty_p($speech_parts$.getGlobalValue())));
    }

    public static SubLObject speech_parts_initializedP() {
        return makeBoolean((NIL != dictionary.dictionary_p($speech_parts$.getGlobalValue())) && (NIL == dictionary.dictionary_empty_p($speech_parts$.getGlobalValue())));
    }

    public static final SubLObject clear_speech_parts_alt() {
        if (NIL == dictionary.dictionary_p($speech_parts$.getGlobalValue())) {
            $speech_parts$.setGlobalValue(dictionary.new_dictionary(symbol_function(EQ), $int$256));
        }
        com.cyc.cycjava.cycl.lexicon_accessors.clear_cached_lexical_access_functions();
        return dictionary.clear_dictionary($speech_parts$.getGlobalValue());
    }

    public static SubLObject clear_speech_parts() {
        if (NIL == dictionary.dictionary_p($speech_parts$.getGlobalValue())) {
            $speech_parts$.setGlobalValue(dictionary.new_dictionary(symbol_function(EQL), $int$256));
        }
        clear_cached_lexical_access_functions();
        return dictionary.clear_dictionary($speech_parts$.getGlobalValue());
    }

    public static final SubLObject initialize_speech_parts_alt() {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            com.cyc.cycjava.cycl.lexicon_accessors.clear_speech_parts();
            {
                SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                try {
                    mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                    mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                    if (NIL != valid_constantP($$SpeechPart, UNPROVIDED)) {
                        {
                            SubLObject node_var = $$SpeechPart;
                            SubLObject deck_type = (false) ? ((SubLObject) ($QUEUE)) : $STACK;
                            SubLObject recur_deck = deck.create_deck(deck_type);
                            {
                                SubLObject _prev_bind_0_299 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                                try {
                                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                                    {
                                        SubLObject tv_var = NIL;
                                        {
                                            SubLObject _prev_bind_0_300 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                                            SubLObject _prev_bind_1_301 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                                            try {
                                                sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? ((SubLObject) (tv_var)) : sbhl_search_vars.get_sbhl_true_tv(), thread);
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? ((SubLObject) (RELEVANT_SBHL_TV_IS_GENERAL_TV)) : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                                                if (NIL != tv_var) {
                                                    if (NIL != sbhl_paranoia.sbhl_object_type_checking_p()) {
                                                        if (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var)) {
                                                            {
                                                                SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                                                if (pcase_var.eql($ERROR)) {
                                                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                } else {
                                                                    if (pcase_var.eql($CERROR)) {
                                                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                    } else {
                                                                        if (pcase_var.eql($WARN)) {
                                                                            Errors.warn($str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        } else {
                                                                            Errors.warn($str_alt51$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                                                            Errors.cerror($$$continue_anyway, $str_alt46$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    SubLObject _prev_bind_0_302 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                                                    SubLObject _prev_bind_1_303 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                                                    SubLObject _prev_bind_2 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                                                    SubLObject _prev_bind_3 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                    SubLObject _prev_bind_4 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                    try {
                                                        sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                        sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                                        if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$SpeechPart, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                                            {
                                                                SubLObject _prev_bind_0_304 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_1_305 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                                                SubLObject _prev_bind_2_306 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                try {
                                                                    sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                                                    while (NIL != node_var) {
                                                                        {
                                                                            SubLObject sp_type = node_var;
                                                                            SubLObject pred_var = $$isa;
                                                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(sp_type, TWO_INTEGER, pred_var)) {
                                                                                {
                                                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(sp_type, TWO_INTEGER, pred_var);
                                                                                    SubLObject done_var = NIL;
                                                                                    SubLObject token_var = NIL;
                                                                                    while (NIL == done_var) {
                                                                                        {
                                                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                                            if (NIL != valid) {
                                                                                                {
                                                                                                    SubLObject final_index_iterator = NIL;
                                                                                                    try {
                                                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                                                        {
                                                                                                            SubLObject done_var_307 = NIL;
                                                                                                            SubLObject token_var_308 = NIL;
                                                                                                            while (NIL == done_var_307) {
                                                                                                                {
                                                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_308);
                                                                                                                    SubLObject valid_309 = makeBoolean(token_var_308 != as);
                                                                                                                    if (NIL != valid_309) {
                                                                                                                        {
                                                                                                                            SubLObject sp = assertions_high.gaf_arg1(as);
                                                                                                                            SubLObject mt = assertions_high.assertion_mt(as);
                                                                                                                            dictionary_utilities.dictionary_push($speech_parts$.getGlobalValue(), sp, mt);
                                                                                                                        }
                                                                                                                    }
                                                                                                                    done_var_307 = makeBoolean(NIL == valid_309);
                                                                                                                }
                                                                                                            } 
                                                                                                        }
                                                                                                    } finally {
                                                                                                        {
                                                                                                            SubLObject _prev_bind_0_310 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                                            try {
                                                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                                                if (NIL != final_index_iterator) {
                                                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                                                }
                                                                                                            } finally {
                                                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_310, thread);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            done_var = makeBoolean(NIL == valid);
                                                                                        }
                                                                                    } 
                                                                                }
                                                                            }
                                                                        }
                                                                        {
                                                                            SubLObject accessible_modules = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                                                            SubLObject cdolist_list_var = accessible_modules;
                                                                            SubLObject module_var = NIL;
                                                                            for (module_var = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , module_var = cdolist_list_var.first()) {
                                                                                {
                                                                                    SubLObject _prev_bind_0_311 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                                                    SubLObject _prev_bind_1_312 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? ((SubLObject) (makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)))) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                                                        {
                                                                                            SubLObject node = function_terms.naut_to_nart(node_var);
                                                                                            if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                                                                {
                                                                                                    SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                    if (NIL != d_link) {
                                                                                                        {
                                                                                                            SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                            if (NIL != mt_links) {
                                                                                                                {
                                                                                                                    SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links));
                                                                                                                    while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                                                                                                                        thread.resetMultipleValues();
                                                                                                                        {
                                                                                                                            SubLObject mt = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                                                                            SubLObject tv_links = thread.secondMultipleValue();
                                                                                                                            thread.resetMultipleValues();
                                                                                                                            if (NIL != mt_relevance_macros.relevant_mtP(mt)) {
                                                                                                                                {
                                                                                                                                    SubLObject _prev_bind_0_313 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                                                                                    try {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.bind(mt, thread);
                                                                                                                                        {
                                                                                                                                            SubLObject iteration_state_314 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links));
                                                                                                                                            while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_314)) {
                                                                                                                                                thread.resetMultipleValues();
                                                                                                                                                {
                                                                                                                                                    SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_314);
                                                                                                                                                    SubLObject link_nodes = thread.secondMultipleValue();
                                                                                                                                                    thread.resetMultipleValues();
                                                                                                                                                    if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                                                                                        {
                                                                                                                                                            SubLObject _prev_bind_0_315 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                                                                                            try {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                                                                                                {
                                                                                                                                                                    SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                                                                    SubLObject cdolist_list_var_316 = new_list;
                                                                                                                                                                    SubLObject node_vars_link_node = NIL;
                                                                                                                                                                    for (node_vars_link_node = cdolist_list_var_316.first(); NIL != cdolist_list_var_316; cdolist_list_var_316 = cdolist_list_var_316.rest() , node_vars_link_node = cdolist_list_var_316.first()) {
                                                                                                                                                                        if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                                                            sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                                                            deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            } finally {
                                                                                                                                                                sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_315, thread);
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    iteration_state_314 = dictionary_contents.do_dictionary_contents_next(iteration_state_314);
                                                                                                                                                }
                                                                                                                                            } 
                                                                                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_314);
                                                                                                                                        }
                                                                                                                                    } finally {
                                                                                                                                        sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_313, thread);
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                                                                                                                        }
                                                                                                                    } 
                                                                                                                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str_alt54$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                                                                    {
                                                                                                        SubLObject new_list = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                                                                        SubLObject cdolist_list_var_317 = new_list;
                                                                                                        SubLObject generating_fn = NIL;
                                                                                                        for (generating_fn = cdolist_list_var_317.first(); NIL != cdolist_list_var_317; cdolist_list_var_317 = cdolist_list_var_317.rest() , generating_fn = cdolist_list_var_317.first()) {
                                                                                                            {
                                                                                                                SubLObject _prev_bind_0_318 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                                                                try {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                                                                    {
                                                                                                                        SubLObject link_nodes = funcall(generating_fn, node);
                                                                                                                        SubLObject new_list_319 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? ((SubLObject) (list_utilities.randomize_list(link_nodes))) : link_nodes;
                                                                                                                        SubLObject cdolist_list_var_320 = new_list_319;
                                                                                                                        SubLObject node_vars_link_node = NIL;
                                                                                                                        for (node_vars_link_node = cdolist_list_var_320.first(); NIL != cdolist_list_var_320; cdolist_list_var_320 = cdolist_list_var_320.rest() , node_vars_link_node = cdolist_list_var_320.first()) {
                                                                                                                            if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED)) {
                                                                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                                                deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } finally {
                                                                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_318, thread);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    } finally {
                                                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_312, thread);
                                                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_311, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        node_var = deck.deck_pop(recur_deck);
                                                                    } 
                                                                } finally {
                                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_306, thread);
                                                                    sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_305, thread);
                                                                    sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_304, thread);
                                                                }
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str_alt55$Node__a_does_not_pass_sbhl_type_t, $$SpeechPart, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } finally {
                                                        sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_4, thread);
                                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_3, thread);
                                                        sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_2, thread);
                                                        sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_303, thread);
                                                        sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_302, thread);
                                                    }
                                                }
                                            } finally {
                                                sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_301, thread);
                                                sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_300, thread);
                                            }
                                        }
                                        sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                                    }
                                } finally {
                                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_299, thread);
                                }
                            }
                        }
                    }
                } finally {
                    mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                    mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                }
            }
            return $speech_parts$.getGlobalValue();
        }
    }

    public static SubLObject initialize_speech_parts() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        clear_speech_parts();
        final SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$mt$.currentBinding(thread);
        try {
            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
            if (NIL != valid_constantP($$SpeechPart, UNPROVIDED)) {
                SubLObject node_var = $$SpeechPart;
                final SubLObject deck_type = $STACK;
                final SubLObject recur_deck = deck.create_deck(deck_type);
                final SubLObject _prev_bind_0_$290 = sbhl_marking_vars.$sbhl_space$.currentBinding(thread);
                try {
                    sbhl_marking_vars.$sbhl_space$.bind(sbhl_marking_vars.get_sbhl_marking_space(), thread);
                    try {
                        final SubLObject tv_var = NIL;
                        final SubLObject _prev_bind_0_$291 = sbhl_search_vars.$sbhl_tv$.currentBinding(thread);
                        final SubLObject _prev_bind_1_$292 = sbhl_search_vars.$relevant_sbhl_tv_function$.currentBinding(thread);
                        try {
                            sbhl_search_vars.$sbhl_tv$.bind(NIL != tv_var ? tv_var : sbhl_search_vars.get_sbhl_true_tv(), thread);
                            sbhl_search_vars.$relevant_sbhl_tv_function$.bind(NIL != tv_var ? RELEVANT_SBHL_TV_IS_GENERAL_TV : sbhl_search_vars.$relevant_sbhl_tv_function$.getDynamicValue(thread), thread);
                            if (((NIL != tv_var) && (NIL != sbhl_paranoia.sbhl_object_type_checking_p())) && (NIL == sbhl_search_vars.sbhl_true_tv_p(tv_var))) {
                                final SubLObject pcase_var = sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread);
                                if (pcase_var.eql($ERROR)) {
                                    sbhl_paranoia.sbhl_error(ONE_INTEGER, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                } else
                                    if (pcase_var.eql($CERROR)) {
                                        sbhl_paranoia.sbhl_cerror(ONE_INTEGER, $$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                    } else
                                        if (pcase_var.eql($WARN)) {
                                            Errors.warn($str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        } else {
                                            Errors.warn($str54$_A_is_not_a_valid__sbhl_type_erro, sbhl_paranoia.$sbhl_type_error_action$.getDynamicValue(thread));
                                            Errors.cerror($$$continue_anyway, $str49$_A_is_not_a__A, tv_var, SBHL_TRUE_TV_P);
                                        }


                            }
                            final SubLObject _prev_bind_0_$292 = sbhl_search_vars.$sbhl_search_module$.currentBinding(thread);
                            final SubLObject _prev_bind_1_$293 = sbhl_search_vars.$sbhl_search_module_type$.currentBinding(thread);
                            final SubLObject _prev_bind_3 = sbhl_search_vars.$sbhl_add_node_to_result_test$.currentBinding(thread);
                            final SubLObject _prev_bind_4 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                            final SubLObject _prev_bind_5 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                            try {
                                sbhl_search_vars.$sbhl_search_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                sbhl_search_vars.$sbhl_search_module_type$.bind(sbhl_module_utilities.get_sbhl_module_type(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.bind(sbhl_module_utilities.get_sbhl_add_node_to_result_test(sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                sbhl_module_vars.$sbhl_module$.bind(sbhl_module_vars.get_sbhl_module($$genls), thread);
                                if ((NIL != sbhl_paranoia.suspend_sbhl_type_checkingP()) || (NIL != sbhl_module_utilities.apply_sbhl_module_type_test($$SpeechPart, sbhl_module_vars.get_sbhl_module(UNPROVIDED)))) {
                                    final SubLObject _prev_bind_0_$293 = sbhl_search_vars.$sbhl_search_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_1_$294 = sbhl_link_vars.$sbhl_link_direction$.currentBinding(thread);
                                    final SubLObject _prev_bind_2_$297 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                    try {
                                        sbhl_search_vars.$sbhl_search_direction$.bind(sbhl_search_vars.get_sbhl_backward_search_direction(), thread);
                                        sbhl_link_vars.$sbhl_link_direction$.bind(sbhl_module_utilities.sbhl_search_direction_to_link_direction(sbhl_search_vars.get_sbhl_backward_search_direction(), sbhl_module_vars.get_sbhl_module($$genls)), thread);
                                        sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL, thread);
                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_var, UNPROVIDED);
                                        while (NIL != node_var) {
                                            final SubLObject sp_type = node_var;
                                            final SubLObject pred_var = $$isa;
                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(sp_type, TWO_INTEGER, pred_var)) {
                                                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(sp_type, TWO_INTEGER, pred_var);
                                                SubLObject done_var = NIL;
                                                final SubLObject token_var = NIL;
                                                while (NIL == done_var) {
                                                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                                    if (NIL != valid) {
                                                        SubLObject final_index_iterator = NIL;
                                                        try {
                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                            SubLObject done_var_$298 = NIL;
                                                            final SubLObject token_var_$299 = NIL;
                                                            while (NIL == done_var_$298) {
                                                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$299);
                                                                final SubLObject valid_$300 = makeBoolean(!token_var_$299.eql(as));
                                                                if (NIL != valid_$300) {
                                                                    final SubLObject sp = assertions_high.gaf_arg1(as);
                                                                    final SubLObject mt = assertions_high.assertion_mt(as);
                                                                    dictionary_utilities.dictionary_push($speech_parts$.getGlobalValue(), sp, mt);
                                                                }
                                                                done_var_$298 = makeBoolean(NIL == valid_$300);
                                                            } 
                                                        } finally {
                                                            final SubLObject _prev_bind_0_$294 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                            try {
                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                final SubLObject _values = getValuesAsVector();
                                                                if (NIL != final_index_iterator) {
                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                }
                                                                restoreValuesFromVector(_values);
                                                            } finally {
                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$294, thread);
                                                            }
                                                        }
                                                    }
                                                    done_var = makeBoolean(NIL == valid);
                                                } 
                                            }
                                            SubLObject cdolist_list_var;
                                            final SubLObject accessible_modules = cdolist_list_var = sbhl_macros.get_sbhl_accessible_modules(sbhl_module_vars.get_sbhl_module($$genls));
                                            SubLObject module_var = NIL;
                                            module_var = cdolist_list_var.first();
                                            while (NIL != cdolist_list_var) {
                                                final SubLObject _prev_bind_0_$295 = sbhl_module_vars.$sbhl_module$.currentBinding(thread);
                                                final SubLObject _prev_bind_1_$295 = sbhl_search_vars.$genl_inverse_mode_p$.currentBinding(thread);
                                                try {
                                                    sbhl_module_vars.$sbhl_module$.bind(module_var, thread);
                                                    sbhl_search_vars.$genl_inverse_mode_p$.bind(NIL != sbhl_search_vars.flip_genl_inverse_modeP(UNPROVIDED, UNPROVIDED) ? makeBoolean(NIL == sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread)) : sbhl_search_vars.$genl_inverse_mode_p$.getDynamicValue(thread), thread);
                                                    final SubLObject node = function_terms.naut_to_nart(node_var);
                                                    if (NIL != sbhl_link_vars.sbhl_node_object_p(node)) {
                                                        final SubLObject d_link = sbhl_graphs.get_sbhl_graph_link(node, sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                        if (NIL != d_link) {
                                                            final SubLObject mt_links = sbhl_links.get_sbhl_mt_links(d_link, sbhl_link_vars.get_sbhl_link_direction(), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            if (NIL != mt_links) {
                                                                SubLObject iteration_state;
                                                                for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(mt_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
                                                                    thread.resetMultipleValues();
                                                                    final SubLObject mt2 = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                                                                    final SubLObject tv_links = thread.secondMultipleValue();
                                                                    thread.resetMultipleValues();
                                                                    if (NIL != mt_relevance_macros.relevant_mtP(mt2)) {
                                                                        final SubLObject _prev_bind_0_$296 = sbhl_link_vars.$sbhl_link_mt$.currentBinding(thread);
                                                                        try {
                                                                            sbhl_link_vars.$sbhl_link_mt$.bind(mt2, thread);
                                                                            SubLObject iteration_state_$305;
                                                                            for (iteration_state_$305 = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents(tv_links)); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state_$305); iteration_state_$305 = dictionary_contents.do_dictionary_contents_next(iteration_state_$305)) {
                                                                                thread.resetMultipleValues();
                                                                                final SubLObject tv = dictionary_contents.do_dictionary_contents_key_value(iteration_state_$305);
                                                                                final SubLObject link_nodes = thread.secondMultipleValue();
                                                                                thread.resetMultipleValues();
                                                                                if (NIL != sbhl_search_vars.relevant_sbhl_tvP(tv)) {
                                                                                    final SubLObject _prev_bind_0_$297 = sbhl_link_vars.$sbhl_link_tv$.currentBinding(thread);
                                                                                    try {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.bind(tv, thread);
                                                                                        final SubLObject sol = link_nodes;
                                                                                        if (NIL != set.set_p(sol)) {
                                                                                            final SubLObject set_contents_var = set.do_set_internal(sol);
                                                                                            SubLObject basis_object;
                                                                                            SubLObject state;
                                                                                            SubLObject node_vars_link_node;
                                                                                            for (basis_object = set_contents.do_set_contents_basis_object(set_contents_var), state = NIL, state = set_contents.do_set_contents_initial_state(basis_object, set_contents_var); NIL == set_contents.do_set_contents_doneP(basis_object, state); state = set_contents.do_set_contents_update_state(state)) {
                                                                                                node_vars_link_node = set_contents.do_set_contents_next(basis_object, state);
                                                                                                if ((NIL != set_contents.do_set_contents_element_validP(state, node_vars_link_node)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node, UNPROVIDED))) {
                                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node, UNPROVIDED);
                                                                                                    deck.deck_push(node_vars_link_node, recur_deck);
                                                                                                }
                                                                                            }
                                                                                        } else
                                                                                            if (sol.isList()) {
                                                                                                SubLObject csome_list_var = sol;
                                                                                                SubLObject node_vars_link_node2 = NIL;
                                                                                                node_vars_link_node2 = csome_list_var.first();
                                                                                                while (NIL != csome_list_var) {
                                                                                                    if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node2, UNPROVIDED)) {
                                                                                                        sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node2, UNPROVIDED);
                                                                                                        deck.deck_push(node_vars_link_node2, recur_deck);
                                                                                                    }
                                                                                                    csome_list_var = csome_list_var.rest();
                                                                                                    node_vars_link_node2 = csome_list_var.first();
                                                                                                } 
                                                                                            } else {
                                                                                                Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol);
                                                                                            }

                                                                                    } finally {
                                                                                        sbhl_link_vars.$sbhl_link_tv$.rebind(_prev_bind_0_$297, thread);
                                                                                    }
                                                                                }
                                                                            }
                                                                            dictionary_contents.do_dictionary_contents_finalize(iteration_state_$305);
                                                                        } finally {
                                                                            sbhl_link_vars.$sbhl_link_mt$.rebind(_prev_bind_0_$296, thread);
                                                                        }
                                                                    }
                                                                }
                                                                dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                                                            }
                                                        } else {
                                                            sbhl_paranoia.sbhl_error(FIVE_INTEGER, $str58$attempting_to_bind_direction_link, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                        }
                                                    } else
                                                        if (NIL != obsolete.cnat_p(node, UNPROVIDED)) {
                                                            SubLObject cdolist_list_var_$307;
                                                            final SubLObject new_list = cdolist_list_var_$307 = (NIL != sbhl_link_vars.sbhl_randomize_lists_p()) ? list_utilities.randomize_list(sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED))) : sbhl_module_utilities.get_sbhl_module_relevant_naut_link_generators(sbhl_link_vars.get_sbhl_link_direction(), sbhl_search_vars.$sbhl_tv$.getDynamicValue(thread), sbhl_module_vars.get_sbhl_module(UNPROVIDED));
                                                            SubLObject generating_fn = NIL;
                                                            generating_fn = cdolist_list_var_$307.first();
                                                            while (NIL != cdolist_list_var_$307) {
                                                                final SubLObject _prev_bind_0_$298 = sbhl_link_vars.$sbhl_link_generator$.currentBinding(thread);
                                                                try {
                                                                    sbhl_link_vars.$sbhl_link_generator$.bind(generating_fn, thread);
                                                                    final SubLObject sol2;
                                                                    final SubLObject link_nodes2 = sol2 = funcall(generating_fn, node);
                                                                    if (NIL != set.set_p(sol2)) {
                                                                        final SubLObject set_contents_var2 = set.do_set_internal(sol2);
                                                                        SubLObject basis_object2;
                                                                        SubLObject state2;
                                                                        SubLObject node_vars_link_node3;
                                                                        for (basis_object2 = set_contents.do_set_contents_basis_object(set_contents_var2), state2 = NIL, state2 = set_contents.do_set_contents_initial_state(basis_object2, set_contents_var2); NIL == set_contents.do_set_contents_doneP(basis_object2, state2); state2 = set_contents.do_set_contents_update_state(state2)) {
                                                                            node_vars_link_node3 = set_contents.do_set_contents_next(basis_object2, state2);
                                                                            if ((NIL != set_contents.do_set_contents_element_validP(state2, node_vars_link_node3)) && (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node3, UNPROVIDED))) {
                                                                                sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node3, UNPROVIDED);
                                                                                deck.deck_push(node_vars_link_node3, recur_deck);
                                                                            }
                                                                        }
                                                                    } else
                                                                        if (sol2.isList()) {
                                                                            SubLObject csome_list_var2 = sol2;
                                                                            SubLObject node_vars_link_node4 = NIL;
                                                                            node_vars_link_node4 = csome_list_var2.first();
                                                                            while (NIL != csome_list_var2) {
                                                                                if (NIL == sbhl_marking_utilities.sbhl_search_path_termination_p(node_vars_link_node4, UNPROVIDED)) {
                                                                                    sbhl_marking_utilities.sbhl_mark_node_marked(node_vars_link_node4, UNPROVIDED);
                                                                                    deck.deck_push(node_vars_link_node4, recur_deck);
                                                                                }
                                                                                csome_list_var2 = csome_list_var2.rest();
                                                                                node_vars_link_node4 = csome_list_var2.first();
                                                                            } 
                                                                        } else {
                                                                            Errors.error($str57$_A_is_neither_SET_P_nor_LISTP_, sol2);
                                                                        }

                                                                } finally {
                                                                    sbhl_link_vars.$sbhl_link_generator$.rebind(_prev_bind_0_$298, thread);
                                                                }
                                                                cdolist_list_var_$307 = cdolist_list_var_$307.rest();
                                                                generating_fn = cdolist_list_var_$307.first();
                                                            } 
                                                        }

                                                } finally {
                                                    sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_1_$295, thread);
                                                    sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_0_$295, thread);
                                                }
                                                cdolist_list_var = cdolist_list_var.rest();
                                                module_var = cdolist_list_var.first();
                                            } 
                                            node_var = deck.deck_pop(recur_deck);
                                        } 
                                    } finally {
                                        sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_2_$297, thread);
                                        sbhl_link_vars.$sbhl_link_direction$.rebind(_prev_bind_1_$294, thread);
                                        sbhl_search_vars.$sbhl_search_direction$.rebind(_prev_bind_0_$293, thread);
                                    }
                                } else {
                                    sbhl_paranoia.sbhl_warn(TWO_INTEGER, $str59$Node__a_does_not_pass_sbhl_type_t, $$SpeechPart, sbhl_module_utilities.get_sbhl_type_test(sbhl_module_vars.get_sbhl_module(UNPROVIDED)), UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                }
                            } finally {
                                sbhl_module_vars.$sbhl_module$.rebind(_prev_bind_5, thread);
                                sbhl_search_vars.$genl_inverse_mode_p$.rebind(_prev_bind_4, thread);
                                sbhl_search_vars.$sbhl_add_node_to_result_test$.rebind(_prev_bind_3, thread);
                                sbhl_search_vars.$sbhl_search_module_type$.rebind(_prev_bind_1_$293, thread);
                                sbhl_search_vars.$sbhl_search_module$.rebind(_prev_bind_0_$292, thread);
                            }
                        } finally {
                            sbhl_search_vars.$relevant_sbhl_tv_function$.rebind(_prev_bind_1_$292, thread);
                            sbhl_search_vars.$sbhl_tv$.rebind(_prev_bind_0_$291, thread);
                        }
                    } finally {
                        final SubLObject _prev_bind_0_$299 = $is_thread_performing_cleanupP$.currentBinding(thread);
                        try {
                            $is_thread_performing_cleanupP$.bind(T, thread);
                            final SubLObject _values2 = getValuesAsVector();
                            sbhl_marking_vars.free_sbhl_marking_space(sbhl_marking_vars.$sbhl_space$.getDynamicValue(thread));
                            restoreValuesFromVector(_values2);
                        } finally {
                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$299, thread);
                        }
                    }
                } finally {
                    sbhl_marking_vars.$sbhl_space$.rebind(_prev_bind_0_$290, thread);
                }
            }
        } finally {
            mt_relevance_macros.$mt$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
        }
        return $speech_parts$.getGlobalValue();
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a #$SpeechPart?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a #$SpeechPart?")
    public static final SubLObject speech_partP_alt(SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        com.cyc.cycjava.cycl.lexicon_accessors.ensure_speech_parts_initialized();
        {
            SubLObject mts = dictionary.dictionary_lookup_without_values($speech_parts$.getGlobalValue(), obj, UNPROVIDED);
            SubLObject mt_okP = eq(mt, $$InferencePSC);
            if (NIL == mt_okP) {
                {
                    SubLObject csome_list_var = mts;
                    SubLObject ok_mt = NIL;
                    for (ok_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
                        mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, ok_mt);
                    }
                }
            }
            return makeBoolean((NIL != mts) && (NIL != mt_okP));
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is OBJ a #$SpeechPart?
     */
    @LispMethod(comment = "@return BOOLEAN; Is OBJ a #$SpeechPart?")
    public static SubLObject speech_partP(final SubLObject obj, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        ensure_speech_parts_initialized();
        final SubLObject mts = dictionary.dictionary_lookup_without_values($speech_parts$.getGlobalValue(), obj, UNPROVIDED);
        SubLObject mt_okP = kb_utilities.kbeq(mt, $$InferencePSC);
        if (NIL == mt_okP) {
            SubLObject csome_list_var;
            SubLObject ok_mt;
            for (csome_list_var = mts, ok_mt = NIL, ok_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, ok_mt) , csome_list_var = csome_list_var.rest() , ok_mt = csome_list_var.first()) {
            }
        }
        return makeBoolean((NIL != mts) && (NIL != mt_okP));
    }

    public static final SubLObject ensure_speech_parts_initialized_alt() {
        if (NIL == com.cyc.cycjava.cycl.lexicon_accessors.speech_parts_initializedP()) {
            com.cyc.cycjava.cycl.lexicon_accessors.initialize_speech_parts();
        }
        return $INITIALIZED;
    }

    public static SubLObject ensure_speech_parts_initialized() {
        if (NIL == speech_parts_initializedP()) {
            initialize_speech_parts();
        }
        return $INITIALIZED;
    }

    /**
     *
     *
     * @return LISTP; of all #$SpeechParts
     */
    @LispMethod(comment = "@return LISTP; of all #$SpeechParts")
    public static final SubLObject all_speech_parts_alt(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            com.cyc.cycjava.cycl.lexicon_accessors.ensure_speech_parts_initialized();
            if (mt == $$InferencePSC) {
                return dictionary.dictionary_keys($speech_parts$.getGlobalValue());
            } else {
                {
                    SubLObject ans = NIL;
                    SubLObject iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents($speech_parts$.getGlobalValue()));
                    while (NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state)) {
                        thread.resetMultipleValues();
                        {
                            SubLObject sp = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
                            SubLObject sp_mts = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            {
                                SubLObject mt_okP = NIL;
                                if (NIL == mt_okP) {
                                    {
                                        SubLObject csome_list_var = sp_mts;
                                        SubLObject sp_mt = NIL;
                                        for (sp_mt = csome_list_var.first(); !((NIL != mt_okP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , sp_mt = csome_list_var.first()) {
                                            mt_okP = com.cyc.cycjava.cycl.lexicon_accessors.genl_lexicon_mtP(mt, sp_mt);
                                        }
                                    }
                                }
                                if (NIL != mt_okP) {
                                    ans = cons(sp, ans);
                                }
                            }
                            iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state);
                        }
                    } 
                    dictionary_contents.do_dictionary_contents_finalize(iteration_state);
                    return ans;
                }
            }
        }
    }

    /**
     *
     *
     * @return LISTP; of all #$SpeechParts
     */
    @LispMethod(comment = "@return LISTP; of all #$SpeechParts")
    public static SubLObject all_speech_parts(SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = $$InferencePSC;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        ensure_speech_parts_initialized();
        if (NIL != kb_utilities.kbeq(mt, $$InferencePSC)) {
            return dictionary.dictionary_keys($speech_parts$.getGlobalValue());
        }
        SubLObject ans = NIL;
        SubLObject iteration_state;
        for (iteration_state = dictionary_contents.do_dictionary_contents_state(dictionary.dictionary_contents($speech_parts$.getGlobalValue())); NIL == dictionary_contents.do_dictionary_contents_doneP(iteration_state); iteration_state = dictionary_contents.do_dictionary_contents_next(iteration_state)) {
            thread.resetMultipleValues();
            final SubLObject sp = dictionary_contents.do_dictionary_contents_key_value(iteration_state);
            final SubLObject sp_mts = thread.secondMultipleValue();
            thread.resetMultipleValues();
            SubLObject mt_okP = NIL;
            if (NIL == mt_okP) {
                SubLObject csome_list_var;
                SubLObject sp_mt;
                for (csome_list_var = sp_mts, sp_mt = NIL, sp_mt = csome_list_var.first(); (NIL == mt_okP) && (NIL != csome_list_var); mt_okP = genl_lexicon_mtP(mt, sp_mt) , csome_list_var = csome_list_var.rest() , sp_mt = csome_list_var.first()) {
                }
            }
            if (NIL != mt_okP) {
                ans = cons(sp, ans);
            }
        }
        dictionary_contents.do_dictionary_contents_finalize(iteration_state);
        return ans;
    }

    public static final SubLObject clear_genl_posP_alt() {
        {
            SubLObject cs = $genl_posP_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_genl_posP() {
        final SubLObject cs = $genl_posP_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_genl_posP_alt(SubLObject spec_pos, SubLObject genl_pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = NIL;
        }
        return memoization_state.caching_state_remove_function_results_with_args($genl_posP_caching_state$.getGlobalValue(), list(spec_pos, genl_pos, mt), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_genl_posP(final SubLObject spec_pos, final SubLObject genl_pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = NIL;
        }
        return memoization_state.caching_state_remove_function_results_with_args($genl_posP_caching_state$.getGlobalValue(), list(spec_pos, genl_pos, mt), UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @param spec-pos;
    fort-p
     * 		
     * @param genl-pos;
    fort-p
     * 		
     * @return boolean : T if SPEC-POS is a spec of GENL-POS; nil otherwise.
     */
    @LispMethod(comment = "@param spec-pos;\nfort-p\r\n\t\t\r\n@param genl-pos;\nfort-p\r\n\t\t\r\n@return boolean : T if SPEC-POS is a spec of GENL-POS; nil otherwise.")
    public static final SubLObject genl_posP_internal_alt(SubLObject spec_pos, SubLObject genl_pos, SubLObject mt) {
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject result = NIL;
                if (NIL != mt) {
                    {
                        SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                        {
                            SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                            SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                            SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                            try {
                                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                                result = genls.genl_ofP(genl_pos, spec_pos, UNPROVIDED, UNPROVIDED);
                            } finally {
                                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                            }
                        }
                    }
                } else {
                    {
                        SubLObject _prev_bind_0 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                        SubLObject _prev_bind_1 = mt_relevance_macros.$mt$.currentBinding(thread);
                        try {
                            mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                            mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                            result = genls.genl_ofP(genl_pos, spec_pos, UNPROVIDED, UNPROVIDED);
                        } finally {
                            mt_relevance_macros.$mt$.rebind(_prev_bind_1, thread);
                            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_0, thread);
                        }
                    }
                }
                return result;
            }
        }
    }

    /**
     *
     *
     * @param spec-pos;
    fort-p
     * 		
     * @param genl-pos;
    fort-p
     * 		
     * @return boolean : T if SPEC-POS is a spec of GENL-POS; nil otherwise.
     */
    @LispMethod(comment = "@param spec-pos;\nfort-p\r\n\t\t\r\n@param genl-pos;\nfort-p\r\n\t\t\r\n@return boolean : T if SPEC-POS is a spec of GENL-POS; nil otherwise.")
    public static SubLObject genl_posP_internal(final SubLObject spec_pos, final SubLObject genl_pos, final SubLObject mt) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject result = NIL;
        if (NIL != mt) {
            final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
            final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
            final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
            try {
                mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                result = genls.genl_ofP(genl_pos, spec_pos, UNPROVIDED, UNPROVIDED);
            } finally {
                mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
                mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
            }
        } else {
            final SubLObject _prev_bind_4 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
            final SubLObject _prev_bind_5 = mt_relevance_macros.$mt$.currentBinding(thread);
            try {
                mt_relevance_macros.$relevant_mt_function$.bind(RELEVANT_MT_IS_EVERYTHING, thread);
                mt_relevance_macros.$mt$.bind($$EverythingPSC, thread);
                result = genls.genl_ofP(genl_pos, spec_pos, UNPROVIDED, UNPROVIDED);
            } finally {
                mt_relevance_macros.$mt$.rebind(_prev_bind_5, thread);
                mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_4, thread);
            }
        }
        return result;
    }

    public static final SubLObject genl_posP_alt(SubLObject spec_pos, SubLObject genl_pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = NIL;
        }
        {
            SubLObject caching_state = $genl_posP_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name($sym262$GENL_POS_, $sym263$_GENL_POS__CACHING_STATE_, NIL, EQUAL, THREE_INTEGER, $int$128);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_3(spec_pos, genl_pos, mt);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (spec_pos.equal(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (genl_pos.equal(cached_args.first())) {
                                        cached_args = cached_args.rest();
                                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                                            return memoization_state.caching_results(results2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.genl_posP_internal(spec_pos, genl_pos, mt)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(spec_pos, genl_pos, mt));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject genl_posP(final SubLObject spec_pos, final SubLObject genl_pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = NIL;
        }
        SubLObject caching_state = $genl_posP_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name($sym275$GENL_POS_, $sym276$_GENL_POS__CACHING_STATE_, NIL, EQUAL, THREE_INTEGER, $int$128);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_3(spec_pos, genl_pos, mt);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (spec_pos.equal(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (genl_pos.equal(cached_args.first())) {
                        cached_args = cached_args.rest();
                        if (((NIL != cached_args) && (NIL == cached_args.rest())) && mt.equal(cached_args.first())) {
                            return memoization_state.caching_results(results2);
                        }
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(genl_posP_internal(spec_pos, genl_pos, mt)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(spec_pos, genl_pos, mt));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @param spec-pos;
    fort-p
     * 		
     * @param pos-list;
    listp
     * 		
     * @return boolean : T if SPEC-POS is a spec of a part-of-speech in POS-LIST;
    nil otherwise.
     */
    @LispMethod(comment = "@param spec-pos;\nfort-p\r\n\t\t\r\n@param pos-list;\nlistp\r\n\t\t\r\n@return boolean : T if SPEC-POS is a spec of a part-of-speech in POS-LIST;\r\nnil otherwise.")
    public static final SubLObject genl_pos_memberP_alt(SubLObject spec_pos, SubLObject pos_list) {
        {
            SubLObject doneP = NIL;
            if (NIL == doneP) {
                {
                    SubLObject csome_list_var = pos_list;
                    SubLObject pos = NIL;
                    for (pos = csome_list_var.first(); !((NIL != doneP) || (NIL == csome_list_var)); csome_list_var = csome_list_var.rest() , pos = csome_list_var.first()) {
                        if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(spec_pos, pos, UNPROVIDED)) {
                            doneP = T;
                        }
                    }
                }
            }
            return doneP;
        }
    }

    /**
     *
     *
     * @param spec-pos;
    fort-p
     * 		
     * @param pos-list;
    listp
     * 		
     * @return boolean : T if SPEC-POS is a spec of a part-of-speech in POS-LIST;
    nil otherwise.
     */
    @LispMethod(comment = "@param spec-pos;\nfort-p\r\n\t\t\r\n@param pos-list;\nlistp\r\n\t\t\r\n@return boolean : T if SPEC-POS is a spec of a part-of-speech in POS-LIST;\r\nnil otherwise.")
    public static SubLObject genl_pos_memberP(final SubLObject spec_pos, final SubLObject pos_list) {
        SubLObject doneP = NIL;
        if (NIL == doneP) {
            SubLObject csome_list_var = pos_list;
            SubLObject pos = NIL;
            pos = csome_list_var.first();
            while ((NIL == doneP) && (NIL != csome_list_var)) {
                if (NIL != genl_posP(spec_pos, pos, UNPROVIDED)) {
                    doneP = T;
                }
                csome_list_var = csome_list_var.rest();
                pos = csome_list_var.first();
            } 
        }
        return doneP;
    }

    public static final SubLObject spec_posP_alt(SubLObject pos1, SubLObject pos2) {
        return com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(pos2, pos1, UNPROVIDED);
    }

    public static SubLObject spec_posP(final SubLObject pos1, final SubLObject pos2) {
        return genl_posP(pos2, pos1, UNPROVIDED);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to adjective phrases?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to adjective phrases?")
    public static final SubLObject adjpP_alt(SubLObject pos) {
        return equalp(com.cyc.cycjava.cycl.lexicon_accessors.safe_nart_hl_formula(pos), $list_alt265);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to adjective phrases?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to adjective phrases?")
    public static SubLObject adjpP(final SubLObject pos) {
        return equalp(safe_nart_hl_formula(pos), $list278);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to vbars?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to vbars?")
    public static final SubLObject vbarP_alt(SubLObject pos) {
        return com.cyc.cycjava.cycl.lexicon_accessors.object_is_compositional_pos_termP(pos, $$PhraseFn_Bar1, $$Verb);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to vbars?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to vbars?")
    public static SubLObject vbarP(final SubLObject pos) {
        return object_is_compositional_pos_termP(pos, $$PhraseFn_Bar1, $$Verb);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to nbars?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to nbars?")
    public static final SubLObject nbarP_alt(SubLObject pos) {
        return com.cyc.cycjava.cycl.lexicon_accessors.object_is_compositional_pos_termP(pos, $$PhraseFn_Bar1, $$Noun);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to nbars?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to nbars?")
    public static SubLObject nbarP(final SubLObject pos) {
        return object_is_compositional_pos_termP(pos, $$PhraseFn_Bar1, $$Noun);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to (PHRASE-FN GENL-POS)?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to (PHRASE-FN GENL-POS)?")
    public static final SubLObject object_is_compositional_pos_termP_alt(SubLObject v_object, SubLObject phrase_fn, SubLObject genl_pos) {
        if (NIL != narts_high.naut_p(v_object)) {
            return makeBoolean((cycl_utilities.nat_functor(v_object) == phrase_fn) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(cycl_utilities.nat_arg1(v_object, UNPROVIDED), genl_pos, UNPROVIDED)));
        } else {
            if (NIL != forts.fort_p(v_object)) {
                {
                    SubLObject nart = com.cyc.cycjava.cycl.lexicon_accessors.compositional_pos_nart(phrase_fn, genl_pos);
                    return makeBoolean((NIL != nart) && (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(v_object, nart, UNPROVIDED)));
                }
            } else {
                return NIL;
            }
        }
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to (PHRASE-FN GENL-POS)?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to (PHRASE-FN GENL-POS)?")
    public static SubLObject object_is_compositional_pos_termP(final SubLObject v_object, final SubLObject phrase_fn, final SubLObject genl_pos) {
        if (NIL != narts_high.naut_p(v_object)) {
            return makeBoolean((NIL != kb_utilities.kbeq(cycl_utilities.nat_functor(v_object), phrase_fn)) && (NIL != genl_posP(cycl_utilities.nat_arg1(v_object, UNPROVIDED), genl_pos, UNPROVIDED)));
        }
        if (NIL != forts.fort_p(v_object)) {
            final SubLObject nart = compositional_pos_nart(phrase_fn, genl_pos);
            return makeBoolean((NIL != nart) && (NIL != genl_posP(v_object, nart, UNPROVIDED)));
        }
        return NIL;
    }

    public static final SubLObject clear_compositional_pos_nart_alt() {
        {
            SubLObject cs = $compositional_pos_nart_caching_state$.getGlobalValue();
            if (NIL != cs) {
                memoization_state.caching_state_clear(cs);
            }
        }
        return NIL;
    }

    public static SubLObject clear_compositional_pos_nart() {
        final SubLObject cs = $compositional_pos_nart_caching_state$.getGlobalValue();
        if (NIL != cs) {
            memoization_state.caching_state_clear(cs);
        }
        return NIL;
    }

    public static final SubLObject remove_compositional_pos_nart_alt(SubLObject phrase_fn, SubLObject genl_pos) {
        return memoization_state.caching_state_remove_function_results_with_args($compositional_pos_nart_caching_state$.getGlobalValue(), list(phrase_fn, genl_pos), UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject remove_compositional_pos_nart(final SubLObject phrase_fn, final SubLObject genl_pos) {
        return memoization_state.caching_state_remove_function_results_with_args($compositional_pos_nart_caching_state$.getGlobalValue(), list(phrase_fn, genl_pos), UNPROVIDED, UNPROVIDED);
    }

    public static final SubLObject compositional_pos_nart_internal_alt(SubLObject phrase_fn, SubLObject genl_pos) {
        return narts_high.find_nart(make_unary_formula(phrase_fn, genl_pos));
    }

    public static SubLObject compositional_pos_nart_internal(final SubLObject phrase_fn, final SubLObject genl_pos) {
        return narts_high.find_nart(make_unary_formula(phrase_fn, genl_pos));
    }

    public static final SubLObject compositional_pos_nart_alt(SubLObject phrase_fn, SubLObject genl_pos) {
        {
            SubLObject caching_state = $compositional_pos_nart_caching_state$.getGlobalValue();
            if (NIL == caching_state) {
                caching_state = memoization_state.create_global_caching_state_for_name(COMPOSITIONAL_POS_NART, $compositional_pos_nart_caching_state$, NIL, EQL, TWO_INTEGER, ZERO_INTEGER);
            }
            {
                SubLObject sxhash = memoization_state.sxhash_calc_2(phrase_fn, genl_pos);
                SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
                if (collisions != $kw3$_MEMOIZED_ITEM_NOT_FOUND_) {
                    {
                        SubLObject cdolist_list_var = collisions;
                        SubLObject collision = NIL;
                        for (collision = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , collision = cdolist_list_var.first()) {
                            {
                                SubLObject cached_args = collision.first();
                                SubLObject results2 = second(collision);
                                if (phrase_fn.eql(cached_args.first())) {
                                    cached_args = cached_args.rest();
                                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && genl_pos.eql(cached_args.first())) {
                                        return memoization_state.caching_results(results2);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    SubLObject results = arg2(resetMultipleValues(), multiple_value_list(com.cyc.cycjava.cycl.lexicon_accessors.compositional_pos_nart_internal(phrase_fn, genl_pos)));
                    memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results, list(phrase_fn, genl_pos));
                    return memoization_state.caching_results(results);
                }
            }
        }
    }

    public static SubLObject compositional_pos_nart(final SubLObject phrase_fn, final SubLObject genl_pos) {
        SubLObject caching_state = $compositional_pos_nart_caching_state$.getGlobalValue();
        if (NIL == caching_state) {
            caching_state = memoization_state.create_global_caching_state_for_name(COMPOSITIONAL_POS_NART, $compositional_pos_nart_caching_state$, NIL, EQL, TWO_INTEGER, ZERO_INTEGER);
        }
        final SubLObject sxhash = memoization_state.sxhash_calc_2(phrase_fn, genl_pos);
        final SubLObject collisions = memoization_state.caching_state_lookup(caching_state, sxhash, UNPROVIDED);
        if (!collisions.eql(memoization_state.$memoized_item_not_found$.getGlobalValue())) {
            SubLObject cdolist_list_var = collisions;
            SubLObject collision = NIL;
            collision = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                SubLObject cached_args = collision.first();
                final SubLObject results2 = second(collision);
                if (phrase_fn.eql(cached_args.first())) {
                    cached_args = cached_args.rest();
                    if (((NIL != cached_args) && (NIL == cached_args.rest())) && genl_pos.eql(cached_args.first())) {
                        return memoization_state.caching_results(results2);
                    }
                }
                cdolist_list_var = cdolist_list_var.rest();
                collision = cdolist_list_var.first();
            } 
        }
        final SubLObject results3 = arg2(resetMultipleValues(), multiple_value_list(compositional_pos_nart_internal(phrase_fn, genl_pos)));
        memoization_state.caching_state_enter_multi_key_n(caching_state, sxhash, collisions, results3, list(phrase_fn, genl_pos));
        return memoization_state.caching_results(results3);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to noun phrases?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to noun phrases?")
    public static final SubLObject npP_alt(SubLObject pos) {
        return subl_promotions.memberP(com.cyc.cycjava.cycl.lexicon_accessors.safe_nart_hl_formula(pos), $list_alt269, symbol_function(EQUALP), UNPROVIDED);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to noun phrases?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to noun phrases?")
    public static SubLObject npP(final SubLObject pos) {
        return subl_promotions.memberP(safe_nart_hl_formula(pos), $list282, symbol_function(EQUALP), UNPROVIDED);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to prepositional phrases?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to prepositional phrases?")
    public static final SubLObject ppP_alt(SubLObject pos) {
        return subl_promotions.memberP(com.cyc.cycjava.cycl.lexicon_accessors.safe_nart_hl_formula(pos), $list_alt270, symbol_function(EQUALP), UNPROVIDED);
    }

    /**
     *
     *
     * @return BOOLEAN; Is POS a Cyc speech part corresponding to prepositional phrases?
     */
    @LispMethod(comment = "@return BOOLEAN; Is POS a Cyc speech part corresponding to prepositional phrases?")
    public static SubLObject ppP(final SubLObject pos) {
        return subl_promotions.memberP(safe_nart_hl_formula(pos), $list283, symbol_function(EQUALP), UNPROVIDED);
    }

    /**
     * If OBJ is a NART, return its HL formula, otherwise OBJ itself.
     */
    @LispMethod(comment = "If OBJ is a NART, return its HL formula, otherwise OBJ itself.")
    public static final SubLObject safe_nart_hl_formula_alt(SubLObject obj) {
        return NIL != nart_handles.nart_p(obj) ? ((SubLObject) (narts_high.nart_hl_formula(obj))) : obj;
    }

    @LispMethod(comment = "If OBJ is a NART, return its HL formula, otherwise OBJ itself.")
    public static SubLObject safe_nart_hl_formula(final SubLObject obj) {
        return NIL != nart_handles.nart_p(obj) ? narts_high.nart_hl_formula(obj) : obj;
    }/**
     * If OBJ is a NART, return its HL formula, otherwise OBJ itself.
     */


    /**
     *
     *
     * @param LEADING-STRINGS;
     * 		listp of stringp
     * @param WU;
     * 		CycL word unit.
     * @param FOLLOWING-STRINGS;
     * 		listp of stringp
     * @param POS;
     * 		something for which speech-part? returns T.
     * @param POSSESSOR;
     * 		CycL expression or :UNDETERMINED.
     * @param PRED;
     * 		Binary CycL predicate or :ANY.
     * @return LISTP of collection-denoting expressions for an nbar or noun phrase of the form (X's) Y,
    where
    - Y is a POS form of WU,
    - [LEADING-STRINGS Y FOLLOWING-STRINGS] denotes PRED (if specified), and
    - X denotes POSSESSOR (if specified).
     */
    @LispMethod(comment = "@param LEADING-STRINGS;\r\n\t\tlistp of stringp\r\n@param WU;\r\n\t\tCycL word unit.\r\n@param FOLLOWING-STRINGS;\r\n\t\tlistp of stringp\r\n@param POS;\r\n\t\tsomething for which speech-part? returns T.\r\n@param POSSESSOR;\r\n\t\tCycL expression or :UNDETERMINED.\r\n@param PRED;\r\n\t\tBinary CycL predicate or :ANY.\r\n@return LISTP of collection-denoting expressions for an nbar or noun phrase of the form (X\'s) Y,\r\nwhere\r\n- Y is a POS form of WU,\r\n- [LEADING-STRINGS Y FOLLOWING-STRINGS] denotes PRED (if specified), and\r\n- X denotes POSSESSOR (if specified).")
    public static final SubLObject relational_noun_denots_alt(SubLObject leading_strings, SubLObject wu, SubLObject following_strings, SubLObject pos, SubLObject possessor, SubLObject pred, SubLObject lexical_mt, SubLObject domain_mt) {
        if (possessor == UNPROVIDED) {
            possessor = $UNDETERMINED;
        }
        if (pred == UNPROVIDED) {
            pred = $ANY;
        }
        if (lexical_mt == UNPROVIDED) {
            lexical_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (domain_mt == UNPROVIDED) {
            domain_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        SubLTrampolineFile.checkType(leading_strings, LISTP);
        SubLTrampolineFile.checkType(wu, FORT_P);
        SubLTrampolineFile.checkType(following_strings, LISTP);
        SubLTrampolineFile.checkType(pos, $sym5$SPEECH_PART_);
        {
            SubLObject preds = (pred == $ANY) ? ((SubLObject) (com.cyc.cycjava.cycl.lexicon_accessors.relational_noun_preds(leading_strings, wu, following_strings, pos, lexical_mt))) : list(pred);
            SubLObject denots = NIL;
            if (NIL != com.cyc.cycjava.cycl.lexicon_accessors.genl_posP(pos, $$Noun, UNPROVIDED)) {
                {
                    SubLObject cdolist_list_var = preds;
                    SubLObject denoted_pred = NIL;
                    for (denoted_pred = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , denoted_pred = cdolist_list_var.first()) {
                        if (NIL != kb_accessors.binary_predicateP(denoted_pred)) {
                            {
                                SubLObject possessed_argnums = com.cyc.cycjava.cycl.lexicon_accessors.relational_noun_possessed_argnums(leading_strings, wu, following_strings, pos, denoted_pred, lexical_mt);
                                SubLObject cdolist_list_var_321 = possessed_argnums;
                                SubLObject possessed_argnum = NIL;
                                for (possessed_argnum = cdolist_list_var_321.first(); NIL != cdolist_list_var_321; cdolist_list_var_321 = cdolist_list_var_321.rest() , possessed_argnum = cdolist_list_var_321.first()) {
                                    {
                                        SubLObject template = NIL;
                                        SubLObject possessed_type = com.cyc.cycjava.cycl.lexicon_accessors.relational_noun_possessed_type(denoted_pred, possessed_argnum, domain_mt);
                                        SubLObject possessor_argnum = subtract(THREE_INTEGER, possessed_argnum);
                                        SubLObject possessor_type = (possessor == $UNDETERMINED) ? ((SubLObject) (com.cyc.cycjava.cycl.lexicon_accessors.relational_noun_possessor_type(denoted_pred, possessor_argnum, domain_mt))) : NIL;
                                        if (NIL == possessed_type) {
                                        } else {
                                            if (possessor != $UNDETERMINED) {
                                                template = com.cyc.cycjava.cycl.lexicon_accessors.relational_noun_denot_template_lookup(NIL, possessed_argnum);
                                            } else {
                                                if (NIL != possessor_type) {
                                                    template = com.cyc.cycjava.cycl.lexicon_accessors.relational_noun_denot_template_lookup(T, possessed_argnum);
                                                }
                                            }
                                        }
                                        if (NIL != template) {
                                            {
                                                SubLObject swap_alist = list(bq_cons($POSSESSED_TYPE, possessed_type), bq_cons($DENOTED_PRED, denoted_pred), bq_cons($POSSESSOR, possessor), bq_cons($POSSESSOR_TYPE, possessor_type));
                                                SubLObject result = cycl_utilities.expression_sublis(swap_alist, template, UNPROVIDED, UNPROVIDED);
                                                denots = cons(result, denots);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return denots;
            }
        }
        return NIL;
    }

    /**
     *
     *
     * @param LEADING-STRINGS;
     * 		listp of stringp
     * @param WU;
     * 		CycL word unit.
     * @param FOLLOWING-STRINGS;
     * 		listp of stringp
     * @param POS;
     * 		something for which speech-part? returns T.
     * @param POSSESSOR;
     * 		CycL expression or :UNDETERMINED.
     * @param PRED;
     * 		Binary CycL predicate or :ANY.
     * @return LISTP of collection-denoting expressions for an nbar or noun phrase of the form (X's) Y,
    where
    - Y is a POS form of WU,
    - [LEADING-STRINGS Y FOLLOWING-STRINGS] denotes PRED (if specified), and
    - X denotes POSSESSOR (if specified).
     */
    @LispMethod(comment = "@param LEADING-STRINGS;\r\n\t\tlistp of stringp\r\n@param WU;\r\n\t\tCycL word unit.\r\n@param FOLLOWING-STRINGS;\r\n\t\tlistp of stringp\r\n@param POS;\r\n\t\tsomething for which speech-part? returns T.\r\n@param POSSESSOR;\r\n\t\tCycL expression or :UNDETERMINED.\r\n@param PRED;\r\n\t\tBinary CycL predicate or :ANY.\r\n@return LISTP of collection-denoting expressions for an nbar or noun phrase of the form (X\'s) Y,\r\nwhere\r\n- Y is a POS form of WU,\r\n- [LEADING-STRINGS Y FOLLOWING-STRINGS] denotes PRED (if specified), and\r\n- X denotes POSSESSOR (if specified).")
    public static SubLObject relational_noun_denots(final SubLObject leading_strings, final SubLObject wu, final SubLObject following_strings, final SubLObject pos, SubLObject possessor, SubLObject pred, SubLObject lexical_mt, SubLObject domain_mt) {
        if (possessor == UNPROVIDED) {
            possessor = $UNDETERMINED;
        }
        if (pred == UNPROVIDED) {
            pred = $ANY;
        }
        if (lexical_mt == UNPROVIDED) {
            lexical_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if (domain_mt == UNPROVIDED) {
            domain_mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        assert NIL != listp(leading_strings) : "! listp(leading_strings) " + ("Types.listp(leading_strings) " + "CommonSymbols.NIL != Types.listp(leading_strings) ") + leading_strings;
        assert NIL != forts.fort_p(wu) : "! forts.fort_p(wu) " + ("forts.fort_p(wu) " + "CommonSymbols.NIL != forts.fort_p(wu) ") + wu;
        assert NIL != listp(following_strings) : "! listp(following_strings) " + ("Types.listp(following_strings) " + "CommonSymbols.NIL != Types.listp(following_strings) ") + following_strings;
        assert NIL != speech_partP(pos, UNPROVIDED) : "! lexicon_accessors.speech_partP(pos, .UNPROVIDED) " + ("lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) " + "CommonSymbols.NIL != lexicon_accessors.speech_partP(pos, CommonSymbols.UNPROVIDED) ") + pos;
        final SubLObject preds = (pred == $ANY) ? relational_noun_preds(leading_strings, wu, following_strings, pos, lexical_mt) : list(pred);
        SubLObject denots = NIL;
        if (NIL != genl_posP(pos, $$Noun, UNPROVIDED)) {
            SubLObject cdolist_list_var = preds;
            SubLObject denoted_pred = NIL;
            denoted_pred = cdolist_list_var.first();
            while (NIL != cdolist_list_var) {
                if (NIL != kb_accessors.binary_predicateP(denoted_pred)) {
                    SubLObject cdolist_list_var_$310;
                    final SubLObject possessed_argnums = cdolist_list_var_$310 = relational_noun_possessed_argnums(leading_strings, wu, following_strings, pos, denoted_pred, lexical_mt);
                    SubLObject possessed_argnum = NIL;
                    possessed_argnum = cdolist_list_var_$310.first();
                    while (NIL != cdolist_list_var_$310) {
                        SubLObject template = NIL;
                        final SubLObject possessed_type = relational_noun_possessed_type(denoted_pred, possessed_argnum, domain_mt);
                        final SubLObject possessor_argnum = subtract(THREE_INTEGER, possessed_argnum);
                        final SubLObject possessor_type = (possessor == $UNDETERMINED) ? relational_noun_possessor_type(denoted_pred, possessor_argnum, domain_mt) : NIL;
                        if (NIL != possessed_type) {
                            if (possessor != $UNDETERMINED) {
                                template = relational_noun_denot_template_lookup(NIL, possessed_argnum);
                            } else
                                if (NIL != possessor_type) {
                                    template = relational_noun_denot_template_lookup(T, possessed_argnum);
                                }

                        }
                        if (NIL != template) {
                            final SubLObject swap_alist = list(bq_cons($POSSESSED_TYPE, possessed_type), bq_cons($DENOTED_PRED, denoted_pred), bq_cons($POSSESSOR, possessor), bq_cons($POSSESSOR_TYPE, possessor_type));
                            final SubLObject result = cycl_utilities.expression_sublis(swap_alist, template, UNPROVIDED, UNPROVIDED);
                            denots = cons(result, denots);
                        }
                        cdolist_list_var_$310 = cdolist_list_var_$310.rest();
                        possessed_argnum = cdolist_list_var_$310.first();
                    } 
                }
                cdolist_list_var = cdolist_list_var.rest();
                denoted_pred = cdolist_list_var.first();
            } 
            return denots;
        }
        return NIL;
    }

    public static final SubLObject relational_noun_denot_template_lookup_alt(SubLObject type_levelP, SubLObject possessed_argnum) {
        return list_utilities.alist_lookup(list_utilities.alist_lookup($relational_noun_denot_templates$.getGlobalValue(), type_levelP, UNPROVIDED, UNPROVIDED), possessed_argnum, UNPROVIDED, UNPROVIDED);
    }

    public static SubLObject relational_noun_denot_template_lookup(final SubLObject type_levelP, final SubLObject possessed_argnum) {
        return list_utilities.alist_lookup(list_utilities.alist_lookup($relational_noun_denot_templates$.getGlobalValue(), type_levelP, UNPROVIDED, UNPROVIDED), possessed_argnum, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return LISTP of argnums (integers) of PRED which the POS form of WU
    plays when in a possessed form.
     */
    @LispMethod(comment = "@return LISTP of argnums (integers) of PRED which the POS form of WU\r\nplays when in a possessed form.")
    public static final SubLObject relational_noun_possessed_argnums_alt(SubLObject leading_strings, SubLObject wu, SubLObject following_strings, SubLObject pos, SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            {
                SubLObject ans = NIL;
                SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
                {
                    SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
                    SubLObject _prev_bind_1 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
                    SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
                    try {
                        mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
                        mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
                        mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
                        if ((NIL != leading_strings) && (NIL != following_strings)) {
                            {
                                SubLObject dair_pred = $$headMedialStringDenotesArgInReln;
                                if (kb_indexing.num_gaf_arg_index(wu, TWO_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                                    {
                                        SubLObject pred_var = dair_pred;
                                        if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, FIVE_INTEGER, pred_var)) {
                                            {
                                                SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, FIVE_INTEGER, pred_var);
                                                SubLObject done_var = NIL;
                                                SubLObject token_var = NIL;
                                                while (NIL == done_var) {
                                                    {
                                                        SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                        SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                        if (NIL != valid) {
                                                            {
                                                                SubLObject final_index_iterator = NIL;
                                                                try {
                                                                    final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                    {
                                                                        SubLObject done_var_322 = NIL;
                                                                        SubLObject token_var_323 = NIL;
                                                                        while (NIL == done_var_322) {
                                                                            {
                                                                                SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_323);
                                                                                SubLObject valid_324 = makeBoolean(token_var_323 != as);
                                                                                if (NIL != valid_324) {
                                                                                    thread.resetMultipleValues();
                                                                                    {
                                                                                        SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                                                        SubLObject as_wu = thread.secondMultipleValue();
                                                                                        SubLObject as_following_strings = thread.thirdMultipleValue();
                                                                                        SubLObject as_pos = thread.fourthMultipleValue();
                                                                                        thread.resetMultipleValues();
                                                                                        if (((as_pos.eql(pos) && as_wu.eql(wu)) && as_leading_strings.equal(leading_strings)) && as_following_strings.equal(following_strings)) {
                                                                                            ans = cons(assertions_high.gaf_arg(as, SIX_INTEGER), ans);
                                                                                        }
                                                                                    }
                                                                                }
                                                                                done_var_322 = makeBoolean(NIL == valid_324);
                                                                            }
                                                                        } 
                                                                    }
                                                                } finally {
                                                                    {
                                                                        SubLObject _prev_bind_0_325 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                        try {
                                                                            $is_thread_performing_cleanupP$.bind(T, thread);
                                                                            if (NIL != final_index_iterator) {
                                                                                kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                            }
                                                                        } finally {
                                                                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_325, thread);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        done_var = makeBoolean(NIL == valid);
                                                    }
                                                } 
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (NIL != leading_strings) {
                                {
                                    SubLObject dair_pred = $$multiWordStringDenotesArgInReln;
                                    if (kb_indexing.num_gaf_arg_index(wu, TWO_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                                        {
                                            SubLObject pred_var = dair_pred;
                                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, FOUR_INTEGER, pred_var)) {
                                                {
                                                    SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, FOUR_INTEGER, pred_var);
                                                    SubLObject done_var = NIL;
                                                    SubLObject token_var = NIL;
                                                    while (NIL == done_var) {
                                                        {
                                                            SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                            SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                            if (NIL != valid) {
                                                                {
                                                                    SubLObject final_index_iterator = NIL;
                                                                    try {
                                                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                        {
                                                                            SubLObject done_var_326 = NIL;
                                                                            SubLObject token_var_327 = NIL;
                                                                            while (NIL == done_var_326) {
                                                                                {
                                                                                    SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_327);
                                                                                    SubLObject valid_328 = makeBoolean(token_var_327 != as);
                                                                                    if (NIL != valid_328) {
                                                                                        thread.resetMultipleValues();
                                                                                        {
                                                                                            SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                                                            SubLObject as_wu = thread.secondMultipleValue();
                                                                                            SubLObject as_following_strings = thread.thirdMultipleValue();
                                                                                            SubLObject as_pos = thread.fourthMultipleValue();
                                                                                            thread.resetMultipleValues();
                                                                                            if ((as_pos.eql(pos) && as_wu.eql(wu)) && as_leading_strings.equal(leading_strings)) {
                                                                                                ans = cons(assertions_high.gaf_arg5(as), ans);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    done_var_326 = makeBoolean(NIL == valid_328);
                                                                                }
                                                                            } 
                                                                        }
                                                                    } finally {
                                                                        {
                                                                            SubLObject _prev_bind_0_329 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                            try {
                                                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                if (NIL != final_index_iterator) {
                                                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                }
                                                                            } finally {
                                                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_329, thread);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            done_var = makeBoolean(NIL == valid);
                                                        }
                                                    } 
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (NIL != following_strings) {
                                    {
                                        SubLObject dair_pred = $$compoundStringDenotesArgInReln;
                                        if (kb_indexing.num_gaf_arg_index(wu, ONE_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                                            {
                                                SubLObject pred_var = dair_pred;
                                                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, FOUR_INTEGER, pred_var)) {
                                                    {
                                                        SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, FOUR_INTEGER, pred_var);
                                                        SubLObject done_var = NIL;
                                                        SubLObject token_var = NIL;
                                                        while (NIL == done_var) {
                                                            {
                                                                SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                if (NIL != valid) {
                                                                    {
                                                                        SubLObject final_index_iterator = NIL;
                                                                        try {
                                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                            {
                                                                                SubLObject done_var_330 = NIL;
                                                                                SubLObject token_var_331 = NIL;
                                                                                while (NIL == done_var_330) {
                                                                                    {
                                                                                        SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_331);
                                                                                        SubLObject valid_332 = makeBoolean(token_var_331 != as);
                                                                                        if (NIL != valid_332) {
                                                                                            thread.resetMultipleValues();
                                                                                            {
                                                                                                SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                                                                SubLObject as_wu = thread.secondMultipleValue();
                                                                                                SubLObject as_following_strings = thread.thirdMultipleValue();
                                                                                                SubLObject as_pos = thread.fourthMultipleValue();
                                                                                                thread.resetMultipleValues();
                                                                                                if ((as_pos.eql(pos) && as_wu.eql(wu)) && as_following_strings.equal(following_strings)) {
                                                                                                    ans = cons(assertions_high.gaf_arg5(as), ans);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        done_var_330 = makeBoolean(NIL == valid_332);
                                                                                    }
                                                                                } 
                                                                            }
                                                                        } finally {
                                                                            {
                                                                                SubLObject _prev_bind_0_333 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                try {
                                                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                    if (NIL != final_index_iterator) {
                                                                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                    }
                                                                                } finally {
                                                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_333, thread);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                done_var = makeBoolean(NIL == valid);
                                                            }
                                                        } 
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    {
                                        SubLObject dair_pred = $$denotesArgInReln;
                                        if (kb_indexing.num_gaf_arg_index(wu, ONE_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                                            {
                                                SubLObject pred_var = dair_pred;
                                                if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(wu, NIL, pred_var)) {
                                                    {
                                                        SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(wu, NIL, pred_var);
                                                        SubLObject done_var = NIL;
                                                        SubLObject token_var = NIL;
                                                        while (NIL == done_var) {
                                                            {
                                                                SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                                                SubLObject valid = makeBoolean(token_var != final_index_spec);
                                                                if (NIL != valid) {
                                                                    {
                                                                        SubLObject final_index_iterator = NIL;
                                                                        try {
                                                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                                                            {
                                                                                SubLObject done_var_334 = NIL;
                                                                                SubLObject token_var_335 = NIL;
                                                                                while (NIL == done_var_334) {
                                                                                    {
                                                                                        SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_335);
                                                                                        SubLObject valid_336 = makeBoolean(token_var_335 != as);
                                                                                        if (NIL != valid_336) {
                                                                                            thread.resetMultipleValues();
                                                                                            {
                                                                                                SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                                                                SubLObject as_wu = thread.secondMultipleValue();
                                                                                                SubLObject as_following_strings = thread.thirdMultipleValue();
                                                                                                SubLObject as_pos = thread.fourthMultipleValue();
                                                                                                SubLObject as_denot = thread.fifthMultipleValue();
                                                                                                thread.resetMultipleValues();
                                                                                                if ((as_pos.eql(pos) && as_denot.equal(pred)) && as_wu.eql(wu)) {
                                                                                                    ans = cons(assertions_high.gaf_arg4(as), ans);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        done_var_334 = makeBoolean(NIL == valid_336);
                                                                                    }
                                                                                } 
                                                                            }
                                                                        } finally {
                                                                            {
                                                                                SubLObject _prev_bind_0_337 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                                                                try {
                                                                                    $is_thread_performing_cleanupP$.bind(T, thread);
                                                                                    if (NIL != final_index_iterator) {
                                                                                        kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                                                    }
                                                                                } finally {
                                                                                    $is_thread_performing_cleanupP$.rebind(_prev_bind_0_337, thread);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                done_var = makeBoolean(NIL == valid);
                                                            }
                                                        } 
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_2, thread);
                        mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_1, thread);
                        mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
                    }
                }
                if (((NIL != list_utilities.non_empty_list_p(ans)) && (NIL != forts.fort_p(pred))) && (NIL != fort_types_interface.symmetric_binary_predicate_p(pred))) {
                    ans = $list_alt281;
                }
                return ans;
            }
        }
    }

    /**
     *
     *
     * @return LISTP of argnums (integers) of PRED which the POS form of WU
    plays when in a possessed form.
     */
    @LispMethod(comment = "@return LISTP of argnums (integers) of PRED which the POS form of WU\r\nplays when in a possessed form.")
    public static SubLObject relational_noun_possessed_argnums(final SubLObject leading_strings, final SubLObject wu, final SubLObject following_strings, final SubLObject pos, final SubLObject pred, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        SubLObject ans = NIL;
        final SubLObject mt_var = mt_relevance_macros.with_inference_mt_relevance_validate(mt);
        final SubLObject _prev_bind_0 = mt_relevance_macros.$mt$.currentBinding(thread);
        final SubLObject _prev_bind_2 = mt_relevance_macros.$relevant_mt_function$.currentBinding(thread);
        final SubLObject _prev_bind_3 = mt_relevance_macros.$relevant_mts$.currentBinding(thread);
        try {
            mt_relevance_macros.$mt$.bind(mt_relevance_macros.update_inference_mt_relevance_mt(mt_var), thread);
            mt_relevance_macros.$relevant_mt_function$.bind(mt_relevance_macros.update_inference_mt_relevance_function(mt_var), thread);
            mt_relevance_macros.$relevant_mts$.bind(mt_relevance_macros.update_inference_mt_relevance_mt_list(mt_var), thread);
            if ((NIL != leading_strings) && (NIL != following_strings)) {
                final SubLObject dair_pred = $$headMedialStringDenotesArgInReln;
                if (kb_indexing.num_gaf_arg_index(wu, TWO_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                    final SubLObject pred_var = dair_pred;
                    if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, FIVE_INTEGER, pred_var)) {
                        final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, FIVE_INTEGER, pred_var);
                        SubLObject done_var = NIL;
                        final SubLObject token_var = NIL;
                        while (NIL == done_var) {
                            final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                            final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                            if (NIL != valid) {
                                SubLObject final_index_iterator = NIL;
                                try {
                                    final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                    SubLObject done_var_$311 = NIL;
                                    final SubLObject token_var_$312 = NIL;
                                    while (NIL == done_var_$311) {
                                        final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$312);
                                        final SubLObject valid_$313 = makeBoolean(!token_var_$312.eql(as));
                                        if (NIL != valid_$313) {
                                            thread.resetMultipleValues();
                                            final SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                            final SubLObject as_wu = thread.secondMultipleValue();
                                            final SubLObject as_following_strings = thread.thirdMultipleValue();
                                            final SubLObject as_pos = thread.fourthMultipleValue();
                                            thread.resetMultipleValues();
                                            if (((as_pos.eql(pos) && as_wu.eql(wu)) && as_leading_strings.equal(leading_strings)) && as_following_strings.equal(following_strings)) {
                                                ans = cons(assertions_high.gaf_arg(as, SIX_INTEGER), ans);
                                            }
                                        }
                                        done_var_$311 = makeBoolean(NIL == valid_$313);
                                    } 
                                } finally {
                                    final SubLObject _prev_bind_0_$314 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                    try {
                                        $is_thread_performing_cleanupP$.bind(T, thread);
                                        final SubLObject _values = getValuesAsVector();
                                        if (NIL != final_index_iterator) {
                                            kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                        }
                                        restoreValuesFromVector(_values);
                                    } finally {
                                        $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$314, thread);
                                    }
                                }
                            }
                            done_var = makeBoolean(NIL == valid);
                        } 
                    }
                }
            } else
                if (NIL != leading_strings) {
                    final SubLObject dair_pred = $$multiWordStringDenotesArgInReln;
                    if (kb_indexing.num_gaf_arg_index(wu, TWO_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                        final SubLObject pred_var = dair_pred;
                        if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, FOUR_INTEGER, pred_var)) {
                            final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, FOUR_INTEGER, pred_var);
                            SubLObject done_var = NIL;
                            final SubLObject token_var = NIL;
                            while (NIL == done_var) {
                                final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                if (NIL != valid) {
                                    SubLObject final_index_iterator = NIL;
                                    try {
                                        final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                        SubLObject done_var_$312 = NIL;
                                        final SubLObject token_var_$313 = NIL;
                                        while (NIL == done_var_$312) {
                                            final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$313);
                                            final SubLObject valid_$314 = makeBoolean(!token_var_$313.eql(as));
                                            if (NIL != valid_$314) {
                                                thread.resetMultipleValues();
                                                final SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                final SubLObject as_wu = thread.secondMultipleValue();
                                                final SubLObject as_following_strings = thread.thirdMultipleValue();
                                                final SubLObject as_pos = thread.fourthMultipleValue();
                                                thread.resetMultipleValues();
                                                if ((as_pos.eql(pos) && as_wu.eql(wu)) && as_leading_strings.equal(leading_strings)) {
                                                    ans = cons(assertions_high.gaf_arg5(as), ans);
                                                }
                                            }
                                            done_var_$312 = makeBoolean(NIL == valid_$314);
                                        } 
                                    } finally {
                                        final SubLObject _prev_bind_0_$315 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                        try {
                                            $is_thread_performing_cleanupP$.bind(T, thread);
                                            final SubLObject _values2 = getValuesAsVector();
                                            if (NIL != final_index_iterator) {
                                                kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                            }
                                            restoreValuesFromVector(_values2);
                                        } finally {
                                            $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$315, thread);
                                        }
                                    }
                                }
                                done_var = makeBoolean(NIL == valid);
                            } 
                        }
                    }
                } else
                    if (NIL != following_strings) {
                        final SubLObject dair_pred = $$compoundStringDenotesArgInReln;
                        if (kb_indexing.num_gaf_arg_index(wu, ONE_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                            final SubLObject pred_var = dair_pred;
                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(pred, FOUR_INTEGER, pred_var)) {
                                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(pred, FOUR_INTEGER, pred_var);
                                SubLObject done_var = NIL;
                                final SubLObject token_var = NIL;
                                while (NIL == done_var) {
                                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                    if (NIL != valid) {
                                        SubLObject final_index_iterator = NIL;
                                        try {
                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                            SubLObject done_var_$313 = NIL;
                                            final SubLObject token_var_$314 = NIL;
                                            while (NIL == done_var_$313) {
                                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$314);
                                                final SubLObject valid_$315 = makeBoolean(!token_var_$314.eql(as));
                                                if (NIL != valid_$315) {
                                                    thread.resetMultipleValues();
                                                    final SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                    final SubLObject as_wu = thread.secondMultipleValue();
                                                    final SubLObject as_following_strings = thread.thirdMultipleValue();
                                                    final SubLObject as_pos = thread.fourthMultipleValue();
                                                    thread.resetMultipleValues();
                                                    if ((as_pos.eql(pos) && as_wu.eql(wu)) && as_following_strings.equal(following_strings)) {
                                                        ans = cons(assertions_high.gaf_arg5(as), ans);
                                                    }
                                                }
                                                done_var_$313 = makeBoolean(NIL == valid_$315);
                                            } 
                                        } finally {
                                            final SubLObject _prev_bind_0_$316 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                            try {
                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                final SubLObject _values3 = getValuesAsVector();
                                                if (NIL != final_index_iterator) {
                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                }
                                                restoreValuesFromVector(_values3);
                                            } finally {
                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$316, thread);
                                            }
                                        }
                                    }
                                    done_var = makeBoolean(NIL == valid);
                                } 
                            }
                        }
                    } else {
                        final SubLObject dair_pred = $$denotesArgInReln;
                        if (kb_indexing.num_gaf_arg_index(wu, ONE_INTEGER, dair_pred, UNPROVIDED).isPositive()) {
                            final SubLObject pred_var = dair_pred;
                            if (NIL != kb_mapping_macros.do_gaf_arg_index_key_validator(wu, NIL, pred_var)) {
                                final SubLObject iterator_var = kb_mapping_macros.new_gaf_arg_final_index_spec_iterator(wu, NIL, pred_var);
                                SubLObject done_var = NIL;
                                final SubLObject token_var = NIL;
                                while (NIL == done_var) {
                                    final SubLObject final_index_spec = iteration.iteration_next_without_values_macro_helper(iterator_var, token_var);
                                    final SubLObject valid = makeBoolean(!token_var.eql(final_index_spec));
                                    if (NIL != valid) {
                                        SubLObject final_index_iterator = NIL;
                                        try {
                                            final_index_iterator = kb_mapping_macros.new_final_index_iterator(final_index_spec, $GAF, $TRUE, NIL);
                                            SubLObject done_var_$314 = NIL;
                                            final SubLObject token_var_$315 = NIL;
                                            while (NIL == done_var_$314) {
                                                final SubLObject as = iteration.iteration_next_without_values_macro_helper(final_index_iterator, token_var_$315);
                                                final SubLObject valid_$316 = makeBoolean(!token_var_$315.eql(as));
                                                if (NIL != valid_$316) {
                                                    thread.resetMultipleValues();
                                                    final SubLObject as_leading_strings = lexicon_utilities.parse_lexical_semantic_formula(assertions_high.gaf_formula(as), UNPROVIDED);
                                                    final SubLObject as_wu = thread.secondMultipleValue();
                                                    final SubLObject as_following_strings = thread.thirdMultipleValue();
                                                    final SubLObject as_pos = thread.fourthMultipleValue();
                                                    final SubLObject as_denot = thread.fifthMultipleValue();
                                                    thread.resetMultipleValues();
                                                    if ((as_pos.eql(pos) && as_denot.equal(pred)) && as_wu.eql(wu)) {
                                                        ans = cons(assertions_high.gaf_arg4(as), ans);
                                                    }
                                                }
                                                done_var_$314 = makeBoolean(NIL == valid_$316);
                                            } 
                                        } finally {
                                            final SubLObject _prev_bind_0_$317 = $is_thread_performing_cleanupP$.currentBinding(thread);
                                            try {
                                                $is_thread_performing_cleanupP$.bind(T, thread);
                                                final SubLObject _values4 = getValuesAsVector();
                                                if (NIL != final_index_iterator) {
                                                    kb_mapping_macros.destroy_final_index_iterator(final_index_iterator);
                                                }
                                                restoreValuesFromVector(_values4);
                                            } finally {
                                                $is_thread_performing_cleanupP$.rebind(_prev_bind_0_$317, thread);
                                            }
                                        }
                                    }
                                    done_var = makeBoolean(NIL == valid);
                                } 
                            }
                        }
                    }


        } finally {
            mt_relevance_macros.$relevant_mts$.rebind(_prev_bind_3, thread);
            mt_relevance_macros.$relevant_mt_function$.rebind(_prev_bind_2, thread);
            mt_relevance_macros.$mt$.rebind(_prev_bind_0, thread);
        }
        if (((NIL != list_utilities.non_empty_list_p(ans)) && (NIL != forts.fort_p(pred))) && (NIL != fort_types_interface.symmetric_binary_predicate_p(pred))) {
            ans = $list294;
        }
        return ans;
    }

    /**
     *
     *
     * @return LISTP of argnums (integers) of PRED which the POS form of WU
    plays when in a possessed form.
     */
    @LispMethod(comment = "@return LISTP of argnums (integers) of PRED which the POS form of WU\r\nplays when in a possessed form.")
    public static final SubLObject relational_noun_preds_alt(SubLObject leading_strings, SubLObject wu, SubLObject following_strings, SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if ((NIL != leading_strings) && (NIL != following_strings)) {
            return ask_utilities.ask_variable($sym282$_PRED, listS($$headMedialStringDenotesArgInReln, leading_strings, wu, following_strings, pos, $list_alt283), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        } else {
            if (NIL != leading_strings) {
                return ask_utilities.ask_variable($sym282$_PRED, listS($$multiWordStringDenotesArgInReln, leading_strings, wu, pos, $list_alt283), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
            } else {
                if (NIL != following_strings) {
                    return ask_utilities.ask_variable($sym282$_PRED, listS($$compoundStringDenotesArgInReln, wu, following_strings, pos, $list_alt283), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                } else {
                    return ask_utilities.ask_variable($sym282$_PRED, listS($$denotesArgInReln, wu, pos, $list_alt283), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                }
            }
        }
    }

    /**
     *
     *
     * @return LISTP of argnums (integers) of PRED which the POS form of WU
    plays when in a possessed form.
     */
    @LispMethod(comment = "@return LISTP of argnums (integers) of PRED which the POS form of WU\r\nplays when in a possessed form.")
    public static SubLObject relational_noun_preds(final SubLObject leading_strings, final SubLObject wu, final SubLObject following_strings, final SubLObject pos, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        if ((NIL != leading_strings) && (NIL != following_strings)) {
            return ask_utilities.ask_variable($sym295$_PRED, listS($$headMedialStringDenotesArgInReln, leading_strings, wu, following_strings, pos, $list296), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        if (NIL != leading_strings) {
            return ask_utilities.ask_variable($sym295$_PRED, listS($$multiWordStringDenotesArgInReln, leading_strings, wu, pos, $list296), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        if (NIL != following_strings) {
            return ask_utilities.ask_variable($sym295$_PRED, listS($$compoundStringDenotesArgInReln, wu, following_strings, pos, $list296), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
        }
        return ask_utilities.ask_variable($sym295$_PRED, listS($$denotesArgInReln, wu, pos, $list296), mt, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
    }

    /**
     *
     *
     * @return FORT-P or NIL; A collection which the ARGNUMth arg of PRED must be an instance.
     */
    @LispMethod(comment = "@return FORT-P or NIL; A collection which the ARGNUMth arg of PRED must be an instance.")
    public static final SubLObject relational_noun_possessed_type_alt(SubLObject pred, SubLObject argnum, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject tightest_constraint = kb_accessors.min_argn_isa(pred, argnum, mt).first();
            return NIL != tightest_constraint ? ((SubLObject) (tightest_constraint)) : $$Thing;
        }
    }

    /**
     *
     *
     * @return FORT-P or NIL; A collection which the ARGNUMth arg of PRED must be an instance.
     */
    @LispMethod(comment = "@return FORT-P or NIL; A collection which the ARGNUMth arg of PRED must be an instance.")
    public static SubLObject relational_noun_possessed_type(final SubLObject pred, final SubLObject argnum, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLObject tightest_constraint = kb_accessors.min_argn_isa(pred, argnum, mt).first();
        return NIL != tightest_constraint ? tightest_constraint : $$Thing;
    }

    public static final SubLObject relational_noun_possessor_type_alt(SubLObject pred, SubLObject argnum, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        {
            SubLObject tightest_constraint = kb_accessors.min_argn_isa(pred, argnum, mt).first();
            return NIL != tightest_constraint ? ((SubLObject) (tightest_constraint)) : $$Thing;
        }
    }

    public static SubLObject relational_noun_possessor_type(final SubLObject pred, final SubLObject argnum, SubLObject mt) {
        if (mt == UNPROVIDED) {
            mt = lexicon_vars.$lexicon_lookup_mt$.getDynamicValue();
        }
        final SubLObject tightest_constraint = kb_accessors.min_argn_isa(pred, argnum, mt).first();
        return NIL != tightest_constraint ? tightest_constraint : $$Thing;
    }

    public static final SubLObject la_test_func_alt(SubLObject thing1, SubLObject thing2) {
        {
            SubLObject cdolist_list_var = thing2;
            SubLObject item = NIL;
            for (item = cdolist_list_var.first(); NIL != cdolist_list_var; cdolist_list_var = cdolist_list_var.rest() , item = cdolist_list_var.first()) {
                if (NIL == subl_promotions.memberP(narts_high.nart_substitute(item), narts_high.nart_substitute(thing1), EQUAL, UNPROVIDED)) {
                    Errors.warn($str_alt294$missing___S, item);
                    return NIL;
                }
            }
        }
        return T;
    }

    public static SubLObject la_test_func(final SubLObject thing1, final SubLObject thing2) {
        SubLObject cdolist_list_var = thing2;
        SubLObject item = NIL;
        item = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            if (NIL == subl_promotions.memberP(narts_high.nart_substitute(item), narts_high.nart_substitute(thing1), EQUAL, UNPROVIDED)) {
                Errors.warn($str306$missing___S, item);
                return NIL;
            }
            cdolist_list_var = cdolist_list_var.rest();
            item = cdolist_list_var.first();
        } 
        return T;
    }

    public static final SubLObject denotation_mapper_test_alt(SubLObject string, SubLObject excluded_preds, SubLObject mode, SubLObject parse_morphologically) {
        if (excluded_preds == UNPROVIDED) {
            excluded_preds = NIL;
        }
        if (mode == UNPROVIDED) {
            mode = $GREEDY;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        {
            final SubLThread thread = SubLProcess.currentSubLThread();
            thread.resetMultipleValues();
            {
                SubLObject result = com.cyc.cycjava.cycl.lexicon_accessors.denotation_mapper(string, excluded_preds, mode, parse_morphologically);
                SubLObject failure = thread.secondMultipleValue();
                thread.resetMultipleValues();
                result = transform_list_utilities.transform(result, HL_TERM_WITH_EL_COUNTERPART_P, HL_TERM_TO_EL_TERM, UNPROVIDED);
                return values(result, failure);
            }
        }
    }

    public static SubLObject denotation_mapper_test(final SubLObject string, SubLObject excluded_preds, SubLObject mode, SubLObject parse_morphologically) {
        if (excluded_preds == UNPROVIDED) {
            excluded_preds = NIL;
        }
        if (mode == UNPROVIDED) {
            mode = $GREEDY;
        }
        if (parse_morphologically == UNPROVIDED) {
            parse_morphologically = lexicon_vars.$parse_morphologically$.getDynamicValue();
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        thread.resetMultipleValues();
        SubLObject result = denotation_mapper(string, excluded_preds, mode, parse_morphologically);
        final SubLObject failure = thread.secondMultipleValue();
        thread.resetMultipleValues();
        result = transform_list_utilities.transform(result, HL_TERM_WITH_EL_COUNTERPART_P, HL_TERM_TO_EL_TERM, UNPROVIDED);
        return values(result, failure);
    }

    public static final SubLObject declare_lexicon_accessors_file_alt() {
        declareFunction("clear_genl_lexicon_mtP", "CLEAR-GENL-LEXICON-MT?", 0, 0, false);
        declareFunction("remove_genl_lexicon_mtP", "REMOVE-GENL-LEXICON-MT?", 2, 0, false);
        declareFunction("genl_lexicon_mtP_internal", "GENL-LEXICON-MT?-INTERNAL", 2, 0, false);
        declareFunction("genl_lexicon_mtP", "GENL-LEXICON-MT?", 2, 0, false);
        declareFunction("initialize_speech_part_caches", "INITIALIZE-SPEECH-PART-CACHES", 0, 0, false);
        declareFunction("preds_matching_pos", "PREDS-MATCHING-POS", 2, 1, false);
        declareFunction("top_level_nl_preds", "TOP-LEVEL-NL-PREDS", 0, 0, false);
        declareFunction("clear_speech_part_pred_caches", "CLEAR-SPEECH-PART-PRED-CACHES", 0, 0, false);
        declareFunction("max_preds_matching_pos", "MAX-PREDS-MATCHING-POS", 3, 1, false);
        declareFunction("clear_max_preds_matching_pos_cached", "CLEAR-MAX-PREDS-MATCHING-POS-CACHED", 0, 0, false);
        declareFunction("remove_max_preds_matching_pos_cached", "REMOVE-MAX-PREDS-MATCHING-POS-CACHED", 4, 0, false);
        declareFunction("max_preds_matching_pos_cached_internal", "MAX-PREDS-MATCHING-POS-CACHED-INTERNAL", 4, 0, false);
        declareFunction("max_preds_matching_pos_cached", "MAX-PREDS-MATCHING-POS-CACHED", 4, 0, false);
        declareFunction("all_preds_of_pos", "ALL-PREDS-OF-POS", 1, 0, false);
        declareFunction("clear_max_preds_of_pos", "CLEAR-MAX-PREDS-OF-POS", 0, 0, false);
        declareFunction("remove_max_preds_of_pos", "REMOVE-MAX-PREDS-OF-POS", 1, 0, false);
        declareFunction("max_preds_of_pos_internal", "MAX-PREDS-OF-POS-INTERNAL", 1, 0, false);
        declareFunction("max_preds_of_pos", "MAX-PREDS-OF-POS", 1, 0, false);
        declareFunction("clear_max_preds_licensed_by_pos", "CLEAR-MAX-PREDS-LICENSED-BY-POS", 0, 0, false);
        declareFunction("remove_max_preds_licensed_by_pos", "REMOVE-MAX-PREDS-LICENSED-BY-POS", 1, 0, false);
        declareFunction("max_preds_licensed_by_pos_internal", "MAX-PREDS-LICENSED-BY-POS-INTERNAL", 1, 0, false);
        declareFunction("max_preds_licensed_by_pos", "MAX-PREDS-LICENSED-BY-POS", 1, 0, false);
        declareFunction("lex_remove_spec_preds", "LEX-REMOVE-SPEC-PREDS", 1, 0, false);
        declareFunction("lex_remove_spec_preds_helper_internal", "LEX-REMOVE-SPEC-PREDS-HELPER-INTERNAL", 1, 0, false);
        declareFunction("lex_remove_spec_preds_helper", "LEX-REMOVE-SPEC-PREDS-HELPER", 1, 0, false);
        declareFunction("speech_part_pred_min_ceilings", "SPEECH-PART-PRED-MIN-CEILINGS", 1, 1, false);
        declareFunction("clear_speech_part_pred_min_ceilings_int", "CLEAR-SPEECH-PART-PRED-MIN-CEILINGS-INT", 0, 0, false);
        declareFunction("remove_speech_part_pred_min_ceilings_int", "REMOVE-SPEECH-PART-PRED-MIN-CEILINGS-INT", 2, 0, false);
        declareFunction("speech_part_pred_min_ceilings_int_internal", "SPEECH-PART-PRED-MIN-CEILINGS-INT-INTERNAL", 2, 0, false);
        declareFunction("speech_part_pred_min_ceilings_int", "SPEECH-PART-PRED-MIN-CEILINGS-INT", 2, 0, false);
        declareFunction("speech_part_pred_max_floors", "SPEECH-PART-PRED-MAX-FLOORS", 1, 1, false);
        declareFunction("clear_speech_part_pred_max_floors_int", "CLEAR-SPEECH-PART-PRED-MAX-FLOORS-INT", 0, 0, false);
        declareFunction("remove_speech_part_pred_max_floors_int", "REMOVE-SPEECH-PART-PRED-MAX-FLOORS-INT", 2, 0, false);
        declareFunction("speech_part_pred_max_floors_int_internal", "SPEECH-PART-PRED-MAX-FLOORS-INT-INTERNAL", 2, 0, false);
        declareFunction("speech_part_pred_max_floors_int", "SPEECH-PART-PRED-MAX-FLOORS-INT", 2, 0, false);
        declareFunction("clear_pos_of_pred", "CLEAR-POS-OF-PRED", 0, 0, false);
        declareFunction("remove_pos_of_pred", "REMOVE-POS-OF-PRED", 1, 0, false);
        declareFunction("pos_of_pred_internal", "POS-OF-PRED-INTERNAL", 1, 0, false);
        declareFunction("pos_of_pred", "POS-OF-PRED", 1, 0, false);
        declareFunction("singular_pred", "SINGULAR-PRED", 1, 0, false);
        declareFunction("plural_pred", "PLURAL-PRED", 1, 0, false);
        declareFunction("derived_preds", "DERIVED-PREDS", 0, 0, false);
        declareFunction("clear_derived_preds", "CLEAR-DERIVED-PREDS", 0, 0, false);
        declareFunction("initialize_derived_preds", "INITIALIZE-DERIVED-PREDS", 0, 0, false);
        declareFunction("derived_predP", "DERIVED-PRED?", 1, 1, false);
        declareFunction("base_preds_of_pred", "BASE-PREDS-OF-PRED", 1, 1, false);
        declareMacro("do_speech_part_preds", "DO-SPEECH-PART-PREDS");
        declareFunction("speech_part_preds_initializedP", "SPEECH-PART-PREDS-INITIALIZED?", 0, 0, false);
        declareFunction("clear_speech_part_preds", "CLEAR-SPEECH-PART-PREDS", 0, 0, false);
        declareFunction("initialize_speech_part_preds", "INITIALIZE-SPEECH-PART-PREDS", 0, 0, false);
        declareFunction("ensure_speech_part_preds_initialized", "ENSURE-SPEECH-PART-PREDS-INITIALIZED", 0, 0, false);
        declareFunction("speech_part_predP", "SPEECH-PART-PRED?", 1, 1, false);
        new com.cyc.cycjava.cycl.lexicon_accessors.$speech_part_predP$UnaryFunction();
        new com.cyc.cycjava.cycl.lexicon_accessors.$speech_part_predP$BinaryFunction();
        declareFunction("all_speech_part_preds", "ALL-SPEECH-PART-PREDS", 0, 1, false);
        declareFunction("spec_pos_predP", "SPEC-POS-PRED?", 2, 1, false);
        declareFunction("clear_genl_pos_predP", "CLEAR-GENL-POS-PRED?", 0, 0, false);
        declareFunction("remove_genl_pos_predP", "REMOVE-GENL-POS-PRED?", 2, 1, false);
        declareFunction("genl_pos_predP_internal", "GENL-POS-PRED?-INTERNAL", 3, 0, false);
        declareFunction("genl_pos_predP", "GENL-POS-PRED?", 2, 1, false);
        new com.cyc.cycjava.cycl.lexicon_accessors.$genl_pos_predP$BinaryFunction();
        declareFunction("clear_genl_pos_pred_from_mt_infoP", "CLEAR-GENL-POS-PRED-FROM-MT-INFO?", 0, 0, false);
        declareFunction("remove_genl_pos_pred_from_mt_infoP", "REMOVE-GENL-POS-PRED-FROM-MT-INFO?", 2, 1, false);
        declareFunction("genl_pos_pred_from_mt_infoP_internal", "GENL-POS-PRED-FROM-MT-INFO?-INTERNAL", 3, 0, false);
        declareFunction("genl_pos_pred_from_mt_infoP", "GENL-POS-PRED-FROM-MT-INFO?", 2, 1, false);
        declareFunction("word_form_predictableP", "WORD-FORM-PREDICTABLE?", 3, 1, false);
        declareFunction("get_strings_of_type", "GET-STRINGS-OF-TYPE", 2, 3, false);
        declareFunction("clear_get_strings_of_type_cached", "CLEAR-GET-STRINGS-OF-TYPE-CACHED", 0, 0, false);
        declareFunction("remove_get_strings_of_type_cached", "REMOVE-GET-STRINGS-OF-TYPE-CACHED", 2, 3, false);
        declareFunction("get_strings_of_type_cached_internal", "GET-STRINGS-OF-TYPE-CACHED-INTERNAL", 5, 0, false);
        declareFunction("get_strings_of_type_cached", "GET-STRINGS-OF-TYPE-CACHED", 2, 3, false);
        declareFunction("string_is_pos_on_wuP_internal", "STRING-IS-POS-ON-WU?-INTERNAL", 3, 3, false);
        declareFunction("string_is_pos_on_wuP", "STRING-IS-POS-ON-WU?", 3, 3, false);
        declareFunction("string_is_pos_on_wuP_asserted", "STRING-IS-POS-ON-WU?-ASSERTED", 4, 0, false);
        declareFunction("string_is_pred_on_wuP", "STRING-IS-PRED-ON-WU?", 3, 2, false);
        declareFunction("best_wu_for_string", "BEST-WU-FOR-STRING", 2, 0, false);
        declareFunction("best_pos_for_stringXwuXpos", "BEST-POS-FOR-STRING&WU&POS", 3, 0, false);
        declareFunction("words_of_stringXpred", "WORDS-OF-STRING&PRED", 2, 3, false);
        declareFunction("clear_pos_for_keyword", "CLEAR-POS-FOR-KEYWORD", 0, 0, false);
        declareFunction("remove_pos_for_keyword", "REMOVE-POS-FOR-KEYWORD", 1, 1, false);
        declareFunction("pos_for_keyword_internal", "POS-FOR-KEYWORD-INTERNAL", 2, 0, false);
        declareFunction("pos_for_keyword", "POS-FOR-KEYWORD", 1, 1, false);
        declareFunction("words_of_stringXpos", "WORDS-OF-STRING&POS", 2, 3, false);
        declareFunction("words_of_stringXspeech_part", "WORDS-OF-STRING&SPEECH-PART", 2, 3, false);
        declareFunction("preds_of_stringXword", "PREDS-OF-STRING&WORD", 2, 3, false);
        declareFunction("clear_preds_of_stringXword", "CLEAR-PREDS-OF-STRING&WORD", 0, 0, false);
        declareFunction("clear_preds_of_stringXword_cached", "CLEAR-PREDS-OF-STRING&WORD-CACHED", 0, 0, false);
        declareFunction("remove_preds_of_stringXword_cached", "REMOVE-PREDS-OF-STRING&WORD-CACHED", 5, 0, false);
        declareFunction("preds_of_stringXword_cached_internal", "PREDS-OF-STRING&WORD-CACHED-INTERNAL", 5, 0, false);
        declareFunction("preds_of_stringXword_cached", "PREDS-OF-STRING&WORD-CACHED", 5, 0, false);
        declareFunction("other_strings_of_wu", "OTHER-STRINGS-OF-WU", 1, 2, false);
        declareFunction("right_frames_for_pos", "RIGHT-FRAMES-FOR-POS", 1, 0, false);
        declareFunction("pos_of_string", "POS-OF-STRING", 1, 3, false);
        declareFunction("string_is_posP", "STRING-IS-POS?", 2, 3, false);
        declareFunction("string_is_form_of_aux_verbP", "STRING-IS-FORM-OF-AUX-VERB?", 1, 2, false);
        declareFunction("clear_closed_lexical_class_hash", "CLEAR-CLOSED-LEXICAL-CLASS-HASH", 0, 0, false);
        declareFunction("initialize_closed_lexical_class_strings", "INITIALIZE-CLOSED-LEXICAL-CLASS-STRINGS", 0, 0, false);
        declareFunction("closed_lexical_class_stringP", "CLOSED-LEXICAL-CLASS-STRING?", 1, 1, false);
        declareFunction("non_pronominal_closed_lexical_class_stringP", "NON-PRONOMINAL-CLOSED-LEXICAL-CLASS-STRING?", 1, 1, false);
        declareFunction("contains_closed_lexical_class_wordP", "CONTAINS-CLOSED-LEXICAL-CLASS-WORD?", 1, 0, false);
        declareFunction("clear_closed_lexical_class_strings", "CLEAR-CLOSED-LEXICAL-CLASS-STRINGS", 0, 0, false);
        declareFunction("remove_closed_lexical_class_strings", "REMOVE-CLOSED-LEXICAL-CLASS-STRINGS", 0, 1, false);
        declareFunction("closed_lexical_class_strings_internal", "CLOSED-LEXICAL-CLASS-STRINGS-INTERNAL", 1, 0, false);
        declareFunction("closed_lexical_class_strings", "CLOSED-LEXICAL-CLASS-STRINGS", 0, 1, false);
        declareFunction("closed_lexical_classP", "CLOSED-LEXICAL-CLASS?", 1, 1, false);
        declareFunction("clear_closed_lexical_classes", "CLEAR-CLOSED-LEXICAL-CLASSES", 0, 0, false);
        declareFunction("remove_closed_lexical_classes", "REMOVE-CLOSED-LEXICAL-CLASSES", 0, 1, false);
        declareFunction("closed_lexical_classes_internal", "CLOSED-LEXICAL-CLASSES-INTERNAL", 1, 0, false);
        declareFunction("closed_lexical_classes", "CLOSED-LEXICAL-CLASSES", 0, 1, false);
        declareFunction("maybe_initialize_prep_strings", "MAYBE-INITIALIZE-PREP-STRINGS", 0, 0, false);
        declareFunction("preposition_stringP", "PREPOSITION-STRING?", 1, 1, false);
        declareFunction("quick_lexical_wordP", "QUICK-LEXICAL-WORD?", 1, 1, false);
        declareFunction("quick_lexical_wordP_int", "QUICK-LEXICAL-WORD?-INT", 2, 0, false);
        declareFunction("quick_word_nautP", "QUICK-WORD-NAUT?", 1, 0, false);
        declareFunction("lexical_wordP_internal", "LEXICAL-WORD?-INTERNAL", 1, 0, false);
        declareFunction("lexical_wordP", "LEXICAL-WORD?", 1, 0, false);
        declareFunction("derived_wordP_internal", "DERIVED-WORD?-INTERNAL", 1, 0, false);
        declareFunction("derived_wordP", "DERIVED-WORD?", 1, 0, false);
        declareFunction("initialize_vulgar_words", "INITIALIZE-VULGAR-WORDS", 0, 0, false);
        declareFunction("vulgar_wordP", "VULGAR-WORD?", 1, 0, false);
        declareFunction("pos_of_stringXword", "POS-OF-STRING&WORD", 2, 3, false);
        declareFunction("clear_nl_caches", "CLEAR-NL-CACHES", 0, 0, false);
        declareFunction("clear_nl_parsing_caches", "CLEAR-NL-PARSING-CACHES", 0, 0, false);
        declareFunction("clear_cached_lexical_access_functions", "CLEAR-CACHED-LEXICAL-ACCESS-FUNCTIONS", 0, 0, false);
        declareFunction("pos_of_word", "POS-OF-WORD", 1, 1, false);
        declareFunction("word_has_posP", "WORD-HAS-POS?", 2, 1, false);
        declareFunction("clear_verb_only_stringP", "CLEAR-VERB-ONLY-STRING?", 0, 0, false);
        declareFunction("remove_verb_only_stringP", "REMOVE-VERB-ONLY-STRING?", 1, 0, false);
        declareFunction("verb_only_stringP_internal", "VERB-ONLY-STRING?-INTERNAL", 1, 0, false);
        declareFunction("verb_only_stringP", "VERB-ONLY-STRING?", 1, 0, false);
        declareFunction("typed_denots_of_string", "TYPED-DENOTS-OF-STRING", 2, 8, false);
        declareFunction("typed_denots_of_string_preds_okP", "TYPED-DENOTS-OF-STRING-PREDS-OK?", 2, 0, false);
        declareFunction("denot_has_typeP_internal", "DENOT-HAS-TYPE?-INTERNAL", 2, 1, false);
        declareFunction("denot_has_typeP", "DENOT-HAS-TYPE?", 2, 1, false);
        declareFunction("denot_might_have_typeP_internal", "DENOT-MIGHT-HAVE-TYPE?-INTERNAL", 2, 0, false);
        declareFunction("denot_might_have_typeP", "DENOT-MIGHT-HAVE-TYPE?", 2, 0, false);
        declareFunction("multi_typed_denots_of_string", "MULTI-TYPED-DENOTS-OF-STRING", 3, 8, false);
        declareFunction("typed_denots_of_string_at_place", "TYPED-DENOTS-OF-STRING-AT-PLACE", 3, 6, false);
        declareFunction("in_region_p", "IN-REGION-P", 3, 0, false);
        declareFunction("geopolitical_subdivisionP", "GEOPOLITICAL-SUBDIVISION?", 3, 0, false);
        declareFunction("geographical_subregionP", "GEOGRAPHICAL-SUBREGION?", 3, 0, false);
        declareFunction("territories_for_gpe", "TERRITORIES-FOR-GPE", 1, 0, false);
        declareFunction("gpe_for_territory", "GPE-FOR-TERRITORY", 1, 0, false);
        declareFunction("denots_of_partial_string", "DENOTS-OF-PARTIAL-STRING", 1, 3, false);
        declareFunction("denotation_mapper", "DENOTATION-MAPPER", 1, 3, false);
        declareFunction("all_denots_of_string", "ALL-DENOTS-OF-STRING", 1, 3, false);
        declareFunction("most_denots_of_string", "MOST-DENOTS-OF-STRING", 1, 3, false);
        declareFunction("all_parsing_denots_of_string", "ALL-PARSING-DENOTS-OF-STRING", 1, 3, false);
        declareFunction("denots_of_string", "DENOTS-OF-STRING", 1, 8, false);
        declareFunction("add_denots_of_string_results", "ADD-DENOTS-OF-STRING-RESULTS", 4, 0, false);
        declareFunction("date_and_number_denots_of_string", "DATE-AND-NUMBER-DENOTS-OF-STRING", 1, 0, false);
        declareFunction("denots_of_stringXpred", "DENOTS-OF-STRING&PRED", 2, 6, false);
        declareFunction("denots_of_stringXnamestring_pred", "DENOTS-OF-STRING&NAMESTRING-PRED", 2, 3, false);
        declareFunction("denots_of_stringXpos_pred", "DENOTS-OF-STRING&POS-PRED", 2, 5, false);
        declareFunction("denots_of_stringXspeech_part", "DENOTS-OF-STRING&SPEECH-PART", 2, 5, false);
        declareFunction("denots_of_stringXpos", "DENOTS-OF-STRING&POS", 2, 5, false);
        declareFunction("denots_of_name_string", "DENOTS-OF-NAME-STRING", 1, 3, false);
        declareFunction("denots_of_name_string_precise", "DENOTS-OF-NAME-STRING-PRECISE", 1, 2, false);
        declareFunction("denots_of_wu", "DENOTS-OF-WU", 1, 1, false);
        declareFunction("proceed_with_morphological_parsingP", "PROCEED-WITH-MORPHOLOGICAL-PARSING?", 2, 0, false);
        declareFunction("skip_to_morphological_parsingP", "SKIP-TO-MORPHOLOGICAL-PARSING?", 1, 0, false);
        declareFunction("denots_of_acronym_string", "DENOTS-OF-ACRONYM-STRING", 1, 2, false);
        declareFunction("names_from_spelling", "NAMES-FROM-SPELLING", 1, 2, false);
        declareFunction("names_from_nickname", "NAMES-FROM-NICKNAME", 1, 2, false);
        declareFunction("denots_of_abbreviation_string", "DENOTS-OF-ABBREVIATION-STRING", 1, 2, false);
        declareFunction("known_proper_noun_phraseP", "KNOWN-PROPER-NOUN-PHRASE?", 1, 0, false);
        declareFunction("determine_denotation_preds", "DETERMINE-DENOTATION-PREDS", 1, 0, false);
        declareFunction("determine_denotation_pred", "DETERMINE-DENOTATION-PRED", 1, 0, false);
        declareFunction("meanings_of_sense", "MEANINGS-OF-SENSE", 4, 1, false);
        declareFunction("meaning_has_senseP", "MEANING-HAS-SENSE?", 5, 1, false);
        declareFunction("denot_has_senseP", "DENOT-HAS-SENSE?", 4, 1, false);
        declareFunction("denots_of_sense", "DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("proper_denots_of_sense", "PROPER-DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("related_denots_of_sense", "RELATED-DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("placeholder_denots_of_sense", "PLACEHOLDER-DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("denots_of_sense_by_mt", "DENOTS-OF-SENSE-BY-MT", 3, 1, false);
        declareFunction("senses_of_wuXpos", "SENSES-OF-WU&POS", 2, 1, false);
        declareFunction("subcat_frame_arity", "SUBCAT-FRAME-ARITY", 1, 0, false);
        declareFunction("frames_of_word", "FRAMES-OF-WORD", 1, 0, false);
        declareFunction("frames_of_wordXpos", "FRAMES-OF-WORD&POS", 2, 0, false);
        declareFunction("frames_of_word_posXdenot", "FRAMES-OF-WORD-POS&DENOT", 3, 0, false);
        declareFunction("frames_of_sense", "FRAMES-OF-SENSE", 3, 1, false);
        declareFunction("frames_of_sense_by_mt", "FRAMES-OF-SENSE-BY-MT", 3, 0, false);
        declareFunction("politeness_of_ws_pred", "POLITENESS-OF-WS-PRED", 0, 0, false);
        declareFunction("formality_of_ws_pred", "FORMALITY-OF-WS-PRED", 0, 0, false);
        declareFunction("politeness_levels_of_assertion", "POLITENESS-LEVELS-OF-ASSERTION", 1, 1, false);
        declareFunction("formality_levels_of_assertion", "FORMALITY-LEVELS-OF-ASSERTION", 1, 1, false);
        declareFunction("potentially_offensive_politeness_levelP", "POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?", 1, 0, false);
        declareFunction("includes_potentially_offensive_politeness_levelP", "INCLUDES-POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?", 1, 0, false);
        declareFunction("potentially_offensive_lexical_assertionP", "POTENTIALLY-OFFENSIVE-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("slang_lexical_assertionP", "SLANG-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("archaic_lexical_assertionP", "ARCHAIC-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("inappropriate_lexical_assertionP", "INAPPROPRIATE-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("gather_denotation_assertions", "GATHER-DENOTATION-ASSERTIONS", 3, 0, false);
        declareFunction("potentially_offensive_senseP", "POTENTIALLY-OFFENSIVE-SENSE?", 3, 0, false);
        declareFunction("inappropriate_senseP", "INAPPROPRIATE-SENSE?", 3, 0, false);
        declareFunction("semtrans_of_ws", "SEMTRANS-OF-WS", 3, 0, false);
        declareFunction("semtrans_of_wuXpos", "SEMTRANS-OF-WU&POS", 2, 1, false);
        declareFunction("semtrans_lookup_int", "SEMTRANS-LOOKUP-INT", 3, 1, false);
        declareFunction("semtrans_template_from_assertion", "SEMTRANS-TEMPLATE-FROM-ASSERTION", 1, 1, false);
        declareFunction("semtrans_sentence_infer", "SEMTRANS-SENTENCE-INFER", 2, 0, false);
        declareFunction("denots_of_word", "DENOTS-OF-WORD", 1, 1, false);
        declareFunction("semtrans_assertion_lookup", "SEMTRANS-ASSERTION-LOOKUP", 2, 1, false);
        declareFunction("all_semtrans_assertions", "ALL-SEMTRANS-ASSERTIONS", 2, 1, false);
        declareFunction("preposition_of_frame", "PREPOSITION-OF-FRAME", 1, 0, false);
        declareFunction("assertion_denotation", "ASSERTION-DENOTATION", 1, 0, false);
        declareFunction("assertion_pos", "ASSERTION-POS", 1, 0, false);
        declareFunction("assertion_sense_num", "ASSERTION-SENSE-NUM", 1, 0, false);
        declareFunction("clear_agr_of_det_string", "CLEAR-AGR-OF-DET-STRING", 0, 0, false);
        declareFunction("remove_agr_of_det_string", "REMOVE-AGR-OF-DET-STRING", 1, 0, false);
        declareFunction("agr_of_det_string_internal", "AGR-OF-DET-STRING-INTERNAL", 1, 0, false);
        declareFunction("agr_of_det_string", "AGR-OF-DET-STRING", 1, 0, false);
        declareFunction("agreement_lookup", "AGREEMENT-LOOKUP", 1, 0, false);
        declareFunction("denot_ws_lookup", "DENOT-WS-LOOKUP", 2, 1, false);
        declareFunction("pos_to_semtrans_pred", "POS-TO-SEMTRANS-PRED", 1, 1, false);
        declareFunction("clear_pos_to_semtrans_pred_cached", "CLEAR-POS-TO-SEMTRANS-PRED-CACHED", 0, 0, false);
        new com.cyc.cycjava.cycl.lexicon_accessors.$clear_pos_to_semtrans_pred_cached$ZeroArityFunction();
        declareFunction("remove_pos_to_semtrans_pred_cached", "REMOVE-POS-TO-SEMTRANS-PRED-CACHED", 2, 0, false);
        declareFunction("pos_to_semtrans_pred_cached_internal", "POS-TO-SEMTRANS-PRED-CACHED-INTERNAL", 2, 0, false);
        declareFunction("pos_to_semtrans_pred_cached", "POS-TO-SEMTRANS-PRED-CACHED", 2, 0, false);
        declareFunction("clear_semtrans_pred_to_pos", "CLEAR-SEMTRANS-PRED-TO-POS", 0, 0, false);
        declareFunction("remove_semtrans_pred_to_pos", "REMOVE-SEMTRANS-PRED-TO-POS", 1, 1, false);
        declareFunction("semtrans_pred_to_pos_internal", "SEMTRANS-PRED-TO-POS-INTERNAL", 2, 0, false);
        declareFunction("semtrans_pred_to_pos", "SEMTRANS-PRED-TO-POS", 1, 1, false);
        declareFunction("nicknames_of_name", "NICKNAMES-OF-NAME", 1, 0, false);
        declareFunction("spellings_of_name", "SPELLINGS-OF-NAME", 1, 0, false);
        declareFunction("argn_is_speech_partP", "ARGN-IS-SPEECH-PART?", 2, 0, false);
        declareFunction("speech_parts_initializedP", "SPEECH-PARTS-INITIALIZED?", 0, 0, false);
        declareFunction("clear_speech_parts", "CLEAR-SPEECH-PARTS", 0, 0, false);
        declareFunction("initialize_speech_parts", "INITIALIZE-SPEECH-PARTS", 0, 0, false);
        declareFunction("speech_partP", "SPEECH-PART?", 1, 1, false);
        declareFunction("ensure_speech_parts_initialized", "ENSURE-SPEECH-PARTS-INITIALIZED", 0, 0, false);
        declareFunction("all_speech_parts", "ALL-SPEECH-PARTS", 0, 1, false);
        declareFunction("clear_genl_posP", "CLEAR-GENL-POS?", 0, 0, false);
        declareFunction("remove_genl_posP", "REMOVE-GENL-POS?", 2, 1, false);
        declareFunction("genl_posP_internal", "GENL-POS?-INTERNAL", 3, 0, false);
        declareFunction("genl_posP", "GENL-POS?", 2, 1, false);
        declareFunction("genl_pos_memberP", "GENL-POS-MEMBER?", 2, 0, false);
        declareFunction("spec_posP", "SPEC-POS?", 2, 0, false);
        declareFunction("adjpP", "ADJP?", 1, 0, false);
        declareFunction("vbarP", "VBAR?", 1, 0, false);
        declareFunction("nbarP", "NBAR?", 1, 0, false);
        declareFunction("object_is_compositional_pos_termP", "OBJECT-IS-COMPOSITIONAL-POS-TERM?", 3, 0, false);
        declareFunction("clear_compositional_pos_nart", "CLEAR-COMPOSITIONAL-POS-NART", 0, 0, false);
        declareFunction("remove_compositional_pos_nart", "REMOVE-COMPOSITIONAL-POS-NART", 2, 0, false);
        declareFunction("compositional_pos_nart_internal", "COMPOSITIONAL-POS-NART-INTERNAL", 2, 0, false);
        declareFunction("compositional_pos_nart", "COMPOSITIONAL-POS-NART", 2, 0, false);
        declareFunction("npP", "NP?", 1, 0, false);
        declareFunction("ppP", "PP?", 1, 0, false);
        declareFunction("safe_nart_hl_formula", "SAFE-NART-HL-FORMULA", 1, 0, false);
        declareFunction("relational_noun_denots", "RELATIONAL-NOUN-DENOTS", 4, 4, false);
        declareFunction("relational_noun_denot_template_lookup", "RELATIONAL-NOUN-DENOT-TEMPLATE-LOOKUP", 2, 0, false);
        declareFunction("relational_noun_possessed_argnums", "RELATIONAL-NOUN-POSSESSED-ARGNUMS", 5, 1, false);
        declareFunction("relational_noun_preds", "RELATIONAL-NOUN-PREDS", 4, 1, false);
        declareFunction("relational_noun_possessed_type", "RELATIONAL-NOUN-POSSESSED-TYPE", 2, 1, false);
        declareFunction("relational_noun_possessor_type", "RELATIONAL-NOUN-POSSESSOR-TYPE", 2, 1, false);
        declareFunction("la_test_func", "LA-TEST-FUNC", 2, 0, false);
        declareFunction("denotation_mapper_test", "DENOTATION-MAPPER-TEST", 1, 3, false);
        return NIL;
    }

    public static SubLObject declare_lexicon_accessors_file() {
        if (SubLFiles.USE_V1) {
            declareFunction("genl_lexicon_mtP", "GENL-LEXICON-MT?", 2, 0, false);
            declareFunction("clear_genl_lexicon_mtP_cached", "CLEAR-GENL-LEXICON-MT?-CACHED", 0, 0, false);
            declareFunction("remove_genl_lexicon_mtP_cached", "REMOVE-GENL-LEXICON-MT?-CACHED", 2, 0, false);
            declareFunction("genl_lexicon_mtP_cached_internal", "GENL-LEXICON-MT?-CACHED-INTERNAL", 2, 0, false);
            declareFunction("genl_lexicon_mtP_cached", "GENL-LEXICON-MT?-CACHED", 2, 0, false);
            declareFunction("initialize_speech_part_caches", "INITIALIZE-SPEECH-PART-CACHES", 0, 0, false);
            declareFunction("preds_matching_pos", "PREDS-MATCHING-POS", 2, 1, false);
            declareFunction("top_level_nl_preds", "TOP-LEVEL-NL-PREDS", 0, 0, false);
            declareFunction("clear_speech_part_pred_caches", "CLEAR-SPEECH-PART-PRED-CACHES", 0, 0, false);
            declareFunction("max_preds_matching_pos", "MAX-PREDS-MATCHING-POS", 3, 1, false);
            declareFunction("clear_max_preds_matching_pos_cached", "CLEAR-MAX-PREDS-MATCHING-POS-CACHED", 0, 0, false);
            declareFunction("remove_max_preds_matching_pos_cached", "REMOVE-MAX-PREDS-MATCHING-POS-CACHED", 4, 0, false);
            declareFunction("max_preds_matching_pos_cached_internal", "MAX-PREDS-MATCHING-POS-CACHED-INTERNAL", 4, 0, false);
            declareFunction("max_preds_matching_pos_cached", "MAX-PREDS-MATCHING-POS-CACHED", 4, 0, false);
            declareFunction("all_preds_of_pos", "ALL-PREDS-OF-POS", 1, 0, false);
            declareFunction("clear_max_preds_of_pos", "CLEAR-MAX-PREDS-OF-POS", 0, 0, false);
            declareFunction("remove_max_preds_of_pos", "REMOVE-MAX-PREDS-OF-POS", 1, 0, false);
            declareFunction("max_preds_of_pos_internal", "MAX-PREDS-OF-POS-INTERNAL", 1, 0, false);
            declareFunction("max_preds_of_pos", "MAX-PREDS-OF-POS", 1, 0, false);
            declareFunction("clear_max_preds_licensed_by_pos", "CLEAR-MAX-PREDS-LICENSED-BY-POS", 0, 0, false);
            declareFunction("remove_max_preds_licensed_by_pos", "REMOVE-MAX-PREDS-LICENSED-BY-POS", 1, 0, false);
            declareFunction("max_preds_licensed_by_pos_internal", "MAX-PREDS-LICENSED-BY-POS-INTERNAL", 1, 0, false);
            declareFunction("max_preds_licensed_by_pos", "MAX-PREDS-LICENSED-BY-POS", 1, 0, false);
            declareFunction("lex_remove_spec_preds", "LEX-REMOVE-SPEC-PREDS", 1, 0, false);
            declareFunction("lex_remove_spec_preds_helper_internal", "LEX-REMOVE-SPEC-PREDS-HELPER-INTERNAL", 1, 0, false);
            declareFunction("lex_remove_spec_preds_helper", "LEX-REMOVE-SPEC-PREDS-HELPER", 1, 0, false);
            declareFunction("speech_part_pred_min_ceilings", "SPEECH-PART-PRED-MIN-CEILINGS", 1, 1, false);
            declareFunction("clear_speech_part_pred_min_ceilings_int", "CLEAR-SPEECH-PART-PRED-MIN-CEILINGS-INT", 0, 0, false);
            declareFunction("remove_speech_part_pred_min_ceilings_int", "REMOVE-SPEECH-PART-PRED-MIN-CEILINGS-INT", 2, 0, false);
            declareFunction("speech_part_pred_min_ceilings_int_internal", "SPEECH-PART-PRED-MIN-CEILINGS-INT-INTERNAL", 2, 0, false);
            declareFunction("speech_part_pred_min_ceilings_int", "SPEECH-PART-PRED-MIN-CEILINGS-INT", 2, 0, false);
            declareFunction("speech_part_pred_max_floors", "SPEECH-PART-PRED-MAX-FLOORS", 1, 1, false);
            declareFunction("clear_speech_part_pred_max_floors_int", "CLEAR-SPEECH-PART-PRED-MAX-FLOORS-INT", 0, 0, false);
            declareFunction("remove_speech_part_pred_max_floors_int", "REMOVE-SPEECH-PART-PRED-MAX-FLOORS-INT", 2, 0, false);
            declareFunction("speech_part_pred_max_floors_int_internal", "SPEECH-PART-PRED-MAX-FLOORS-INT-INTERNAL", 2, 0, false);
            declareFunction("speech_part_pred_max_floors_int", "SPEECH-PART-PRED-MAX-FLOORS-INT", 2, 0, false);
            declareFunction("clear_pos_of_pred", "CLEAR-POS-OF-PRED", 0, 0, false);
            declareFunction("remove_pos_of_pred", "REMOVE-POS-OF-PRED", 1, 0, false);
            declareFunction("pos_of_pred_internal", "POS-OF-PRED-INTERNAL", 1, 0, false);
            declareFunction("pos_of_pred", "POS-OF-PRED", 1, 0, false);
            declareFunction("singular_pred", "SINGULAR-PRED", 1, 0, false);
            declareFunction("plural_pred", "PLURAL-PRED", 1, 0, false);
            declareFunction("derived_preds", "DERIVED-PREDS", 0, 0, false);
            declareFunction("clear_derived_preds", "CLEAR-DERIVED-PREDS", 0, 0, false);
            declareFunction("initialize_derived_preds", "INITIALIZE-DERIVED-PREDS", 0, 0, false);
            declareFunction("derived_predP", "DERIVED-PRED?", 1, 1, false);
            declareFunction("base_preds_of_pred", "BASE-PREDS-OF-PRED", 1, 1, false);
            declareMacro("do_speech_part_preds", "DO-SPEECH-PART-PREDS");
            declareFunction("speech_part_preds_initializedP", "SPEECH-PART-PREDS-INITIALIZED?", 0, 0, false);
            declareFunction("clear_speech_part_preds", "CLEAR-SPEECH-PART-PREDS", 0, 0, false);
            declareFunction("initialize_speech_part_preds", "INITIALIZE-SPEECH-PART-PREDS", 0, 0, false);
            declareFunction("ensure_speech_part_preds_initialized", "ENSURE-SPEECH-PART-PREDS-INITIALIZED", 0, 0, false);
            declareFunction("speech_part_predP", "SPEECH-PART-PRED?", 1, 1, false);
            new lexicon_accessors.$speech_part_predP$UnaryFunction();
            new lexicon_accessors.$speech_part_predP$BinaryFunction();
            declareFunction("all_speech_part_preds", "ALL-SPEECH-PART-PREDS", 0, 1, false);
            declareFunction("spec_pos_predP", "SPEC-POS-PRED?", 2, 1, false);
            declareFunction("clear_genl_pos_predP", "CLEAR-GENL-POS-PRED?", 0, 0, false);
            declareFunction("remove_genl_pos_predP", "REMOVE-GENL-POS-PRED?", 2, 1, false);
            declareFunction("genl_pos_predP_internal", "GENL-POS-PRED?-INTERNAL", 3, 0, false);
            declareFunction("genl_pos_predP", "GENL-POS-PRED?", 2, 1, false);
            new lexicon_accessors.$genl_pos_predP$BinaryFunction();
            declareFunction("clear_genl_pos_pred_from_mt_infoP", "CLEAR-GENL-POS-PRED-FROM-MT-INFO?", 0, 0, false);
            declareFunction("remove_genl_pos_pred_from_mt_infoP", "REMOVE-GENL-POS-PRED-FROM-MT-INFO?", 2, 1, false);
            declareFunction("genl_pos_pred_from_mt_infoP_internal", "GENL-POS-PRED-FROM-MT-INFO?-INTERNAL", 3, 0, false);
            declareFunction("genl_pos_pred_from_mt_infoP", "GENL-POS-PRED-FROM-MT-INFO?", 2, 1, false);
            declareFunction("word_form_predictableP", "WORD-FORM-PREDICTABLE?", 3, 1, false);
            declareFunction("get_strings_of_type", "GET-STRINGS-OF-TYPE", 2, 3, false);
            declareFunction("clear_get_strings_of_type_cached", "CLEAR-GET-STRINGS-OF-TYPE-CACHED", 0, 0, false);
            declareFunction("remove_get_strings_of_type_cached", "REMOVE-GET-STRINGS-OF-TYPE-CACHED", 2, 3, false);
            declareFunction("get_strings_of_type_cached_internal", "GET-STRINGS-OF-TYPE-CACHED-INTERNAL", 5, 0, false);
            declareFunction("get_strings_of_type_cached", "GET-STRINGS-OF-TYPE-CACHED", 2, 3, false);
            declareFunction("string_is_pos_on_wuP_internal", "STRING-IS-POS-ON-WU?-INTERNAL", 3, 3, false);
            declareFunction("string_is_pos_on_wuP", "STRING-IS-POS-ON-WU?", 3, 3, false);
            declareFunction("string_is_pos_on_wuP_asserted", "STRING-IS-POS-ON-WU?-ASSERTED", 4, 0, false);
            declareFunction("string_is_pred_on_wuP", "STRING-IS-PRED-ON-WU?", 3, 2, false);
            declareFunction("best_wu_for_string", "BEST-WU-FOR-STRING", 2, 0, false);
            declareFunction("best_pos_for_stringXwuXpos", "BEST-POS-FOR-STRING&WU&POS", 3, 0, false);
            declareFunction("words_of_stringXpred", "WORDS-OF-STRING&PRED", 2, 3, false);
            declareFunction("clear_pos_for_keyword", "CLEAR-POS-FOR-KEYWORD", 0, 0, false);
            declareFunction("remove_pos_for_keyword", "REMOVE-POS-FOR-KEYWORD", 1, 1, false);
            declareFunction("pos_for_keyword_internal", "POS-FOR-KEYWORD-INTERNAL", 2, 0, false);
            declareFunction("pos_for_keyword", "POS-FOR-KEYWORD", 1, 1, false);
            declareFunction("words_of_stringXpos", "WORDS-OF-STRING&POS", 2, 3, false);
            declareFunction("words_of_stringXspeech_part", "WORDS-OF-STRING&SPEECH-PART", 2, 3, false);
            declareFunction("preds_of_stringXword", "PREDS-OF-STRING&WORD", 2, 3, false);
            declareFunction("clear_preds_of_stringXword", "CLEAR-PREDS-OF-STRING&WORD", 0, 0, false);
            declareFunction("clear_preds_of_stringXword_cached", "CLEAR-PREDS-OF-STRING&WORD-CACHED", 0, 0, false);
            declareFunction("remove_preds_of_stringXword_cached", "REMOVE-PREDS-OF-STRING&WORD-CACHED", 5, 0, false);
            declareFunction("preds_of_stringXword_cached_internal", "PREDS-OF-STRING&WORD-CACHED-INTERNAL", 5, 0, false);
            declareFunction("preds_of_stringXword_cached", "PREDS-OF-STRING&WORD-CACHED", 5, 0, false);
            declareFunction("other_strings_of_wu", "OTHER-STRINGS-OF-WU", 1, 2, false);
            declareFunction("right_frames_for_pos", "RIGHT-FRAMES-FOR-POS", 1, 0, false);
            declareFunction("pos_of_string", "POS-OF-STRING", 1, 3, false);
            declareFunction("string_is_posP", "STRING-IS-POS?", 2, 3, false);
            declareFunction("string_is_form_of_aux_verbP", "STRING-IS-FORM-OF-AUX-VERB?", 1, 2, false);
            declareFunction("clear_closed_lexical_class_hash", "CLEAR-CLOSED-LEXICAL-CLASS-HASH", 0, 0, false);
            declareFunction("initialize_closed_lexical_class_strings", "INITIALIZE-CLOSED-LEXICAL-CLASS-STRINGS", 0, 0, false);
            declareFunction("closed_lexical_class_string_intP", "CLOSED-LEXICAL-CLASS-STRING-INT?", 3, 0, false);
            declareFunction("closed_lexical_class_stringP", "CLOSED-LEXICAL-CLASS-STRING?", 1, 1, false);
            declareFunction("closed_lexical_class_string_case_insensitiveP", "CLOSED-LEXICAL-CLASS-STRING-CASE-INSENSITIVE?", 1, 1, false);
            declareFunction("non_pronominal_closed_lexical_class_stringP", "NON-PRONOMINAL-CLOSED-LEXICAL-CLASS-STRING?", 1, 1, false);
            declareFunction("contains_closed_lexical_class_wordP", "CONTAINS-CLOSED-LEXICAL-CLASS-WORD?", 1, 0, false);
            declareFunction("clear_closed_lexical_class_strings", "CLEAR-CLOSED-LEXICAL-CLASS-STRINGS", 0, 0, false);
            declareFunction("remove_closed_lexical_class_strings", "REMOVE-CLOSED-LEXICAL-CLASS-STRINGS", 0, 1, false);
            declareFunction("closed_lexical_class_strings_internal", "CLOSED-LEXICAL-CLASS-STRINGS-INTERNAL", 1, 0, false);
            declareFunction("closed_lexical_class_strings", "CLOSED-LEXICAL-CLASS-STRINGS", 0, 1, false);
            declareFunction("closed_lexical_classP", "CLOSED-LEXICAL-CLASS?", 1, 1, false);
            declareFunction("clear_closed_lexical_classes", "CLEAR-CLOSED-LEXICAL-CLASSES", 0, 0, false);
            declareFunction("remove_closed_lexical_classes", "REMOVE-CLOSED-LEXICAL-CLASSES", 0, 1, false);
            declareFunction("closed_lexical_classes_internal", "CLOSED-LEXICAL-CLASSES-INTERNAL", 1, 0, false);
            declareFunction("closed_lexical_classes", "CLOSED-LEXICAL-CLASSES", 0, 1, false);
            declareFunction("maybe_initialize_prep_strings", "MAYBE-INITIALIZE-PREP-STRINGS", 0, 0, false);
            declareFunction("preposition_stringP", "PREPOSITION-STRING?", 1, 1, false);
            declareFunction("quick_lexical_wordP", "QUICK-LEXICAL-WORD?", 1, 1, false);
            declareFunction("quick_lexical_wordP_int", "QUICK-LEXICAL-WORD?-INT", 2, 0, false);
            declareFunction("quick_word_nautP", "QUICK-WORD-NAUT?", 1, 0, false);
            declareFunction("lexical_wordP_internal", "LEXICAL-WORD?-INTERNAL", 1, 0, false);
            declareFunction("lexical_wordP", "LEXICAL-WORD?", 1, 0, false);
            declareFunction("derived_wordP_internal", "DERIVED-WORD?-INTERNAL", 1, 0, false);
            declareFunction("derived_wordP", "DERIVED-WORD?", 1, 0, false);
            declareFunction("initialize_vulgar_words", "INITIALIZE-VULGAR-WORDS", 0, 0, false);
            declareFunction("vulgar_wordP", "VULGAR-WORD?", 1, 0, false);
            declareFunction("pos_of_stringXword", "POS-OF-STRING&WORD", 2, 3, false);
            declareFunction("clear_nl_caches", "CLEAR-NL-CACHES", 0, 0, false);
            declareFunction("clear_nl_parsing_caches", "CLEAR-NL-PARSING-CACHES", 0, 0, false);
            declareFunction("clear_cached_lexical_access_functions", "CLEAR-CACHED-LEXICAL-ACCESS-FUNCTIONS", 0, 0, false);
            declareFunction("pos_of_word", "POS-OF-WORD", 1, 1, false);
            declareFunction("word_has_posP", "WORD-HAS-POS?", 2, 1, false);
            declareFunction("clear_verb_only_stringP", "CLEAR-VERB-ONLY-STRING?", 0, 0, false);
            declareFunction("remove_verb_only_stringP", "REMOVE-VERB-ONLY-STRING?", 1, 0, false);
            declareFunction("verb_only_stringP_internal", "VERB-ONLY-STRING?-INTERNAL", 1, 0, false);
            declareFunction("verb_only_stringP", "VERB-ONLY-STRING?", 1, 0, false);
            declareFunction("typed_denots_of_string", "TYPED-DENOTS-OF-STRING", 2, 8, false);
            declareFunction("typed_denots_of_string_preds_okP", "TYPED-DENOTS-OF-STRING-PREDS-OK?", 2, 0, false);
            declareFunction("denot_has_typeP_internal", "DENOT-HAS-TYPE?-INTERNAL", 2, 1, false);
            declareFunction("denot_has_typeP", "DENOT-HAS-TYPE?", 2, 1, false);
            declareFunction("denot_might_have_typeP_internal", "DENOT-MIGHT-HAVE-TYPE?-INTERNAL", 2, 0, false);
            declareFunction("denot_might_have_typeP", "DENOT-MIGHT-HAVE-TYPE?", 2, 0, false);
            declareFunction("multi_typed_denots_of_string", "MULTI-TYPED-DENOTS-OF-STRING", 3, 8, false);
            declareFunction("typed_denots_of_string_at_place", "TYPED-DENOTS-OF-STRING-AT-PLACE", 3, 6, false);
            declareFunction("in_region_p", "IN-REGION-P", 3, 0, false);
            declareFunction("geopolitical_subdivisionP", "GEOPOLITICAL-SUBDIVISION?", 3, 0, false);
            declareFunction("geographical_subregionP", "GEOGRAPHICAL-SUBREGION?", 3, 0, false);
            declareFunction("territories_for_gpe", "TERRITORIES-FOR-GPE", 1, 0, false);
            declareFunction("gpe_for_territory", "GPE-FOR-TERRITORY", 1, 0, false);
            declareFunction("denots_of_partial_string", "DENOTS-OF-PARTIAL-STRING", 1, 3, false);
            declareFunction("denotation_mapper", "DENOTATION-MAPPER", 1, 3, false);
            declareFunction("all_denots_of_string", "ALL-DENOTS-OF-STRING", 1, 3, false);
            declareFunction("most_denots_of_string", "MOST-DENOTS-OF-STRING", 1, 3, false);
            declareFunction("all_parsing_denots_of_string", "ALL-PARSING-DENOTS-OF-STRING", 1, 3, false);
            declareFunction("denots_of_string", "DENOTS-OF-STRING", 1, 8, false);
            declareFunction("valid_denots_of_string_lookup_mt_specificationP", "VALID-DENOTS-OF-STRING-LOOKUP-MT-SPECIFICATION?", 1, 0, false);
            declareFunction("denots_mt_for_language", "DENOTS-MT-FOR-LANGUAGE", 1, 0, false);
            declareFunction("add_denots_of_string_results", "ADD-DENOTS-OF-STRING-RESULTS", 4, 0, false);
            declareFunction("date_and_number_denots_of_string", "DATE-AND-NUMBER-DENOTS-OF-STRING", 1, 0, false);
            declareFunction("denots_of_stringXpred", "DENOTS-OF-STRING&PRED", 2, 6, false);
            declareFunction("denots_of_stringXnamestring_pred", "DENOTS-OF-STRING&NAMESTRING-PRED", 2, 3, false);
            declareFunction("denots_of_stringXpos_pred", "DENOTS-OF-STRING&POS-PRED", 2, 5, false);
            declareFunction("denots_of_stringXspeech_part", "DENOTS-OF-STRING&SPEECH-PART", 2, 5, false);
            declareFunction("denots_of_stringXpos", "DENOTS-OF-STRING&POS", 2, 5, false);
            declareFunction("denots_of_name_string", "DENOTS-OF-NAME-STRING", 1, 3, false);
            declareFunction("denots_of_name_string_precise", "DENOTS-OF-NAME-STRING-PRECISE", 1, 2, false);
            declareFunction("denots_of_wu", "DENOTS-OF-WU", 1, 1, false);
            declareFunction("proceed_with_morphological_parsingP", "PROCEED-WITH-MORPHOLOGICAL-PARSING?", 2, 0, false);
            declareFunction("skip_to_morphological_parsingP", "SKIP-TO-MORPHOLOGICAL-PARSING?", 1, 0, false);
            declareFunction("denots_of_acronym_string", "DENOTS-OF-ACRONYM-STRING", 1, 2, false);
            declareFunction("names_from_spelling", "NAMES-FROM-SPELLING", 1, 2, false);
            declareFunction("names_from_nickname", "NAMES-FROM-NICKNAME", 1, 2, false);
            declareFunction("denots_of_abbreviation_string", "DENOTS-OF-ABBREVIATION-STRING", 1, 2, false);
            declareFunction("known_proper_noun_phraseP", "KNOWN-PROPER-NOUN-PHRASE?", 1, 0, false);
            declareFunction("determine_denotation_preds", "DETERMINE-DENOTATION-PREDS", 1, 0, false);
            declareFunction("determine_denotation_pred", "DETERMINE-DENOTATION-PRED", 1, 0, false);
            declareFunction("meanings_of_sense", "MEANINGS-OF-SENSE", 4, 1, false);
            declareFunction("meaning_has_senseP", "MEANING-HAS-SENSE?", 5, 1, false);
            declareFunction("denot_has_senseP", "DENOT-HAS-SENSE?", 4, 1, false);
            declareFunction("denots_of_sense", "DENOTS-OF-SENSE", 3, 1, false);
            declareFunction("proper_denots_of_sense", "PROPER-DENOTS-OF-SENSE", 3, 1, false);
            declareFunction("related_denots_of_sense", "RELATED-DENOTS-OF-SENSE", 3, 1, false);
            declareFunction("placeholder_denots_of_sense", "PLACEHOLDER-DENOTS-OF-SENSE", 3, 1, false);
            declareFunction("denots_of_sense_by_mt", "DENOTS-OF-SENSE-BY-MT", 3, 1, false);
            declareFunction("senses_of_wuXpos", "SENSES-OF-WU&POS", 2, 1, false);
            declareFunction("subcat_frame_arity", "SUBCAT-FRAME-ARITY", 1, 0, false);
            declareFunction("frames_of_word", "FRAMES-OF-WORD", 1, 0, false);
            declareFunction("frames_of_wordXpos", "FRAMES-OF-WORD&POS", 2, 0, false);
            declareFunction("frames_of_word_posXdenot", "FRAMES-OF-WORD-POS&DENOT", 3, 0, false);
            declareFunction("frames_of_sense", "FRAMES-OF-SENSE", 3, 1, false);
            declareFunction("frames_of_sense_by_mt", "FRAMES-OF-SENSE-BY-MT", 3, 0, false);
            declareFunction("politeness_of_ws_pred", "POLITENESS-OF-WS-PRED", 0, 0, false);
            declareFunction("formality_of_ws_pred", "FORMALITY-OF-WS-PRED", 0, 0, false);
            declareFunction("politeness_levels_of_assertion", "POLITENESS-LEVELS-OF-ASSERTION", 1, 1, false);
            declareFunction("formality_levels_of_assertion", "FORMALITY-LEVELS-OF-ASSERTION", 1, 1, false);
            declareFunction("potentially_offensive_politeness_levelP", "POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?", 1, 0, false);
            declareFunction("includes_potentially_offensive_politeness_levelP", "INCLUDES-POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?", 1, 0, false);
            declareFunction("potentially_offensive_lexical_assertionP", "POTENTIALLY-OFFENSIVE-LEXICAL-ASSERTION?", 1, 0, false);
            declareFunction("slang_lexical_assertionP", "SLANG-LEXICAL-ASSERTION?", 1, 0, false);
            declareFunction("archaic_lexical_assertionP", "ARCHAIC-LEXICAL-ASSERTION?", 1, 0, false);
            declareFunction("clear_indirect_lexical_assertionP", "CLEAR-INDIRECT-LEXICAL-ASSERTION?", 0, 0, false);
            declareFunction("remove_indirect_lexical_assertionP", "REMOVE-INDIRECT-LEXICAL-ASSERTION?", 1, 0, false);
            declareFunction("indirect_lexical_assertionP_internal", "INDIRECT-LEXICAL-ASSERTION?-INTERNAL", 1, 0, false);
            declareFunction("indirect_lexical_assertionP", "INDIRECT-LEXICAL-ASSERTION?", 1, 0, false);
            declareFunction("inappropriate_lexical_assertionP", "INAPPROPRIATE-LEXICAL-ASSERTION?", 1, 0, false);
            declareFunction("gather_denotation_assertions", "GATHER-DENOTATION-ASSERTIONS", 3, 0, false);
            declareFunction("potentially_offensive_senseP", "POTENTIALLY-OFFENSIVE-SENSE?", 3, 0, false);
            declareFunction("inappropriate_senseP", "INAPPROPRIATE-SENSE?", 3, 0, false);
            declareFunction("semtrans_of_ws", "SEMTRANS-OF-WS", 3, 0, false);
            declareFunction("semtrans_of_wuXpos", "SEMTRANS-OF-WU&POS", 2, 1, false);
            declareFunction("semtrans_lookup_int", "SEMTRANS-LOOKUP-INT", 3, 1, false);
            declareFunction("semtrans_template_from_assertion", "SEMTRANS-TEMPLATE-FROM-ASSERTION", 1, 1, false);
            declareFunction("semtrans_sentence_infer", "SEMTRANS-SENTENCE-INFER", 2, 0, false);
            declareFunction("denots_of_word", "DENOTS-OF-WORD", 1, 1, false);
            declareFunction("semtrans_assertion_lookup", "SEMTRANS-ASSERTION-LOOKUP", 2, 1, false);
            declareFunction("all_semtrans_assertions", "ALL-SEMTRANS-ASSERTIONS", 2, 1, false);
            declareFunction("preposition_of_frame", "PREPOSITION-OF-FRAME", 1, 0, false);
            declareFunction("assertion_denotation", "ASSERTION-DENOTATION", 1, 0, false);
            declareFunction("assertion_pos", "ASSERTION-POS", 1, 0, false);
            declareFunction("assertion_sense_num", "ASSERTION-SENSE-NUM", 1, 0, false);
            declareFunction("clear_agr_of_det_string", "CLEAR-AGR-OF-DET-STRING", 0, 0, false);
            declareFunction("remove_agr_of_det_string", "REMOVE-AGR-OF-DET-STRING", 1, 0, false);
            declareFunction("agr_of_det_string_internal", "AGR-OF-DET-STRING-INTERNAL", 1, 0, false);
            declareFunction("agr_of_det_string", "AGR-OF-DET-STRING", 1, 0, false);
            declareFunction("agreement_lookup", "AGREEMENT-LOOKUP", 1, 0, false);
            declareFunction("denot_ws_lookup", "DENOT-WS-LOOKUP", 2, 1, false);
            declareFunction("pos_to_semtrans_pred", "POS-TO-SEMTRANS-PRED", 1, 1, false);
            declareFunction("clear_pos_to_semtrans_pred_cached", "CLEAR-POS-TO-SEMTRANS-PRED-CACHED", 0, 0, false);
            new lexicon_accessors.$clear_pos_to_semtrans_pred_cached$ZeroArityFunction();
            declareFunction("remove_pos_to_semtrans_pred_cached", "REMOVE-POS-TO-SEMTRANS-PRED-CACHED", 2, 0, false);
            declareFunction("pos_to_semtrans_pred_cached_internal", "POS-TO-SEMTRANS-PRED-CACHED-INTERNAL", 2, 0, false);
            declareFunction("pos_to_semtrans_pred_cached", "POS-TO-SEMTRANS-PRED-CACHED", 2, 0, false);
            declareFunction("clear_semtrans_pred_to_pos", "CLEAR-SEMTRANS-PRED-TO-POS", 0, 0, false);
            declareFunction("remove_semtrans_pred_to_pos", "REMOVE-SEMTRANS-PRED-TO-POS", 1, 1, false);
            declareFunction("semtrans_pred_to_pos_internal", "SEMTRANS-PRED-TO-POS-INTERNAL", 2, 0, false);
            declareFunction("semtrans_pred_to_pos", "SEMTRANS-PRED-TO-POS", 1, 1, false);
            declareFunction("nicknames_of_name", "NICKNAMES-OF-NAME", 1, 0, false);
            declareFunction("spellings_of_name", "SPELLINGS-OF-NAME", 1, 0, false);
            declareFunction("argn_is_speech_partP", "ARGN-IS-SPEECH-PART?", 2, 0, false);
            declareFunction("speech_parts_initializedP", "SPEECH-PARTS-INITIALIZED?", 0, 0, false);
            declareFunction("clear_speech_parts", "CLEAR-SPEECH-PARTS", 0, 0, false);
            declareFunction("initialize_speech_parts", "INITIALIZE-SPEECH-PARTS", 0, 0, false);
            declareFunction("speech_partP", "SPEECH-PART?", 1, 1, false);
            declareFunction("ensure_speech_parts_initialized", "ENSURE-SPEECH-PARTS-INITIALIZED", 0, 0, false);
            declareFunction("all_speech_parts", "ALL-SPEECH-PARTS", 0, 1, false);
            declareFunction("clear_genl_posP", "CLEAR-GENL-POS?", 0, 0, false);
            declareFunction("remove_genl_posP", "REMOVE-GENL-POS?", 2, 1, false);
            declareFunction("genl_posP_internal", "GENL-POS?-INTERNAL", 3, 0, false);
            declareFunction("genl_posP", "GENL-POS?", 2, 1, false);
            declareFunction("genl_pos_memberP", "GENL-POS-MEMBER?", 2, 0, false);
            declareFunction("spec_posP", "SPEC-POS?", 2, 0, false);
            declareFunction("adjpP", "ADJP?", 1, 0, false);
            declareFunction("vbarP", "VBAR?", 1, 0, false);
            declareFunction("nbarP", "NBAR?", 1, 0, false);
            declareFunction("object_is_compositional_pos_termP", "OBJECT-IS-COMPOSITIONAL-POS-TERM?", 3, 0, false);
            declareFunction("clear_compositional_pos_nart", "CLEAR-COMPOSITIONAL-POS-NART", 0, 0, false);
            declareFunction("remove_compositional_pos_nart", "REMOVE-COMPOSITIONAL-POS-NART", 2, 0, false);
            declareFunction("compositional_pos_nart_internal", "COMPOSITIONAL-POS-NART-INTERNAL", 2, 0, false);
            declareFunction("compositional_pos_nart", "COMPOSITIONAL-POS-NART", 2, 0, false);
            declareFunction("npP", "NP?", 1, 0, false);
            declareFunction("ppP", "PP?", 1, 0, false);
            declareFunction("safe_nart_hl_formula", "SAFE-NART-HL-FORMULA", 1, 0, false);
            declareFunction("relational_noun_denots", "RELATIONAL-NOUN-DENOTS", 4, 4, false);
            declareFunction("relational_noun_denot_template_lookup", "RELATIONAL-NOUN-DENOT-TEMPLATE-LOOKUP", 2, 0, false);
            declareFunction("relational_noun_possessed_argnums", "RELATIONAL-NOUN-POSSESSED-ARGNUMS", 5, 1, false);
            declareFunction("relational_noun_preds", "RELATIONAL-NOUN-PREDS", 4, 1, false);
            declareFunction("relational_noun_possessed_type", "RELATIONAL-NOUN-POSSESSED-TYPE", 2, 1, false);
            declareFunction("relational_noun_possessor_type", "RELATIONAL-NOUN-POSSESSOR-TYPE", 2, 1, false);
            declareFunction("la_test_func", "LA-TEST-FUNC", 2, 0, false);
            declareFunction("denotation_mapper_test", "DENOTATION-MAPPER-TEST", 1, 3, false);
        }
        if (SubLFiles.USE_V2) {
            declareFunction("clear_genl_lexicon_mtP", "CLEAR-GENL-LEXICON-MT?", 0, 0, false);
            declareFunction("remove_genl_lexicon_mtP", "REMOVE-GENL-LEXICON-MT?", 2, 0, false);
            declareFunction("genl_lexicon_mtP_internal", "GENL-LEXICON-MT?-INTERNAL", 2, 0, false);
        }
        return NIL;
    }

    public static SubLObject declare_lexicon_accessors_file_Previous() {
        declareFunction("genl_lexicon_mtP", "GENL-LEXICON-MT?", 2, 0, false);
        declareFunction("clear_genl_lexicon_mtP_cached", "CLEAR-GENL-LEXICON-MT?-CACHED", 0, 0, false);
        declareFunction("remove_genl_lexicon_mtP_cached", "REMOVE-GENL-LEXICON-MT?-CACHED", 2, 0, false);
        declareFunction("genl_lexicon_mtP_cached_internal", "GENL-LEXICON-MT?-CACHED-INTERNAL", 2, 0, false);
        declareFunction("genl_lexicon_mtP_cached", "GENL-LEXICON-MT?-CACHED", 2, 0, false);
        declareFunction("initialize_speech_part_caches", "INITIALIZE-SPEECH-PART-CACHES", 0, 0, false);
        declareFunction("preds_matching_pos", "PREDS-MATCHING-POS", 2, 1, false);
        declareFunction("top_level_nl_preds", "TOP-LEVEL-NL-PREDS", 0, 0, false);
        declareFunction("clear_speech_part_pred_caches", "CLEAR-SPEECH-PART-PRED-CACHES", 0, 0, false);
        declareFunction("max_preds_matching_pos", "MAX-PREDS-MATCHING-POS", 3, 1, false);
        declareFunction("clear_max_preds_matching_pos_cached", "CLEAR-MAX-PREDS-MATCHING-POS-CACHED", 0, 0, false);
        declareFunction("remove_max_preds_matching_pos_cached", "REMOVE-MAX-PREDS-MATCHING-POS-CACHED", 4, 0, false);
        declareFunction("max_preds_matching_pos_cached_internal", "MAX-PREDS-MATCHING-POS-CACHED-INTERNAL", 4, 0, false);
        declareFunction("max_preds_matching_pos_cached", "MAX-PREDS-MATCHING-POS-CACHED", 4, 0, false);
        declareFunction("all_preds_of_pos", "ALL-PREDS-OF-POS", 1, 0, false);
        declareFunction("clear_max_preds_of_pos", "CLEAR-MAX-PREDS-OF-POS", 0, 0, false);
        declareFunction("remove_max_preds_of_pos", "REMOVE-MAX-PREDS-OF-POS", 1, 0, false);
        declareFunction("max_preds_of_pos_internal", "MAX-PREDS-OF-POS-INTERNAL", 1, 0, false);
        declareFunction("max_preds_of_pos", "MAX-PREDS-OF-POS", 1, 0, false);
        declareFunction("clear_max_preds_licensed_by_pos", "CLEAR-MAX-PREDS-LICENSED-BY-POS", 0, 0, false);
        declareFunction("remove_max_preds_licensed_by_pos", "REMOVE-MAX-PREDS-LICENSED-BY-POS", 1, 0, false);
        declareFunction("max_preds_licensed_by_pos_internal", "MAX-PREDS-LICENSED-BY-POS-INTERNAL", 1, 0, false);
        declareFunction("max_preds_licensed_by_pos", "MAX-PREDS-LICENSED-BY-POS", 1, 0, false);
        declareFunction("lex_remove_spec_preds", "LEX-REMOVE-SPEC-PREDS", 1, 0, false);
        declareFunction("lex_remove_spec_preds_helper_internal", "LEX-REMOVE-SPEC-PREDS-HELPER-INTERNAL", 1, 0, false);
        declareFunction("lex_remove_spec_preds_helper", "LEX-REMOVE-SPEC-PREDS-HELPER", 1, 0, false);
        declareFunction("speech_part_pred_min_ceilings", "SPEECH-PART-PRED-MIN-CEILINGS", 1, 1, false);
        declareFunction("clear_speech_part_pred_min_ceilings_int", "CLEAR-SPEECH-PART-PRED-MIN-CEILINGS-INT", 0, 0, false);
        declareFunction("remove_speech_part_pred_min_ceilings_int", "REMOVE-SPEECH-PART-PRED-MIN-CEILINGS-INT", 2, 0, false);
        declareFunction("speech_part_pred_min_ceilings_int_internal", "SPEECH-PART-PRED-MIN-CEILINGS-INT-INTERNAL", 2, 0, false);
        declareFunction("speech_part_pred_min_ceilings_int", "SPEECH-PART-PRED-MIN-CEILINGS-INT", 2, 0, false);
        declareFunction("speech_part_pred_max_floors", "SPEECH-PART-PRED-MAX-FLOORS", 1, 1, false);
        declareFunction("clear_speech_part_pred_max_floors_int", "CLEAR-SPEECH-PART-PRED-MAX-FLOORS-INT", 0, 0, false);
        declareFunction("remove_speech_part_pred_max_floors_int", "REMOVE-SPEECH-PART-PRED-MAX-FLOORS-INT", 2, 0, false);
        declareFunction("speech_part_pred_max_floors_int_internal", "SPEECH-PART-PRED-MAX-FLOORS-INT-INTERNAL", 2, 0, false);
        declareFunction("speech_part_pred_max_floors_int", "SPEECH-PART-PRED-MAX-FLOORS-INT", 2, 0, false);
        declareFunction("clear_pos_of_pred", "CLEAR-POS-OF-PRED", 0, 0, false);
        declareFunction("remove_pos_of_pred", "REMOVE-POS-OF-PRED", 1, 0, false);
        declareFunction("pos_of_pred_internal", "POS-OF-PRED-INTERNAL", 1, 0, false);
        declareFunction("pos_of_pred", "POS-OF-PRED", 1, 0, false);
        declareFunction("singular_pred", "SINGULAR-PRED", 1, 0, false);
        declareFunction("plural_pred", "PLURAL-PRED", 1, 0, false);
        declareFunction("derived_preds", "DERIVED-PREDS", 0, 0, false);
        declareFunction("clear_derived_preds", "CLEAR-DERIVED-PREDS", 0, 0, false);
        declareFunction("initialize_derived_preds", "INITIALIZE-DERIVED-PREDS", 0, 0, false);
        declareFunction("derived_predP", "DERIVED-PRED?", 1, 1, false);
        declareFunction("base_preds_of_pred", "BASE-PREDS-OF-PRED", 1, 1, false);
        declareMacro("do_speech_part_preds", "DO-SPEECH-PART-PREDS");
        declareFunction("speech_part_preds_initializedP", "SPEECH-PART-PREDS-INITIALIZED?", 0, 0, false);
        declareFunction("clear_speech_part_preds", "CLEAR-SPEECH-PART-PREDS", 0, 0, false);
        declareFunction("initialize_speech_part_preds", "INITIALIZE-SPEECH-PART-PREDS", 0, 0, false);
        declareFunction("ensure_speech_part_preds_initialized", "ENSURE-SPEECH-PART-PREDS-INITIALIZED", 0, 0, false);
        declareFunction("speech_part_predP", "SPEECH-PART-PRED?", 1, 1, false);
        new lexicon_accessors.$speech_part_predP$UnaryFunction();
        new lexicon_accessors.$speech_part_predP$BinaryFunction();
        declareFunction("all_speech_part_preds", "ALL-SPEECH-PART-PREDS", 0, 1, false);
        declareFunction("spec_pos_predP", "SPEC-POS-PRED?", 2, 1, false);
        declareFunction("clear_genl_pos_predP", "CLEAR-GENL-POS-PRED?", 0, 0, false);
        declareFunction("remove_genl_pos_predP", "REMOVE-GENL-POS-PRED?", 2, 1, false);
        declareFunction("genl_pos_predP_internal", "GENL-POS-PRED?-INTERNAL", 3, 0, false);
        declareFunction("genl_pos_predP", "GENL-POS-PRED?", 2, 1, false);
        new lexicon_accessors.$genl_pos_predP$BinaryFunction();
        declareFunction("clear_genl_pos_pred_from_mt_infoP", "CLEAR-GENL-POS-PRED-FROM-MT-INFO?", 0, 0, false);
        declareFunction("remove_genl_pos_pred_from_mt_infoP", "REMOVE-GENL-POS-PRED-FROM-MT-INFO?", 2, 1, false);
        declareFunction("genl_pos_pred_from_mt_infoP_internal", "GENL-POS-PRED-FROM-MT-INFO?-INTERNAL", 3, 0, false);
        declareFunction("genl_pos_pred_from_mt_infoP", "GENL-POS-PRED-FROM-MT-INFO?", 2, 1, false);
        declareFunction("word_form_predictableP", "WORD-FORM-PREDICTABLE?", 3, 1, false);
        declareFunction("get_strings_of_type", "GET-STRINGS-OF-TYPE", 2, 3, false);
        declareFunction("clear_get_strings_of_type_cached", "CLEAR-GET-STRINGS-OF-TYPE-CACHED", 0, 0, false);
        declareFunction("remove_get_strings_of_type_cached", "REMOVE-GET-STRINGS-OF-TYPE-CACHED", 2, 3, false);
        declareFunction("get_strings_of_type_cached_internal", "GET-STRINGS-OF-TYPE-CACHED-INTERNAL", 5, 0, false);
        declareFunction("get_strings_of_type_cached", "GET-STRINGS-OF-TYPE-CACHED", 2, 3, false);
        declareFunction("string_is_pos_on_wuP_internal", "STRING-IS-POS-ON-WU?-INTERNAL", 3, 3, false);
        declareFunction("string_is_pos_on_wuP", "STRING-IS-POS-ON-WU?", 3, 3, false);
        declareFunction("string_is_pos_on_wuP_asserted", "STRING-IS-POS-ON-WU?-ASSERTED", 4, 0, false);
        declareFunction("string_is_pred_on_wuP", "STRING-IS-PRED-ON-WU?", 3, 2, false);
        declareFunction("best_wu_for_string", "BEST-WU-FOR-STRING", 2, 0, false);
        declareFunction("best_pos_for_stringXwuXpos", "BEST-POS-FOR-STRING&WU&POS", 3, 0, false);
        declareFunction("words_of_stringXpred", "WORDS-OF-STRING&PRED", 2, 3, false);
        declareFunction("clear_pos_for_keyword", "CLEAR-POS-FOR-KEYWORD", 0, 0, false);
        declareFunction("remove_pos_for_keyword", "REMOVE-POS-FOR-KEYWORD", 1, 1, false);
        declareFunction("pos_for_keyword_internal", "POS-FOR-KEYWORD-INTERNAL", 2, 0, false);
        declareFunction("pos_for_keyword", "POS-FOR-KEYWORD", 1, 1, false);
        declareFunction("words_of_stringXpos", "WORDS-OF-STRING&POS", 2, 3, false);
        declareFunction("words_of_stringXspeech_part", "WORDS-OF-STRING&SPEECH-PART", 2, 3, false);
        declareFunction("preds_of_stringXword", "PREDS-OF-STRING&WORD", 2, 3, false);
        declareFunction("clear_preds_of_stringXword", "CLEAR-PREDS-OF-STRING&WORD", 0, 0, false);
        declareFunction("clear_preds_of_stringXword_cached", "CLEAR-PREDS-OF-STRING&WORD-CACHED", 0, 0, false);
        declareFunction("remove_preds_of_stringXword_cached", "REMOVE-PREDS-OF-STRING&WORD-CACHED", 5, 0, false);
        declareFunction("preds_of_stringXword_cached_internal", "PREDS-OF-STRING&WORD-CACHED-INTERNAL", 5, 0, false);
        declareFunction("preds_of_stringXword_cached", "PREDS-OF-STRING&WORD-CACHED", 5, 0, false);
        declareFunction("other_strings_of_wu", "OTHER-STRINGS-OF-WU", 1, 2, false);
        declareFunction("right_frames_for_pos", "RIGHT-FRAMES-FOR-POS", 1, 0, false);
        declareFunction("pos_of_string", "POS-OF-STRING", 1, 3, false);
        declareFunction("string_is_posP", "STRING-IS-POS?", 2, 3, false);
        declareFunction("string_is_form_of_aux_verbP", "STRING-IS-FORM-OF-AUX-VERB?", 1, 2, false);
        declareFunction("clear_closed_lexical_class_hash", "CLEAR-CLOSED-LEXICAL-CLASS-HASH", 0, 0, false);
        declareFunction("initialize_closed_lexical_class_strings", "INITIALIZE-CLOSED-LEXICAL-CLASS-STRINGS", 0, 0, false);
        declareFunction("closed_lexical_class_string_intP", "CLOSED-LEXICAL-CLASS-STRING-INT?", 3, 0, false);
        declareFunction("closed_lexical_class_stringP", "CLOSED-LEXICAL-CLASS-STRING?", 1, 1, false);
        declareFunction("closed_lexical_class_string_case_insensitiveP", "CLOSED-LEXICAL-CLASS-STRING-CASE-INSENSITIVE?", 1, 1, false);
        declareFunction("non_pronominal_closed_lexical_class_stringP", "NON-PRONOMINAL-CLOSED-LEXICAL-CLASS-STRING?", 1, 1, false);
        declareFunction("contains_closed_lexical_class_wordP", "CONTAINS-CLOSED-LEXICAL-CLASS-WORD?", 1, 0, false);
        declareFunction("clear_closed_lexical_class_strings", "CLEAR-CLOSED-LEXICAL-CLASS-STRINGS", 0, 0, false);
        declareFunction("remove_closed_lexical_class_strings", "REMOVE-CLOSED-LEXICAL-CLASS-STRINGS", 0, 1, false);
        declareFunction("closed_lexical_class_strings_internal", "CLOSED-LEXICAL-CLASS-STRINGS-INTERNAL", 1, 0, false);
        declareFunction("closed_lexical_class_strings", "CLOSED-LEXICAL-CLASS-STRINGS", 0, 1, false);
        declareFunction("closed_lexical_classP", "CLOSED-LEXICAL-CLASS?", 1, 1, false);
        declareFunction("clear_closed_lexical_classes", "CLEAR-CLOSED-LEXICAL-CLASSES", 0, 0, false);
        declareFunction("remove_closed_lexical_classes", "REMOVE-CLOSED-LEXICAL-CLASSES", 0, 1, false);
        declareFunction("closed_lexical_classes_internal", "CLOSED-LEXICAL-CLASSES-INTERNAL", 1, 0, false);
        declareFunction("closed_lexical_classes", "CLOSED-LEXICAL-CLASSES", 0, 1, false);
        declareFunction("maybe_initialize_prep_strings", "MAYBE-INITIALIZE-PREP-STRINGS", 0, 0, false);
        declareFunction("preposition_stringP", "PREPOSITION-STRING?", 1, 1, false);
        declareFunction("quick_lexical_wordP", "QUICK-LEXICAL-WORD?", 1, 1, false);
        declareFunction("quick_lexical_wordP_int", "QUICK-LEXICAL-WORD?-INT", 2, 0, false);
        declareFunction("quick_word_nautP", "QUICK-WORD-NAUT?", 1, 0, false);
        declareFunction("lexical_wordP_internal", "LEXICAL-WORD?-INTERNAL", 1, 0, false);
        declareFunction("lexical_wordP", "LEXICAL-WORD?", 1, 0, false);
        declareFunction("derived_wordP_internal", "DERIVED-WORD?-INTERNAL", 1, 0, false);
        declareFunction("derived_wordP", "DERIVED-WORD?", 1, 0, false);
        declareFunction("initialize_vulgar_words", "INITIALIZE-VULGAR-WORDS", 0, 0, false);
        declareFunction("vulgar_wordP", "VULGAR-WORD?", 1, 0, false);
        declareFunction("pos_of_stringXword", "POS-OF-STRING&WORD", 2, 3, false);
        declareFunction("clear_nl_caches", "CLEAR-NL-CACHES", 0, 0, false);
        declareFunction("clear_nl_parsing_caches", "CLEAR-NL-PARSING-CACHES", 0, 0, false);
        declareFunction("clear_cached_lexical_access_functions", "CLEAR-CACHED-LEXICAL-ACCESS-FUNCTIONS", 0, 0, false);
        declareFunction("pos_of_word", "POS-OF-WORD", 1, 1, false);
        declareFunction("word_has_posP", "WORD-HAS-POS?", 2, 1, false);
        declareFunction("clear_verb_only_stringP", "CLEAR-VERB-ONLY-STRING?", 0, 0, false);
        declareFunction("remove_verb_only_stringP", "REMOVE-VERB-ONLY-STRING?", 1, 0, false);
        declareFunction("verb_only_stringP_internal", "VERB-ONLY-STRING?-INTERNAL", 1, 0, false);
        declareFunction("verb_only_stringP", "VERB-ONLY-STRING?", 1, 0, false);
        declareFunction("typed_denots_of_string", "TYPED-DENOTS-OF-STRING", 2, 8, false);
        declareFunction("typed_denots_of_string_preds_okP", "TYPED-DENOTS-OF-STRING-PREDS-OK?", 2, 0, false);
        declareFunction("denot_has_typeP_internal", "DENOT-HAS-TYPE?-INTERNAL", 2, 1, false);
        declareFunction("denot_has_typeP", "DENOT-HAS-TYPE?", 2, 1, false);
        declareFunction("denot_might_have_typeP_internal", "DENOT-MIGHT-HAVE-TYPE?-INTERNAL", 2, 0, false);
        declareFunction("denot_might_have_typeP", "DENOT-MIGHT-HAVE-TYPE?", 2, 0, false);
        declareFunction("multi_typed_denots_of_string", "MULTI-TYPED-DENOTS-OF-STRING", 3, 8, false);
        declareFunction("typed_denots_of_string_at_place", "TYPED-DENOTS-OF-STRING-AT-PLACE", 3, 6, false);
        declareFunction("in_region_p", "IN-REGION-P", 3, 0, false);
        declareFunction("geopolitical_subdivisionP", "GEOPOLITICAL-SUBDIVISION?", 3, 0, false);
        declareFunction("geographical_subregionP", "GEOGRAPHICAL-SUBREGION?", 3, 0, false);
        declareFunction("territories_for_gpe", "TERRITORIES-FOR-GPE", 1, 0, false);
        declareFunction("gpe_for_territory", "GPE-FOR-TERRITORY", 1, 0, false);
        declareFunction("denots_of_partial_string", "DENOTS-OF-PARTIAL-STRING", 1, 3, false);
        declareFunction("denotation_mapper", "DENOTATION-MAPPER", 1, 3, false);
        declareFunction("all_denots_of_string", "ALL-DENOTS-OF-STRING", 1, 3, false);
        declareFunction("most_denots_of_string", "MOST-DENOTS-OF-STRING", 1, 3, false);
        declareFunction("all_parsing_denots_of_string", "ALL-PARSING-DENOTS-OF-STRING", 1, 3, false);
        declareFunction("denots_of_string", "DENOTS-OF-STRING", 1, 8, false);
        declareFunction("valid_denots_of_string_lookup_mt_specificationP", "VALID-DENOTS-OF-STRING-LOOKUP-MT-SPECIFICATION?", 1, 0, false);
        declareFunction("denots_mt_for_language", "DENOTS-MT-FOR-LANGUAGE", 1, 0, false);
        declareFunction("add_denots_of_string_results", "ADD-DENOTS-OF-STRING-RESULTS", 4, 0, false);
        declareFunction("date_and_number_denots_of_string", "DATE-AND-NUMBER-DENOTS-OF-STRING", 1, 0, false);
        declareFunction("denots_of_stringXpred", "DENOTS-OF-STRING&PRED", 2, 6, false);
        declareFunction("denots_of_stringXnamestring_pred", "DENOTS-OF-STRING&NAMESTRING-PRED", 2, 3, false);
        declareFunction("denots_of_stringXpos_pred", "DENOTS-OF-STRING&POS-PRED", 2, 5, false);
        declareFunction("denots_of_stringXspeech_part", "DENOTS-OF-STRING&SPEECH-PART", 2, 5, false);
        declareFunction("denots_of_stringXpos", "DENOTS-OF-STRING&POS", 2, 5, false);
        declareFunction("denots_of_name_string", "DENOTS-OF-NAME-STRING", 1, 3, false);
        declareFunction("denots_of_name_string_precise", "DENOTS-OF-NAME-STRING-PRECISE", 1, 2, false);
        declareFunction("denots_of_wu", "DENOTS-OF-WU", 1, 1, false);
        declareFunction("proceed_with_morphological_parsingP", "PROCEED-WITH-MORPHOLOGICAL-PARSING?", 2, 0, false);
        declareFunction("skip_to_morphological_parsingP", "SKIP-TO-MORPHOLOGICAL-PARSING?", 1, 0, false);
        declareFunction("denots_of_acronym_string", "DENOTS-OF-ACRONYM-STRING", 1, 2, false);
        declareFunction("names_from_spelling", "NAMES-FROM-SPELLING", 1, 2, false);
        declareFunction("names_from_nickname", "NAMES-FROM-NICKNAME", 1, 2, false);
        declareFunction("denots_of_abbreviation_string", "DENOTS-OF-ABBREVIATION-STRING", 1, 2, false);
        declareFunction("known_proper_noun_phraseP", "KNOWN-PROPER-NOUN-PHRASE?", 1, 0, false);
        declareFunction("determine_denotation_preds", "DETERMINE-DENOTATION-PREDS", 1, 0, false);
        declareFunction("determine_denotation_pred", "DETERMINE-DENOTATION-PRED", 1, 0, false);
        declareFunction("meanings_of_sense", "MEANINGS-OF-SENSE", 4, 1, false);
        declareFunction("meaning_has_senseP", "MEANING-HAS-SENSE?", 5, 1, false);
        declareFunction("denot_has_senseP", "DENOT-HAS-SENSE?", 4, 1, false);
        declareFunction("denots_of_sense", "DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("proper_denots_of_sense", "PROPER-DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("related_denots_of_sense", "RELATED-DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("placeholder_denots_of_sense", "PLACEHOLDER-DENOTS-OF-SENSE", 3, 1, false);
        declareFunction("denots_of_sense_by_mt", "DENOTS-OF-SENSE-BY-MT", 3, 1, false);
        declareFunction("senses_of_wuXpos", "SENSES-OF-WU&POS", 2, 1, false);
        declareFunction("subcat_frame_arity", "SUBCAT-FRAME-ARITY", 1, 0, false);
        declareFunction("frames_of_word", "FRAMES-OF-WORD", 1, 0, false);
        declareFunction("frames_of_wordXpos", "FRAMES-OF-WORD&POS", 2, 0, false);
        declareFunction("frames_of_word_posXdenot", "FRAMES-OF-WORD-POS&DENOT", 3, 0, false);
        declareFunction("frames_of_sense", "FRAMES-OF-SENSE", 3, 1, false);
        declareFunction("frames_of_sense_by_mt", "FRAMES-OF-SENSE-BY-MT", 3, 0, false);
        declareFunction("politeness_of_ws_pred", "POLITENESS-OF-WS-PRED", 0, 0, false);
        declareFunction("formality_of_ws_pred", "FORMALITY-OF-WS-PRED", 0, 0, false);
        declareFunction("politeness_levels_of_assertion", "POLITENESS-LEVELS-OF-ASSERTION", 1, 1, false);
        declareFunction("formality_levels_of_assertion", "FORMALITY-LEVELS-OF-ASSERTION", 1, 1, false);
        declareFunction("potentially_offensive_politeness_levelP", "POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?", 1, 0, false);
        declareFunction("includes_potentially_offensive_politeness_levelP", "INCLUDES-POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?", 1, 0, false);
        declareFunction("potentially_offensive_lexical_assertionP", "POTENTIALLY-OFFENSIVE-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("slang_lexical_assertionP", "SLANG-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("archaic_lexical_assertionP", "ARCHAIC-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("clear_indirect_lexical_assertionP", "CLEAR-INDIRECT-LEXICAL-ASSERTION?", 0, 0, false);
        declareFunction("remove_indirect_lexical_assertionP", "REMOVE-INDIRECT-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("indirect_lexical_assertionP_internal", "INDIRECT-LEXICAL-ASSERTION?-INTERNAL", 1, 0, false);
        declareFunction("indirect_lexical_assertionP", "INDIRECT-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("inappropriate_lexical_assertionP", "INAPPROPRIATE-LEXICAL-ASSERTION?", 1, 0, false);
        declareFunction("gather_denotation_assertions", "GATHER-DENOTATION-ASSERTIONS", 3, 0, false);
        declareFunction("potentially_offensive_senseP", "POTENTIALLY-OFFENSIVE-SENSE?", 3, 0, false);
        declareFunction("inappropriate_senseP", "INAPPROPRIATE-SENSE?", 3, 0, false);
        declareFunction("semtrans_of_ws", "SEMTRANS-OF-WS", 3, 0, false);
        declareFunction("semtrans_of_wuXpos", "SEMTRANS-OF-WU&POS", 2, 1, false);
        declareFunction("semtrans_lookup_int", "SEMTRANS-LOOKUP-INT", 3, 1, false);
        declareFunction("semtrans_template_from_assertion", "SEMTRANS-TEMPLATE-FROM-ASSERTION", 1, 1, false);
        declareFunction("semtrans_sentence_infer", "SEMTRANS-SENTENCE-INFER", 2, 0, false);
        declareFunction("denots_of_word", "DENOTS-OF-WORD", 1, 1, false);
        declareFunction("semtrans_assertion_lookup", "SEMTRANS-ASSERTION-LOOKUP", 2, 1, false);
        declareFunction("all_semtrans_assertions", "ALL-SEMTRANS-ASSERTIONS", 2, 1, false);
        declareFunction("preposition_of_frame", "PREPOSITION-OF-FRAME", 1, 0, false);
        declareFunction("assertion_denotation", "ASSERTION-DENOTATION", 1, 0, false);
        declareFunction("assertion_pos", "ASSERTION-POS", 1, 0, false);
        declareFunction("assertion_sense_num", "ASSERTION-SENSE-NUM", 1, 0, false);
        declareFunction("clear_agr_of_det_string", "CLEAR-AGR-OF-DET-STRING", 0, 0, false);
        declareFunction("remove_agr_of_det_string", "REMOVE-AGR-OF-DET-STRING", 1, 0, false);
        declareFunction("agr_of_det_string_internal", "AGR-OF-DET-STRING-INTERNAL", 1, 0, false);
        declareFunction("agr_of_det_string", "AGR-OF-DET-STRING", 1, 0, false);
        declareFunction("agreement_lookup", "AGREEMENT-LOOKUP", 1, 0, false);
        declareFunction("denot_ws_lookup", "DENOT-WS-LOOKUP", 2, 1, false);
        declareFunction("pos_to_semtrans_pred", "POS-TO-SEMTRANS-PRED", 1, 1, false);
        declareFunction("clear_pos_to_semtrans_pred_cached", "CLEAR-POS-TO-SEMTRANS-PRED-CACHED", 0, 0, false);
        new lexicon_accessors.$clear_pos_to_semtrans_pred_cached$ZeroArityFunction();
        declareFunction("remove_pos_to_semtrans_pred_cached", "REMOVE-POS-TO-SEMTRANS-PRED-CACHED", 2, 0, false);
        declareFunction("pos_to_semtrans_pred_cached_internal", "POS-TO-SEMTRANS-PRED-CACHED-INTERNAL", 2, 0, false);
        declareFunction("pos_to_semtrans_pred_cached", "POS-TO-SEMTRANS-PRED-CACHED", 2, 0, false);
        declareFunction("clear_semtrans_pred_to_pos", "CLEAR-SEMTRANS-PRED-TO-POS", 0, 0, false);
        declareFunction("remove_semtrans_pred_to_pos", "REMOVE-SEMTRANS-PRED-TO-POS", 1, 1, false);
        declareFunction("semtrans_pred_to_pos_internal", "SEMTRANS-PRED-TO-POS-INTERNAL", 2, 0, false);
        declareFunction("semtrans_pred_to_pos", "SEMTRANS-PRED-TO-POS", 1, 1, false);
        declareFunction("nicknames_of_name", "NICKNAMES-OF-NAME", 1, 0, false);
        declareFunction("spellings_of_name", "SPELLINGS-OF-NAME", 1, 0, false);
        declareFunction("argn_is_speech_partP", "ARGN-IS-SPEECH-PART?", 2, 0, false);
        declareFunction("speech_parts_initializedP", "SPEECH-PARTS-INITIALIZED?", 0, 0, false);
        declareFunction("clear_speech_parts", "CLEAR-SPEECH-PARTS", 0, 0, false);
        declareFunction("initialize_speech_parts", "INITIALIZE-SPEECH-PARTS", 0, 0, false);
        declareFunction("speech_partP", "SPEECH-PART?", 1, 1, false);
        declareFunction("ensure_speech_parts_initialized", "ENSURE-SPEECH-PARTS-INITIALIZED", 0, 0, false);
        declareFunction("all_speech_parts", "ALL-SPEECH-PARTS", 0, 1, false);
        declareFunction("clear_genl_posP", "CLEAR-GENL-POS?", 0, 0, false);
        declareFunction("remove_genl_posP", "REMOVE-GENL-POS?", 2, 1, false);
        declareFunction("genl_posP_internal", "GENL-POS?-INTERNAL", 3, 0, false);
        declareFunction("genl_posP", "GENL-POS?", 2, 1, false);
        declareFunction("genl_pos_memberP", "GENL-POS-MEMBER?", 2, 0, false);
        declareFunction("spec_posP", "SPEC-POS?", 2, 0, false);
        declareFunction("adjpP", "ADJP?", 1, 0, false);
        declareFunction("vbarP", "VBAR?", 1, 0, false);
        declareFunction("nbarP", "NBAR?", 1, 0, false);
        declareFunction("object_is_compositional_pos_termP", "OBJECT-IS-COMPOSITIONAL-POS-TERM?", 3, 0, false);
        declareFunction("clear_compositional_pos_nart", "CLEAR-COMPOSITIONAL-POS-NART", 0, 0, false);
        declareFunction("remove_compositional_pos_nart", "REMOVE-COMPOSITIONAL-POS-NART", 2, 0, false);
        declareFunction("compositional_pos_nart_internal", "COMPOSITIONAL-POS-NART-INTERNAL", 2, 0, false);
        declareFunction("compositional_pos_nart", "COMPOSITIONAL-POS-NART", 2, 0, false);
        declareFunction("npP", "NP?", 1, 0, false);
        declareFunction("ppP", "PP?", 1, 0, false);
        declareFunction("safe_nart_hl_formula", "SAFE-NART-HL-FORMULA", 1, 0, false);
        declareFunction("relational_noun_denots", "RELATIONAL-NOUN-DENOTS", 4, 4, false);
        declareFunction("relational_noun_denot_template_lookup", "RELATIONAL-NOUN-DENOT-TEMPLATE-LOOKUP", 2, 0, false);
        declareFunction("relational_noun_possessed_argnums", "RELATIONAL-NOUN-POSSESSED-ARGNUMS", 5, 1, false);
        declareFunction("relational_noun_preds", "RELATIONAL-NOUN-PREDS", 4, 1, false);
        declareFunction("relational_noun_possessed_type", "RELATIONAL-NOUN-POSSESSED-TYPE", 2, 1, false);
        declareFunction("relational_noun_possessor_type", "RELATIONAL-NOUN-POSSESSOR-TYPE", 2, 1, false);
        declareFunction("la_test_func", "LA-TEST-FUNC", 2, 0, false);
        declareFunction("denotation_mapper_test", "DENOTATION-MAPPER-TEST", 1, 3, false);
        return NIL;
    }

    public static final SubLObject init_lexicon_accessors_file_alt() {
        deflexical("*GENL-LEXICON-MT?-CACHING-STATE*", NIL);
        deflexical("*MAX-PREDS-MATCHING-POS-CACHED-CACHING-STATE*", NIL);
        deflexical("*MAX-PREDS-OF-POS-CACHING-STATE*", NIL);
        deflexical("*MAX-PREDS-LICENSED-BY-POS-CACHING-STATE*", NIL);
        deflexical("*SPEECH-PART-PRED-MIN-CEILINGS-INT-CACHING-STATE*", NIL);
        deflexical("*SPEECH-PART-PRED-MAX-FLOORS-INT-CACHING-STATE*", NIL);
        deflexical("*POS-OF-PRED-CACHING-STATE*", NIL);
        deflexical("*DERIVED-PREDS*", NIL != boundp($derived_preds$) ? ((SubLObject) ($derived_preds$.getGlobalValue())) : make_hash_table($int$256, UNPROVIDED, UNPROVIDED));
        deflexical("*SPEECH-PART-PREDS*", NIL != boundp($speech_part_preds$) ? ((SubLObject) ($speech_part_preds$.getGlobalValue())) : dictionary.new_dictionary(symbol_function(EQ), $int$256));
        deflexical("*GENL-POS-PRED?-CACHING-STATE*", NIL);
        deflexical("*GENL-POS-PRED-FROM-MT-INFO?-CACHING-STATE*", NIL);
        deflexical("*GET-STRINGS-OF-TYPE-CACHED-CACHING-STATE*", NIL);
        deflexical("*POS-FOR-KEYWORD-CACHING-STATE*", NIL);
        deflexical("*PREDS-OF-STRING&WORD-CACHED-CACHING-STATE*", NIL);
        deflexical("*CLOSED-LEXICAL-CLASS-STRINGS*", NIL != boundp($closed_lexical_class_strings$) ? ((SubLObject) ($closed_lexical_class_strings$.getGlobalValue())) : make_hash_table($int$512, symbol_function(EQUALP), UNPROVIDED));
        deflexical("*CLOSED-LEXICAL-CLASS-STRINGS-CACHING-STATE*", NIL);
        deflexical("*CLOSED-LEXICAL-CLASSES-CACHING-STATE*", NIL);
        defparameter("*PREPOSITION-STRINGS*", make_hash_table($int$64, symbol_function(EQUALP), UNPROVIDED));
        deflexical("*POS-FORMS-SPEC-PREDS*", $list_alt156);
        deflexical("*VULGAR-WORDS*", NIL != boundp($vulgar_words$) ? ((SubLObject) ($vulgar_words$.getGlobalValue())) : new_set(UNPROVIDED, UNPROVIDED));
        deflexical("*VERB-ONLY-STRING?-CACHING-STATE*", NIL);
        deflexical("*AGR-OF-DET-STRING-CACHING-STATE*", NIL);
        deflexical("*POS-TO-SEMTRANS-PRED-CACHED-CACHING-STATE*", NIL);
        deflexical("*SEMTRANS-PRED-TO-POS-CACHING-STATE*", NIL);
        deflexical("*SPEECH-PARTS*", NIL != boundp($speech_parts$) ? ((SubLObject) ($speech_parts$.getGlobalValue())) : dictionary.new_dictionary(symbol_function(EQ), $int$256));
        deflexical("*GENL-POS?-CACHING-STATE*", NIL);
        deflexical("*MOST-GENERAL-SPEECH-PART*", $$NLWordForm);
        deflexical("*COMPOSITIONAL-POS-NART-CACHING-STATE*", NIL);
        deflexical("*RELATIONAL-NOUN-DENOT-TEMPLATES*", $list_alt276);
        return NIL;
    }

    public static SubLObject init_lexicon_accessors_file() {
        if (SubLFiles.USE_V1) {
            deflexical("*GENL-LEXICON-MT?-CACHED-CACHING-STATE*", NIL);
            deflexical("*MAX-PREDS-MATCHING-POS-CACHED-CACHING-STATE*", NIL);
            deflexical("*MAX-PREDS-OF-POS-CACHING-STATE*", NIL);
            deflexical("*MAX-PREDS-LICENSED-BY-POS-CACHING-STATE*", NIL);
            deflexical("*SPEECH-PART-PRED-MIN-CEILINGS-INT-CACHING-STATE*", NIL);
            deflexical("*SPEECH-PART-PRED-MAX-FLOORS-INT-CACHING-STATE*", NIL);
            deflexical("*POS-OF-PRED-CACHING-STATE*", NIL);
            deflexical("*DERIVED-PREDS*", SubLTrampolineFile.maybeDefault($derived_preds$, $derived_preds$, () -> make_hash_table($int$256, UNPROVIDED, UNPROVIDED)));
            deflexical("*SPEECH-PART-PREDS*", SubLTrampolineFile.maybeDefault($speech_part_preds$, $speech_part_preds$, () -> dictionary.new_dictionary(symbol_function(EQL), $int$256)));
            deflexical("*GENL-POS-PRED?-CACHING-STATE*", NIL);
            deflexical("*GENL-POS-PRED-FROM-MT-INFO?-CACHING-STATE*", NIL);
            deflexical("*GET-STRINGS-OF-TYPE-CACHED-CACHING-STATE*", NIL);
            deflexical("*POS-FOR-KEYWORD-CACHING-STATE*", NIL);
            deflexical("*PREDS-OF-STRING&WORD-CACHED-CACHING-STATE*", NIL);
            deflexical("*CLOSED-LEXICAL-CLASS-STRINGS*", SubLTrampolineFile.maybeDefault($closed_lexical_class_strings$, $closed_lexical_class_strings$, () -> make_hash_table($int$512, symbol_function(EQUAL), UNPROVIDED)));
            deflexical("*CLOSED-LEXICAL-CLASS-STRINGS-CASE-INSENSITIVE*", SubLTrampolineFile.maybeDefault($closed_lexical_class_strings_case_insensitive$, $closed_lexical_class_strings_case_insensitive$, () -> make_hash_table($int$512, symbol_function(EQUALP), UNPROVIDED)));
            deflexical("*CLOSED-LEXICAL-CLASS-STRINGS-CACHING-STATE*", NIL);
            deflexical("*CLOSED-LEXICAL-CLASSES-CACHING-STATE*", NIL);
            defparameter("*PREPOSITION-STRINGS*", make_hash_table($int$64, symbol_function(EQUALP), UNPROVIDED));
            deflexical("*POS-FORMS-SPEC-PREDS*", $list160);
            deflexical("*VULGAR-WORDS*", SubLTrampolineFile.maybeDefault($vulgar_words$, $vulgar_words$, () -> set.new_set(UNPROVIDED, UNPROVIDED)));
            deflexical("*VERB-ONLY-STRING?-CACHING-STATE*", NIL);
            deflexical("*INDIRECT-LEXICAL-ASSERTION?-CACHING-STATE*", NIL);
            deflexical("*AGR-OF-DET-STRING-CACHING-STATE*", NIL);
            deflexical("*POS-TO-SEMTRANS-PRED-CACHED-CACHING-STATE*", NIL);
            deflexical("*SEMTRANS-PRED-TO-POS-CACHING-STATE*", NIL);
            deflexical("*SPEECH-PARTS*", SubLTrampolineFile.maybeDefault($speech_parts$, $speech_parts$, () -> dictionary.new_dictionary(symbol_function(EQL), $int$256)));
            deflexical("*GENL-POS?-CACHING-STATE*", NIL);
            deflexical("*MOST-GENERAL-SPEECH-PART*", $$NLWordForm);
            deflexical("*COMPOSITIONAL-POS-NART-CACHING-STATE*", NIL);
            deflexical("*RELATIONAL-NOUN-DENOT-TEMPLATES*", $list289);
        }
        if (SubLFiles.USE_V2) {
            deflexical("*GENL-LEXICON-MT?-CACHING-STATE*", NIL);
            deflexical("*DERIVED-PREDS*", NIL != boundp($derived_preds$) ? ((SubLObject) ($derived_preds$.getGlobalValue())) : make_hash_table($int$256, UNPROVIDED, UNPROVIDED));
            deflexical("*SPEECH-PART-PREDS*", NIL != boundp($speech_part_preds$) ? ((SubLObject) ($speech_part_preds$.getGlobalValue())) : dictionary.new_dictionary(symbol_function(EQ), $int$256));
            deflexical("*CLOSED-LEXICAL-CLASS-STRINGS*", NIL != boundp($closed_lexical_class_strings$) ? ((SubLObject) ($closed_lexical_class_strings$.getGlobalValue())) : make_hash_table($int$512, symbol_function(EQUALP), UNPROVIDED));
            deflexical("*POS-FORMS-SPEC-PREDS*", $list_alt156);
            deflexical("*VULGAR-WORDS*", NIL != boundp($vulgar_words$) ? ((SubLObject) ($vulgar_words$.getGlobalValue())) : new_set(UNPROVIDED, UNPROVIDED));
            deflexical("*SPEECH-PARTS*", NIL != boundp($speech_parts$) ? ((SubLObject) ($speech_parts$.getGlobalValue())) : dictionary.new_dictionary(symbol_function(EQ), $int$256));
            deflexical("*RELATIONAL-NOUN-DENOT-TEMPLATES*", $list_alt276);
        }
        return NIL;
    }

    public static SubLObject init_lexicon_accessors_file_Previous() {
        deflexical("*GENL-LEXICON-MT?-CACHED-CACHING-STATE*", NIL);
        deflexical("*MAX-PREDS-MATCHING-POS-CACHED-CACHING-STATE*", NIL);
        deflexical("*MAX-PREDS-OF-POS-CACHING-STATE*", NIL);
        deflexical("*MAX-PREDS-LICENSED-BY-POS-CACHING-STATE*", NIL);
        deflexical("*SPEECH-PART-PRED-MIN-CEILINGS-INT-CACHING-STATE*", NIL);
        deflexical("*SPEECH-PART-PRED-MAX-FLOORS-INT-CACHING-STATE*", NIL);
        deflexical("*POS-OF-PRED-CACHING-STATE*", NIL);
        deflexical("*DERIVED-PREDS*", SubLTrampolineFile.maybeDefault($derived_preds$, $derived_preds$, () -> make_hash_table($int$256, UNPROVIDED, UNPROVIDED)));
        deflexical("*SPEECH-PART-PREDS*", SubLTrampolineFile.maybeDefault($speech_part_preds$, $speech_part_preds$, () -> dictionary.new_dictionary(symbol_function(EQL), $int$256)));
        deflexical("*GENL-POS-PRED?-CACHING-STATE*", NIL);
        deflexical("*GENL-POS-PRED-FROM-MT-INFO?-CACHING-STATE*", NIL);
        deflexical("*GET-STRINGS-OF-TYPE-CACHED-CACHING-STATE*", NIL);
        deflexical("*POS-FOR-KEYWORD-CACHING-STATE*", NIL);
        deflexical("*PREDS-OF-STRING&WORD-CACHED-CACHING-STATE*", NIL);
        deflexical("*CLOSED-LEXICAL-CLASS-STRINGS*", SubLTrampolineFile.maybeDefault($closed_lexical_class_strings$, $closed_lexical_class_strings$, () -> make_hash_table($int$512, symbol_function(EQUAL), UNPROVIDED)));
        deflexical("*CLOSED-LEXICAL-CLASS-STRINGS-CASE-INSENSITIVE*", SubLTrampolineFile.maybeDefault($closed_lexical_class_strings_case_insensitive$, $closed_lexical_class_strings_case_insensitive$, () -> make_hash_table($int$512, symbol_function(EQUALP), UNPROVIDED)));
        deflexical("*CLOSED-LEXICAL-CLASS-STRINGS-CACHING-STATE*", NIL);
        deflexical("*CLOSED-LEXICAL-CLASSES-CACHING-STATE*", NIL);
        defparameter("*PREPOSITION-STRINGS*", make_hash_table($int$64, symbol_function(EQUALP), UNPROVIDED));
        deflexical("*POS-FORMS-SPEC-PREDS*", $list160);
        deflexical("*VULGAR-WORDS*", SubLTrampolineFile.maybeDefault($vulgar_words$, $vulgar_words$, () -> set.new_set(UNPROVIDED, UNPROVIDED)));
        deflexical("*VERB-ONLY-STRING?-CACHING-STATE*", NIL);
        deflexical("*INDIRECT-LEXICAL-ASSERTION?-CACHING-STATE*", NIL);
        deflexical("*AGR-OF-DET-STRING-CACHING-STATE*", NIL);
        deflexical("*POS-TO-SEMTRANS-PRED-CACHED-CACHING-STATE*", NIL);
        deflexical("*SEMTRANS-PRED-TO-POS-CACHING-STATE*", NIL);
        deflexical("*SPEECH-PARTS*", SubLTrampolineFile.maybeDefault($speech_parts$, $speech_parts$, () -> dictionary.new_dictionary(symbol_function(EQL), $int$256)));
        deflexical("*GENL-POS?-CACHING-STATE*", NIL);
        deflexical("*MOST-GENERAL-SPEECH-PART*", $$NLWordForm);
        deflexical("*COMPOSITIONAL-POS-NART-CACHING-STATE*", NIL);
        deflexical("*RELATIONAL-NOUN-DENOT-TEMPLATES*", $list289);
        return NIL;
    }

    public static final SubLObject setup_lexicon_accessors_file_alt() {
        memoization_state.note_globally_cached_function($sym0$GENL_LEXICON_MT_);
        memoization_state.note_globally_cached_function(MAX_PREDS_MATCHING_POS_CACHED);
        memoization_state.note_globally_cached_function(MAX_PREDS_OF_POS);
        memoization_state.note_globally_cached_function(MAX_PREDS_LICENSED_BY_POS);
        memoization_state.note_memoized_function(LEX_REMOVE_SPEC_PREDS_HELPER);
        memoization_state.note_globally_cached_function(SPEECH_PART_PRED_MIN_CEILINGS_INT);
        memoization_state.note_globally_cached_function(SPEECH_PART_PRED_MAX_FLOORS_INT);
        memoization_state.note_globally_cached_function(POS_OF_PRED);
        declare_defglobal($derived_preds$);
        declare_defglobal($speech_part_preds$);
        memoization_state.note_globally_cached_function($sym73$GENL_POS_PRED_);
        memoization_state.note_globally_cached_function($sym78$GENL_POS_PRED_FROM_MT_INFO_);
        memoization_state.note_globally_cached_function(GET_STRINGS_OF_TYPE_CACHED);
        memoization_state.note_memoized_function($sym90$STRING_IS_POS_ON_WU_);
        memoization_state.note_globally_cached_function(POS_FOR_KEYWORD);
        memoization_state.note_globally_cached_function($sym133$PREDS_OF_STRING_WORD_CACHED);
        declare_defglobal($closed_lexical_class_strings$);
        memoization_state.note_globally_cached_function(CLOSED_LEXICAL_CLASS_STRINGS);
        memoization_state.note_globally_cached_function(CLOSED_LEXICAL_CLASSES);
        memoization_state.note_memoized_function($sym92$LEXICAL_WORD_);
        memoization_state.note_memoized_function($sym160$DERIVED_WORD_);
        declare_defglobal($vulgar_words$);
        memoization_state.note_globally_cached_function($sym166$VERB_ONLY_STRING_);
        register_cyc_api_function(TYPED_DENOTS_OF_STRING, $list_alt175, $str_alt176$_param_STRING_string_____param_TY, $list_alt177, $list_alt178);
        memoization_state.note_memoized_function($sym179$DENOT_HAS_TYPE_);
        memoization_state.note_memoized_function($sym180$DENOT_MIGHT_HAVE_TYPE_);
        register_cyc_api_function(DENOTATION_MAPPER, $list_alt201, $str_alt202$_param_STRING_string__the_string_, $list_alt203, $list_alt204);
        register_cyc_api_function(DENOTS_OF_STRING, $list_alt210, $str_alt211$_param_PARSE_MORPHOLOGICALLY__PAR, $list_alt212, NIL);
        memoization_state.note_globally_cached_function(AGR_OF_DET_STRING);
        memoization_state.note_globally_cached_function(POS_TO_SEMTRANS_PRED_CACHED);
        memoization_state.note_globally_cached_function(SEMTRANS_PRED_TO_POS);
        declare_defglobal($speech_parts$);
        memoization_state.note_globally_cached_function($sym262$GENL_POS_);
        memoization_state.note_globally_cached_function(COMPOSITIONAL_POS_NART);
        define_test_case_table_int(DENOTS_OF_STRING, list(new SubLObject[]{ $TEST, $sym286$SETS_EQUAL_EQUAL_, $OWNER, $$$daves, $CLASSES, NIL, $KB, $FULL, $WORKING_, T }), $list_alt293);
        return NIL;
    }

    public static SubLObject setup_lexicon_accessors_file() {
        if (SubLFiles.USE_V1) {
            memoization_state.note_globally_cached_function($sym2$GENL_LEXICON_MT__CACHED);
            memoization_state.note_globally_cached_function(MAX_PREDS_MATCHING_POS_CACHED);
            memoization_state.note_globally_cached_function(MAX_PREDS_OF_POS);
            memoization_state.note_globally_cached_function(MAX_PREDS_LICENSED_BY_POS);
            memoization_state.note_memoized_function(LEX_REMOVE_SPEC_PREDS_HELPER);
            memoization_state.note_globally_cached_function(SPEECH_PART_PRED_MIN_CEILINGS_INT);
            memoization_state.note_globally_cached_function(SPEECH_PART_PRED_MAX_FLOORS_INT);
            memoization_state.note_globally_cached_function(POS_OF_PRED);
            declare_defglobal($derived_preds$);
            declare_defglobal($speech_part_preds$);
            memoization_state.note_globally_cached_function($sym78$GENL_POS_PRED_);
            memoization_state.note_globally_cached_function($sym81$GENL_POS_PRED_FROM_MT_INFO_);
            memoization_state.note_globally_cached_function(GET_STRINGS_OF_TYPE_CACHED);
            memoization_state.note_memoized_function($sym93$STRING_IS_POS_ON_WU_);
            memoization_state.note_globally_cached_function(POS_FOR_KEYWORD);
            memoization_state.note_globally_cached_function($sym137$PREDS_OF_STRING_WORD_CACHED);
            declare_defglobal($closed_lexical_class_strings$);
            declare_defglobal($closed_lexical_class_strings_case_insensitive$);
            memoization_state.note_globally_cached_function(CLOSED_LEXICAL_CLASS_STRINGS);
            memoization_state.note_globally_cached_function(CLOSED_LEXICAL_CLASSES);
            memoization_state.note_memoized_function($sym95$LEXICAL_WORD_);
            memoization_state.note_memoized_function($sym164$DERIVED_WORD_);
            declare_defglobal($vulgar_words$);
            memoization_state.note_globally_cached_function($sym170$VERB_ONLY_STRING_);
            register_cyc_api_function(TYPED_DENOTS_OF_STRING, $list179, $str180$_param_STRING_string_____param_TY, $list181, $list182);
            memoization_state.note_memoized_function($sym183$DENOT_HAS_TYPE_);
            memoization_state.note_memoized_function($sym184$DENOT_MIGHT_HAVE_TYPE_);
            register_cyc_api_function(DENOTATION_MAPPER, $list205, $str206$_param_STRING_string__the_string_, $list207, $list208);
            register_cyc_api_function(DENOTS_OF_STRING, $list215, $str216$_param_PARSE_MORPHOLOGICALLY__PAR, $list217, NIL);
            register_external_symbol(DENOTS_MT_FOR_LANGUAGE);
            memoization_state.note_globally_cached_function($sym250$INDIRECT_LEXICAL_ASSERTION_);
            memoization_state.note_globally_cached_function(AGR_OF_DET_STRING);
            memoization_state.note_globally_cached_function(POS_TO_SEMTRANS_PRED_CACHED);
            memoization_state.note_globally_cached_function(SEMTRANS_PRED_TO_POS);
            declare_defglobal($speech_parts$);
            memoization_state.note_globally_cached_function($sym275$GENL_POS_);
            memoization_state.note_globally_cached_function(COMPOSITIONAL_POS_NART);
            define_test_case_table_int(DENOTS_OF_STRING, list(new SubLObject[]{ $TEST, $sym299$SETS_EQUAL_EQUAL_, $OWNER, NIL, $CLASSES, NIL, $KB, $FULL, $WORKING_, T }), $list305);
        }
        if (SubLFiles.USE_V2) {
            memoization_state.note_globally_cached_function($sym0$GENL_LEXICON_MT_);
            memoization_state.note_globally_cached_function($sym73$GENL_POS_PRED_);
            memoization_state.note_globally_cached_function($sym78$GENL_POS_PRED_FROM_MT_INFO_);
            memoization_state.note_memoized_function($sym90$STRING_IS_POS_ON_WU_);
            memoization_state.note_globally_cached_function($sym133$PREDS_OF_STRING_WORD_CACHED);
            memoization_state.note_memoized_function($sym92$LEXICAL_WORD_);
            memoization_state.note_memoized_function($sym160$DERIVED_WORD_);
            memoization_state.note_globally_cached_function($sym166$VERB_ONLY_STRING_);
            register_cyc_api_function(TYPED_DENOTS_OF_STRING, $list_alt175, $str_alt176$_param_STRING_string_____param_TY, $list_alt177, $list_alt178);
            memoization_state.note_memoized_function($sym179$DENOT_HAS_TYPE_);
            memoization_state.note_memoized_function($sym180$DENOT_MIGHT_HAVE_TYPE_);
            register_cyc_api_function(DENOTATION_MAPPER, $list_alt201, $str_alt202$_param_STRING_string__the_string_, $list_alt203, $list_alt204);
            register_cyc_api_function(DENOTS_OF_STRING, $list_alt210, $str_alt211$_param_PARSE_MORPHOLOGICALLY__PAR, $list_alt212, NIL);
            memoization_state.note_globally_cached_function($sym262$GENL_POS_);
            define_test_case_table_int(DENOTS_OF_STRING, list(new SubLObject[]{ $TEST, $sym286$SETS_EQUAL_EQUAL_, $OWNER, $$$daves, $CLASSES, NIL, $KB, $FULL, $WORKING_, T }), $list_alt293);
        }
        return NIL;
    }

    public static SubLObject setup_lexicon_accessors_file_Previous() {
        memoization_state.note_globally_cached_function($sym2$GENL_LEXICON_MT__CACHED);
        memoization_state.note_globally_cached_function(MAX_PREDS_MATCHING_POS_CACHED);
        memoization_state.note_globally_cached_function(MAX_PREDS_OF_POS);
        memoization_state.note_globally_cached_function(MAX_PREDS_LICENSED_BY_POS);
        memoization_state.note_memoized_function(LEX_REMOVE_SPEC_PREDS_HELPER);
        memoization_state.note_globally_cached_function(SPEECH_PART_PRED_MIN_CEILINGS_INT);
        memoization_state.note_globally_cached_function(SPEECH_PART_PRED_MAX_FLOORS_INT);
        memoization_state.note_globally_cached_function(POS_OF_PRED);
        declare_defglobal($derived_preds$);
        declare_defglobal($speech_part_preds$);
        memoization_state.note_globally_cached_function($sym78$GENL_POS_PRED_);
        memoization_state.note_globally_cached_function($sym81$GENL_POS_PRED_FROM_MT_INFO_);
        memoization_state.note_globally_cached_function(GET_STRINGS_OF_TYPE_CACHED);
        memoization_state.note_memoized_function($sym93$STRING_IS_POS_ON_WU_);
        memoization_state.note_globally_cached_function(POS_FOR_KEYWORD);
        memoization_state.note_globally_cached_function($sym137$PREDS_OF_STRING_WORD_CACHED);
        declare_defglobal($closed_lexical_class_strings$);
        declare_defglobal($closed_lexical_class_strings_case_insensitive$);
        memoization_state.note_globally_cached_function(CLOSED_LEXICAL_CLASS_STRINGS);
        memoization_state.note_globally_cached_function(CLOSED_LEXICAL_CLASSES);
        memoization_state.note_memoized_function($sym95$LEXICAL_WORD_);
        memoization_state.note_memoized_function($sym164$DERIVED_WORD_);
        declare_defglobal($vulgar_words$);
        memoization_state.note_globally_cached_function($sym170$VERB_ONLY_STRING_);
        register_cyc_api_function(TYPED_DENOTS_OF_STRING, $list179, $str180$_param_STRING_string_____param_TY, $list181, $list182);
        memoization_state.note_memoized_function($sym183$DENOT_HAS_TYPE_);
        memoization_state.note_memoized_function($sym184$DENOT_MIGHT_HAVE_TYPE_);
        register_cyc_api_function(DENOTATION_MAPPER, $list205, $str206$_param_STRING_string__the_string_, $list207, $list208);
        register_cyc_api_function(DENOTS_OF_STRING, $list215, $str216$_param_PARSE_MORPHOLOGICALLY__PAR, $list217, NIL);
        register_external_symbol(DENOTS_MT_FOR_LANGUAGE);
        memoization_state.note_globally_cached_function($sym250$INDIRECT_LEXICAL_ASSERTION_);
        memoization_state.note_globally_cached_function(AGR_OF_DET_STRING);
        memoization_state.note_globally_cached_function(POS_TO_SEMTRANS_PRED_CACHED);
        memoization_state.note_globally_cached_function(SEMTRANS_PRED_TO_POS);
        declare_defglobal($speech_parts$);
        memoization_state.note_globally_cached_function($sym275$GENL_POS_);
        memoization_state.note_globally_cached_function(COMPOSITIONAL_POS_NART);
        define_test_case_table_int(DENOTS_OF_STRING, list(new SubLObject[]{ $TEST, $sym299$SETS_EQUAL_EQUAL_, $OWNER, NIL, $CLASSES, NIL, $KB, $FULL, $WORKING_, T }), $list305);
        return NIL;
    }

    @Override
    public void declareFunctions() {
        declare_lexicon_accessors_file();
    }

    @Override
    public void initializeVariables() {
        init_lexicon_accessors_file();
    }

    @Override
    public void runTopLevelForms() {
        setup_lexicon_accessors_file();
    }

    static {
    }

    public static final class $speech_part_predP$UnaryFunction extends UnaryFunction {
        public $speech_part_predP$UnaryFunction() {
            super(extractFunctionNamed("SPEECH-PART-PRED?"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1) {
            return speech_part_predP(arg1, lexicon_accessors.$speech_part_predP$UnaryFunction.UNPROVIDED);
        }
    }

    public static final class $speech_part_predP$BinaryFunction extends BinaryFunction {
        public $speech_part_predP$BinaryFunction() {
            super(extractFunctionNamed("SPEECH-PART-PRED?"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1, final SubLObject arg2) {
            return speech_part_predP(arg1, arg2);
        }
    }

    public static final class $genl_pos_predP$BinaryFunction extends BinaryFunction {
        public $genl_pos_predP$BinaryFunction() {
            super(extractFunctionNamed("GENL-POS-PRED?"));
        }

        @Override
        public SubLObject processItem(final SubLObject arg1, final SubLObject arg2) {
            return genl_pos_predP(arg1, arg2, lexicon_accessors.$genl_pos_predP$BinaryFunction.UNPROVIDED);
        }
    }

    public static final class $clear_pos_to_semtrans_pred_cached$ZeroArityFunction extends ZeroArityFunction {
        public $clear_pos_to_semtrans_pred_cached$ZeroArityFunction() {
            super(extractFunctionNamed("CLEAR-POS-TO-SEMTRANS-PRED-CACHED"));
        }

        @Override
        public SubLObject processItem() {
            return clear_pos_to_semtrans_pred_cached();
        }
    }

    // Internal Constants
    @LispMethod(comment = "Internal Constants")
    static private final SubLSymbol $sym0$GENL_LEXICON_MT_ = makeSymbol("GENL-LEXICON-MT?");

    static private final SubLSymbol $sym1$_GENL_LEXICON_MT__CACHING_STATE_ = makeSymbol("*GENL-LEXICON-MT?-CACHING-STATE*");

    public static final SubLSymbol $kw3$_MEMOIZED_ITEM_NOT_FOUND_ = makeKeyword("&MEMOIZED-ITEM-NOT-FOUND&");

    static private final SubLSymbol $sym5$SPEECH_PART_ = makeSymbol("SPEECH-PART?");

    static private final SubLString $str_alt17$Invalid_attempt_to_reuse_memoizat = makeString("Invalid attempt to reuse memoization state in multiple threads simultaneously.");

    static private final SubLList $list_alt20 = cons(makeSymbol("NOW"), makeSymbol("LATER"));

    static private final SubLSymbol $sym29$SPEECH_PART_PRED_ = makeSymbol("SPEECH-PART-PRED?");

    static private final SubLSymbol $sym31$SPEC_POS_ = makeSymbol("SPEC-POS?");

    static private final SubLString $str_alt46$_A_is_not_a__A = makeString("~A is not a ~A");

    static private final SubLString $str_alt51$_A_is_not_a_valid__sbhl_type_erro = makeString("~A is not a valid *sbhl-type-error-action* value");

    static private final SubLString $str_alt54$attempting_to_bind_direction_link = makeString("attempting to bind direction link variable, to NIL. macro body not executed.");

    static private final SubLString $str_alt55$Node__a_does_not_pass_sbhl_type_t = makeString("Node ~a does not pass sbhl-type-test ~a~%");

    static private final SubLList $list_alt59 = list(list(makeSymbol("PRED"), makeSymbol("&KEY"), list(makeSymbol("MT"), reader_make_constant_shell("InferencePSC")), list(makeSymbol("DONE"), NIL)), makeSymbol("&BODY"), makeSymbol("BODY"));

    static private final SubLList $list_alt60 = list(makeKeyword("MT"), $DONE);

    static private final SubLSymbol $sym64$DEFINING_MT = makeUninternedSymbol("DEFINING-MT");

    static private final SubLList $list_alt66 = list(makeSymbol("ENSURE-SPEECH-PART-PREDS-INITIALIZED"));

    static private final SubLList $list_alt70 = list(reader_make_constant_shell("InferencePSC"));

    static private final SubLSymbol $sym73$GENL_POS_PRED_ = makeSymbol("GENL-POS-PRED?");

    static private final SubLSymbol $sym74$_GENL_POS_PRED__CACHING_STATE_ = makeSymbol("*GENL-POS-PRED?-CACHING-STATE*");

    static private final SubLSymbol $sym77$CLEAR_GENL_POS_PRED_ = makeSymbol("CLEAR-GENL-POS-PRED?");

    static private final SubLSymbol $sym78$GENL_POS_PRED_FROM_MT_INFO_ = makeSymbol("GENL-POS-PRED-FROM-MT-INFO?");

    static private final SubLSymbol $sym82$_GENL_POS_PRED_FROM_MT_INFO__CACHING_STATE_ = makeSymbol("*GENL-POS-PRED-FROM-MT-INFO?-CACHING-STATE*");

    static private final SubLSymbol $sym83$CLEAR_GENL_POS_PRED_FROM_MT_INFO_ = makeSymbol("CLEAR-GENL-POS-PRED-FROM-MT-INFO?");

    static private final SubLSymbol $sym85$STRING_ = makeSymbol("STRING=");

    static private final SubLSymbol $sym90$STRING_IS_POS_ON_WU_ = makeSymbol("STRING-IS-POS-ON-WU?");

    static private final SubLSymbol $sym92$LEXICAL_WORD_ = makeSymbol("LEXICAL-WORD?");

    static private final SubLSymbol $sym95$EQUALS_EL_ = makeSymbol("EQUALS-EL?");

    static private final SubLSymbol $sym97$SPEC_ = makeSymbol("SPEC?");

    static private final SubLList $list_alt103 = list(reader_make_constant_shell("CountNoun"), reader_make_constant_shell("AgentiveNoun"), reader_make_constant_shell("MassNoun"), reader_make_constant_shell("GerundiveNoun"));

    static private final SubLList $list_alt105 = list(reader_make_constant_shell("MassNoun"));

    static private final SubLList $list_alt116 = list(reader_make_constant_shell("Verb"));

    static private final SubLList $list_alt131 = list(reader_make_constant_shell("abbreviationForLexicalWord"));

    static private final SubLSymbol $sym133$PREDS_OF_STRING_WORD_CACHED = makeSymbol("PREDS-OF-STRING&WORD-CACHED");

    static private final SubLSymbol $sym134$_PREDS_OF_STRING_WORD_CACHED_CACHING_STATE_ = makeSymbol("*PREDS-OF-STRING&WORD-CACHED-CACHING-STATE*");

    static private final SubLSymbol $sym135$_STRING = makeSymbol("?STRING");

    static private final SubLSymbol $sym137$_POS = makeSymbol("?POS");

    static private final SubLList $list_alt142 = list(reader_make_constant_shell("DefiniteDeterminerFrame"));

    static private final SubLList $list_alt156 = list(reader_make_constant_shell("posForms"), reader_make_constant_shell("posBaseForms"));

    static private final SubLList $list_alt157 = cons(list(makeKeyword("OR"), reader_make_constant_shell("WordWithPrefixFn"), reader_make_constant_shell("WordWithSuffixFn"), reader_make_constant_shell("CompoundWordFn"), reader_make_constant_shell("WordFn"), reader_make_constant_shell("CompoundWordFn-HeadMedial"), reader_make_constant_shell("CompoundWordFn-HeadInitial")), makeKeyword("ANYTHING"));

    static private final SubLSymbol $sym160$DERIVED_WORD_ = makeSymbol("DERIVED-WORD?");

    static private final SubLList $list_alt164 = list(makeUninternedSymbol("LINK-NODE"), makeUninternedSymbol("MT"), makeUninternedSymbol("TV"));

    static private final SubLString $str_alt165$The_word_unit__S_is_neither_a_FOR = makeString("The word-unit ~S is neither a FORT nor a NAUT.");

    static private final SubLSymbol $sym166$VERB_ONLY_STRING_ = makeSymbol("VERB-ONLY-STRING?");

    static private final SubLSymbol $sym167$_VERB_ONLY_STRING__CACHING_STATE_ = makeSymbol("*VERB-ONLY-STRING?-CACHING-STATE*");

    static private final SubLSymbol $sym172$HLMT_ = makeSymbol("HLMT?");

    static private final SubLList $list_alt175 = list(new SubLObject[]{ makeSymbol("STRING"), makeSymbol("TYPE"), makeSymbol("&OPTIONAL"), list(makeSymbol("ABBREV-TYPES"), NIL), list(makeSymbol("DENOT-TYPE"), makeKeyword("DENOT")), list(makeSymbol("MISSPELLINGS?"), T), list(makeSymbol("SKIP-NAMESTRINGS?"), NIL), list(makeSymbol("LOOKUP-MT"), makeSymbol("*LEXICON-LOOKUP-MT*")), list(makeSymbol("SEMANTIC-MT"), reader_make_constant_shell("InferencePSC")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("*PARSE-MORPHOLOGICALLY*")), list(makeSymbol("EXCLUDED-PREDICATES"), makeSymbol("*SEMANTIC-PREDICATES-EXCLUDED-FROM-LEXICAL-LOOKUP*")) });

    static private final SubLString $str_alt176$_param_STRING_string_____param_TY = makeString("@param STRING string\n   @param TYPE collection\n   @param PARSE-MORPHOLOGICALLY: PARSE-MORPHOLOGICALLY-OPTION-P\n                                  Do we attempt to parse STRING as a complex (multi-morpheme) word?\n   @return list; a list of denotata for STRING that are instances of TYPE\n   note that this function does some parsing, if the type sent in is appropriate");

    static private final SubLList $list_alt177 = list(new SubLObject[]{ list(makeSymbol("STRING"), makeSymbol("STRINGP")), list(makeSymbol("TYPE"), makeSymbol("EL-FORT-P")), list(makeSymbol("ABBREV-TYPES"), makeSymbol("LISTP")), list(makeSymbol("DENOT-TYPE"), makeSymbol("KEYWORDP")), list(makeSymbol("MISSPELLINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("SKIP-NAMESTRINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("LOOKUP-MT"), makeSymbol("HLMT?")), list(makeSymbol("SEMANTIC-MT"), makeSymbol("HLMT?")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P")), list(makeSymbol("EXCLUDED-PREDICATES"), makeSymbol("SET-P")) });

    static private final SubLList $list_alt178 = list(makeSymbol("LISTP"));

    static private final SubLSymbol $sym179$DENOT_HAS_TYPE_ = makeSymbol("DENOT-HAS-TYPE?");

    static private final SubLSymbol $sym180$DENOT_MIGHT_HAVE_TYPE_ = makeSymbol("DENOT-MIGHT-HAVE-TYPE?");

    static private final SubLString $str_alt192$_ = makeString("*");

    static private final SubLList $list_alt193 = list(CHAR_asterisk);

    static private final SubLList $list_alt194 = list(makeString("*"));

    static private final SubLString $str_alt197$I_should_never_be_called___ = makeString("I should never be called...");

    static private final SubLList $list_alt201 = list(makeSymbol("STRING"), makeSymbol("&OPTIONAL"), makeSymbol("EXCLUDED-PREDS"), list(makeSymbol("MODE"), makeKeyword("GREEDY")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("*PARSE-MORPHOLOGICALLY*")));

    static private final SubLString $str_alt202$_param_STRING_string__the_string_ = makeString("@param STRING string; the string to map to its denotations\n   @param EXCLUDED-PREDS list; a list of semantic predicates which should be ignored when computing mappings \n   @param MODE keyword; :greedy or :diligent\n   @param PARSE-MORPHOLOGICALLY: PARSE-MORPHOLOGICALLY-OPTION-P\n                                  Do we attempt to parse STRING as a complex (multi-morpheme) word?\n   @return 0 LISTP; a list of STRING-TOKENs, each of which contains as its STRING-TOKEN-STRING some substring \n                    of STRING and as its STRING-TOKEN-VALUE a denotatum for that string\n   @return 1 LISTP; a list of STRING-TOKENS for which no denotatum could be found");

    static private final SubLList $list_alt203 = list(list(makeSymbol("STRING"), makeSymbol("STRINGP")), list(makeSymbol("EXCLUDED-PREDS"), makeSymbol("LIST-OF-PREDICATES-P")), list(makeSymbol("MODE"), makeSymbol("KEYWORDP")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P")));

    static private final SubLList $list_alt204 = list(list(makeSymbol("LIST"), makeSymbol("STRING-TOKEN-P")), list(makeSymbol("LIST"), makeSymbol("STRING-TOKEN-P")));

    static private final SubLList $list_alt205 = list(makeKeyword("ABBREVS"), makeKeyword("ACRONYMS"));

    static private final SubLList $list_alt208 = list(reader_make_constant_shell("termStrings"));

    static private final SubLList $list_alt210 = list(new SubLObject[]{ makeSymbol("STRING"), makeSymbol("&OPTIONAL"), list(makeSymbol("ABBREV-TYPES"), NIL), list(makeSymbol("DENOT-TYPE"), makeKeyword("DENOT")), list(makeSymbol("MISSPELLINGS?"), T), list(makeSymbol("SKIP-NAMESTRINGS?"), NIL), list(makeSymbol("LOOKUP-MT"), makeSymbol("*LEXICON-LOOKUP-MT*")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("*PARSE-MORPHOLOGICALLY*")), list(makeSymbol("PARSE-DATES-AND-NUMBERS?"), T), list(makeSymbol("LEXICON"), NIL) });

    static private final SubLString $str_alt211$_param_PARSE_MORPHOLOGICALLY__PAR = makeString("@param PARSE-MORPHOLOGICALLY: PARSE-MORPHOLOGICALLY-OPTION-P\n                                  Do we attempt to parse STRING as a complex (multi-morpheme) word?\n   @param abbrev-types; listp: if it includes :abbrevs, include abbreviations;\n                               if it includes :acronyms, include acronyms\n   @param denot-type; keywordp: \n      :denot =  #$denotation assertions  (parsing)\n      :related = #$denotation and #$denotationRelatedTo (generation)\n      :any = #$denotation, #$denotationRelatedTo, and #$denotationPlaceholder\n   @param PARSE-DATES-AND-NUMBERS? booleanp; if set to NIL, DENOTS-OF-STRING will only perform lexical lookup, and \n      not try to parse any dates or numbers\n   @param LEXICON term-lexicon-p; if present, LOOKUP-MT will be ignored and LEXICON will be used instead.\n   @return 0. LISTP ; CycL denotational terms serving as denotations for the phrase\n   @return 1. LISTP ; list of predicate lists for each denotation");

    static private final SubLList $list_alt212 = list(list(makeSymbol("STRING"), makeSymbol("STRINGP")), list(makeSymbol("ABBREV-TYPES"), makeSymbol("LISTP")), list(makeSymbol("DENOT-TYPE"), makeSymbol("KEYWORDP")), list(makeSymbol("MISSPELLINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("SKIP-NAMESTRINGS?"), makeSymbol("BOOLEANP")), list(makeSymbol("LOOKUP-MT"), makeSymbol("HLMT-P")), list(makeSymbol("PARSE-MORPHOLOGICALLY"), makeSymbol("PARSE-MORPHOLOGICALLY-OPTION-P")));

    static private final SubLString $str_alt213$_S_passes_neither_SPEECH_PART_PRE = makeString("~S passes neither SPEECH-PART-PRED? nor NAME-STRING-PRED?");

    static private final SubLSymbol $sym214$NAME_STRING_PRED_ = makeSymbol("NAME-STRING-PRED?");

    static private final SubLList $list_alt219 = list(reader_make_constant_shell("denotationRelatedTo"));

    static private final SubLList $list_alt221 = list(reader_make_constant_shell("denotationPlaceholder"));

    static private final SubLList $list_alt222 = list(reader_make_constant_shell("denotationRelatedTo"), reader_make_constant_shell("denotation"));

    static private final SubLList $list_alt223 = list(reader_make_constant_shell("denotationPlaceholder"), reader_make_constant_shell("denotationRelatedTo"), reader_make_constant_shell("denotation"));

    static private final SubLList $list_alt224 = list(reader_make_constant_shell("denotation"));

    static private final SubLSymbol $sym230$_ = makeSymbol("<");

    static private final SubLSymbol $sym235$_LEVEL = makeSymbol("?LEVEL");

    static private final SubLList $list_alt236 = list(makeSymbol("?LEVEL"));

    static private final SubLList $list_alt237 = list(reader_make_constant_shell("RudeSpeech"), reader_make_constant_shell("VulgarSpeech"), reader_make_constant_shell("ObjectionableSpeech"));

    static private final SubLSymbol $sym238$POTENTIALLY_OFFENSIVE_POLITENESS_LEVEL_ = makeSymbol("POTENTIALLY-OFFENSIVE-POLITENESS-LEVEL?");

    static private final SubLSymbol $sym242$GAF_ASSERTION_ = makeSymbol("GAF-ASSERTION?");

    static private final SubLList $list_alt249 = list(reader_make_constant_shell("nonSingular-Generic"));

    static private final SubLSymbol $sym262$GENL_POS_ = makeSymbol("GENL-POS?");

    static private final SubLSymbol $sym263$_GENL_POS__CACHING_STATE_ = makeSymbol("*GENL-POS?-CACHING-STATE*");

    static private final SubLList $list_alt265 = list(reader_make_constant_shell("PhraseFn"), reader_make_constant_shell("Adjective"));

    static private final SubLList $list_alt269 = list(list(reader_make_constant_shell("PhraseFn"), reader_make_constant_shell("Noun")), reader_make_constant_shell("NounPhrase"));

    static private final SubLList $list_alt270 = list(list(reader_make_constant_shell("PhraseFn"), reader_make_constant_shell("Preposition")), reader_make_constant_shell("PrepositionalPhrase"));

    static private final SubLList $list_alt276 = list(list(T, list(ONE_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationToTypeFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR-TYPE")), list(TWO_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationFromTypeFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR-TYPE"))), list(NIL, list(ONE_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationToFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR")), list(TWO_INTEGER, reader_make_constant_shell("SubcollectionOfWithRelationFromFn"), makeKeyword("POSSESSED-TYPE"), makeKeyword("DENOTED-PRED"), makeKeyword("POSSESSOR"))));

    static private final SubLList $list_alt281 = list(ONE_INTEGER);

    static private final SubLSymbol $sym282$_PRED = makeSymbol("?PRED");

    static private final SubLList $list_alt283 = list(makeSymbol("?PRED"), makeSymbol("?ARGNUM"));

    static private final SubLSymbol $sym286$SETS_EQUAL_EQUAL_ = makeSymbol("SETS-EQUAL-EQUAL?");

    static private final SubLString $$$daves = makeString("daves");

    static private final SubLList $list_alt293 = list(list(list(makeString("ABEDA"), list(makeSymbol("ABBREV-TYPES"), makeKeyword("ACRONYMS"))), list(reader_make_constant_shell("ArabBankForEconomicDevelopmentInAfrica")), list(list(reader_make_constant_shell("acronymString")))), list(list(makeString("platform")), list(reader_make_constant_shell("Platform-Military"), reader_make_constant_shell("ComputerProcessor"), reader_make_constant_shell("PoliticalBeliefSystem"), reader_make_constant_shell("Platform")), list(list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("singular")), list(reader_make_constant_shell("singular")))), list(list(makeString("chemical engineering")), list(reader_make_constant_shell("ChemicalEngineering")), list(list(reader_make_constant_shell("massNumber")))));

    static private final SubLString $str_alt294$missing___S = makeString("missing: ~S");
}

/**
 * Total time: 5747 ms
 */
