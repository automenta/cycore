/* Copyright 2005-6 Cycorp, Inc., use controled by license terms only. */

options
{
 LOOKAHEAD = 1; 
 FORCE_LA_CHECK = true;
 DEBUG_PARSER = false;
 DEBUG_LOOKAHEAD = false;
 DEBUG_TOKEN_MANAGER = false;
 STATIC = false;
}

PARSER_BEGIN(SubLParser)
package com.cyc.tool.subl.parser;

import com.cyc.tool.subl.jrtl.nativeCode.type.core.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.exception.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.number.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.operator.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.symbol.*;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.*;
import java.io.*;

/**
* <P>This class implements a parser for the SubL grammar. This file
* was automatically generated with javacc based on the file: "subl.jj".
* The SubL parser files can be regenerated by calling:
* /opt/local/pkg/JavaCC/bin/javacc subl.jj
* JavaCC 3.2 was used in the creation of the source files.
*
* Note:
* SubL supports these built-in Common Lisp datatypes:
*   Numbers (fixnum, double), Symbols, Lists, Vector, Character,
*   Strings, Hashtables, Stream, Function, Packages(limited support: ),
*   Structures
* SubL does not support these Common Lisp datatypes:
*   Readtables, Multi-dimensional arrays, Pathnames, Random-states, Lambda-Expressions or Closures
* 
* @version $Id: subl.jj 126640 2008-12-04 13:39:36Z builder $
* @author Tony Brusseau
*
* <p>Copyright 2005-6 Cycorp, Inc., use controled by license terms only.
*/
 public class SubLParser implements CommonSymbols {

   private String currentPackage = "SUBLISP";

   /**
    * The parser program.
    *
    * @param args currently ignored.
    */
   public static void main(String[] args) {
     SubLParser parser = new SubLParser(System.in);
     try {
       parser.termList(true, true);
     } catch (Exception e) {
       System.err.println(e);
     }
   }
 }

PARSER_END(SubLParser)

//cope with the in-package command
//remove unnecessary backslashes from strings
//support #+ and #-
//support comma, @ and back quote
/********************** MISC ***********************/

TOKEN :
{
 < OPEN_PAREN : "(" >
 | < CLOSE_PAREN : ")" >
 | < PACKAGE_SEPARATOR : ":" >
 | < SUBL_SYMBOL_NAME_QUOTE : "|" >
 | < VECTOR_PREFIX : "#(" >
 | < FUNCTION_QUOTE : "#'" >
 | < QUOTE_CHAR : "'" >
 | < BACK_QUOTE : "`" >
 | < SPLICING_UNQUOTE : ",@" >
 | < UNQUOTE : "," >
 | < DOT : "." >
 | < STRING_QUOTE : "\"" >
 | < UNINTERNED_SYMBOL_PREFIX : "#:" >
 | < READ_TIME_EVALUATION : "#." >
 | < IF_FEATURE : "#+" >
 | < IF_NOT_FEATURE : "#-" >
 | < #CHARACTER_PREFIX : "#\\" >
 | < #HASH_MARK : "#" >
 | < #BACKSLASH : "\\" >
}

MORE :
{
  ";" : IN_SINGLE_LINE_COMMENT
  | "#|" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "|#" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN [IGNORE_CASE] :
{
 < WS : [" ", "\t", "\f", "\r", "\n"] >
}

/********************* Terminals ********************/

//// NUMBERS

// @Note numbers win out when they are ambiguous with symbols
TOKEN [IGNORE_CASE] :
{
  < FLOAT1 : ( ["+","-"] )? ( < NUMBER_CHAR > )+ ( "." ( < NUMBER_CHAR > )* )? < EXPONENT > >
  | < FLOAT2 : ( ["+","-"] )? ( < NUMBER_CHAR > )* "." ( < NUMBER_CHAR > )+ ( < EXPONENT > )? >
  | < #EXPONENT : ["e", "d", "f", "l", "s"] ( ["+","-"] )? ( < NUMBER_CHAR > )+ >
  | < DECIMAL_INTEGER : ( ["+","-"] )? ( < NUMBER_CHAR > )+ ( ["."] )? >
  | < BASED_INTEGER : < BASED_INTEGER_PREFIX > ( ["+","-"] )? ( ["0"-"9", "A"-"Z"] )+ >
  | < #BASED_INTEGER_PREFIX : < HASH_MARK > ( ( < NUMBER_CHAR > ( < NUMBER_CHAR > )? "r" ) | ["b","o","x"] ) >
  | < #NUMBER_CHAR : ["0"-"9"] >
}

//// CHARACTERS

TOKEN [IGNORE_CASE] :
{  
  < NAMED_CHARACTER : < CHARACTER_START > < CHAR_NAME > >
  | < CHARACTER : < CHARACTER_START > < PRINTABLE_CHAR > >
  | < #CHARACTER_START : < HASH_MARK > < BACKSLASH > ( < CONTROL_BITS > ( < BACKSLASH > )? )? >
  | < #CONTROL_BITS : ( < CONTROL_LONG > | < CONTROL_SHORT > )? ( < META_LONG > | < META_SHORT > )? >
  | < #CONTROL_LONG : "Control-" >
  | < #CONTROL_SHORT : "C-" >
  | < #META_LONG : "Meta-" >
  | < #META_SHORT : "M-" >
  | < #CHAR_NAME : "Null" | "NUL" | "SOH" | "STX" | "ETX" | "EOT" 
      | "ENQ" | "ACK" | "Bell" | "BEL" | "Backspace" | "BS" | "Tab" | "HT" 
      | "Newline" | "Linefeed" | "LF" | "NL" | "Vertical-Tab" | "VT" 
      | "Page" | "FF" | "Return" | "CR" | "SO" | "SI" | "DLE" | "DC1" | "DC2" 
      | "DC3" | "DC4" | "NAK" | "SYN" | "ETB" | "CAN" | "EM" | "SUB" | "Escape" 
      | "ESC" | "ALT" | "FS" | "GS" | "RS" | "US" | "Space" | "SP" | "Rubout" 
      | "DEL" >
}

//// STRINGS 

TOKEN :
{
  < STRING : < STRING_QUOTE > ( ( ~["\u0080"-"\uFFFF", "\"","\\"] ) | ( "\\" ~["\u0080"-"\uFFFF"] ) )* < STRING_QUOTE > >
}

//// SYMBOLS

TOKEN :
{
  < CASE_SENSITIVE_SUBL_SYMBOL_NAME : < SUBL_SYMBOL_NAME_QUOTE > ( ( ~[ "|", "\\"] ) | ( "\\" ~[] ) )+ < SUBL_SYMBOL_NAME_QUOTE > >
  | < #CONSTITUENT_CHAR : ( "\\" ~["\u0080"-"\uFFFF"] ) | ~["\u0000"-"\u0020", "\u007F"-"\uFFFF", "\\", "#", ":", ";", "|", "\"", "'", "`", ",", "(", ")"] >
  | < #PRINTABLE_CHAR : "S" | ~[ "\u0000"-"\u0020", "\u007F"-"\uFFFF" ] > //@hack needing the "S" is strange...-APB
  | < SUBL_SYMBOL_NAME : ( < CONSTITUENT_CHAR > )+ >
}


/********************* Parser ********************/

SubLList termList(boolean requireEOF, boolean eatInitialWS) :
{
 SubLList val = NIL;
 SubLObject curTerm = null;
 boolean shouldFeaturizeOut = false;
}
{
 eatWhiteSpace(eatInitialWS)
 ( curTerm = term(false, false) { 
    val = SubLObjectFactory.makeCons(curTerm, val); } ( < WS > )* )*
 eof(requireEOF)
 { return val.reverse(true).toList(); }
}

SubLObject term(boolean requireEOF, boolean eatInitialWS) :
{
 SubLObject curTerm = null;
 SubLList currentQuotes = SubLNil.NIL;
 boolean doReadTimeEvaluation = false;
}
{
 eatWhiteSpace(eatInitialWS)
 ( ( < QUOTE_CHAR > ( < WS > )* { currentQuotes = manageQuote(SubLQuote.QUOTE_SYMBOL, currentQuotes); } )
  | ( < BACK_QUOTE > ( < WS > )* { currentQuotes = manageQuote(SubLQuote.BACK_QUOTE_SYMBOL, currentQuotes); } )
  | ( < FUNCTION_QUOTE > ( < WS > )* { currentQuotes = manageQuote(SubLQuote.FUNCTION_QUOTE_SYMBOL, currentQuotes); } )
  | ( < SPLICING_UNQUOTE > ( < WS > )* { currentQuotes = manageQuote(SubLQuote.SPLICING_UNQUOTE_SYMBOL, currentQuotes); } )
  | ( < UNQUOTE > ( < WS > )* { currentQuotes = manageQuote(SubLQuote.UNQUOTE_SYMBOL, currentQuotes); } ) 
  | ( < READ_TIME_EVALUATION > ( < WS > )*  { doReadTimeEvaluation = true; } ) )*
 ( ( curTerm = form(false, false) ) | (curTerm = vector(false, false)) | ( curTerm = atom(false, false) ) )
 eof(requireEOF)
 { 
   SubLObject result = processQuotes(curTerm, currentQuotes); 
   return doReadTimeEvaluation ? result.eval(SubLEnvironment.currentEnvironment()) : result;
 } 
}

SubLObject processQuotes(SubLObject quotedObject, SubLList quoteList) :
{
  SubLList result = null;
  SubLList currentQuote = SubLNil.NIL;
  SubLQuote theQuote = null;
}
{
{
  if (quoteList == SubLNil.NIL) { return quotedObject; }
  if (quoteList.size() == 1) { 
    theQuote = (SubLQuote)quoteList.first();
    if ((theQuote == SubLQuote.FUNCTION_QUOTE_SYMBOL) && (!quotedObject.isSymbol())) {
      throw new ParseException("Got invalid quote: " + theQuote + " for term: " + quotedObject);
    } 
    quoteList = quoteList.push(quotedObject);
    quoteList = quoteList.reverse(true).toList();
    return quoteList; 
  }
  result = SubLObjectFactory.makeCons(quotedObject, SubLNil.NIL);
  for (int i = 0, size = quoteList.size(); i < size; i++) {
    theQuote = (SubLQuote)quoteList.get(i);
    result = SubLObjectFactory.makeCons(result, result);
  }
  return result;
}
}

SubLList manageQuote(SubLQuote quoteType, SubLList currentQuotes) :
{
}
{
{
  currentQuotes = currentQuotes.push(quoteType);
  return currentQuotes;
}
}

SubLList form(boolean requireEOF, boolean eatInitialWS) :
{
 SubLList result = null;
 SubLList contents = null;
 SubLObject dottedItem = null;
}
{
 eatWhiteSpace(eatInitialWS)
 ( ( < OPEN_PAREN > contents = termList(false, true) 
    ( ( < DOT > ( < WS > )+ ) dottedItem = term(false, false) )? 
      ( < WS > )* < CLOSE_PAREN > ) { result = contents; } )
 eof(requireEOF)
 { 
   if ((contents != null) && (dottedItem != null)) {
      contents.setDottedElement(dottedItem);
   }
   if (result.isEmpty()) {
      return NIL;
   }
 }
 { return result; }
}

SubLVector vector(boolean requireEOF, boolean eatInitialWS) :
{
 SubLList result = null;
}
{
 eatWhiteSpace(eatInitialWS)
 ( < VECTOR_PREFIX > result = termList(false, true) 
   ( < WS > )* < CLOSE_PAREN > )
 eof(requireEOF)
 { return SubLObjectFactory.makeVector(result); }
}

SubLObject atom(boolean requireEOF, boolean eatInitialWS) :
{
 SubLObject atom;
}
{
 eatWhiteSpace(eatInitialWS)
 ( atom = character(false, false) |
   atom = string(false, false) |
   atom = number(false, false) |
   atom = symbol(false, false) )
 eof(requireEOF)
 { return atom; }
}

//internal use only
String symbolName() :
{
  String val = null;
  Token t = null;
}
{ 
  ( ( t = < SUBL_SYMBOL_NAME > { val = t.image; } ) | 
    ( t = < CASE_SENSITIVE_SUBL_SYMBOL_NAME > { val = t.image; } ) )
  { if ((val == null) || (val.equals(""))) { return currentPackage; } else { return val; } }
}

SubLString string(boolean requireEOF, boolean eatInitialWS) :
{
 Token t = null;
}
{
 eatWhiteSpace(eatInitialWS)
 ( t = < STRING > )
 eof(requireEOF)
 { return SubLObjectFactory.makeString(t.image.substring(1, t.image.length()-1)); }
}

SubLNumber number(boolean requireEOF, boolean eatInitialWS) :
{
 SubLNumber val = null;
 Token t = null;
 String baseOrFPStr = "";
}
{
 eatWhiteSpace(eatInitialWS)
 ( ( ( t = < DECIMAL_INTEGER > ) 
      { val = SubLObjectFactory.makeIntegralNumber((t.image.startsWith("+") ? t.image.substring(1) : t.image), 10); } )
   | ( ( t = < BASED_INTEGER > ) { val = SubLObjectFactory.makeBasedIntegralNumber(t.image); } )
   | ( ( t = < FLOAT1 > | t = < FLOAT2 > ) { 
     baseOrFPStr = t.image.toLowerCase();
     val = SubLObjectFactory.makeDouble(t.image.toLowerCase().replaceAll("\\p{Alpha}", "e")); } ) ) 
 eof(requireEOF)
 { return val; }
}

SubLSymbol symbol(boolean requireEOF, boolean eatInitialWS) :
{
  Token t = null;
  String symbolOrPackageName = SubLPackage.KEYWORD_PACKAGE.getName();
  String symName = "";
  boolean isInterned = true;
  SubLSymbol symbol = null;
}
{ 
   eatWhiteSpace(eatInitialWS)
   ( ( < UNINTERNED_SYMBOL_PREFIX > symbolOrPackageName = symbolName() { isInterned = false; } ) |
     ( ( <PACKAGE_SEPARATOR> ( <PACKAGE_SEPARATOR> )? symName = symbolName() ) ) | 
     ( ( ( symbolOrPackageName = symbolName() ) 
       ( <PACKAGE_SEPARATOR> ( <PACKAGE_SEPARATOR> )? symName = symbolName() )? ) ) )
 {
    if ((symName == null) || ("".equals(symName))) {
      symbol = SubLObjectFactory.makeSymbol(symbolOrPackageName, isInterned ? SubLPackage.getCurrentPackage() : null);
    } else {
      symbol = SubLObjectFactory.makeSymbol(symName, symbolOrPackageName);
    }
 }
 eof(requireEOF)
 { return symbol; }
}

SubLCharacter character(boolean requireEOF, boolean eatInitialWS) : {
 SubLCharacter val = null;
 Token t = null;
} {
 eatWhiteSpace(eatInitialWS)
(
 ( t = < NAMED_CHARACTER > { val = SubLObjectFactory.makeChar(t.image); } )
 | ( t = < CHARACTER > { val = SubLObjectFactory.makeChar(t.image); } )
)
 eof(requireEOF)
 { return val; }
}

void eatWhiteSpace(boolean shouldEatWS) : { } {
  ( { if (!shouldEatWS) { return; } } ) ( < WS > )*
}

void eof(boolean requireEOF) : { } {
 ( { if (!requireEOF) return; } ) ( < WS > )* < EOF >
}

